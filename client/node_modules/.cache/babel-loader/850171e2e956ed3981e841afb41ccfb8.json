{"ast":null,"code":"'use strict';\n\nmodule.exports = {\n  isExpected: function isExpected(type, message, transaction, config, urltils) {\n    let isExpectedTransactionCode = false;\n\n    if (transaction && urltils.isExpectedError(config, transaction.statusCode)) {\n      isExpectedTransactionCode = true;\n    }\n\n    return this.isExpectedErrorMessage(config, type, message) || this.isExpectedErrorClass(config, type) || isExpectedTransactionCode;\n  },\n  isExpectedErrorMessage: function isExpectedErrorMessage(config, type, message) {\n    if (!config.error_collector.expected_messages[type]) {\n      return false;\n    }\n\n    if (config.error_collector.expected_messages[type].length > 0) {\n      if (-1 !== config.error_collector.expected_messages[type].indexOf(message)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  isExpectedErrorClass: function isExpectedErrorClass(config, className) {\n    if (config.error_collector.expected_classes.length > 0) {\n      if (-1 !== config.error_collector.expected_classes.indexOf(className)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  isExpectedException: function isExpectedException(transaction, exception, config, urltils) {\n    let _this$extractErrorInf = this.extractErrorInformation(transaction, exception, config, urltils),\n        type = _this$extractErrorInf.type,\n        message = _this$extractErrorInf.message;\n\n    return this.isExpectedErrorClass(config, type) || this.isExpectedErrorMessage(config, type, message);\n  },\n  extractErrorInformation: function extractErrorInformation(transaction, exception, config, urltils) {\n    let name = 'Unknown';\n    let message = '';\n    let type = 'Error'; // String errors do not provide us with as much information to provide to the\n    // user, but it is a common pattern.\n\n    if (typeof exception === 'string') {\n      message = exception;\n    } else if (exception !== null && typeof exception === 'object' && exception.message && !config.high_security && !config.strip_exception_messages.enabled) {\n      message = exception.message;\n\n      if (exception.name) {\n        type = exception.name;\n      } else if (exception.constructor && exception.constructor.name) {\n        type = exception.constructor.name;\n      }\n    } else if (transaction && transaction.statusCode && urltils.isError(config, transaction.statusCode)) {\n      message = 'HttpError ' + transaction.statusCode;\n    }\n\n    if (transaction) {\n      // transaction.getName is expensive due to running normalizers and ignore\n      // rules if a name hasn't been assigned yet.\n      const txName = transaction.getFullName();\n\n      if (txName) {\n        name = txName;\n      }\n    }\n\n    return {\n      name: name,\n      message: message,\n      type: type\n    };\n  },\n  shouldIgnoreError: function shouldIgnoreError(transaction, exception, config) {\n    // extract _just_ the error information, not transaction stuff\n    let errorInfo = this.extractErrorInformation(null, exception, config, null);\n    return this.shouldIgnoreErrorClass(errorInfo, config) || this.shouldIgnoreErrorMessage(errorInfo, config) || this.shouldIgnoreStatusCode(transaction, config);\n  },\n  shouldIgnoreStatusCode: function shouldIgnoreStatusCode(transaction, config) {\n    if (!transaction) {\n      return false;\n    }\n\n    return config.error_collector.ignore_status_codes.indexOf(transaction.statusCode) !== -1;\n  },\n  shouldIgnoreErrorClass: function shouldIgnoreErrorClass(errorInfo, config) {\n    if (config.error_collector.ignore_classes.length < 1) {\n      return false;\n    }\n\n    return -1 !== config.error_collector.ignore_classes.indexOf(errorInfo.type);\n  },\n  shouldIgnoreErrorMessage: function shouldIgnoreErrorMessage(errorInfo, config) {\n    let configIgnoreMessages = config.error_collector.ignore_messages[errorInfo.type];\n\n    if (!configIgnoreMessages) {\n      return false;\n    }\n\n    if (configIgnoreMessages.length > 0) {\n      if (-1 !== configIgnoreMessages.indexOf(errorInfo.message)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n};","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/errors/helper.js"],"names":["module","exports","isExpected","type","message","transaction","config","urltils","isExpectedTransactionCode","isExpectedError","statusCode","isExpectedErrorMessage","isExpectedErrorClass","error_collector","expected_messages","length","indexOf","className","expected_classes","isExpectedException","exception","extractErrorInformation","name","high_security","strip_exception_messages","enabled","constructor","isError","txName","getFullName","shouldIgnoreError","errorInfo","shouldIgnoreErrorClass","shouldIgnoreErrorMessage","shouldIgnoreStatusCode","ignore_status_codes","ignore_classes","configIgnoreMessages","ignore_messages"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = {\n  isExpected: function isExpected(type, message, transaction, config, urltils) {\n    let isExpectedTransactionCode = false\n    if (transaction && urltils.isExpectedError(config, transaction.statusCode)) {\n      isExpectedTransactionCode = true\n    }\n    return this.isExpectedErrorMessage(config, type, message) ||\n      this.isExpectedErrorClass(config, type) ||\n      isExpectedTransactionCode\n  },\n  isExpectedErrorMessage: function isExpectedErrorMessage(config, type, message) {\n    if (!config.error_collector.expected_messages[type]) {\n      return false\n    }\n    if (config.error_collector.expected_messages[type].length > 0) {\n      if (-1 !== config.error_collector.expected_messages[type].indexOf(message)) {\n        return true\n      }\n    }\n    return false\n  },\n  isExpectedErrorClass: function isExpectedErrorClass(config, className) {\n    if (config.error_collector.expected_classes.length > 0) {\n      if (-1 !== config.error_collector.expected_classes.indexOf(className)) {\n        return true\n      }\n    }\n    return false\n  },\n  isExpectedException: function isExpectedException(\n    transaction,\n    exception,\n    config,\n    urltils\n  ) {\n    let {type, message} = this.extractErrorInformation(\n      transaction,\n      exception,\n      config,\n      urltils\n    )\n\n    return this.isExpectedErrorClass(config, type) ||\n      this.isExpectedErrorMessage(config, type, message)\n  },\n\n  extractErrorInformation: function extractErrorInformation(\n    transaction,\n    exception,\n    config,\n    urltils\n  ) {\n    let name = 'Unknown'\n    let message = ''\n    let type = 'Error'\n\n    // String errors do not provide us with as much information to provide to the\n    // user, but it is a common pattern.\n    if (typeof exception === 'string') {\n      message = exception\n    } else if (\n      exception !== null &&\n      typeof exception === 'object' &&\n      exception.message &&\n      !config.high_security &&\n      !config.strip_exception_messages.enabled\n    ) {\n      message = exception.message\n\n      if (exception.name) {\n        type = exception.name\n      } else if (exception.constructor && exception.constructor.name) {\n        type = exception.constructor.name\n      }\n    } else if (transaction && transaction.statusCode &&\n               urltils.isError(config, transaction.statusCode)) {\n      message = 'HttpError ' + transaction.statusCode\n    }\n\n    if (transaction) {\n      // transaction.getName is expensive due to running normalizers and ignore\n      // rules if a name hasn't been assigned yet.\n      const txName = transaction.getFullName()\n      if (txName) {\n        name = txName\n      }\n    }\n\n    return {\n      name:name,\n      message:message,\n      type:type,\n    }\n  },\n\n  shouldIgnoreError: function shouldIgnoreError(transaction, exception, config) {\n    // extract _just_ the error information, not transaction stuff\n    let errorInfo = this.extractErrorInformation(null, exception, config, null)\n\n    return this.shouldIgnoreErrorClass(errorInfo, config) ||\n      this.shouldIgnoreErrorMessage(errorInfo, config) ||\n      this.shouldIgnoreStatusCode(transaction, config)\n  },\n\n  shouldIgnoreStatusCode: function shouldIgnoreStatusCode(transaction, config) {\n    if (!transaction) {\n      return false\n    }\n    return config.error_collector.ignore_status_codes.indexOf(\n      transaction.statusCode\n    ) !== -1\n  },\n\n  shouldIgnoreErrorClass: function shouldIgnoreErrorClass(errorInfo, config) {\n    if (config.error_collector.ignore_classes.length < 1) {\n      return false\n    }\n\n    return -1 !== config.error_collector.ignore_classes.indexOf(errorInfo.type)\n  },\n\n  shouldIgnoreErrorMessage: function shouldIgnoreErrorMessage(errorInfo, config) {\n    let configIgnoreMessages = config.error_collector.ignore_messages[errorInfo.type]\n    if (!configIgnoreMessages) {\n      return false\n    }\n\n    if (configIgnoreMessages.length > 0) {\n      if (-1 !== configIgnoreMessages.indexOf(errorInfo.message)) {\n        return true\n      }\n    }\n    return false\n  }\n}\n"]},"metadata":{},"sourceType":"script"}