{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar url = require('url');\n\nvar https = require('https');\n\nvar zlib = require('zlib');\n\nvar logger = require('../logger').child({\n  component: 'remote_method'\n});\n\nvar parse = require('./parse-response');\n\nvar stringify = require('json-stringify-safe');\n\nvar Sink = require('../util/stream-sink');\n\nvar agents = require('./http-agents');\n\nvar certificates = require('./ssl/certificates');\n\nconst isValidLength = require('../util/byte-limit').isValidLength;\n/*\n *\n * CONSTANTS\n *\n */\n\n\nconst RUN_ID_NAME = 'run_id';\nconst RAW_METHOD_PATH = '/agent_listener/invoke_raw_method'; // see job/collector-master/javadoc/com/nr/servlet/AgentListener.html on NR Jenkins\n\nconst USER_AGENT_FORMAT = 'NewRelic-NodeAgent/%s (nodejs %s %s-%s)';\nconst ENCODING_HEADER = 'CONTENT-ENCODING';\nconst DEFAULT_ENCODING = 'identity';\n\nfunction RemoteMethod(name, config) {\n  if (!name) {\n    throw new TypeError('Must include name of method to invoke on collector.');\n  }\n\n  this.name = name;\n  this._config = config;\n  this._protocolVersion = 17;\n}\n\nRemoteMethod.prototype.serialize = function serialize(payload, callback) {\n  try {\n    var res = stringify(payload);\n  } catch (error) {\n    logger.error(error, 'Unable to serialize payload for method %s.', this.name);\n    return process.nextTick(function onNextTick() {\n      return callback(error);\n    });\n  }\n\n  return callback(null, res);\n};\n/**\n * The primary operation on RemoteMethod objects. If you're calling anything on\n * RemoteMethod objects aside from invoke (and you're not writing test code),\n * you're doing it wrong.\n *\n * @param {object}   payload           Serializable payload.\n * @param {object}   [nrHeaders=null]  NR request headers from connect response.\n * @param {Function} callback          What to do next. Gets passed any error.\n */\n\n\nRemoteMethod.prototype.invoke = function invoke(payload, nrHeaders, callback) {\n  if (typeof nrHeaders === 'function') {\n    callback = nrHeaders;\n    nrHeaders = null;\n  }\n\n  if (!payload) payload = [];\n  logger.trace('Invoking remote method %s', this.name);\n  this.serialize(payload, function onSerialize(err, serialized) {\n    if (err) return callback(err);\n\n    this._post(serialized, nrHeaders, callback);\n  }.bind(this));\n};\n/**\n * Take a serialized payload and create a response wrapper for it before\n * invoking the method on the collector.\n *\n * @param {string}   methodName Name of method to invoke on collector.\n * @param {string}   data       Serialized payload.\n * @param {?object}  nrHeaders  NR request headers from connect response.\n * @param {Function} callback   What to do next. Gets passed any error.\n */\n\n\nRemoteMethod.prototype._post = function _post(data, nrHeaders, callback) {\n  var method = this;\n  var options = {\n    port: this._config.port,\n    host: this._config.host,\n    compressed: this._shouldCompress(data),\n    path: this._path(),\n    onError: callback,\n    onResponse,\n    nrHeaders\n  }; // Check trace enabled first since we're creating an object for this log message.\n\n  if (logger.traceEnabled()) {\n    logger.trace({\n      data,\n      compressed: options.compressed\n    }, 'Calling %s on collector API', this.name);\n  }\n\n  if (options.compressed) {\n    var useGzip = this._config.compressed_content_encoding === 'gzip';\n    var compressor = useGzip ? zlib.gzip : zlib.deflate;\n    compressor(data, function onCompress(err, compressed) {\n      if (err) {\n        logger.warn(err, 'Error compressing JSON for delivery. Not sending.');\n        return callback(err);\n      }\n\n      options.body = compressed;\n      makeRequest();\n    });\n  } else {\n    options.body = data;\n    makeRequest();\n  }\n\n  function makeRequest() {\n    try {\n      method._safeRequest(options);\n    } catch (err) {\n      logger.warn(err, 'Failed to prepare request to collector method %s!', method.name);\n      callback(err);\n    }\n  } // set up standard response handling\n\n\n  function onResponse(response) {\n    response.on('end', function onEnd() {\n      logger.debug('Finished receiving data back from the collector for %s.', method.name);\n    });\n    response.setEncoding('utf8');\n    response.pipe(new Sink(parse(method.name, response, callback)));\n  }\n};\n/**\n * http.request does its own DNS lookup, and if it fails, will cause\n * dns.lookup to throw asynchronously instead of passing the error to\n * the callback (which is obviously awesome). To prevent New Relic from\n * crashing people's applications, verify that lookup works and bail out\n * early if not.\n *\n * Also, ensure that all the necessary parameters are set before\n * actually making the request. Useful to put here to simplify test code\n * that calls _request directly.\n *\n * @param {object} options A dictionary of request parameters.\n */\n\n\nRemoteMethod.prototype._safeRequest = function _safeRequest(options) {\n  if (!options) throw new Error('Must include options to make request!');\n  if (!options.host) throw new Error('Must include collector hostname!');\n  if (!options.port) throw new Error('Must include collector port!');\n  if (!options.onError) throw new Error('Must include error handler!');\n  if (!options.onResponse) throw new Error('Must include response handler!');\n  if (!options.body) throw new Error('Must include body to send to collector!');\n  if (!options.path) throw new Error('Must include URL to request!');\n  var protocol = 'https';\n  var logConfig = this._config.logging;\n  var auditLog = this._config.audit_log;\n  const maxPayloadSize = this._config.max_payload_size_in_bytes;\n  var level = 'trace';\n\n  if (!isValidLength(options.body, maxPayloadSize)) {\n    logger.warn('The payload size %d being sent to method %s exceeded the maximum size of %d', Buffer.byteLength(options.body, 'utf8'), this.name, maxPayloadSize);\n    throw new Error('Maximum payload size exceeded');\n  } // If trace level is not explicity enabled check to see if the audit log is\n  // enabled.\n\n\n  if (logConfig != null && logConfig.level !== 'trace' && auditLog.enabled) {\n    // If the filter property is empty, then always log the event otherwise\n    // check to see if the filter includes this method.\n    if (auditLog.endpoints.length === 0 || auditLog.endpoints.indexOf(this.name) > -1) {\n      level = 'info';\n    }\n  }\n\n  const logBody = Buffer.isBuffer(options.body) ? 'Buffer ' + options.body.length : options.body;\n  logger[level]({\n    body: logBody\n  }, 'Posting to %s://%s:%s%s', protocol, options.host, options.port, options.path);\n\n  this._request(options);\n};\n/**\n * Generate the request headers and wire up the request. There are many\n * parameters used to make a request:\n *\n * @param {string}   options.host       Hostname (or proxy hostname) for collector.\n * @param {string}   options.port       Port (or proxy port) for collector.\n * @param {string}   options.path       URL path for method being invoked on collector.\n * @param {string}   options.body       Serialized payload to be sent to collector.\n * @param {boolean}  options.compressed Whether the payload has been compressed.\n * @param {object}   options.nrHeaders  NR request headers passed in connect response.\n * @param {Function} options.onError    Error handler for this request (probably the\n *                                      original callback given to .send).\n * @param {Function} options.onResponse Response handler for this request (created by\n *                                      ._post).\n */\n\n\nRemoteMethod.prototype._request = function _request(options) {\n  var requestOptions = {\n    method: this._config.put_for_data_send ? 'PUT' : 'POST',\n    setHost: false,\n    // See below\n    host: options.host,\n    // Set explicitly in the headers\n    port: options.port,\n    path: options.path,\n    headers: this._headers(options),\n    agent: agents.keepAliveAgent(),\n    __NR__connection: true // Who measures the metrics measurer?\n\n  };\n  var request;\n  var isProxy = !!(this._config.proxy || this._config.proxy_port || this._config.proxy_host);\n\n  if (isProxy) {\n    // proxy\n    requestOptions.agent = agents.proxyAgent(this._config);\n    request = https.request(requestOptions);\n  } else {\n    if (this._config.certificates && this._config.certificates.length > 0) {\n      logger.debug('Adding custom certificate to the cert bundle.');\n      requestOptions.ca = this._config.certificates.concat(certificates);\n    }\n\n    request = https.request(requestOptions);\n  }\n\n  request.on('error', options.onError);\n  request.on('response', options.onResponse);\n  request.end(options.body);\n};\n/**\n * See the constants list for the format string (and the URL that explains it).\n */\n\n\nRemoteMethod.prototype._userAgent = function _userAgent() {\n  return util.format(USER_AGENT_FORMAT, this._config.version, process.versions.node, process.platform, process.arch);\n};\n/**\n * Generate a URL the collector understands.\n *\n * @returns {string} The URL path to be POSTed to.\n */\n\n\nRemoteMethod.prototype._path = function _path() {\n  var query = {\n    marshal_format: 'json',\n    protocol_version: this._protocolVersion,\n    license_key: this._config.license_key,\n    method: this.name\n  };\n\n  if (this._config.run_id) {\n    query[RUN_ID_NAME] = this._config.run_id;\n  }\n\n  var formatted = url.format({\n    pathname: RAW_METHOD_PATH,\n    query: query\n  });\n  return formatted;\n};\n/**\n * @param {object} options\n * @param {number} options.body       - Data to be sent.\n * @param {object} options.nrHeaders  - NR request headers from the connect response.\n * @param {bool}   options.compressed - The compression method used, if any.\n */\n\n\nRemoteMethod.prototype._headers = function _headers(options) {\n  var agent = this._userAgent();\n\n  var headers = {\n    // select the virtual host on the server end\n    'Host': this._config.host,\n    'User-Agent': agent,\n    'Connection': 'Keep-Alive',\n    'Content-Length': byteLength(options.body),\n    'Content-Type': 'application/json'\n  };\n\n  if (options.compressed) {\n    headers[ENCODING_HEADER] = this._config.compressed_content_encoding;\n  } else {\n    headers[ENCODING_HEADER] = DEFAULT_ENCODING;\n  }\n\n  if (options.nrHeaders) {\n    Object.assign(headers, options.nrHeaders);\n  }\n\n  return headers;\n};\n/**\n * FLN pretty much decided on his own recognizance that 64K was a good point\n * at which to compress a server response. There's only a loose consensus that\n * the threshold should probably be much higher than this, if only to keep the\n * load on the collector down.\n *\n * FIXME: come up with a better heuristic\n */\n\n\nRemoteMethod.prototype._shouldCompress = function _shouldCompress(data) {\n  return data && byteLength(data) > 65536;\n};\n\nfunction byteLength(data) {\n  if (!data) {\n    return 0;\n  }\n\n  if (data instanceof Buffer) {\n    return data.length;\n  }\n\n  return Buffer.byteLength(data, 'utf8');\n}\n\nmodule.exports = RemoteMethod;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/collector/remote-method.js"],"names":["util","require","url","https","zlib","logger","child","component","parse","stringify","Sink","agents","certificates","isValidLength","RUN_ID_NAME","RAW_METHOD_PATH","USER_AGENT_FORMAT","ENCODING_HEADER","DEFAULT_ENCODING","RemoteMethod","name","config","TypeError","_config","_protocolVersion","prototype","serialize","payload","callback","res","error","process","nextTick","onNextTick","invoke","nrHeaders","trace","onSerialize","err","serialized","_post","bind","data","method","options","port","host","compressed","_shouldCompress","path","_path","onError","onResponse","traceEnabled","useGzip","compressed_content_encoding","compressor","gzip","deflate","onCompress","warn","body","makeRequest","_safeRequest","response","on","onEnd","debug","setEncoding","pipe","Error","protocol","logConfig","logging","auditLog","audit_log","maxPayloadSize","max_payload_size_in_bytes","level","Buffer","byteLength","enabled","endpoints","length","indexOf","logBody","isBuffer","_request","requestOptions","put_for_data_send","setHost","headers","_headers","agent","keepAliveAgent","__NR__connection","request","isProxy","proxy","proxy_port","proxy_host","proxyAgent","ca","concat","end","_userAgent","format","version","versions","node","platform","arch","query","marshal_format","protocol_version","license_key","run_id","formatted","pathname","Object","assign","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar util = require('util')\nvar url = require('url')\nvar https = require('https')\nvar zlib = require('zlib')\nvar logger = require('../logger').child({component: 'remote_method'})\nvar parse = require('./parse-response')\nvar stringify = require('json-stringify-safe')\nvar Sink = require('../util/stream-sink')\nvar agents = require('./http-agents')\nvar certificates = require('./ssl/certificates')\nconst isValidLength = require('../util/byte-limit').isValidLength\n\n/*\n *\n * CONSTANTS\n *\n */\nconst RUN_ID_NAME = 'run_id'\nconst RAW_METHOD_PATH = '/agent_listener/invoke_raw_method'\n// see job/collector-master/javadoc/com/nr/servlet/AgentListener.html on NR Jenkins\nconst USER_AGENT_FORMAT = 'NewRelic-NodeAgent/%s (nodejs %s %s-%s)'\nconst ENCODING_HEADER = 'CONTENT-ENCODING'\nconst DEFAULT_ENCODING = 'identity'\n\nfunction RemoteMethod(name, config) {\n  if (!name) {\n    throw new TypeError('Must include name of method to invoke on collector.')\n  }\n\n  this.name = name\n  this._config = config\n\n  this._protocolVersion = 17\n}\n\nRemoteMethod.prototype.serialize = function serialize(payload, callback) {\n  try {\n    var res = stringify(payload)\n  } catch (error) {\n    logger.error(error, 'Unable to serialize payload for method %s.', this.name)\n    return process.nextTick(function onNextTick() {\n      return callback(error)\n    })\n  }\n  return callback(null, res)\n}\n\n/**\n * The primary operation on RemoteMethod objects. If you're calling anything on\n * RemoteMethod objects aside from invoke (and you're not writing test code),\n * you're doing it wrong.\n *\n * @param {object}   payload           Serializable payload.\n * @param {object}   [nrHeaders=null]  NR request headers from connect response.\n * @param {Function} callback          What to do next. Gets passed any error.\n */\nRemoteMethod.prototype.invoke = function invoke(payload, nrHeaders, callback) {\n  if (typeof nrHeaders === 'function') {\n    callback = nrHeaders\n    nrHeaders = null\n  }\n\n  if (!payload) payload = []\n  logger.trace('Invoking remote method %s', this.name)\n\n  this.serialize(payload, function onSerialize(err, serialized) {\n    if (err) return callback(err)\n    this._post(serialized, nrHeaders, callback)\n  }.bind(this))\n}\n\n/**\n * Take a serialized payload and create a response wrapper for it before\n * invoking the method on the collector.\n *\n * @param {string}   methodName Name of method to invoke on collector.\n * @param {string}   data       Serialized payload.\n * @param {?object}  nrHeaders  NR request headers from connect response.\n * @param {Function} callback   What to do next. Gets passed any error.\n */\nRemoteMethod.prototype._post = function _post(data, nrHeaders, callback) {\n  var method = this\n  var options = {\n    port: this._config.port,\n    host: this._config.host,\n    compressed: this._shouldCompress(data),\n    path: this._path(),\n    onError: callback,\n    onResponse,\n    nrHeaders\n  }\n\n  // Check trace enabled first since we're creating an object for this log message.\n  if (logger.traceEnabled()) {\n    logger.trace(\n      {data, compressed: options.compressed},\n      'Calling %s on collector API',\n      this.name\n    )\n  }\n\n  if (options.compressed) {\n    var useGzip = this._config.compressed_content_encoding === 'gzip'\n    var compressor = useGzip ? zlib.gzip : zlib.deflate\n    compressor(data, function onCompress(err, compressed) {\n      if (err) {\n        logger.warn(err, 'Error compressing JSON for delivery. Not sending.')\n        return callback(err)\n      }\n\n      options.body = compressed\n      makeRequest()\n    })\n  } else {\n    options.body = data\n    makeRequest()\n  }\n\n  function makeRequest() {\n    try {\n      method._safeRequest(options)\n    } catch (err) {\n      logger.warn(err, 'Failed to prepare request to collector method %s!', method.name)\n      callback(err)\n    }\n  }\n\n  // set up standard response handling\n  function onResponse(response) {\n    response.on('end', function onEnd() {\n      logger.debug(\n        'Finished receiving data back from the collector for %s.',\n        method.name\n      )\n    })\n\n    response.setEncoding('utf8')\n    response.pipe(new Sink(parse(method.name, response, callback)))\n  }\n}\n\n/**\n * http.request does its own DNS lookup, and if it fails, will cause\n * dns.lookup to throw asynchronously instead of passing the error to\n * the callback (which is obviously awesome). To prevent New Relic from\n * crashing people's applications, verify that lookup works and bail out\n * early if not.\n *\n * Also, ensure that all the necessary parameters are set before\n * actually making the request. Useful to put here to simplify test code\n * that calls _request directly.\n *\n * @param {object} options A dictionary of request parameters.\n */\nRemoteMethod.prototype._safeRequest = function _safeRequest(options) {\n  if (!options) throw new Error('Must include options to make request!')\n  if (!options.host) throw new Error('Must include collector hostname!')\n  if (!options.port) throw new Error('Must include collector port!')\n  if (!options.onError) throw new Error('Must include error handler!')\n  if (!options.onResponse) throw new Error('Must include response handler!')\n  if (!options.body) throw new Error('Must include body to send to collector!')\n  if (!options.path) throw new Error('Must include URL to request!')\n\n  var protocol = 'https'\n  var logConfig = this._config.logging\n  var auditLog = this._config.audit_log\n  const maxPayloadSize = this._config.max_payload_size_in_bytes\n  var level = 'trace'\n\n  if (!isValidLength(options.body, maxPayloadSize)) {\n    logger.warn(\n      'The payload size %d being sent to method %s exceeded the maximum size of %d',\n      Buffer.byteLength(options.body, 'utf8'),\n      this.name,\n      maxPayloadSize\n    )\n    throw new Error('Maximum payload size exceeded')\n  }\n\n  // If trace level is not explicity enabled check to see if the audit log is\n  // enabled.\n  if (logConfig != null && logConfig.level !== 'trace' && auditLog.enabled) {\n    // If the filter property is empty, then always log the event otherwise\n    // check to see if the filter includes this method.\n    if (auditLog.endpoints.length === 0 || auditLog.endpoints.indexOf(this.name) > -1) {\n      level = 'info'\n    }\n  }\n\n  const logBody =\n    Buffer.isBuffer(options.body) ? 'Buffer ' + options.body.length : options.body\n  logger[level](\n    {body: logBody},\n    'Posting to %s://%s:%s%s',\n    protocol,\n    options.host,\n    options.port,\n    options.path\n  )\n\n  this._request(options)\n}\n\n/**\n * Generate the request headers and wire up the request. There are many\n * parameters used to make a request:\n *\n * @param {string}   options.host       Hostname (or proxy hostname) for collector.\n * @param {string}   options.port       Port (or proxy port) for collector.\n * @param {string}   options.path       URL path for method being invoked on collector.\n * @param {string}   options.body       Serialized payload to be sent to collector.\n * @param {boolean}  options.compressed Whether the payload has been compressed.\n * @param {object}   options.nrHeaders  NR request headers passed in connect response.\n * @param {Function} options.onError    Error handler for this request (probably the\n *                                      original callback given to .send).\n * @param {Function} options.onResponse Response handler for this request (created by\n *                                      ._post).\n */\nRemoteMethod.prototype._request = function _request(options) {\n  var requestOptions = {\n    method: this._config.put_for_data_send ? 'PUT' : 'POST',\n    setHost: false,         // See below\n    host: options.host,     // Set explicitly in the headers\n    port: options.port,\n    path: options.path,\n    headers: this._headers(options),\n    agent: agents.keepAliveAgent(),\n    __NR__connection: true,  // Who measures the metrics measurer?\n  }\n  var request\n\n  var isProxy = !!(\n    this._config.proxy ||\n    this._config.proxy_port ||\n    this._config.proxy_host\n  )\n\n  if (isProxy) {\n    // proxy\n    requestOptions.agent = agents.proxyAgent(this._config)\n    request = https.request(requestOptions)\n  } else {\n    if (this._config.certificates && this._config.certificates.length > 0) {\n      logger.debug(\n        'Adding custom certificate to the cert bundle.'\n      )\n      requestOptions.ca = this._config.certificates.concat(certificates)\n    }\n    request = https.request(requestOptions)\n  }\n\n  request.on('error', options.onError)\n  request.on('response', options.onResponse)\n\n  request.end(options.body)\n}\n\n/**\n * See the constants list for the format string (and the URL that explains it).\n */\nRemoteMethod.prototype._userAgent = function _userAgent() {\n  return util.format(\n    USER_AGENT_FORMAT,\n    this._config.version,\n    process.versions.node,\n    process.platform,\n    process.arch\n  )\n}\n\n/**\n * Generate a URL the collector understands.\n *\n * @returns {string} The URL path to be POSTed to.\n */\nRemoteMethod.prototype._path = function _path() {\n  var query = {\n    marshal_format: 'json',\n    protocol_version: this._protocolVersion,\n    license_key: this._config.license_key,\n    method: this.name\n  }\n\n  if (this._config.run_id) {\n    query[RUN_ID_NAME] = this._config.run_id\n  }\n\n  var formatted = url.format({\n    pathname: RAW_METHOD_PATH,\n    query: query\n  })\n\n  return formatted\n}\n\n/**\n * @param {object} options\n * @param {number} options.body       - Data to be sent.\n * @param {object} options.nrHeaders  - NR request headers from the connect response.\n * @param {bool}   options.compressed - The compression method used, if any.\n */\nRemoteMethod.prototype._headers = function _headers(options) {\n  var agent = this._userAgent()\n\n  var headers = {\n    // select the virtual host on the server end\n    'Host': this._config.host,\n    'User-Agent': agent,\n    'Connection': 'Keep-Alive',\n    'Content-Length': byteLength(options.body),\n    'Content-Type': 'application/json'\n  }\n\n  if (options.compressed) {\n    headers[ENCODING_HEADER] = this._config.compressed_content_encoding\n  } else {\n    headers[ENCODING_HEADER] = DEFAULT_ENCODING\n  }\n\n  if (options.nrHeaders) {\n    Object.assign(headers, options.nrHeaders)\n  }\n\n  return headers\n}\n\n/**\n * FLN pretty much decided on his own recognizance that 64K was a good point\n * at which to compress a server response. There's only a loose consensus that\n * the threshold should probably be much higher than this, if only to keep the\n * load on the collector down.\n *\n * FIXME: come up with a better heuristic\n */\nRemoteMethod.prototype._shouldCompress = function _shouldCompress(data) {\n  return data && byteLength(data) > 65536\n}\n\nfunction byteLength(data) {\n  if (!data) {\n    return 0\n  }\n\n  if (data instanceof Buffer) {\n    return data.length\n  }\n\n  return Buffer.byteLength(data, 'utf8')\n}\n\nmodule.exports = RemoteMethod\n"]},"metadata":{},"sourceType":"script"}