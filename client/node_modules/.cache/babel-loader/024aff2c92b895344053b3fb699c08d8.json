{"ast":null,"code":"'use strict';\n\nconst CollectorResponse = require('./response');\n\nconst facts = require('./facts');\n\nconst logger = require('../logger').child({\n  component: 'collector_api'\n});\n\nconst RemoteMethod = require('./remote-method');\n\nconst NAMES = require('../metrics/names'); // just to make clear what's going on\n\n\nconst TO_MILLIS = 1e3; // taken directly from Python agent's newrelic.core.application\n\nconst BACKOFFS = [{\n  interval: 15,\n  warn: false\n}, {\n  interval: 15,\n  warn: false\n}, {\n  interval: 30,\n  warn: false\n}, {\n  interval: 60,\n  warn: true\n}, {\n  interval: 120,\n  warn: false\n}, {\n  interval: 300,\n  warn: false\n}]; // Expected collector response codes\n\nconst SUCCESS = new Set([200, 202]);\nconst RESTART = new Set([401, 409]);\nconst FAILURE_SAVE_DATA = new Set([408, 429, 500, 503]);\nconst FAILURE_DISCARD_DATA = new Set([400, 403, 404, 405, 407, 411, 413, 414, 415, 417, 431]);\nconst AGENT_RUN_BEHAVIOR = CollectorResponse.AGENT_RUN_BEHAVIOR;\n\nfunction dumpErrors(errors, name) {\n  var index = 1;\n  errors.forEach(function forEachError(error) {\n    logger.trace(error, 'Error %s during %s:', index++, name);\n\n    if (error.laterErrors) {\n      error.laterErrors.forEach(function forEachLaterError(laterError) {\n        logger.trace(laterError, 'Error %s during %s:', index++, name);\n      });\n    }\n  });\n}\n\nfunction CollectorAPI(agent) {\n  this._agent = agent;\n  this._reqHeadersMap = null;\n  /* RemoteMethods can be reused and have little per-object state, so why not\n   * save some GC time?\n   */\n\n  this._methods = {\n    redirect: new RemoteMethod('preconnect', agent.config),\n    handshake: new RemoteMethod('connect', agent.config),\n    settings: new RemoteMethod('agent_settings', agent.config),\n    errors: new RemoteMethod('error_data', agent.config),\n    metrics: new RemoteMethod('metric_data', agent.config),\n    traces: new RemoteMethod('transaction_sample_data', agent.config),\n    shutdown: new RemoteMethod('shutdown', agent.config),\n    events: new RemoteMethod('analytic_event_data', agent.config),\n    customEvents: new RemoteMethod('custom_event_data', agent.config),\n    queryData: new RemoteMethod('sql_trace_data', agent.config),\n    errorEvents: new RemoteMethod('error_event_data', agent.config),\n    spanEvents: new RemoteMethod('span_event_data', agent.config)\n  };\n}\n\nCollectorAPI.prototype.connect = function connect(callback) {\n  if (!callback) {\n    throw new TypeError('callback is required');\n  }\n\n  logger.trace('Starting collector.');\n\n  this._agent.setState('connecting');\n\n  const api = this;\n  const max = BACKOFFS.length;\n  const errors = [];\n  let attempts = 1;\n\n  const metric = this._agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.REGISTRATION + '/Attempts'); // Reset headers map for good measure\n\n\n  if (this._reqHeadersMap) {\n    this._reqHeadersMap = null;\n  }\n\n  function retry(error, response) {\n    metric.incrementCallCount();\n\n    if (error) {\n      errors.push(error);\n    } else if (response && SUCCESS.has(response.status)) {\n      dumpErrors(errors, 'connect');\n      return callback(null, CollectorResponse.success(response.payload));\n    }\n\n    if (!response) {\n      response = CollectorResponse.retry();\n    } // Retry everything except for an explicit Disconnect response code.\n\n\n    if (response.status === 410 || response.agentRun === AGENT_RUN_BEHAVIOR.SHUTDOWN) {\n      logger.error('The New Relic collector rejected this agent.');\n      return callback(null, CollectorResponse.fatal(response.payload));\n    } else if (response.status === 401) {\n      logger.warn(error, 'Your license key appears to be invalid. Reattempting connection to New' + ' Relic. If the problem persists, please contact support@newrelic.com.' + ' (status code %s)', response.status);\n    }\n\n    let backoff = BACKOFFS[Math.min(attempts, max) - 1];\n\n    if (backoff.warn) {\n      logger.warn('No connection has been established to New Relic after %d attempts.', attempts);\n    }\n\n    logger.debug(error, 'Failed to connect to New Relic after attempt %d, waiting %ds to retry.', attempts, backoff.interval);\n    ++attempts;\n    const timeout = setTimeout(function again() {\n      api._login(retry);\n    }, backoff.interval * TO_MILLIS);\n    timeout.unref();\n  }\n\n  this._login(retry);\n};\n\nCollectorAPI.prototype._login = function _login(callback) {\n  var methods = this._methods;\n  var agent = this._agent;\n  var self = this;\n  const preconnectData = {\n    high_security: agent.config.high_security\n  };\n\n  if (agent.config.security_policies_token) {\n    preconnectData.security_policies_token = agent.config.security_policies_token;\n  }\n\n  const payload = [preconnectData];\n  methods.redirect.invoke(payload, onPreConnect);\n\n  function onPreConnect(error, response) {\n    if (error || !SUCCESS.has(response.status)) {\n      return callback(error, response);\n    }\n\n    const res = response.payload || Object.create(null);\n\n    if (!res.redirect_host) {\n      logger.error(\"Requesting this account's collector from %s failed; trying default.\", agent.config.host);\n    } else {\n      var parts = res.redirect_host.split(':');\n\n      if (parts.length > 2) {\n        logger.error(\"Requesting collector from %s returned bogus result '%s'; trying default.\", agent.config.host, res.redirect_host);\n      } else {\n        logger.debug(\"Requesting this account's collector from %s returned %s; reconfiguring.\", agent.config.host, res.redirect_host);\n        agent.config.host = parts[0];\n        agent.config.port = parts[1] || 443;\n      }\n    }\n\n    var policies = res.security_policies || Object.create(null);\n    const laspResponse = agent.config.applyLasp(agent, policies);\n\n    if (laspResponse.shouldShutdownRun()) {\n      return callback(null, laspResponse);\n    }\n\n    self._getFacts(laspResponse.payload, callback);\n  }\n};\n\nCollectorAPI.prototype._getFacts = function _getFacts(lasp, callback) {\n  var agent = this._agent;\n  var self = this;\n  facts(agent, function getEnvDict(environmentDict) {\n    if (lasp) {\n      environmentDict.security_policies = lasp;\n    } // The collector really likes arrays.\n    // In fact, it kind of insists on them.\n\n\n    var environment = [environmentDict];\n\n    self._connect(environment, callback);\n  });\n};\n\nCollectorAPI.prototype._connect = function _connect(env, callback) {\n  const collector = this;\n  const methods = this._methods;\n  const agent = this._agent;\n  methods.handshake.invoke(env, onConnect);\n\n  function onConnect(error, res) {\n    if (error || !SUCCESS.has(res.status)) {\n      return callback(error, res);\n    }\n\n    const config = res.payload;\n\n    if (!config || !config.agent_run_id) {\n      return callback(new Error('No agent run ID received from handshake.'), res);\n    }\n\n    agent.setState('connected');\n    logger.info('Connected to %s:%d with agent run ID %s.', agent.config.host, agent.config.port, config.agent_run_id); // Log \"Reporting to...\" message from connect response.\n\n    if (config.messages) {\n      config.messages.forEach(element => {\n        logger.info(element.message);\n      });\n    } // Store request headers for future collector requests if they're present\n\n\n    collector._reqHeadersMap = config.request_headers_map; // pass configuration data from the API so automatic reconnect works\n\n    agent.reconfigure(config);\n    callback(null, res);\n  }\n};\n/**\n * Send current public agent settings to collector. This should always be\n * invoked after a successful connect response with server-side settings, but\n * will also be invoked on any other config changes.\n *\n * @param {Function} callback The continuation / error handler.\n */\n\n\nCollectorAPI.prototype.reportSettings = function reportSettings(callback) {\n  // The second argument to the callback is always empty data\n  this._methods.settings.invoke([this._agent.config.publicSettings()], this._reqHeadersMap, function onReportSettings(error, response) {\n    if (error) dumpErrors([error], 'agent_settings');\n    if (callback) callback(error, response);\n  });\n};\n/**\n * Send already-formatted error data by calling error_data. For\n * performance reasons, the API methods do no validation, but the\n * collector expects data in an exact format. It expects a JSON array\n * containing the following 2 elements:\n *\n * 1. The agent run ID.\n * 2. An array of one or more errors. See lib/error.js for details.\n *\n * @param {Array}    errors   The encoded errors list.\n * @param {Function} callback The continuation / error handler.\n */\n\n\nCollectorAPI.prototype.error_data = function errorData(errors, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required');\n  }\n\n  if (!errors) {\n    return callback(new TypeError('must pass errors to send'));\n  }\n\n  this._sendData(this._methods.errors, errors, callback);\n};\n\nCollectorAPI.prototype.error_event_data = function errorEvents(events, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required');\n  }\n\n  if (!events) {\n    return callback(new TypeError('must pass errors to send'));\n  }\n\n  this._sendData(this._methods.errorEvents, events, callback);\n};\n\nCollectorAPI.prototype.analytic_event_data = transactionEvents;\n\nfunction transactionEvents(events, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required');\n  }\n\n  if (!events) {\n    return callback(new TypeError('must pass events to send'));\n  }\n\n  this._sendData(this._methods.events, events, callback);\n}\n\nCollectorAPI.prototype.custom_event_data = function customEvents(events, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required');\n  }\n\n  if (!events) {\n    return callback(new TypeError('must pass events to send'));\n  }\n\n  this._sendData(this._methods.customEvents, events, callback);\n};\n/**\n * Send already-formatted metric data by calling metric_data. For\n * performance reasons, the API methods do no validation, but the collector\n * expects data in an exact format format. It expects a JSON array containing\n * the following 4 elements:\n *\n * 1. The agent run ID.\n * 2. The time the metric data started being collected, in seconds since the\n *    epoch.\n * 3. The time the metric data finished being collected, in seconds since the\n *    epoch.\n * 4. An array of 1 or more metric arrays. See lib/metrics.js for details.\n *\n * @param {Array}    metrics  The encoded metrics list.\n * @param {Function} callback The continuation / error handler.\n */\n\n\nCollectorAPI.prototype.metric_data = function metricData(metrics, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required');\n  }\n\n  if (!metrics) {\n    return callback(new TypeError('must pass metrics to send'));\n  }\n\n  this._sendData(this._methods.metrics, metrics, callback);\n};\n/**\n * Send already-formatted slow SQL data by calling\n * sql_trace_data. For performance reasons, the API methods\n * do no validation, but the collector expects data in an exact format\n * format. It expects a JSON array containing the following 2 elements:\n *\n * 1. The agent run ID.\n * 2. The encoded slow SQL data.\n *\n * @param {Array}    queries  The encoded slow SQL data.\n * @param {Function} callback The continuation / error handler.\n */\n\n\nCollectorAPI.prototype.sql_trace_data = function queryData(queries, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required');\n  }\n\n  if (!queries) {\n    return callback(new TypeError('must pass queries to send'));\n  }\n\n  this._sendData(this._methods.queryData, queries, callback);\n};\n\nCollectorAPI.prototype.span_event_data = function spanEvents(events, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required');\n  }\n\n  if (!events) {\n    return callback(new TypeError('must pass spans to send'));\n  }\n\n  this._sendData(this._methods.spanEvents, events, callback);\n};\n/**\n * Send already-formatted slow trace data by calling\n * transaction_sample_data. For performance reasons, the API methods\n * do no validation, but the collector expects data in an exact format\n * format. It expects a JSON array containing the following 2 elements:\n *\n * 1. The agent run ID.\n * 2. The encoded slow trace data. This is the most complicated data\n *    format handled by the module, and documenting it is almost beyond the\n *    scope of comments. See lib/transaction/trace.js for details.\n *\n * @param {Array}    trace    The encoded trace data.\n * @param {Function} callback The continuation / error handler.\n */\n\n\nCollectorAPI.prototype.transaction_sample_data = transactionSampleData;\n\nfunction transactionSampleData(traces, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required');\n  }\n\n  if (!traces) {\n    return callback(new TypeError('must pass traces to send'));\n  }\n\n  this._sendData(this._methods.traces, traces, callback);\n}\n/**\n * Sends no data aside from the message itself. Clears the run ID, which\n * effectively disconnects the agent from the collector.\n *\n * @param Function callback Runs after the run ID has been cleared.\n */\n\n\nCollectorAPI.prototype.shutdown = function shutdown(callback) {\n  if (!callback) {\n    throw new TypeError('callback is required');\n  }\n\n  logger.info('Shutting down collector.');\n  var agent = this._agent;\n\n  this._methods.shutdown.invoke(null, this._reqHeadersMap, onShutdown);\n\n  function onShutdown(error, response) {\n    if (error) {\n      dumpErrors([error], 'shutdown');\n    }\n\n    agent.setState('disconnected');\n    logger.info('Disconnected from New Relic; clearing run ID %s.', agent.config.run_id);\n    agent.config.run_id = undefined;\n    callback(error, CollectorResponse.fatal(response && response.payload));\n  }\n};\n\nCollectorAPI.prototype.restart = function restart(callback) {\n  logger.info('Restarting collector.');\n\n  this._agent.stopAggregators();\n\n  var api = this;\n  this.shutdown(function reconnect() {\n    api.connect(function afterConnect() {\n      api._agent.onConnect();\n\n      api._agent.startAggregators();\n\n      return callback.apply(null, arguments);\n    });\n  });\n};\n\nCollectorAPI.prototype._runLifecycle = function _runLifecycle(method, body, callback) {\n  if (!this.isConnected()) {\n    logger.warn('Not connected to New Relic. Not calling.', method.name);\n    const error = new Error('Not connected to collector.', null, null);\n    return setImmediate(callback, error);\n  }\n\n  const api = this;\n  method.invoke(body, this._reqHeadersMap, function standardHandler(error, response) {\n    if (error) {\n      return callback(error);\n    }\n\n    return api._handleResponseCode(response, method.name, callback);\n  });\n};\n\nCollectorAPI.prototype._sendData = function _sendData(method, data, callback) {\n  this._runLifecycle(method, data, (error, response) => {\n    // Any runtime errors should preserve the agent run.\n    if (error) {\n      // TODO: log error\n      // TODO: differentiate between network (retain) and non-network (drop).\n      callback(error, {\n        retainData: true\n      });\n      return;\n    }\n\n    if (!response) {\n      callback();\n      return;\n    } // TODO: log the payload if exists?\n\n\n    if (response.agentRun === AGENT_RUN_BEHAVIOR.SHUTDOWN) {\n      // TODO: for now, shut handled in _handleResponseCode for consistency\n      // either find way to safely change while side-by-side or move\n      // once side-by-side gone. Currently, stop is called twice on teh old code path\n      // TODO: almost seems better to let aggregator finish (cb) then shutdown?\n      // this._agent.stop((err) => {\n      //   // TODO: agent stop requires a callback. if we don't care to do anythig here\n      //   // do we loosen that requirement or perhaps have a different \"shutdown\"\n      //   // method? Does seem like you'd want to log a shutdown error\n      //   // but don't really care about that *here*\n      // })\n      callback(null, {\n        retainData: response.retainData\n      });\n    } else if (response.agentRun === AGENT_RUN_BEHAVIOR.RESTART) {\n      // TODO: almost seems better to leg aggregator finish (cb) then restart?\n      // TODO: ensure harvesting stopped for all other endpoints. same for shutdown.\n      this.restart(function afterRestart(connectError) {\n        if (connectError) {\n          // TODO: What if preconnect/connect respond with shutdown here?\n          // TODO: maybe indicate which endpoint triggered\n          // other behaviors on failure?\n          logger.warn('Failed to restart agent run.');\n        } else {\n          logger.trace('Restart succeeded.');\n        }\n\n        callback(null, {\n          retainData: response.retainData\n        }); // TODO: keep object or enum of actions? retain / split / other?\n      });\n    } else {\n      callback(null, {\n        retainData: response.retainData\n      });\n    }\n  });\n};\n\nCollectorAPI.prototype.isConnected = function isConnected() {\n  return !!this._agent.config.run_id;\n};\n/**\n * Returns appropriate CollectorResponse object according to response code.\n *\n * @param {object} response\n * @param {number} response.status  - Status code from collector response\n * @param {object} response.payload - Parsed response body, if any\n * @param {string} endpoint         - Collector endpoint name\n * @param {Function} cb             - CollectorAPI method invocation callback\n */\n\n\nCollectorAPI.prototype._handleResponseCode = _handleResponseCode;\n\nfunction _handleResponseCode(response, endpoint, cb) {\n  const code = response.status;\n  /* eslint-disable padded-blocks */\n\n  if (SUCCESS.has(code)) {\n    // The request was a success!\n    return setImmediate(cb, null, CollectorResponse.success(response.payload));\n  } else if (RESTART.has(code)) {\n    // The agent needs to disconnect and restart.\n    logFailure(endpoint, code, 'Restarting');\n    return setImmediate(cb, null, CollectorResponse.reconnect(0, null));\n  } else if (FAILURE_DISCARD_DATA.has(code)) {\n    // Something was wrong with our payload so we must delete our data.\n    logFailure(endpoint, code, 'Discarding harvest data');\n    return setImmediate(cb, null, CollectorResponse.discard(null));\n  } else if (FAILURE_SAVE_DATA.has(code)) {\n    // Something was wrong with the request, but it wasn't our fault. We'll try again.\n    logFailure(endpoint, code, 'Retaining data for next harvest');\n    return setImmediate(cb, null, CollectorResponse.error(response.payload));\n  } else if (code === 410) {\n    // New Relic doesn't like us and we shouldn't try to talk to them any more.\n    logFailure(endpoint, code, 'Disconnecting from New Relic');\n    return this._agent.stop(function onShutdown() {\n      cb(null, CollectorResponse.fatal(response.payload));\n    });\n  }\n  /* eslint-enable padded-blocks */\n  // We're not sure what New Relic is trying to tell us. Let's get rid of our\n  // data just in case it is our fault.\n\n\n  logger.error('Agent endpoint %s returned unexpected status %s.', endpoint, code);\n  return setImmediate(cb, null, CollectorResponse.discard(null));\n}\n\nfunction logFailure(endpoint, code, action) {\n  logger.error('Agent endpoint %s returned %s status. %s.', endpoint, code, action);\n}\n\nmodule.exports = CollectorAPI;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/collector/api.js"],"names":["CollectorResponse","require","facts","logger","child","component","RemoteMethod","NAMES","TO_MILLIS","BACKOFFS","interval","warn","SUCCESS","Set","RESTART","FAILURE_SAVE_DATA","FAILURE_DISCARD_DATA","AGENT_RUN_BEHAVIOR","dumpErrors","errors","name","index","forEach","forEachError","error","trace","laterErrors","forEachLaterError","laterError","CollectorAPI","agent","_agent","_reqHeadersMap","_methods","redirect","config","handshake","settings","metrics","traces","shutdown","events","customEvents","queryData","errorEvents","spanEvents","prototype","connect","callback","TypeError","setState","api","max","length","attempts","metric","getOrCreateMetric","SUPPORTABILITY","REGISTRATION","retry","response","incrementCallCount","push","has","status","success","payload","agentRun","SHUTDOWN","fatal","backoff","Math","min","debug","timeout","setTimeout","again","_login","unref","methods","self","preconnectData","high_security","security_policies_token","invoke","onPreConnect","res","Object","create","redirect_host","host","parts","split","port","policies","security_policies","laspResponse","applyLasp","shouldShutdownRun","_getFacts","lasp","getEnvDict","environmentDict","environment","_connect","env","collector","onConnect","agent_run_id","Error","info","messages","element","message","request_headers_map","reconfigure","reportSettings","publicSettings","onReportSettings","error_data","errorData","_sendData","error_event_data","analytic_event_data","transactionEvents","custom_event_data","metric_data","metricData","sql_trace_data","queries","span_event_data","transaction_sample_data","transactionSampleData","onShutdown","run_id","undefined","restart","stopAggregators","reconnect","afterConnect","startAggregators","apply","arguments","_runLifecycle","method","body","isConnected","setImmediate","standardHandler","_handleResponseCode","data","retainData","afterRestart","connectError","endpoint","cb","code","logFailure","discard","stop","action","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CollectorResponse = require('./response')\nconst facts = require('./facts')\nconst logger = require('../logger').child({component: 'collector_api'})\nconst RemoteMethod = require('./remote-method')\n\nconst NAMES = require('../metrics/names')\n\n// just to make clear what's going on\nconst TO_MILLIS = 1e3\n\n// taken directly from Python agent's newrelic.core.application\nconst BACKOFFS = [\n  {interval: 15, warn: false},\n  {interval: 15, warn: false},\n  {interval: 30, warn: false},\n  {interval: 60, warn: true},\n  {interval: 120, warn: false},\n  {interval: 300, warn: false}\n]\n\n// Expected collector response codes\nconst SUCCESS = new Set([200, 202])\nconst RESTART = new Set([401, 409])\nconst FAILURE_SAVE_DATA = new Set([408, 429, 500, 503])\nconst FAILURE_DISCARD_DATA = new Set(\n  [400, 403, 404, 405, 407, 411, 413, 414, 415, 417, 431]\n)\n\nconst AGENT_RUN_BEHAVIOR = CollectorResponse.AGENT_RUN_BEHAVIOR\n\nfunction dumpErrors(errors, name) {\n  var index = 1\n\n  errors.forEach(function forEachError(error) {\n    logger.trace(error, 'Error %s during %s:', index++, name)\n\n    if (error.laterErrors) {\n      error.laterErrors.forEach(function forEachLaterError(laterError) {\n        logger.trace(laterError, 'Error %s during %s:', index++, name)\n      })\n    }\n  })\n}\n\n\nfunction CollectorAPI(agent) {\n  this._agent = agent\n  this._reqHeadersMap = null\n\n  /* RemoteMethods can be reused and have little per-object state, so why not\n   * save some GC time?\n   */\n  this._methods = {\n    redirect: new RemoteMethod('preconnect', agent.config),\n    handshake: new RemoteMethod('connect', agent.config),\n    settings: new RemoteMethod('agent_settings', agent.config),\n    errors: new RemoteMethod('error_data', agent.config),\n    metrics: new RemoteMethod('metric_data', agent.config),\n    traces: new RemoteMethod('transaction_sample_data', agent.config),\n    shutdown: new RemoteMethod('shutdown', agent.config),\n    events: new RemoteMethod('analytic_event_data', agent.config),\n    customEvents: new RemoteMethod('custom_event_data', agent.config),\n    queryData: new RemoteMethod('sql_trace_data', agent.config),\n    errorEvents: new RemoteMethod('error_event_data', agent.config),\n    spanEvents: new RemoteMethod('span_event_data', agent.config)\n  }\n}\n\nCollectorAPI.prototype.connect = function connect(callback) {\n  if (!callback) {\n    throw new TypeError('callback is required')\n  }\n\n  logger.trace('Starting collector.')\n\n  this._agent.setState('connecting')\n\n  const api = this\n  const max = BACKOFFS.length\n  const errors = []\n  let attempts = 1\n\n  const metric = this._agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.REGISTRATION + '/Attempts'\n  )\n\n  // Reset headers map for good measure\n  if (this._reqHeadersMap) {\n    this._reqHeadersMap = null\n  }\n\n  function retry(error, response) {\n    metric.incrementCallCount()\n\n    if (error) {\n      errors.push(error)\n    } else if (response && SUCCESS.has(response.status)) {\n      dumpErrors(errors, 'connect')\n      return callback(null, CollectorResponse.success(response.payload))\n    }\n    if (!response) {\n      response = CollectorResponse.retry()\n    }\n\n    // Retry everything except for an explicit Disconnect response code.\n    if (response.status === 410 || response.agentRun === AGENT_RUN_BEHAVIOR.SHUTDOWN) {\n      logger.error('The New Relic collector rejected this agent.')\n      return callback(null, CollectorResponse.fatal(response.payload))\n    } else if (response.status === 401) {\n      logger.warn(\n        error,\n        'Your license key appears to be invalid. Reattempting connection to New' +\n        ' Relic. If the problem persists, please contact support@newrelic.com.' +\n        ' (status code %s)',\n        response.status\n      )\n    }\n\n    let backoff = BACKOFFS[Math.min(attempts, max) - 1]\n    if (backoff.warn) {\n      logger.warn(\n        'No connection has been established to New Relic after %d attempts.',\n        attempts\n      )\n    }\n\n    logger.debug(\n      error,\n      'Failed to connect to New Relic after attempt %d, waiting %ds to retry.',\n      attempts,\n      backoff.interval\n    )\n\n    ++attempts\n    const timeout = setTimeout(function again() {\n      api._login(retry)\n    }, backoff.interval * TO_MILLIS)\n    timeout.unref()\n  }\n\n  this._login(retry)\n}\n\nCollectorAPI.prototype._login = function _login(callback) {\n  var methods = this._methods\n  var agent = this._agent\n  var self = this\n\n  const preconnectData = { high_security: agent.config.high_security }\n  if (agent.config.security_policies_token) {\n    preconnectData.security_policies_token = agent.config.security_policies_token\n  }\n\n  const payload = [preconnectData]\n\n  methods.redirect.invoke(payload, onPreConnect)\n\n  function onPreConnect(error, response) {\n    if (error || !SUCCESS.has(response.status)) {\n      return callback(error, response)\n    }\n\n    const res = response.payload || Object.create(null)\n    if (!res.redirect_host) {\n      logger.error(\n        \"Requesting this account's collector from %s failed; trying default.\",\n        agent.config.host\n      )\n    } else {\n      var parts = res.redirect_host.split(':')\n      if (parts.length > 2) {\n        logger.error(\n          \"Requesting collector from %s returned bogus result '%s'; trying default.\",\n          agent.config.host,\n          res.redirect_host\n        )\n      } else {\n        logger.debug(\n          \"Requesting this account's collector from %s returned %s; reconfiguring.\",\n          agent.config.host,\n          res.redirect_host\n        )\n\n        agent.config.host = parts[0]\n        agent.config.port = parts[1] || 443\n      }\n    }\n\n    var policies = res.security_policies || Object.create(null)\n\n    const laspResponse = agent.config.applyLasp(agent, policies)\n    if (laspResponse.shouldShutdownRun()) {\n      return callback(null, laspResponse)\n    }\n\n    self._getFacts(laspResponse.payload, callback)\n  }\n}\n\nCollectorAPI.prototype._getFacts = function _getFacts(lasp, callback) {\n  var agent = this._agent\n  var self = this\n\n  facts(agent, function getEnvDict(environmentDict) {\n    if (lasp) {\n      environmentDict.security_policies = lasp\n    }\n\n    // The collector really likes arrays.\n    // In fact, it kind of insists on them.\n    var environment = [environmentDict]\n\n    self._connect(environment, callback)\n  })\n}\n\nCollectorAPI.prototype._connect = function _connect(env, callback) {\n  const collector = this\n  const methods = this._methods\n  const agent = this._agent\n\n  methods.handshake.invoke(env, onConnect)\n\n  function onConnect(error, res) {\n    if (error || !SUCCESS.has(res.status)) {\n      return callback(error, res)\n    }\n\n    const config = res.payload\n    if (!config || !config.agent_run_id) {\n      return callback(new Error('No agent run ID received from handshake.'), res)\n    }\n\n    agent.setState('connected')\n    logger.info(\n      'Connected to %s:%d with agent run ID %s.',\n      agent.config.host,\n      agent.config.port,\n      config.agent_run_id\n    )\n\n    // Log \"Reporting to...\" message from connect response.\n    if (config.messages) {\n      config.messages.forEach((element) => {\n        logger.info(element.message)\n      })\n    }\n\n    // Store request headers for future collector requests if they're present\n    collector._reqHeadersMap = config.request_headers_map\n\n    // pass configuration data from the API so automatic reconnect works\n    agent.reconfigure(config)\n\n    callback(null, res)\n  }\n}\n\n/**\n * Send current public agent settings to collector. This should always be\n * invoked after a successful connect response with server-side settings, but\n * will also be invoked on any other config changes.\n *\n * @param {Function} callback The continuation / error handler.\n */\nCollectorAPI.prototype.reportSettings = function reportSettings(callback) {\n  // The second argument to the callback is always empty data\n  this._methods.settings.invoke(\n    [this._agent.config.publicSettings()],\n    this._reqHeadersMap,\n    function onReportSettings(error, response) {\n      if (error) dumpErrors([error], 'agent_settings')\n\n      if (callback) callback(error, response)\n    }\n  )\n}\n\n/**\n * Send already-formatted error data by calling error_data. For\n * performance reasons, the API methods do no validation, but the\n * collector expects data in an exact format. It expects a JSON array\n * containing the following 2 elements:\n *\n * 1. The agent run ID.\n * 2. An array of one or more errors. See lib/error.js for details.\n *\n * @param {Array}    errors   The encoded errors list.\n * @param {Function} callback The continuation / error handler.\n */\nCollectorAPI.prototype.error_data = function errorData(errors, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required')\n  }\n  if (!errors) {\n    return callback(new TypeError('must pass errors to send'))\n  }\n\n  this._sendData(this._methods.errors, errors, callback)\n}\n\nCollectorAPI.prototype.error_event_data = function errorEvents(events, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required')\n  }\n  if (!events) {\n    return callback(new TypeError('must pass errors to send'))\n  }\n\n  this._sendData(this._methods.errorEvents, events, callback)\n}\n\nCollectorAPI.prototype.analytic_event_data = transactionEvents\nfunction transactionEvents(events, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required')\n  }\n  if (!events) {\n    return callback(new TypeError('must pass events to send'))\n  }\n\n  this._sendData(this._methods.events, events, callback)\n}\n\nCollectorAPI.prototype.custom_event_data = function customEvents(events, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required')\n  }\n  if (!events) {\n    return callback(new TypeError('must pass events to send'))\n  }\n\n  this._sendData(this._methods.customEvents, events, callback)\n}\n\n/**\n * Send already-formatted metric data by calling metric_data. For\n * performance reasons, the API methods do no validation, but the collector\n * expects data in an exact format format. It expects a JSON array containing\n * the following 4 elements:\n *\n * 1. The agent run ID.\n * 2. The time the metric data started being collected, in seconds since the\n *    epoch.\n * 3. The time the metric data finished being collected, in seconds since the\n *    epoch.\n * 4. An array of 1 or more metric arrays. See lib/metrics.js for details.\n *\n * @param {Array}    metrics  The encoded metrics list.\n * @param {Function} callback The continuation / error handler.\n */\nCollectorAPI.prototype.metric_data = function metricData(metrics, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required')\n  }\n  if (!metrics) {\n    return callback(new TypeError('must pass metrics to send'))\n  }\n\n  this._sendData(this._methods.metrics, metrics, callback)\n}\n\n/**\n * Send already-formatted slow SQL data by calling\n * sql_trace_data. For performance reasons, the API methods\n * do no validation, but the collector expects data in an exact format\n * format. It expects a JSON array containing the following 2 elements:\n *\n * 1. The agent run ID.\n * 2. The encoded slow SQL data.\n *\n * @param {Array}    queries  The encoded slow SQL data.\n * @param {Function} callback The continuation / error handler.\n */\nCollectorAPI.prototype.sql_trace_data = function queryData(queries, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required')\n  }\n  if (!queries) {\n    return callback(new TypeError('must pass queries to send'))\n  }\n  this._sendData(this._methods.queryData, queries, callback)\n}\n\nCollectorAPI.prototype.span_event_data = function spanEvents(events, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required')\n  }\n  if (!events) {\n    return callback(new TypeError('must pass spans to send'))\n  }\n  this._sendData(this._methods.spanEvents, events, callback)\n}\n\n/**\n * Send already-formatted slow trace data by calling\n * transaction_sample_data. For performance reasons, the API methods\n * do no validation, but the collector expects data in an exact format\n * format. It expects a JSON array containing the following 2 elements:\n *\n * 1. The agent run ID.\n * 2. The encoded slow trace data. This is the most complicated data\n *    format handled by the module, and documenting it is almost beyond the\n *    scope of comments. See lib/transaction/trace.js for details.\n *\n * @param {Array}    trace    The encoded trace data.\n * @param {Function} callback The continuation / error handler.\n */\nCollectorAPI.prototype.transaction_sample_data = transactionSampleData\nfunction transactionSampleData(traces, callback) {\n  if (!callback) {\n    throw new TypeError('callback is required')\n  }\n  if (!traces) {\n    return callback(new TypeError('must pass traces to send'))\n  }\n\n  this._sendData(this._methods.traces, traces, callback)\n}\n\n/**\n * Sends no data aside from the message itself. Clears the run ID, which\n * effectively disconnects the agent from the collector.\n *\n * @param Function callback Runs after the run ID has been cleared.\n */\nCollectorAPI.prototype.shutdown = function shutdown(callback) {\n  if (!callback) {\n    throw new TypeError('callback is required')\n  }\n\n  logger.info('Shutting down collector.')\n\n  var agent = this._agent\n  this._methods.shutdown.invoke(null, this._reqHeadersMap, onShutdown)\n\n  function onShutdown(error, response) {\n    if (error) {\n      dumpErrors([error], 'shutdown')\n    }\n\n    agent.setState('disconnected')\n    logger.info(\n      'Disconnected from New Relic; clearing run ID %s.',\n      agent.config.run_id\n    )\n    agent.config.run_id = undefined\n\n    callback(error, CollectorResponse.fatal(response && response.payload))\n  }\n}\n\nCollectorAPI.prototype.restart = function restart(callback) {\n  logger.info('Restarting collector.')\n\n  this._agent.stopAggregators()\n  var api = this\n  this.shutdown(function reconnect() {\n    api.connect(function afterConnect() {\n      api._agent.onConnect()\n      api._agent.startAggregators()\n      return callback.apply(null, arguments)\n    })\n  })\n}\n\nCollectorAPI.prototype._runLifecycle = function _runLifecycle(method, body, callback) {\n  if (!this.isConnected()) {\n    logger.warn('Not connected to New Relic. Not calling.', method.name)\n    const error = new Error('Not connected to collector.', null, null)\n    return setImmediate(callback, error)\n  }\n\n  const api = this\n  method.invoke(body, this._reqHeadersMap, function standardHandler(error, response) {\n    if (error) {\n      return callback(error)\n    }\n\n    return api._handleResponseCode(response, method.name, callback)\n  })\n}\n\nCollectorAPI.prototype._sendData = function _sendData(method, data, callback) {\n  this._runLifecycle(method, data, (error, response) => {\n    // Any runtime errors should preserve the agent run.\n    if (error) {\n      // TODO: log error\n      // TODO: differentiate between network (retain) and non-network (drop).\n\n      callback(error, { retainData: true })\n\n      return\n    }\n\n    if (!response) {\n      callback()\n\n      return\n    }\n\n    // TODO: log the payload if exists?\n\n    if (response.agentRun === AGENT_RUN_BEHAVIOR.SHUTDOWN) {\n      // TODO: for now, shut handled in _handleResponseCode for consistency\n      // either find way to safely change while side-by-side or move\n      // once side-by-side gone. Currently, stop is called twice on teh old code path\n\n      // TODO: almost seems better to let aggregator finish (cb) then shutdown?\n\n      // this._agent.stop((err) => {\n      //   // TODO: agent stop requires a callback. if we don't care to do anythig here\n      //   // do we loosen that requirement or perhaps have a different \"shutdown\"\n      //   // method? Does seem like you'd want to log a shutdown error\n      //   // but don't really care about that *here*\n      // })\n\n      callback(null, {retainData: response.retainData})\n    } else if (response.agentRun === AGENT_RUN_BEHAVIOR.RESTART) {\n      // TODO: almost seems better to leg aggregator finish (cb) then restart?\n\n      // TODO: ensure harvesting stopped for all other endpoints. same for shutdown.\n\n      this.restart(function afterRestart(connectError) {\n        if (connectError) {\n          // TODO: What if preconnect/connect respond with shutdown here?\n\n          // TODO: maybe indicate which endpoint triggered\n          // other behaviors on failure?\n          logger.warn('Failed to restart agent run.')\n        } else {\n          logger.trace('Restart succeeded.')\n        }\n\n        callback(null, {retainData: response.retainData})\n        // TODO: keep object or enum of actions? retain / split / other?\n      })\n    } else {\n      callback(null, {\n        retainData: response.retainData\n      })\n    }\n  })\n}\n\n\nCollectorAPI.prototype.isConnected = function isConnected() {\n  return !!this._agent.config.run_id\n}\n\n/**\n * Returns appropriate CollectorResponse object according to response code.\n *\n * @param {object} response\n * @param {number} response.status  - Status code from collector response\n * @param {object} response.payload - Parsed response body, if any\n * @param {string} endpoint         - Collector endpoint name\n * @param {Function} cb             - CollectorAPI method invocation callback\n */\nCollectorAPI.prototype._handleResponseCode = _handleResponseCode\nfunction _handleResponseCode(response, endpoint, cb) {\n  const code = response.status\n\n  /* eslint-disable padded-blocks */\n  if (SUCCESS.has(code)) {\n    // The request was a success!\n    return setImmediate(cb, null, CollectorResponse.success(response.payload))\n  } else if (RESTART.has(code)) {\n    // The agent needs to disconnect and restart.\n    logFailure(endpoint, code, 'Restarting')\n    return setImmediate(cb, null, CollectorResponse.reconnect(0, null))\n\n  } else if (FAILURE_DISCARD_DATA.has(code)) {\n    // Something was wrong with our payload so we must delete our data.\n    logFailure(endpoint, code, 'Discarding harvest data')\n    return setImmediate(cb, null, CollectorResponse.discard(null))\n\n  } else if (FAILURE_SAVE_DATA.has(code)) {\n    // Something was wrong with the request, but it wasn't our fault. We'll try again.\n    logFailure(endpoint, code, 'Retaining data for next harvest')\n    return setImmediate(cb, null, CollectorResponse.error(response.payload))\n\n  } else if (code === 410) {\n    // New Relic doesn't like us and we shouldn't try to talk to them any more.\n    logFailure(endpoint, code, 'Disconnecting from New Relic')\n\n    return this._agent.stop(function onShutdown() {\n      cb(null, CollectorResponse.fatal(response.payload))\n    })\n  }\n  /* eslint-enable padded-blocks */\n\n  // We're not sure what New Relic is trying to tell us. Let's get rid of our\n  // data just in case it is our fault.\n  logger.error(\n    'Agent endpoint %s returned unexpected status %s.',\n    endpoint,\n    code\n  )\n  return setImmediate(cb, null, CollectorResponse.discard(null))\n}\n\nfunction logFailure(endpoint, code, action) {\n  logger.error('Agent endpoint %s returned %s status. %s.', endpoint, code, action)\n}\n\nmodule.exports = CollectorAPI\n"]},"metadata":{},"sourceType":"script"}