{"ast":null,"code":"'use strict';\n\nvar url = require('url'); // TODO: Make this an external module.\n// var newrelic = require('newrelic')\n// newrelic.instrumentMessages('amqplib', instrumentChannelAPI)\n// newrelic.instrumentMessages('amqplib/channel_api', instrumentChannelAPI)\n// newrelic.instrumentMessages('amqplib/channel_api.js', instrumentChannelAPI)\n// newrelic.instrumentMessages('amqplib/callback_api', instrumentCallbackAPI)\n// newrelic.instrumentMessages('amqplib/callback_api.js', instrumentCallbackAPI)\n\n\nmodule.exports.selfRegister = function selfRegister(shimmer) {\n  shimmer.registerInstrumentation({\n    moduleName: 'amqplib',\n    type: 'message',\n    onRequire: instrumentChannelAPI\n  });\n  shimmer.registerInstrumentation({\n    moduleName: 'amqplib/channel_api',\n    type: 'message',\n    onRequire: instrumentChannelAPI\n  });\n  shimmer.registerInstrumentation({\n    moduleName: 'amqplib/channel_api.js',\n    type: 'message',\n    onRequire: instrumentChannelAPI\n  });\n  shimmer.registerInstrumentation({\n    moduleName: 'amqplib/callback_api',\n    type: 'message',\n    onRequire: instrumentCallbackAPI\n  });\n  shimmer.registerInstrumentation({\n    moduleName: 'amqplib/callback_api.js',\n    type: 'message',\n    onRequire: instrumentCallbackAPI\n  });\n};\n\nmodule.exports.instrumentPromiseAPI = instrumentChannelAPI;\nmodule.exports.instrumentCallbackAPI = instrumentCallbackAPI;\nvar CHANNEL_METHODS = ['close', 'open', 'assertQueue', 'checkQueue', 'deleteQueue', 'bindQueue', 'unbindQueue', 'assertExchange', 'checkExchange', 'deleteExchange', 'bindExchange', 'unbindExchange', 'cancel', 'prefetch', 'recover'];\nvar TEMP_RE = /^amq\\./;\n\nfunction instrumentChannelAPI(shim, amqp) {\n  instrumentAMQP(shim, amqp, true);\n  wrapPromiseChannel(shim);\n}\n\nfunction instrumentCallbackAPI(shim, amqp) {\n  instrumentAMQP(shim, amqp, false);\n  wrapCallbackChannel(shim);\n}\n\nfunction instrumentAMQP(shim, amqp, promiseMode) {\n  if (!amqp || !amqp.connect) {\n    shim.logger.debug('This module is not the amqplib we\\'re looking for.');\n    return false;\n  }\n\n  if (shim.isWrapped(amqp.connect)) {\n    shim.logger.trace('This module has already been instrumented, skipping.');\n    return;\n  }\n\n  shim.setLibrary(shim.RABBITMQ);\n  shim.record(amqp, 'connect', function recordConnect(shim, connect, name, args) {\n    var connArgs = args[0];\n    var params = null;\n\n    if (shim.isString(connArgs)) {\n      connArgs = url.parse(connArgs);\n      params = {\n        host: connArgs.hostname\n      };\n\n      if (connArgs.port) {\n        params.port = connArgs.port;\n      }\n    }\n\n    return {\n      name: 'amqplib.connect',\n      callback: promiseMode ? null : shim.LAST,\n      promise: promiseMode,\n      parameters: params,\n      stream: null,\n      recorder: null\n    };\n  });\n  wrapChannel(shim);\n}\n\nfunction wrapChannel(shim) {\n  var libChannel = shim.require('./lib/channel');\n\n  if (!libChannel || !libChannel.Channel || !libChannel.Channel.prototype) {\n    shim.logger.debug('Could not get Channel class to instrument.');\n    return;\n  }\n\n  var proto = libChannel.Channel.prototype;\n\n  if (shim.isWrapped(proto.sendMessage)) {\n    shim.logger.trace('Channel already instrumented.');\n    return;\n  }\n\n  shim.logger.trace('Instrumenting basic Channel class.');\n  shim.wrap(proto, 'sendOrEnqueue', function wrapSendOrEnqueue(shim, fn) {\n    if (!shim.isFunction(fn)) {\n      return fn;\n    }\n\n    return function wrappedSendOrEnqueue() {\n      var segment = shim.getSegment();\n      var cb = arguments[arguments.length - 1];\n\n      if (!shim.isFunction(cb) || !segment) {\n        shim.logger.debug({\n          cb: !!cb,\n          segment: !!segment\n        }, 'Not binding sendOrEnqueue callback');\n        return fn.apply(this, arguments);\n      }\n\n      shim.logger.trace('Binding sendOrEnqueue callback to %s', segment.name);\n      var args = shim.argsToArray.apply(shim, arguments);\n      args[args.length - 1] = shim.bindSegment(cb, segment);\n      return fn.apply(this, args);\n    };\n  }); // Example fields:\n  // { exchange: 'test-exchange-topic',\n  //   routingKey: 'routing.key',\n  //   mandatory: false,\n  //   immediate: false,\n  //   ticket: undefined,\n  //   contentType: undefined,\n  //   contentEncoding: undefined,\n  //   headers: {},\n  //   deliveryMode: undefined,\n  //   priority: undefined,\n  //   correlationId: undefined,\n  //   replyTo: undefined,\n  //   expiration: undefined,\n  //   messageId: undefined,\n  //   timestamp: undefined,\n  //   type: undefined,\n  //   userId: undefined,\n  //   appId: undefined,\n  //   clusterId: undefined }\n\n  shim.recordProduce(proto, 'sendMessage', recordSendMessage);\n\n  function recordSendMessage(shim, fn, n, args) {\n    var fields = args[0];\n\n    if (!fields) {\n      return null;\n    }\n\n    var isDefault = fields.exchange === '';\n    let exchange = 'Default';\n\n    if (!isDefault) {\n      exchange = TEMP_RE.test(fields.exchange) ? null : fields.exchange;\n    }\n\n    return {\n      destinationName: exchange,\n      destinationType: shim.EXCHANGE,\n      routingKey: fields.routingKey,\n      headers: fields.headers,\n      parameters: getParameters(Object.create(null), fields)\n    };\n  }\n}\n\nfunction getParameters(parameters, fields) {\n  if (fields.routingKey) {\n    parameters.routing_key = fields.routingKey;\n  }\n\n  if (fields.correlationId) {\n    parameters.correlation_id = fields.correlationId;\n  }\n\n  if (fields.replyTo) {\n    parameters.reply_to = fields.replyTo;\n  }\n\n  return parameters;\n}\n\nfunction wrapPromiseChannel(shim) {\n  var libPModel = shim.require('./lib/channel_model');\n\n  if (!libPModel || !libPModel.Channel || !libPModel.Channel.prototype) {\n    shim.logger.debug('Could not get promise model Channel to instrument');\n  }\n\n  var proto = libPModel.Channel.prototype;\n\n  if (shim.isWrapped(proto.consume)) {\n    shim.logger.trace('Promise model already isntrumented.');\n    return;\n  }\n\n  shim.record(proto, CHANNEL_METHODS, function recordChannelMethod(shim, fn, name) {\n    return {\n      name: 'Channel#' + name,\n      promise: true\n    };\n  });\n  shim.recordConsume(proto, 'get', {\n    destinationName: shim.FIRST,\n    promise: true,\n    messageHandler: function handleConsumedMessage(shim, fn, name, message) {\n      if (!message) {\n        shim.logger.trace('No results from consume.');\n        return null;\n      }\n\n      var parameters = Object.create(null);\n      getParameters(parameters, message.fields);\n      getParameters(parameters, message.properties);\n      var headers = null;\n\n      if (message.properties && message.properties.headers) {\n        headers = message.properties.headers;\n      }\n\n      return {\n        parameters: parameters,\n        headers: headers\n      };\n    }\n  });\n  shim.recordPurgeQueue(proto, 'purgeQueue', function recordPurge(shim, fn, name, args) {\n    var queue = args[0] || null;\n\n    if (TEMP_RE.test(queue)) {\n      queue = null;\n    }\n\n    return {\n      queue: queue,\n      promise: true\n    };\n  });\n  shim.recordSubscribedConsume(proto, 'consume', {\n    name: 'amqplib.Channel#consume',\n    queue: shim.FIRST,\n    consumer: shim.SECOND,\n    promise: true,\n    messageHandler: describeMessage\n  });\n}\n\nfunction wrapCallbackChannel(shim) {\n  var libCbModel = shim.require('./lib/callback_model');\n\n  if (!libCbModel || !libCbModel.Channel || !libCbModel.Channel.prototype) {\n    shim.logger.debug('Could not get callback model Channel to instrument');\n    return;\n  }\n\n  var proto = libCbModel.Channel.prototype;\n\n  if (shim.isWrapped(proto.consume)) {\n    return;\n  } // Example message:\n  // { fields:\n  //  { consumerTag: 'amq.ctag-8oZE10ovvyAP8e-vgbOnSA',\n  //    deliveryTag: 1,\n  //    redelivered: false,\n  //    exchange: 'test-exchange-topic',\n  //    routingKey: 'routing.key' },\n  // properties:\n  //  { contentType: undefined,\n  //    contentEncoding: undefined,\n  //    headers: {},\n  //    deliveryMode: undefined,\n  //    priority: undefined,\n  //    correlationId: undefined,\n  //    replyTo: undefined,\n  //    expiration: undefined,\n  //    messageId: undefined,\n  //    timestamp: undefined,\n  //    type: undefined,\n  //    userId: undefined,\n  //    appId: undefined,\n  //    clusterId: undefined },\n  // content: Buffer [ 97 ] }\n\n\n  shim.record(proto, CHANNEL_METHODS, function recordChannelMethod(shim, fn, name) {\n    return {\n      name: 'Channel#' + name,\n      callback: shim.LAST\n    };\n  });\n  shim.recordConsume(proto, 'get', {\n    destinationName: shim.FIRST,\n    callback: shim.LAST,\n    messageHandler: function handleConsumedMessage(shim, fn, name, args) {\n      var message = args[1];\n\n      if (!message) {\n        shim.logger.trace('No results from consume.');\n        return null;\n      }\n\n      var parameters = Object.create(null);\n      getParameters(parameters, message.fields);\n      getParameters(parameters, message.properties);\n      var headers = null;\n\n      if (message.properties && message.properties.headers) {\n        headers = message.properties.headers;\n      }\n\n      return {\n        parameters: parameters,\n        headers: headers\n      };\n    }\n  });\n  shim.recordPurgeQueue(proto, 'purgeQueue', function recordPurge(shim, fn, name, args) {\n    var queue = args[0];\n\n    if (TEMP_RE.test(queue)) {\n      queue = null;\n    }\n\n    return {\n      queue: queue,\n      callback: shim.LAST\n    };\n  });\n  shim.recordSubscribedConsume(proto, 'consume', {\n    name: 'amqplib.Channel#consume',\n    queue: shim.FIRST,\n    consumer: shim.SECOND,\n    callback: shim.FOURTH,\n    promise: false,\n    messageHandler: describeMessage\n  });\n}\n\nfunction describeMessage(shim, consumer, name, args) {\n  var message = args[0];\n\n  if (!message || !message.properties) {\n    shim.logger.debug({\n      message: message\n    }, 'Failed to find message in consume arguments.');\n    return null;\n  }\n\n  var exchangeName = message.fields.exchange;\n  var parameters = getParameters(Object.create(null), message.fields);\n  getParameters(parameters, message.properties);\n\n  if (!exchangeName) {\n    exchangeName = 'Default';\n  } else if (TEMP_RE.test(exchangeName)) {\n    exchangeName = null;\n  }\n\n  return {\n    destinationName: exchangeName,\n    destinationType: shim.EXCHANGE,\n    routingKey: message.fields.routingKey,\n    headers: message.properties.headers,\n    parameters: parameters\n  };\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/instrumentation/amqplib.js"],"names":["url","require","module","exports","selfRegister","shimmer","registerInstrumentation","moduleName","type","onRequire","instrumentChannelAPI","instrumentCallbackAPI","instrumentPromiseAPI","CHANNEL_METHODS","TEMP_RE","shim","amqp","instrumentAMQP","wrapPromiseChannel","wrapCallbackChannel","promiseMode","connect","logger","debug","isWrapped","trace","setLibrary","RABBITMQ","record","recordConnect","name","args","connArgs","params","isString","parse","host","hostname","port","callback","LAST","promise","parameters","stream","recorder","wrapChannel","libChannel","Channel","prototype","proto","sendMessage","wrap","wrapSendOrEnqueue","fn","isFunction","wrappedSendOrEnqueue","segment","getSegment","cb","arguments","length","apply","argsToArray","bindSegment","recordProduce","recordSendMessage","n","fields","isDefault","exchange","test","destinationName","destinationType","EXCHANGE","routingKey","headers","getParameters","Object","create","routing_key","correlationId","correlation_id","replyTo","reply_to","libPModel","consume","recordChannelMethod","recordConsume","FIRST","messageHandler","handleConsumedMessage","message","properties","recordPurgeQueue","recordPurge","queue","recordSubscribedConsume","consumer","SECOND","describeMessage","libCbModel","FOURTH","exchangeName"],"mappings":"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","sourcesContent":["'use strict'\n\nvar url = require('url')\n\n\n// TODO: Make this an external module.\n// var newrelic = require('newrelic')\n// newrelic.instrumentMessages('amqplib', instrumentChannelAPI)\n// newrelic.instrumentMessages('amqplib/channel_api', instrumentChannelAPI)\n// newrelic.instrumentMessages('amqplib/channel_api.js', instrumentChannelAPI)\n// newrelic.instrumentMessages('amqplib/callback_api', instrumentCallbackAPI)\n// newrelic.instrumentMessages('amqplib/callback_api.js', instrumentCallbackAPI)\nmodule.exports.selfRegister = function selfRegister(shimmer) {\n  shimmer.registerInstrumentation({\n    moduleName: 'amqplib',\n    type: 'message',\n    onRequire: instrumentChannelAPI\n  })\n  shimmer.registerInstrumentation({\n    moduleName: 'amqplib/channel_api',\n    type: 'message',\n    onRequire: instrumentChannelAPI\n  })\n  shimmer.registerInstrumentation({\n    moduleName: 'amqplib/channel_api.js',\n    type: 'message',\n    onRequire: instrumentChannelAPI\n  })\n  shimmer.registerInstrumentation({\n    moduleName: 'amqplib/callback_api',\n    type: 'message',\n    onRequire: instrumentCallbackAPI\n  })\n  shimmer.registerInstrumentation({\n    moduleName: 'amqplib/callback_api.js',\n    type: 'message',\n    onRequire: instrumentCallbackAPI\n  })\n}\n\nmodule.exports.instrumentPromiseAPI = instrumentChannelAPI\nmodule.exports.instrumentCallbackAPI = instrumentCallbackAPI\n\nvar CHANNEL_METHODS = [\n  'close',\n  'open',\n  'assertQueue',\n  'checkQueue',\n  'deleteQueue',\n  'bindQueue',\n  'unbindQueue',\n  'assertExchange',\n  'checkExchange',\n  'deleteExchange',\n  'bindExchange',\n  'unbindExchange',\n  'cancel',\n  'prefetch',\n  'recover'\n]\n\nvar TEMP_RE = /^amq\\./\n\n\nfunction instrumentChannelAPI(shim, amqp) {\n  instrumentAMQP(shim, amqp, true)\n  wrapPromiseChannel(shim)\n}\n\nfunction instrumentCallbackAPI(shim, amqp) {\n  instrumentAMQP(shim, amqp, false)\n  wrapCallbackChannel(shim)\n}\n\nfunction instrumentAMQP(shim, amqp, promiseMode) {\n  if (!amqp || !amqp.connect) {\n    shim.logger.debug('This module is not the amqplib we\\'re looking for.')\n    return false\n  }\n\n  if (shim.isWrapped(amqp.connect)) {\n    shim.logger.trace('This module has already been instrumented, skipping.')\n    return\n  }\n  shim.setLibrary(shim.RABBITMQ)\n\n  shim.record(amqp, 'connect', function recordConnect(shim, connect, name, args) {\n    var connArgs = args[0]\n    var params = null\n\n    if (shim.isString(connArgs)) {\n      connArgs = url.parse(connArgs)\n      params = {host: connArgs.hostname}\n      if (connArgs.port) {\n        params.port = connArgs.port\n      }\n    }\n\n    return {\n      name: 'amqplib.connect',\n      callback: promiseMode ? null : shim.LAST,\n      promise: promiseMode,\n      parameters: params,\n\n      stream: null,\n      recorder: null\n    }\n  })\n\n  wrapChannel(shim)\n}\n\nfunction wrapChannel(shim) {\n  var libChannel = shim.require('./lib/channel')\n  if (!libChannel || !libChannel.Channel || !libChannel.Channel.prototype) {\n    shim.logger.debug('Could not get Channel class to instrument.')\n    return\n  }\n\n  var proto = libChannel.Channel.prototype\n  if (shim.isWrapped(proto.sendMessage)) {\n    shim.logger.trace('Channel already instrumented.')\n    return\n  }\n  shim.logger.trace('Instrumenting basic Channel class.')\n\n  shim.wrap(proto, 'sendOrEnqueue', function wrapSendOrEnqueue(shim, fn) {\n    if (!shim.isFunction(fn)) {\n      return fn\n    }\n\n    return function wrappedSendOrEnqueue() {\n      var segment = shim.getSegment()\n      var cb = arguments[arguments.length - 1]\n      if (!shim.isFunction(cb) || !segment) {\n        shim.logger.debug(\n          {cb: !!cb, segment: !!segment},\n          'Not binding sendOrEnqueue callback'\n        )\n        return fn.apply(this, arguments)\n      }\n\n      shim.logger.trace('Binding sendOrEnqueue callback to %s', segment.name)\n      var args = shim.argsToArray.apply(shim, arguments)\n      args[args.length - 1] = shim.bindSegment(cb, segment)\n      return fn.apply(this, args)\n    }\n  })\n\n  // Example fields:\n  // { exchange: 'test-exchange-topic',\n  //   routingKey: 'routing.key',\n  //   mandatory: false,\n  //   immediate: false,\n  //   ticket: undefined,\n  //   contentType: undefined,\n  //   contentEncoding: undefined,\n  //   headers: {},\n  //   deliveryMode: undefined,\n  //   priority: undefined,\n  //   correlationId: undefined,\n  //   replyTo: undefined,\n  //   expiration: undefined,\n  //   messageId: undefined,\n  //   timestamp: undefined,\n  //   type: undefined,\n  //   userId: undefined,\n  //   appId: undefined,\n  //   clusterId: undefined }\n\n  shim.recordProduce(proto, 'sendMessage', recordSendMessage)\n  function recordSendMessage(shim, fn, n, args) {\n    var fields = args[0]\n    if (!fields) {\n      return null\n    }\n    var isDefault = fields.exchange === ''\n    let exchange = 'Default'\n    if (!isDefault) {\n      exchange = TEMP_RE.test(fields.exchange) ? null : fields.exchange\n    }\n\n    return {\n      destinationName: exchange,\n      destinationType: shim.EXCHANGE,\n      routingKey: fields.routingKey,\n      headers: fields.headers,\n      parameters: getParameters(Object.create(null), fields)\n    }\n  }\n}\n\nfunction getParameters(parameters, fields) {\n  if (fields.routingKey) {\n    parameters.routing_key = fields.routingKey\n  }\n  if (fields.correlationId) {\n    parameters.correlation_id = fields.correlationId\n  }\n  if (fields.replyTo) {\n    parameters.reply_to = fields.replyTo\n  }\n\n  return parameters\n}\n\nfunction wrapPromiseChannel(shim) {\n  var libPModel = shim.require('./lib/channel_model')\n  if (!libPModel || !libPModel.Channel || !libPModel.Channel.prototype) {\n    shim.logger.debug('Could not get promise model Channel to instrument')\n  }\n\n  var proto = libPModel.Channel.prototype\n  if (shim.isWrapped(proto.consume)) {\n    shim.logger.trace('Promise model already isntrumented.')\n    return\n  }\n\n  shim.record(proto, CHANNEL_METHODS, function recordChannelMethod(shim, fn, name) {\n    return {\n      name: 'Channel#' + name,\n      promise: true\n    }\n  })\n\n  shim.recordConsume(proto, 'get', {\n    destinationName: shim.FIRST,\n    promise: true,\n    messageHandler: function handleConsumedMessage(shim, fn, name, message) {\n      if (!message) {\n        shim.logger.trace('No results from consume.')\n        return null\n      }\n      var parameters = Object.create(null)\n      getParameters(parameters, message.fields)\n      getParameters(parameters, message.properties)\n\n      var headers = null\n      if (message.properties && message.properties.headers) {\n        headers = message.properties.headers\n      }\n\n      return {parameters: parameters, headers: headers}\n    }\n  })\n\n  shim.recordPurgeQueue(proto, 'purgeQueue', function recordPurge(shim, fn, name, args) {\n    var queue = args[0] || null\n    if (TEMP_RE.test(queue)) {\n      queue = null\n    }\n\n    return {queue: queue, promise: true}\n  })\n\n  shim.recordSubscribedConsume(proto, 'consume', {\n    name: 'amqplib.Channel#consume',\n    queue: shim.FIRST,\n    consumer: shim.SECOND,\n    promise: true,\n    messageHandler: describeMessage\n  })\n}\n\nfunction wrapCallbackChannel(shim) {\n  var libCbModel = shim.require('./lib/callback_model')\n  if (!libCbModel || !libCbModel.Channel || !libCbModel.Channel.prototype) {\n    shim.logger.debug('Could not get callback model Channel to instrument')\n    return\n  }\n\n  var proto = libCbModel.Channel.prototype\n  if (shim.isWrapped(proto.consume)) {\n    return\n  }\n\n  // Example message:\n  // { fields:\n  //  { consumerTag: 'amq.ctag-8oZE10ovvyAP8e-vgbOnSA',\n  //    deliveryTag: 1,\n  //    redelivered: false,\n  //    exchange: 'test-exchange-topic',\n  //    routingKey: 'routing.key' },\n  // properties:\n  //  { contentType: undefined,\n  //    contentEncoding: undefined,\n  //    headers: {},\n  //    deliveryMode: undefined,\n  //    priority: undefined,\n  //    correlationId: undefined,\n  //    replyTo: undefined,\n  //    expiration: undefined,\n  //    messageId: undefined,\n  //    timestamp: undefined,\n  //    type: undefined,\n  //    userId: undefined,\n  //    appId: undefined,\n  //    clusterId: undefined },\n  // content: Buffer [ 97 ] }\n\n  shim.record(proto, CHANNEL_METHODS, function recordChannelMethod(shim, fn, name) {\n    return {\n      name: 'Channel#' + name,\n      callback: shim.LAST\n    }\n  })\n\n  shim.recordConsume(proto, 'get', {\n    destinationName: shim.FIRST,\n    callback: shim.LAST,\n    messageHandler: function handleConsumedMessage(shim, fn, name, args) {\n      var message = args[1]\n      if (!message) {\n        shim.logger.trace('No results from consume.')\n        return null\n      }\n      var parameters = Object.create(null)\n      getParameters(parameters, message.fields)\n      getParameters(parameters, message.properties)\n\n      var headers = null\n      if (message.properties && message.properties.headers) {\n        headers = message.properties.headers\n      }\n\n      return {parameters: parameters, headers: headers}\n    }\n  })\n\n  shim.recordPurgeQueue(proto, 'purgeQueue', function recordPurge(shim, fn, name, args) {\n    var queue = args[0]\n    if (TEMP_RE.test(queue)) {\n      queue = null\n    }\n\n    return {queue: queue, callback: shim.LAST}\n  })\n\n\n  shim.recordSubscribedConsume(proto, 'consume', {\n    name: 'amqplib.Channel#consume',\n    queue: shim.FIRST,\n    consumer: shim.SECOND,\n    callback: shim.FOURTH,\n    promise: false,\n    messageHandler: describeMessage\n  })\n}\n\nfunction describeMessage(shim, consumer, name, args) {\n  var message = args[0]\n  if (!message || !message.properties) {\n    shim.logger.debug(\n      {message: message},\n      'Failed to find message in consume arguments.'\n    )\n    return null\n  }\n\n  var exchangeName = message.fields.exchange\n  var parameters = getParameters(Object.create(null), message.fields)\n  getParameters(parameters, message.properties)\n\n  if (!exchangeName) {\n    exchangeName = 'Default'\n  } else if (TEMP_RE.test(exchangeName)) {\n    exchangeName = null\n  }\n\n  return {\n    destinationName: exchangeName,\n    destinationType: shim.EXCHANGE,\n    routingKey: message.fields.routingKey,\n    headers: message.properties.headers,\n    parameters: parameters\n  }\n}\n"]},"metadata":{},"sourceType":"script"}