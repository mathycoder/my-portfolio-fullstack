{"ast":null,"code":"'use strict';\n\nvar codec = require('../../util/codec');\n\nvar Segment = require('./segment');\n\nvar Attributes = require('../../attributes');\n\nvar logger = require('../../logger').child({\n  component: 'trace'\n});\n\nvar _require = require('../../config/attribute-filter'),\n    DESTINATIONS = _require.DESTINATIONS;\n\nvar FROM_MILLIS = 1e-3;\nconst ATTRIBUTE_SCOPE = 'transaction';\n/**\n * A Trace holds the root of the Segment graph and produces the final\n * serialization of the transaction trace.\n *\n * @param {Transaction} transaction The transaction bound to the trace.\n */\n\nfunction Trace(transaction) {\n  if (!transaction) throw new Error('All traces must be associated with a transaction.');\n  this.transaction = transaction;\n  this.root = new Segment(transaction, 'ROOT');\n  this.root.start();\n  this.intrinsics = Object.create(null);\n  this.segmentsSeen = 0;\n  this.totalTimeCache = null;\n  this.custom = new Attributes(ATTRIBUTE_SCOPE, 64);\n  this.attributes = new Attributes(ATTRIBUTE_SCOPE); // sending displayName if set by user\n\n  var displayName = transaction.agent.config.getDisplayHost();\n  var hostName = transaction.agent.config.getHostnameSafe();\n\n  if (displayName !== hostName) {\n    this.attributes.addAttribute(DESTINATIONS.TRANS_COMMON, 'host.displayName', displayName);\n  }\n\n  this.domain = null;\n}\n/**\n * End and close the current trace. Triggers metric recording for trace\n * segments that support recording.\n */\n\n\nTrace.prototype.end = function end() {\n  const segments = [this.root];\n\n  while (segments.length) {\n    const segment = segments.pop();\n    segment.finalize();\n    const children = segment.getChildren();\n\n    for (let i = 0; i < children.length; ++i) {\n      segments.push(children[i]);\n    }\n  }\n};\n/**\n * Iterates over the trace tree and generates a span event for each segment.\n */\n\n\nTrace.prototype.generateSpanEvents = function generateSpanEvents() {\n  var config = this.transaction.agent.config;\n\n  if (this.transaction.sampled && config.span_events.enabled && config.distributed_tracing.enabled) {\n    var toProcess = []; // Root segment does not become a span, so we need to process it separately.\n\n    const spanAggregator = this.transaction.agent.spanEventAggregator;\n    const children = this.root.getChildren();\n\n    for (let i = 0; i < children.length; ++i) {\n      toProcess.push(new DTTraceNode(children[i], this.transaction.parentSpanId));\n    }\n\n    while (toProcess.length) {\n      var segmentInfo = toProcess.pop();\n      var segment = segmentInfo.segment; // Even though at some point we might want to stop adding events\n      // because all the priorities should be the same, we need to count\n      // the spans as seen.\n\n      spanAggregator.addSegment(segment, segmentInfo.parentId);\n      const nodes = segment.getChildren();\n\n      for (let i = 0; i < nodes.length; ++i) {\n        const node = new DTTraceNode(nodes[i], segment.id);\n        toProcess.push(node);\n      }\n    }\n  }\n};\n\nfunction DTTraceNode(segment, parentId) {\n  this.segment = segment;\n  this.parentId = parentId;\n}\n/**\n * Add a child to the list of segments.\n *\n * @param {string} childName Name for the new segment.\n * @returns {Segment} Newly-created Segment.\n */\n\n\nTrace.prototype.add = function add(childName, callback) {\n  return this.root.add(childName, callback);\n};\n/**\n * Explicitly set a trace's runtime instead of using it as a stopwatch.\n * (As a byproduct, stops the timer.)\n *\n * @param {int} duration Duration of this particular trace.\n * @param {int} startTimeInMillis (optional) Start of this trace.\n */\n\n\nTrace.prototype.setDurationInMillis = setDurationInMillis;\n\nfunction setDurationInMillis(duration, startTimeInMillis) {\n  this.root.setDurationInMillis(duration, startTimeInMillis);\n}\n/**\n * @return {integer} The amount of time the trace took, in milliseconds.\n */\n\n\nTrace.prototype.getDurationInMillis = function getDurationInMillis() {\n  return this.root.getDurationInMillis();\n};\n/**\n * Adds given key-value pair to trace's custom attributes, if it passes filtering rules.\n *\n * @param {string} key    - The attribute name.\n * @param {string} value  - The attribute value.\n */\n\n\nTrace.prototype.addCustomAttribute = function addCustomAttribute(key, value) {\n  if (this.custom.has(key)) {\n    logger.debug('Potentially changing custom attribute %s from %s to %s.', key, this.custom.attributes[key].value, value);\n  }\n\n  this.custom.addAttribute(DESTINATIONS.TRANS_SCOPE, key, value);\n};\n/**\n * The duration of the transaction trace tree that only this level accounts\n * for.\n *\n * @return {integer} The amount of time the trace took, minus any child\n *                   traces, in milliseconds.\n */\n\n\nTrace.prototype.getExclusiveDurationInMillis = function getExclusiveDurationInMillis() {\n  return this.root.getExclusiveDurationInMillis();\n};\n/**\n * The duration of all segments in a transaction trace.  The root is not\n * accounted for, since it doesn't represent a unit of work.\n *\n * @return {integer} The sum of durations for all segments in a trace in\n *                   milliseconds\n */\n\n\nTrace.prototype.getTotalTimeDurationInMillis = function getTotalTimeDurationInMillis() {\n  if (this.totalTimeCache !== null) return this.totalTimeCache;\n  if (this.root.children.length === 0) return 0;\n  var segments = this.root.getChildren();\n  var totalTimeInMillis = 0;\n\n  while (segments.length !== 0) {\n    var segment = segments.pop();\n    totalTimeInMillis += segment.getExclusiveDurationInMillis();\n    segments = segments.concat(segment.getChildren());\n  }\n\n  if (!this.transaction.isActive()) this.totalTimeCache = totalTimeInMillis;\n  return totalTimeInMillis;\n};\n/**\n * The serializer is asynchronous, so serialization is as well.\n *\n * The transaction trace sent to the collector is a nested set of arrays. The\n * outermost array has the following fields, in order:\n *\n * 0: start time of the trace, in milliseconds\n * 1: duration, in milliseconds\n * 2: the path, or root metric name\n * 3: the URL (fragment) for this trace\n * 4: an array of segment arrays, deflated and then base64 encoded\n * 5: the guid for this transaction, used to correlate across\n *    transactions\n * 6: reserved for future use, specified to be null for now\n * 7: FIXME: RUM2 force persist flag\n *\n * In addition, there is a \"root node\" (not the same as the first child, which\n * is a node with the special name ROOT and contents otherwise identical to the\n * top-level segment of the actual trace) with the following fields:\n *\n * 0: start time IN SECONDS\n * 1: a dictionary containing request parameters\n * 2: a dictionary containing custom parameters (currently not user-modifiable)\n * 3: the transaction trace segments (including the aforementioned root node)\n * 4: FIXME: a dictionary containing \"parameter groups\" with special information\n *    related to this trace\n *\n * @param {Function} callback Called after serialization with either\n *                            an error (in the first parameter) or\n *                            the serialized transaction trace.\n */\n\n\nTrace.prototype.generateJSON = function generateJSON(callback) {\n  const serializedTrace = this._serializeTrace();\n\n  const trace = this;\n\n  if (!this.transaction.agent.config.simple_compression) {\n    codec.encode(serializedTrace, respond);\n  } else {\n    setImmediate(respond, null, serializedTrace);\n  }\n\n  function respond(err, data) {\n    if (err) {\n      return callback(err, null, null);\n    }\n\n    return callback(null, trace._generatePayload(data), trace);\n  }\n};\n/**\n * This is the synchronous version of Trace#generateJSON\n */\n\n\nTrace.prototype.generateJSONSync = function generateJSONSync() {\n  const serializedTrace = this._serializeTrace();\n\n  const shouldCompress = !this.transaction.agent.config.simple_compression;\n  const data = shouldCompress ? codec.encodeSync(serializedTrace) : serializedTrace;\n  return this._generatePayload(data);\n};\n/**\n * Generates the payload used in a trace harvest.\n *\n * @private\n *\n * @returns {Array} The formatted payload.\n */\n\n\nTrace.prototype._generatePayload = function _generatePayload(data) {\n  let syntheticsResourceId = null;\n\n  if (this.transaction.syntheticsData) {\n    syntheticsResourceId = this.transaction.syntheticsData.resourceId;\n  }\n\n  return [this.root.timer.start, // start\n  this.transaction.getResponseTimeInMillis(), // response time\n  this.transaction.getFullName(), // path\n  this.transaction.url, // request.uri\n  data, // encodedCompressedData\n  this.transaction.id, // guid\n  null, // reserved for future use\n  false, // forcePersist\n  null, // xraySessionId\n  syntheticsResourceId // synthetics resource id\n  ];\n};\n/**\n * Serializes the trace into the expected JSON format to be sent.\n *\n * @private\n *\n * @returns {Array} Serialized trace data.\n */\n\n\nTrace.prototype._serializeTrace = function _serializeTrace() {\n  const attributes = {\n    agentAttributes: this.attributes.get(DESTINATIONS.TRANS_TRACE),\n    userAttributes: this.custom.get(DESTINATIONS.TRANS_TRACE),\n    intrinsics: this.intrinsics\n  };\n  return [this.root.timer.start * FROM_MILLIS, {}, // moved to agentAttributes\n  {\n    // hint to RPM for how to display this trace's segments\n    nr_flatten_leading: false\n  }, // moved to userAttributes\n  this.root.toJSON(), attributes, [] // FIXME: parameter groups\n  ];\n};\n\nmodule.exports = Trace;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/transaction/trace/index.js"],"names":["codec","require","Segment","Attributes","logger","child","component","DESTINATIONS","FROM_MILLIS","ATTRIBUTE_SCOPE","Trace","transaction","Error","root","start","intrinsics","Object","create","segmentsSeen","totalTimeCache","custom","attributes","displayName","agent","config","getDisplayHost","hostName","getHostnameSafe","addAttribute","TRANS_COMMON","domain","prototype","end","segments","length","segment","pop","finalize","children","getChildren","i","push","generateSpanEvents","sampled","span_events","enabled","distributed_tracing","toProcess","spanAggregator","spanEventAggregator","DTTraceNode","parentSpanId","segmentInfo","addSegment","parentId","nodes","node","id","add","childName","callback","setDurationInMillis","duration","startTimeInMillis","getDurationInMillis","addCustomAttribute","key","value","has","debug","TRANS_SCOPE","getExclusiveDurationInMillis","getTotalTimeDurationInMillis","totalTimeInMillis","concat","isActive","generateJSON","serializedTrace","_serializeTrace","trace","simple_compression","encode","respond","setImmediate","err","data","_generatePayload","generateJSONSync","shouldCompress","encodeSync","syntheticsResourceId","syntheticsData","resourceId","timer","getResponseTimeInMillis","getFullName","url","agentAttributes","get","TRANS_TRACE","userAttributes","nr_flatten_leading","toJSON","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar codec = require('../../util/codec')\nvar Segment = require('./segment')\nvar Attributes = require('../../attributes')\nvar logger = require('../../logger').child({component: 'trace'})\n\n\nvar {DESTINATIONS} = require('../../config/attribute-filter')\nvar FROM_MILLIS = 1e-3\nconst ATTRIBUTE_SCOPE = 'transaction'\n\n\n/**\n * A Trace holds the root of the Segment graph and produces the final\n * serialization of the transaction trace.\n *\n * @param {Transaction} transaction The transaction bound to the trace.\n */\nfunction Trace(transaction) {\n  if (!transaction) throw new Error('All traces must be associated with a transaction.')\n\n  this.transaction = transaction\n\n  this.root = new Segment(transaction, 'ROOT')\n  this.root.start()\n\n  this.intrinsics = Object.create(null)\n  this.segmentsSeen = 0\n  this.totalTimeCache = null\n\n  this.custom = new Attributes(ATTRIBUTE_SCOPE, 64)\n  this.attributes = new Attributes(ATTRIBUTE_SCOPE)\n\n  // sending displayName if set by user\n  var displayName = transaction.agent.config.getDisplayHost()\n  var hostName = transaction.agent.config.getHostnameSafe()\n  if (displayName !== hostName) {\n    this.attributes.addAttribute(\n      DESTINATIONS.TRANS_COMMON,\n      'host.displayName',\n      displayName\n    )\n  }\n  this.domain = null\n}\n\n/**\n * End and close the current trace. Triggers metric recording for trace\n * segments that support recording.\n */\nTrace.prototype.end = function end() {\n  const segments = [this.root]\n\n  while (segments.length) {\n    const segment = segments.pop()\n    segment.finalize()\n\n    const children = segment.getChildren()\n    for (let i = 0; i < children.length; ++i) {\n      segments.push(children[i])\n    }\n  }\n}\n\n/**\n * Iterates over the trace tree and generates a span event for each segment.\n */\nTrace.prototype.generateSpanEvents = function generateSpanEvents() {\n  var config = this.transaction.agent.config\n\n  if (\n    this.transaction.sampled &&\n    config.span_events.enabled &&\n    config.distributed_tracing.enabled\n  ) {\n    var toProcess = []\n    // Root segment does not become a span, so we need to process it separately.\n    const spanAggregator = this.transaction.agent.spanEventAggregator\n    const children = this.root.getChildren()\n    for (let i = 0; i < children.length; ++i) {\n      toProcess.push(new DTTraceNode(children[i], this.transaction.parentSpanId))\n    }\n\n    while (toProcess.length) {\n      var segmentInfo = toProcess.pop()\n      var segment = segmentInfo.segment\n\n      // Even though at some point we might want to stop adding events\n      // because all the priorities should be the same, we need to count\n      // the spans as seen.\n      spanAggregator.addSegment(segment, segmentInfo.parentId)\n\n      const nodes = segment.getChildren()\n      for (let i = 0; i < nodes.length; ++i) {\n        const node = new DTTraceNode(nodes[i], segment.id)\n        toProcess.push(node)\n      }\n    }\n  }\n}\n\nfunction DTTraceNode(segment, parentId) {\n  this.segment = segment\n  this.parentId = parentId\n}\n\n/**\n * Add a child to the list of segments.\n *\n * @param {string} childName Name for the new segment.\n * @returns {Segment} Newly-created Segment.\n */\nTrace.prototype.add = function add(childName, callback) {\n  return this.root.add(childName, callback)\n}\n\n/**\n * Explicitly set a trace's runtime instead of using it as a stopwatch.\n * (As a byproduct, stops the timer.)\n *\n * @param {int} duration Duration of this particular trace.\n * @param {int} startTimeInMillis (optional) Start of this trace.\n */\nTrace.prototype.setDurationInMillis = setDurationInMillis\n\nfunction setDurationInMillis(duration, startTimeInMillis) {\n  this.root.setDurationInMillis(duration, startTimeInMillis)\n}\n\n/**\n * @return {integer} The amount of time the trace took, in milliseconds.\n */\nTrace.prototype.getDurationInMillis = function getDurationInMillis() {\n  return this.root.getDurationInMillis()\n}\n\n/**\n * Adds given key-value pair to trace's custom attributes, if it passes filtering rules.\n *\n * @param {string} key    - The attribute name.\n * @param {string} value  - The attribute value.\n */\nTrace.prototype.addCustomAttribute = function addCustomAttribute(key, value) {\n  if (this.custom.has(key)) {\n    logger.debug(\n      'Potentially changing custom attribute %s from %s to %s.',\n      key,\n      this.custom.attributes[key].value,\n      value\n    )\n  }\n\n  this.custom.addAttribute(DESTINATIONS.TRANS_SCOPE, key, value)\n}\n\n/**\n * The duration of the transaction trace tree that only this level accounts\n * for.\n *\n * @return {integer} The amount of time the trace took, minus any child\n *                   traces, in milliseconds.\n */\nTrace.prototype.getExclusiveDurationInMillis = function getExclusiveDurationInMillis() {\n  return this.root.getExclusiveDurationInMillis()\n}\n\n\n/**\n * The duration of all segments in a transaction trace.  The root is not\n * accounted for, since it doesn't represent a unit of work.\n *\n * @return {integer} The sum of durations for all segments in a trace in\n *                   milliseconds\n */\nTrace.prototype.getTotalTimeDurationInMillis = function getTotalTimeDurationInMillis() {\n  if (this.totalTimeCache !== null) return this.totalTimeCache\n  if (this.root.children.length === 0) return 0\n  var segments = this.root.getChildren()\n  var totalTimeInMillis = 0\n\n  while (segments.length !== 0) {\n    var segment = segments.pop()\n    totalTimeInMillis += segment.getExclusiveDurationInMillis()\n    segments = segments.concat(segment.getChildren())\n  }\n\n  if (!this.transaction.isActive()) this.totalTimeCache = totalTimeInMillis\n  return totalTimeInMillis\n}\n\n/**\n * The serializer is asynchronous, so serialization is as well.\n *\n * The transaction trace sent to the collector is a nested set of arrays. The\n * outermost array has the following fields, in order:\n *\n * 0: start time of the trace, in milliseconds\n * 1: duration, in milliseconds\n * 2: the path, or root metric name\n * 3: the URL (fragment) for this trace\n * 4: an array of segment arrays, deflated and then base64 encoded\n * 5: the guid for this transaction, used to correlate across\n *    transactions\n * 6: reserved for future use, specified to be null for now\n * 7: FIXME: RUM2 force persist flag\n *\n * In addition, there is a \"root node\" (not the same as the first child, which\n * is a node with the special name ROOT and contents otherwise identical to the\n * top-level segment of the actual trace) with the following fields:\n *\n * 0: start time IN SECONDS\n * 1: a dictionary containing request parameters\n * 2: a dictionary containing custom parameters (currently not user-modifiable)\n * 3: the transaction trace segments (including the aforementioned root node)\n * 4: FIXME: a dictionary containing \"parameter groups\" with special information\n *    related to this trace\n *\n * @param {Function} callback Called after serialization with either\n *                            an error (in the first parameter) or\n *                            the serialized transaction trace.\n */\nTrace.prototype.generateJSON = function generateJSON(callback) {\n  const serializedTrace = this._serializeTrace()\n\n  const trace = this\n  if (!this.transaction.agent.config.simple_compression) {\n    codec.encode(serializedTrace, respond)\n  } else {\n    setImmediate(respond, null, serializedTrace)\n  }\n\n  function respond(err, data) {\n    if (err) {\n      return callback(err, null, null)\n    }\n\n    return callback(null, trace._generatePayload(data), trace)\n  }\n}\n\n/**\n * This is the synchronous version of Trace#generateJSON\n */\nTrace.prototype.generateJSONSync = function generateJSONSync() {\n  const serializedTrace = this._serializeTrace()\n  const shouldCompress = !this.transaction.agent.config.simple_compression\n  const data = shouldCompress ? codec.encodeSync(serializedTrace) : serializedTrace\n  return this._generatePayload(data)\n}\n\n/**\n * Generates the payload used in a trace harvest.\n *\n * @private\n *\n * @returns {Array} The formatted payload.\n */\nTrace.prototype._generatePayload = function _generatePayload(data) {\n  let syntheticsResourceId = null\n  if (this.transaction.syntheticsData) {\n    syntheticsResourceId = this.transaction.syntheticsData.resourceId\n  }\n\n  return [\n    this.root.timer.start, // start\n    this.transaction.getResponseTimeInMillis(),  // response time\n    this.transaction.getFullName(),              // path\n    this.transaction.url,  // request.uri\n    data,                   // encodedCompressedData\n    this.transaction.id,    // guid\n    null,                   // reserved for future use\n    false,                  // forcePersist\n    null,                   // xraySessionId\n    syntheticsResourceId    // synthetics resource id\n  ]\n}\n\n/**\n * Serializes the trace into the expected JSON format to be sent.\n *\n * @private\n *\n * @returns {Array} Serialized trace data.\n */\nTrace.prototype._serializeTrace = function _serializeTrace() {\n  const attributes = {\n    agentAttributes: this.attributes.get(DESTINATIONS.TRANS_TRACE),\n    userAttributes: this.custom.get(DESTINATIONS.TRANS_TRACE),\n    intrinsics: this.intrinsics\n  }\n\n  return [\n    this.root.timer.start * FROM_MILLIS,\n    {}, // moved to agentAttributes\n    {\n      // hint to RPM for how to display this trace's segments\n      nr_flatten_leading: false\n    }, // moved to userAttributes\n    this.root.toJSON(),\n    attributes,\n    []  // FIXME: parameter groups\n  ]\n}\n\nmodule.exports = Trace\n"]},"metadata":{},"sourceType":"script"}