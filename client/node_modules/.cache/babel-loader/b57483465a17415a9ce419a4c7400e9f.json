{"ast":null,"code":"'use strict';\n\nconst apiGateway = require('./api-gateway');\n\nconst headerAttributes = require('../header-attributes');\n\nconst logger = require('../logger').child({\n  component: 'aws-lambda'\n});\n\nconst recordBackground = require('../metrics/recorders/other');\n\nconst recordWeb = require('../metrics/recorders/http');\n\nconst TransactionShim = require('../shim/transaction-shim');\n\nconst urltils = require('../util/urltils'); // CONSTANTS\n\n\nconst ATTR_DEST = require('../config/attribute-filter').DESTINATIONS;\n\nconst COLD_START_KEY = 'aws.lambda.coldStart';\nconst EVENT_SOURCE_ARN_KEY = 'aws.lambda.eventSource.arn';\n\nconst NAMES = require('../metrics/names'); // A function with no references used to stub out closures\n\n\nfunction cleanClosure() {} // this array holds all the closures used to end transactions\n\n\nlet transactionEnders = []; // this tracks unhandled exceptions to be able to relate them back to\n// the invocation transaction.\n\nlet uncaughtException = null; // Tracking the first time patchLambdaHandler is called for one off functionality\n\nlet patchCalled = false;\nlet coldStartRecorded = false;\n\nclass AwsLambda {\n  constructor(agent) {\n    this.agent = agent;\n    this.shim = new TransactionShim(agent, 'aws-lambda');\n  } // FOR TESTING PURPORSES ONLY\n\n\n  _resetModuleState() {\n    patchCalled = false;\n    coldStartRecorded = false;\n    transactionEnders = [];\n  }\n\n  patchLambdaHandler(handler) {\n    const awsLambda = this;\n    const shim = this.shim;\n\n    if (typeof handler !== 'function') {\n      logger.warn('handler argument is not a function and cannot be recorded');\n      return handler;\n    }\n\n    if (!patchCalled) {\n      // Only wrap emit on process the first time patch is called.\n      patchCalled = true; // There is no prependListener in node 4, so we wrap emit to look for 'beforeExit'\n      // NOTE: This may be converted to holding onto a single ender function if only\n      // one invocation is executing at a time.\n\n      shim.wrap(process, 'emit', function wrapEmit(shim, emit) {\n        return function wrappedEmit(ev) {\n          if (ev === 'beforeExit') {\n            transactionEnders.forEach(ender => {\n              ender();\n            });\n            transactionEnders = [];\n          }\n\n          return emit.apply(process, arguments);\n        };\n      });\n      shim.wrap(process, '_fatalException', function wrapper(shim, original) {\n        return function wrappedFatalException(error) {\n          // logic placed before the _fatalException call, since it ends the invocation\n          uncaughtException = error;\n          transactionEnders.forEach(ender => {\n            ender();\n          });\n          transactionEnders = [];\n          return original.apply(this, arguments);\n        };\n      });\n    }\n\n    return shim.bindCreateTransaction(wrappedHandler, {\n      type: shim.BG\n    });\n\n    function wrappedHandler() {\n      const args = shim.argsToArray.apply(shim, arguments);\n      const event = args[0];\n      const context = args[1];\n      const functionName = context.functionName;\n      const group = NAMES.FUNCTION.PREFIX;\n      const transactionName = group + functionName;\n      const transaction = shim.tracer.getTransaction();\n\n      if (!transaction) {\n        return handler.apply(this, arguments);\n      }\n\n      transaction.setPartialName(transactionName);\n      const isApiGatewayLambdaProxy = apiGateway.isLambdaProxyEvent(event); // resultProcessor is used to execute additional logic based on the\n      // payload supplied to the callback.\n\n      let resultProcessor;\n\n      if (isApiGatewayLambdaProxy) {\n        const webRequest = new apiGateway.LambdaProxyWebRequest(event);\n        setWebRequest(shim, transaction, webRequest);\n        resultProcessor = getApiGatewayLambdaProxyResultProcessor(transaction);\n      }\n\n      const segmentRecorder = isApiGatewayLambdaProxy ? recordWeb : recordBackground;\n      const segment = shim.createSegment(functionName, segmentRecorder);\n      transaction.baseSegment = segment;\n      const cbIndex = args.length - 1; // Add transaction ending closure to the list of functions to be called on\n      // beforeExit (i.e. in the case that context.{done,fail,succeed} or callback\n      // were not called).\n\n      const txnEnder = endTransaction.bind(null, transaction, transactionEnders.length);\n      transactionEnders.push(txnEnder);\n      args[cbIndex] = wrapCallbackAndCaptureError(transaction, txnEnder, args[cbIndex], resultProcessor); // context.{done,fail,succeed} are all considered deprecated by\n      // AWS, but are considered functional.\n\n      context.done = wrapCallbackAndCaptureError(transaction, txnEnder, context.done);\n      context.fail = wrapCallbackAndCaptureError(transaction, txnEnder, context.fail);\n      shim.wrap(context, 'succeed', function wrapSucceed(shim, original) {\n        return function wrappedSucceed() {\n          txnEnder();\n          return original.apply(this, arguments);\n        };\n      });\n\n      const awsAttributes = awsLambda._getAwsAgentAttributes(event, context);\n\n      transaction.trace.attributes.addAttributes(ATTR_DEST.TRANS_COMMON, awsAttributes);\n      shim.agent.setLambdaArn(context.invokedFunctionArn);\n      segment.start();\n      let res = shim.applySegment(handler, segment, false, this, args);\n\n      if (shim.isPromise(res)) {\n        res = shim.interceptPromise(res, txnEnder);\n      }\n\n      return res;\n    }\n\n    function wrapCallbackAndCaptureError(transaction, txnEnder, cb, processResult) {\n      return function wrappedCallback() {\n        let err = arguments[0];\n\n        if (typeof err === 'string') {\n          err = new Error(err);\n        }\n\n        shim.agent.errors.add(transaction, err);\n\n        if (processResult) {\n          const result = arguments[1];\n          processResult(result);\n        }\n\n        txnEnder();\n        return cb.apply(this, arguments);\n      };\n    }\n  }\n\n  _getAwsAgentAttributes(event, context) {\n    const attributes = {\n      'aws.lambda.arn': context.invokedFunctionArn,\n      'aws.requestId': context.awsRequestId\n    };\n    setEventSourceAttributes(event, attributes);\n\n    if (!coldStartRecorded) {\n      coldStartRecorded = attributes[COLD_START_KEY] = true;\n    }\n\n    return attributes;\n  }\n\n}\n\nfunction setEventSourceAttributes(event, attributes) {\n  if (event.Records) {\n    const record = event.Records[0];\n\n    if (record.eventSourceARN) {\n      // SQS/Kinesis Stream/DynamoDB/CodeCommit\n      attributes[EVENT_SOURCE_ARN_KEY] = record.eventSourceARN;\n    } else if (record.s3 && record.s3.bucket && record.s3.bucket.arn) {\n      // S3\n      attributes[EVENT_SOURCE_ARN_KEY] = record.s3.bucket.arn;\n    } else if (record.EventSubscriptionArn) {\n      // SNS\n      attributes[EVENT_SOURCE_ARN_KEY] = record.EventSubscriptionArn;\n    } else {\n      logger.trace('Unable to determine ARN from event record.', event, record);\n    }\n  } else if (event.records && event.deliveryStreamArn) {\n    // Kinesis Firehose\n    attributes[EVENT_SOURCE_ARN_KEY] = event.deliveryStreamArn;\n  } else {\n    logger.trace('Unable to determine ARN for event type.', event);\n  }\n}\n\nfunction getApiGatewayLambdaProxyResultProcessor(transaction) {\n  return function processApiGatewayLambdaProxyResponse(response) {\n    if (apiGateway.isValidLambdaProxyResponse(response)) {\n      const webResponse = new apiGateway.LambdaProxyWebResponse(response);\n      setWebResponse(transaction, webResponse);\n    } else {\n      logger.debug('Did not contain a valid API Gateway Lambda Proxy response.');\n    }\n  };\n}\n\nfunction setWebRequest(shim, transaction, request) {\n  transaction.type = shim.WEB;\n  transaction.url = urltils.scrub(request.url.path);\n  transaction.verb = request.method;\n  transaction.trace.attributes.addAttribute(ATTR_DEST.TRANS_COMMON, 'request.method', request.method);\n  transaction.port = request.url.port;\n  transaction.addRequestParameters(request.url.requestParameters); // URL is sent as an agent attribute with transaction events\n\n  transaction.trace.attributes.addAttribute(ATTR_DEST.TRANS_EVENT | ATTR_DEST.ERROR_EVENT, 'request.uri', request.url.path);\n  headerAttributes.collectRequestHeaders(request.headers, transaction);\n\n  if (shim.agent.config.distributed_tracing.enabled) {\n    // These are the three cases specified in the DT spec\n    // https://source.datanerd.us/agents/agent-specs/blob/master/Distributed-Tracing.md#supported-transports\n    const payload = request.headers.newrelic || request.headers.NEWRELIC || request.headers.Newrelic;\n\n    if (payload) {\n      logger.trace('Accepting distributed trace payload for transaction %s', transaction.id);\n      transaction.acceptDistributedTracePayload(payload, request.transportType);\n    }\n  }\n}\n\nfunction endTransaction(transaction, enderIndex) {\n  if (transactionEnders[enderIndex] === cleanClosure) {\n    // In the case where we have already been called, we return early. There may be a\n    // case where this is called more than once, given the lambda is left in a dirty\n    // state after thread suspension (e.g. timeouts)\n    return;\n  }\n\n  if (uncaughtException !== null) {\n    transaction.agent.errors.add(transaction, uncaughtException);\n    uncaughtException = null;\n  }\n\n  transaction.baseSegment.end(); // Clear the end closure to let go of captured references\n\n  transactionEnders[enderIndex] = cleanClosure;\n  transaction.finalizeName();\n  transaction.end();\n\n  try {\n    transaction.agent.harvestSync();\n  } catch (err) {\n    logger.warn('Failed to harvest transaction', err);\n  }\n}\n\nfunction setWebResponse(transaction, response) {\n  transaction.statusCode = response.statusCode;\n  const responseCode = String(response.statusCode);\n  transaction.trace.attributes.addAttribute(ATTR_DEST.TRANS_COMMON, 'httpResponseCode', responseCode);\n\n  if (/^\\d+$/.test(responseCode)) {\n    transaction.trace.attributes.addAttribute(ATTR_DEST.TRANS_COMMON, 'response.status', responseCode);\n  }\n\n  headerAttributes.collectResponseHeaders(response.headers, transaction);\n}\n\nmodule.exports = AwsLambda;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/serverless/aws-lambda.js"],"names":["apiGateway","require","headerAttributes","logger","child","component","recordBackground","recordWeb","TransactionShim","urltils","ATTR_DEST","DESTINATIONS","COLD_START_KEY","EVENT_SOURCE_ARN_KEY","NAMES","cleanClosure","transactionEnders","uncaughtException","patchCalled","coldStartRecorded","AwsLambda","constructor","agent","shim","_resetModuleState","patchLambdaHandler","handler","awsLambda","warn","wrap","process","wrapEmit","emit","wrappedEmit","ev","forEach","ender","apply","arguments","wrapper","original","wrappedFatalException","error","bindCreateTransaction","wrappedHandler","type","BG","args","argsToArray","event","context","functionName","group","FUNCTION","PREFIX","transactionName","transaction","tracer","getTransaction","setPartialName","isApiGatewayLambdaProxy","isLambdaProxyEvent","resultProcessor","webRequest","LambdaProxyWebRequest","setWebRequest","getApiGatewayLambdaProxyResultProcessor","segmentRecorder","segment","createSegment","baseSegment","cbIndex","length","txnEnder","endTransaction","bind","push","wrapCallbackAndCaptureError","done","fail","wrapSucceed","wrappedSucceed","awsAttributes","_getAwsAgentAttributes","trace","attributes","addAttributes","TRANS_COMMON","setLambdaArn","invokedFunctionArn","start","res","applySegment","isPromise","interceptPromise","cb","processResult","wrappedCallback","err","Error","errors","add","result","awsRequestId","setEventSourceAttributes","Records","record","eventSourceARN","s3","bucket","arn","EventSubscriptionArn","records","deliveryStreamArn","processApiGatewayLambdaProxyResponse","response","isValidLambdaProxyResponse","webResponse","LambdaProxyWebResponse","setWebResponse","debug","request","WEB","url","scrub","path","verb","method","addAttribute","port","addRequestParameters","requestParameters","TRANS_EVENT","ERROR_EVENT","collectRequestHeaders","headers","config","distributed_tracing","enabled","payload","newrelic","NEWRELIC","Newrelic","id","acceptDistributedTracePayload","transportType","enderIndex","end","finalizeName","harvestSync","statusCode","responseCode","String","test","collectResponseHeaders","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst apiGateway = require('./api-gateway')\nconst headerAttributes = require('../header-attributes')\nconst logger = require('../logger').child({component: 'aws-lambda'})\nconst recordBackground = require('../metrics/recorders/other')\nconst recordWeb = require('../metrics/recorders/http')\nconst TransactionShim = require('../shim/transaction-shim')\nconst urltils = require('../util/urltils')\n\n// CONSTANTS\nconst ATTR_DEST = require('../config/attribute-filter').DESTINATIONS\nconst COLD_START_KEY = 'aws.lambda.coldStart'\nconst EVENT_SOURCE_ARN_KEY = 'aws.lambda.eventSource.arn'\nconst NAMES = require('../metrics/names')\n\n\n// A function with no references used to stub out closures\nfunction cleanClosure() {}\n\n// this array holds all the closures used to end transactions\nlet transactionEnders = []\n\n// this tracks unhandled exceptions to be able to relate them back to\n// the invocation transaction.\nlet uncaughtException = null\n\n// Tracking the first time patchLambdaHandler is called for one off functionality\nlet patchCalled = false\nlet coldStartRecorded = false\n\nclass AwsLambda {\n  constructor(agent) {\n    this.agent = agent\n    this.shim = new TransactionShim(agent, 'aws-lambda')\n  }\n\n  // FOR TESTING PURPORSES ONLY\n  _resetModuleState() {\n    patchCalled = false\n    coldStartRecorded = false\n    transactionEnders = []\n  }\n\n  patchLambdaHandler(handler) {\n    const awsLambda = this\n    const shim = this.shim\n\n    if (typeof handler !== 'function') {\n      logger.warn('handler argument is not a function and cannot be recorded')\n      return handler\n    }\n\n    if (!patchCalled) {\n      // Only wrap emit on process the first time patch is called.\n      patchCalled = true\n\n      // There is no prependListener in node 4, so we wrap emit to look for 'beforeExit'\n      // NOTE: This may be converted to holding onto a single ender function if only\n      // one invocation is executing at a time.\n      shim.wrap(process, 'emit', function wrapEmit(shim, emit) {\n        return function wrappedEmit(ev) {\n          if (ev === 'beforeExit') {\n            transactionEnders.forEach((ender) => {\n              ender()\n            })\n            transactionEnders = []\n          }\n          return emit.apply(process, arguments)\n        }\n      })\n\n      shim.wrap(process, '_fatalException', function wrapper(shim, original) {\n        return function wrappedFatalException(error) {\n          // logic placed before the _fatalException call, since it ends the invocation\n          uncaughtException = error\n          transactionEnders.forEach((ender) => {\n            ender()\n          })\n          transactionEnders = []\n          return original.apply(this, arguments)\n        }\n      })\n    }\n\n    return shim.bindCreateTransaction(wrappedHandler, {type: shim.BG})\n\n    function wrappedHandler() {\n      const args = shim.argsToArray.apply(shim, arguments)\n\n      const event = args[0]\n      const context = args[1]\n\n      const functionName = context.functionName\n      const group = NAMES.FUNCTION.PREFIX\n      const transactionName = group + functionName\n\n      const transaction = shim.tracer.getTransaction()\n      if (!transaction) {\n        return handler.apply(this, arguments)\n      }\n\n      transaction.setPartialName(transactionName)\n\n      const isApiGatewayLambdaProxy = apiGateway.isLambdaProxyEvent(event)\n\n      // resultProcessor is used to execute additional logic based on the\n      // payload supplied to the callback.\n      let resultProcessor\n      if (isApiGatewayLambdaProxy) {\n        const webRequest = new apiGateway.LambdaProxyWebRequest(event)\n        setWebRequest(shim, transaction, webRequest)\n        resultProcessor = getApiGatewayLambdaProxyResultProcessor(transaction)\n      }\n\n      const segmentRecorder = isApiGatewayLambdaProxy ? recordWeb : recordBackground\n      const segment = shim.createSegment(functionName, segmentRecorder)\n      transaction.baseSegment = segment\n\n      const cbIndex = args.length - 1\n\n      // Add transaction ending closure to the list of functions to be called on\n      // beforeExit (i.e. in the case that context.{done,fail,succeed} or callback\n      // were not called).\n      const txnEnder = endTransaction.bind(\n        null,\n        transaction,\n        transactionEnders.length\n      )\n\n      transactionEnders.push(txnEnder)\n\n      args[cbIndex] = wrapCallbackAndCaptureError(\n        transaction,\n        txnEnder,\n        args[cbIndex],\n        resultProcessor\n      )\n\n      // context.{done,fail,succeed} are all considered deprecated by\n      // AWS, but are considered functional.\n      context.done = wrapCallbackAndCaptureError(transaction, txnEnder, context.done)\n      context.fail = wrapCallbackAndCaptureError(transaction, txnEnder, context.fail)\n      shim.wrap(context, 'succeed', function wrapSucceed(shim, original) {\n        return function wrappedSucceed() {\n          txnEnder()\n          return original.apply(this, arguments)\n        }\n      })\n\n      const awsAttributes = awsLambda._getAwsAgentAttributes(event, context)\n      transaction.trace.attributes.addAttributes(\n        ATTR_DEST.TRANS_COMMON,\n        awsAttributes\n      )\n\n      shim.agent.setLambdaArn(context.invokedFunctionArn)\n\n      segment.start()\n\n      let res = shim.applySegment(handler, segment, false, this, args)\n      if (shim.isPromise(res)) {\n        res = shim.interceptPromise(res, txnEnder)\n      }\n      return res\n    }\n\n    function wrapCallbackAndCaptureError(transaction, txnEnder, cb, processResult) {\n      return function wrappedCallback() {\n        let err = arguments[0]\n        if (typeof err === 'string') {\n          err = new Error(err)\n        }\n\n        shim.agent.errors.add(transaction, err)\n\n        if (processResult) {\n          const result = arguments[1]\n          processResult(result)\n        }\n\n        txnEnder()\n\n        return cb.apply(this, arguments)\n      }\n    }\n  }\n\n  _getAwsAgentAttributes(event, context) {\n    const attributes = {\n      'aws.lambda.arn': context.invokedFunctionArn,\n      'aws.requestId': context.awsRequestId\n    }\n\n    setEventSourceAttributes(event, attributes)\n\n    if (!coldStartRecorded) {\n      coldStartRecorded = attributes[COLD_START_KEY] = true\n    }\n\n    return attributes\n  }\n}\n\nfunction setEventSourceAttributes(event, attributes) {\n  if (event.Records) {\n    const record = event.Records[0]\n    if (record.eventSourceARN) {\n      // SQS/Kinesis Stream/DynamoDB/CodeCommit\n      attributes[EVENT_SOURCE_ARN_KEY] = record.eventSourceARN\n    } else if (record.s3 && record.s3.bucket && record.s3.bucket.arn) {\n      // S3\n      attributes[EVENT_SOURCE_ARN_KEY] = record.s3.bucket.arn\n    } else if (record.EventSubscriptionArn) {\n      // SNS\n      attributes[EVENT_SOURCE_ARN_KEY] = record.EventSubscriptionArn\n    } else {\n      logger.trace('Unable to determine ARN from event record.', event, record)\n    }\n  } else if (event.records && event.deliveryStreamArn) {\n    // Kinesis Firehose\n    attributes[EVENT_SOURCE_ARN_KEY] = event.deliveryStreamArn\n  } else {\n    logger.trace('Unable to determine ARN for event type.', event)\n  }\n}\n\nfunction getApiGatewayLambdaProxyResultProcessor(transaction) {\n  return function processApiGatewayLambdaProxyResponse(response) {\n    if (apiGateway.isValidLambdaProxyResponse(response)) {\n      const webResponse = new apiGateway.LambdaProxyWebResponse(response)\n      setWebResponse(transaction, webResponse)\n    } else {\n      logger.debug('Did not contain a valid API Gateway Lambda Proxy response.')\n    }\n  }\n}\n\nfunction setWebRequest(shim, transaction, request) {\n  transaction.type = shim.WEB\n\n  transaction.url = urltils.scrub(request.url.path)\n  transaction.verb = request.method\n  transaction.trace.attributes.addAttribute(\n    ATTR_DEST.TRANS_COMMON,\n    'request.method',\n    request.method\n  )\n  transaction.port = request.url.port\n\n  transaction.addRequestParameters(request.url.requestParameters)\n\n  // URL is sent as an agent attribute with transaction events\n  transaction.trace.attributes.addAttribute(\n    ATTR_DEST.TRANS_EVENT | ATTR_DEST.ERROR_EVENT,\n    'request.uri',\n    request.url.path\n  )\n\n  headerAttributes.collectRequestHeaders(request.headers, transaction)\n\n  if (shim.agent.config.distributed_tracing.enabled) {\n    // These are the three cases specified in the DT spec\n    // https://source.datanerd.us/agents/agent-specs/blob/master/Distributed-Tracing.md#supported-transports\n    const payload = request.headers.newrelic || request.headers.NEWRELIC ||\n      request.headers.Newrelic\n\n    if (payload) {\n      logger.trace(\n        'Accepting distributed trace payload for transaction %s',\n        transaction.id\n      )\n      transaction.acceptDistributedTracePayload(payload, request.transportType)\n    }\n  }\n}\n\nfunction endTransaction(transaction, enderIndex) {\n  if (transactionEnders[enderIndex] === cleanClosure) {\n    // In the case where we have already been called, we return early. There may be a\n    // case where this is called more than once, given the lambda is left in a dirty\n    // state after thread suspension (e.g. timeouts)\n    return\n  }\n\n  if (uncaughtException !== null) {\n    transaction.agent.errors.add(transaction, uncaughtException)\n    uncaughtException = null\n  }\n\n  transaction.baseSegment.end()\n\n  // Clear the end closure to let go of captured references\n  transactionEnders[enderIndex] = cleanClosure\n  transaction.finalizeName()\n  transaction.end()\n  try {\n    transaction.agent.harvestSync()\n  } catch (err) {\n    logger.warn('Failed to harvest transaction', err)\n  }\n}\n\nfunction setWebResponse(transaction, response) {\n  transaction.statusCode = response.statusCode\n\n  const responseCode = String(response.statusCode)\n  transaction.trace.attributes.addAttribute(\n    ATTR_DEST.TRANS_COMMON,\n    'httpResponseCode',\n    responseCode\n  )\n\n  if (/^\\d+$/.test(responseCode)) {\n    transaction.trace.attributes.addAttribute(\n      ATTR_DEST.TRANS_COMMON,\n      'response.status',\n      responseCode)\n  }\n\n  headerAttributes.collectResponseHeaders(response.headers, transaction)\n}\n\nmodule.exports = AwsLambda\n"]},"metadata":{},"sourceType":"script"}