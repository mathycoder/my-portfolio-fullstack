{"ast":null,"code":"'use strict';\n\nvar cat = require('../util/cat');\n\nvar hashes = require('../util/hashes');\n\nvar logger = require('../logger').child({\n  component: 'TransactionShim'\n});\n\nvar Shim = require('./shim');\n\nvar Transaction = require('../transaction');\n\nvar util = require('util');\n\nconst DISTRIBUTED_TRACE_HEADER = 'newrelic';\nconst HTTP_CAT_ID_HEADER = 'X-NewRelic-Id';\nconst MQ_CAT_ID_HEADER = 'NewRelicID';\nconst MATCH_CAT_ID_HEADER = new RegExp('^(?:' + HTTP_CAT_ID_HEADER + '|' + MQ_CAT_ID_HEADER + ')$', 'i');\nconst HTTP_CAT_TRANSACTION_HEADER = 'X-NewRelic-Transaction';\nconst MQ_CAT_TRANSACTION_HEADER = 'NewRelicTransaction';\nconst MATCH_CAT_TRANSACTION_HEADER = new RegExp('^(?:' + HTTP_CAT_TRANSACTION_HEADER + '|' + MQ_CAT_TRANSACTION_HEADER + ')$', 'i');\nconst HTTP_CAT_APP_DATA_HEADER = 'X-NewRelic-App-Data';\nconst MQ_CAT_APP_DATA_HEADER = 'NewRelicAppData';\nconst MATCH_CAT_APP_DATA_HEADER = new RegExp('^(?:' + HTTP_CAT_APP_DATA_HEADER + '|' + MQ_CAT_APP_DATA_HEADER + ')$', 'i');\nconst TRANSACTION_TYPES_SET = Transaction.TYPES_SET;\nconst TRANSPORT_TYPES_SET = Transaction.TRANSPORT_TYPES_SET;\n/**\n * Constructs a transaction managing shim.\n *\n * @constructor\n * @extends Shim\n * @classdesc\n *  A helper class for working with transactions.\n *\n * @param {Agent}   agent         - The agent the shim will use.\n * @param {string}  moduleName    - The name of the module being instrumented.\n * @param {string}  resolvedName  - The full path to the loaded module.\n *\n * @see Shim\n * @see WebFrameworkShim\n */\n\nfunction TransactionShim(agent, moduleName, resolvedName) {\n  Shim.call(this, agent, moduleName, resolvedName);\n  this._logger = logger.child({\n    module: moduleName\n  });\n}\n\nmodule.exports = TransactionShim;\nutil.inherits(TransactionShim, Shim);\n/**\n * Enumeration of transaction types.\n *\n * Each of these values is also exposed directly on the `TransactionShim` class\n * as static members.\n *\n * @readonly\n * @memberof TransactionShim.prototype\n * @enum {string}\n */\n\nTransactionShim.TRANSACTION_TYPES = Transaction.TYPES;\nObject.keys(Transaction.TYPES).forEach(function defineTypeEnum(type) {\n  Shim.defineProperty(TransactionShim, type, Transaction.TYPES[type]);\n  Shim.defineProperty(TransactionShim.prototype, type, Transaction.TYPES[type]);\n});\n/**\n * Enumeration of possible transaction transport types used for distributed tracing.\n *\n * This enumeration is also exposed on the `TransactionShim` class.\n *\n * @readonly\n * @memberof TransactionShim.prototype\n * @enum {string}\n */\n\nShim.defineProperty(TransactionShim, 'TRANSPORT_TYPES', Transaction.TRANSPORT_TYPES);\nShim.defineProperty(TransactionShim.prototype, 'TRANSPORT_TYPES', Transaction.TRANSPORT_TYPES);\nTransactionShim.prototype.bindCreateTransaction = bindCreateTransaction;\nTransactionShim.prototype.pushTransactionName = pushTransactionName;\nTransactionShim.prototype.popTransactionName = popTransactionName;\nTransactionShim.prototype.setTransactionName = setTransactionName;\nTransactionShim.prototype.handleCATHeaders = handleCATHeaders;\nTransactionShim.prototype.insertCATRequestHeaders = insertCATRequestHeaders;\nTransactionShim.prototype.insertCATReplyHeader = insertCATReplyHeader; // -------------------------------------------------------------------------- //\n\n/**\n * @interface TransactionSpec\n *\n * @description\n *  Describes the type of transaction to be created by the function being\n *  wrapped by {@link Shim#bindCreateTransaction}.\n *\n * @property {string} type\n *  The type of transaction to create. Must be one of the values from\n *  {@link Shim#TRANSACTION_TYPES}.\n *\n * @property {bool} [nest=false]\n *  Indicates if the transaction being created is allowed to be nested within\n *  another transaction of the same type. If `false`, the default, the transaction\n *  will only be created if there is no existing transaction, or the current\n *  transaction is of a different type. If `true`, the transaction will be\n *  created regardless of the current transaction's type.\n *\n * @see Shim#bindCreateTransaction\n * @see Shim#TRANSACTION_TYPES\n */\n// -------------------------------------------------------------------------- //\n\n/**\n * Wraps one or more functions such that new transactions are created when\n * invoked.\n *\n * - `bindCreateTransaction(nodule, property, spec)`\n * - `bindCreateTransaction(func, spec)`\n *\n * @memberof TransactionShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the property to wrap, or a single function to wrap.\n *\n * @param {string} [property]\n *  The property to wrap. If omitted, the `nodule` parameter is assumed to be\n *  the function to wrap.\n *\n * @param {TransactionSpec} spec\n *  The spec for creating the transaction.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its property.\n */\n\nfunction bindCreateTransaction(nodule, property, spec) {\n  if (this.isObject(property) && !this.isArray(property)) {\n    // bindCreateTransaction(nodule, spec)\n    spec = property;\n    property = null;\n  } // Refuse to perform the wrapping if `spec.type` is not valid.\n\n\n  if (!TRANSACTION_TYPES_SET[spec.type]) {\n    this.logger.error({\n      stack: new Error().stack\n    }, 'Invalid spec type \"%s\", must be one of %j.', spec.type, Object.keys(TRANSACTION_TYPES_SET));\n    return nodule;\n  } // Perform the actual wrapping.\n\n\n  return this.wrap(nodule, property, function makeTransWrapper(shim, fn, name) {\n    if (!shim.isFunction(fn)) {\n      shim.logger.debug('Not wrapping \"%s\" with transaction, not a function.', name);\n      return fn;\n    } // Is this transaction supposed to be nested? Pick the right wrapper for the\n    // job.\n\n\n    var makeWrapper = spec.nest ? _makeNestedTransWrapper : _makeTransWrapper;\n    return makeWrapper(shim, fn, name, spec);\n  });\n}\n/**\n * Pushes a new path segment onto the transaction naming stack.\n *\n * - `pushTransactionName(pathSegment)`\n *\n * Transactions are named for the middlware that sends the reponse. Some web\n * frameworks are capable of mounting middlware in complex routing stacks. In\n * order to maintain the correct name, transactions keep a stack of mount points\n * for each middlware/router/app/whatever. The instrumentation should push on\n * the mount path for wrapped things when route resolution enters and pop it\n * back off when resolution exits the item.\n *\n * @memberof TransactionShim.prototype\n *\n * @param {string} pathSegment - The path segment to add to the naming stack.\n */\n\n\nfunction pushTransactionName(pathSegment) {\n  var tx = this.tracer.getTransaction();\n\n  if (tx && tx.nameState) {\n    tx.nameState.appendPath(pathSegment);\n  }\n}\n/**\n * Pops one or more elements off the transaction naming stack.\n *\n * - `popTransactionName([pathSegment])`\n *\n * Ideally it is not necessary to ever provide the `pathSegment` parameter for\n * this function, but we do not live in an ideal world.\n *\n * @memberof TransactionShim.prototype\n *\n * @param {string} [pathSegment]\n *  Optional. Path segment to pop the stack repeatedly until a segment matching\n *  `pathSegment` is removed.\n */\n\n\nfunction popTransactionName(pathSegment) {\n  var tx = this.tracer.getTransaction();\n\n  if (tx && tx.nameState) {\n    tx.nameState.popPath(pathSegment);\n  }\n}\n/**\n * Sets the name to be used for this transaction.\n *\n * - `setTransactionName(name)`\n *\n * Either this _or_ the naming stack should be used. Do not use them together.\n *\n * @memberof TransactionShim.prototype\n *\n * @param {string} name - The name to use for the transaction.\n */\n\n\nfunction setTransactionName(name) {\n  var tx = this.tracer.getTransaction();\n\n  if (tx) {\n    tx.setPartialName(name);\n  }\n}\n/**\n * Retrieves whatever CAT headers may be in the given headers.\n *\n * - `handleCATHeaders(headers [, segment [, transportType]])`\n *\n * @memberof TransactionShim.prototype\n *\n * This will check for either header naming style, and both request and reply\n * CAT headers.\n *\n * @param {object} headers\n *  The request/response headers object to look in.\n *\n * @param {TraceSegment} [segment=null]\n *  The trace segment to associate the header data with. If no segment is\n *  provided then the currently active segment is used.\n *\n * @param {string} [transportType='Unknown']\n *  The transport type that brought the headers. Usually `HTTP` or `HTTPS`.\n */\n\n\nfunction handleCATHeaders(headers, segment, transportType) {\n  // Is CAT enabled?\n  if (!this.agent.config.cross_application_tracer.enabled) {\n    this.logger.trace('CAT disabled, not extracting header.');\n    return;\n  }\n\n  if (!this.agent.config.encoding_key) {\n    this.logger.warn('Missing encoding key, not extracting CAT headers!');\n    return;\n  } else if (!headers) {\n    this.logger.debug('No headers to search for CAT within');\n    return;\n  } // Check that we're in an active transaction.\n\n\n  segment = segment || this.getSegment();\n\n  if (!segment || !segment.transaction.isActive()) {\n    this.logger.trace('Not adding CAT reply header, not in an active transaction.');\n    return;\n  }\n\n  var tx = segment.transaction; // Ensure this is a valid transport type.\n\n  transportType = transportType || Transaction.TRANSPORT_TYPES.UNKNOWN;\n\n  if (!TRANSPORT_TYPES_SET[transportType]) {\n    this.logger.debug('Unknown transport type: %j', transportType);\n    transportType = Transaction.TRANSPORT_TYPES.UNKNOWN;\n  }\n\n  if (this.agent.config.distributed_tracing.enabled) {\n    const payload = headers[DISTRIBUTED_TRACE_HEADER];\n\n    if (payload) {\n      tx.acceptDistributedTracePayload(payload, transportType);\n    }\n\n    return;\n  } // Hunt down the CAT headers.\n\n\n  var catId = null;\n  var transactionData = null;\n  var appData = null;\n\n  for (var key in headers) {\n    // eslint-disable-line guard-for-in\n    if (MATCH_CAT_ID_HEADER.test(key)) {\n      catId = headers[key];\n    } else if (MATCH_CAT_TRANSACTION_HEADER.test(key)) {\n      transactionData = headers[key];\n    } else if (MATCH_CAT_APP_DATA_HEADER.test(key)) {\n      appData = headers[key];\n    }\n\n    if (catId && transactionData && appData) {\n      break;\n    }\n  }\n\n  if (catId && transactionData) {\n    cat.handleCatHeaders(catId, transactionData, this.agent.config.encoding_key, tx);\n\n    if (tx.incomingCatId) {\n      this.logger.trace('Got inbound CAT headers in transaction %s from %s', tx.id, tx.incomingCatId);\n    }\n  }\n\n  if (appData) {\n    _handleCATReplyHeader(this, segment, appData); // TODO: Handle adding ExternalTransaction metrics for this segment.\n\n  }\n}\n/**\n * Adds CAT headers for an outbound request.\n *\n * - `insertCATRequestHeaders(headers [, useAlternateHeaderNames])`\n *\n * @memberof TransactionShim.prototype\n *\n * @param {object} headers\n *  The outbound request headers object to inject our CAT headers into.\n *\n * @param {bool} [useAlternateHeaderNames=false]\n *  Indicates if HTTP-style headers should be used or alternate style. Some\n *  transport protocols are more strict on the characters allowed in headers\n *  and this option can be used to toggle use of pure-alpha header names.\n */\n// TODO: abstract header logic shared with wrapRequest in http instrumentation\n\n\nfunction insertCATRequestHeaders(headers, useAlternateHeaderNames) {\n  const crossAppTracingEnabled = this.agent.config.cross_application_tracer.enabled;\n  const distributedTracingEnabled = this.agent.config.distributed_tracing.enabled;\n\n  if (!distributedTracingEnabled && !crossAppTracingEnabled) {\n    this.logger.trace('Distributed Tracing and CAT are both disabled, not adding headers.');\n    return;\n  }\n\n  if (!headers) {\n    this.logger.debug('Missing headers object, not adding headers!');\n    return;\n  }\n\n  const tx = this.tracer.getTransaction();\n\n  if (!tx || !tx.isActive()) {\n    this.logger.trace('No active transaction found, not adding headers.');\n    return;\n  }\n\n  if (distributedTracingEnabled) {\n    const dtPayload = tx.createDistributedTracePayload().httpSafe();\n\n    if (dtPayload) {\n      headers[DISTRIBUTED_TRACE_HEADER] = dtPayload;\n      this.logger.trace('Added Distributed Tracing headers for transaction %s', tx.id);\n    }\n  } else {\n    if (!this.agent.config.encoding_key) {\n      this.logger.warn('Missing encoding key, not adding CAT headers!');\n      return;\n    } // Determine the names of the headers we'll add.\n\n\n    let transHeader = HTTP_CAT_TRANSACTION_HEADER;\n    let idHeader = HTTP_CAT_ID_HEADER;\n\n    if (useAlternateHeaderNames) {\n      idHeader = MQ_CAT_ID_HEADER;\n      transHeader = MQ_CAT_TRANSACTION_HEADER;\n    } // Add in the application ID.\n\n\n    if (this.agent.config.obfuscatedId) {\n      headers[idHeader] = this.agent.config.obfuscatedId;\n    } // Generate an application path hash. This is essentially a snapshot of what\n    // the transaction would be named if it ended right now.\n\n\n    const pathHash = hashes.calculatePathHash(this.agent.config.applications()[0], tx.getFullName(), tx.referringPathHash);\n    tx.pushPathHash(pathHash);\n\n    try {\n      const catData = hashes.obfuscateNameUsingKey(JSON.stringify([tx.id, false, tx.tripId || tx.id, pathHash]), this.agent.config.encoding_key);\n\n      if (catData) {\n        headers[transHeader] = catData;\n        this.logger.trace('Added CAT headers for transaction %s', tx.id);\n      }\n    } catch (e) {\n      this.logger.warn({\n        error: e.stack\n      }, 'Failed to serialize CAT header!');\n    }\n  }\n}\n/**\n * Adds CAT headers for an outbound response.\n *\n * - `insertCATReplyHeaders(headers [, useAlternateHeaderNames])`\n *\n * @memberof TransactionShim.prototype\n *\n * @param {object} headers\n *  The outbound response headers object to inject our CAT headers into.\n *\n * @param {bool} [useAlternateHeaderNames=false]\n *  Indicates if HTTP-style headers should be used or alternate style. Some\n *  transport protocols are more strict on the characters allowed in headers\n *  and this option can be used to toggle use of pure-alpha header names.\n */\n\n\nfunction insertCATReplyHeader(headers, useAlternateHeaderNames) {\n  // Is CAT enabled?\n  var config = this.agent.config;\n\n  if (!config.cross_application_tracer.enabled) {\n    this.logger.trace('CAT disabled, not adding CAT reply header.');\n    return;\n  } else if (config.distributed_tracing.enabled) {\n    this.logger.warn('Distributed tracing is enabled, not adding CAT reply header.');\n    return;\n  } else if (!config.encoding_key) {\n    this.logger.warn('Missing encoding key, not adding CAT reply header!');\n    return;\n  } else if (!headers) {\n    this.logger.debug('Missing headers object, not adding CAT reply header!');\n    return;\n  } // Are we in a transaction?\n\n\n  var segment = this.getSegment();\n\n  if (!segment || !segment.transaction.isActive()) {\n    this.logger.trace('Not adding CAT reply header, not in an active transaction.');\n    return;\n  }\n\n  var tx = segment.transaction; // Hunt down the content length.\n  // NOTE: In AMQP, content-type and content-encoding are guaranteed fields, but\n  // there is no content-length field or header. For that, content length will\n  // always be -1.\n\n  var contentLength = -1;\n\n  for (var key in headers) {\n    if (key.toLowerCase() === 'content-length') {\n      contentLength = headers[key];\n      break;\n    }\n  } // Compose the obfuscated app data value.\n\n\n  var appData = null;\n  var txName = tx.getFullName();\n\n  try {\n    appData = hashes.obfuscateNameUsingKey(JSON.stringify([config.cross_process_id, txName, tx.queueTime / 1000, tx.catResponseTime / 1000, contentLength, tx.id, false]), config.encoding_key);\n  } catch (e) {\n    this.logger.warn({\n      error: e.stack\n    }, 'Failed to serialize CAT data for %s', txName);\n  } // Add the header.\n\n\n  headers[useAlternateHeaderNames ? MQ_CAT_APP_DATA_HEADER : HTTP_CAT_APP_DATA_HEADER] = appData;\n  this.logger.trace('Added outbound response CAT headers for transaction %s', tx.id);\n}\n/**\n * Parses the given CAT response app-data and links the transaction to it.\n *\n * - `_handleCATReplyHeader(shim, segment, appData)`\n *\n * @private\n *\n * @param {TransactionShim} shim\n *  The shim to use in the process of extracting the app data.\n *\n * @param {!TraceSegment} segment\n *  The segment to attach the CAT data to.\n *\n * @param {string} appData\n *  The application data to parse and use.\n */\n\n\nfunction _handleCATReplyHeader(shim, segment, appData) {\n  // Attempt to parse the app data header.\n  var config = shim.agent.config;\n\n  try {\n    appData = JSON.parse(hashes.deobfuscateNameUsingKey(appData, config.encoding_key));\n  } catch (e) {\n    shim.logger.warn('Unparsable CAT application data header: %s', appData);\n    return;\n  } // Make sure the app data is of the expected format and that we trust the\n  // origin application.\n\n\n  if (!appData.length || !shim.isString(appData[0])) {\n    shim.logger.trace('Unknown format for CAT application data header.');\n    return;\n  }\n\n  var accountId = parseInt(appData[0].split('#')[0], 10);\n  var trustedIds = config.trusted_account_ids;\n\n  if (trustedIds && trustedIds.indexOf(accountId) === -1) {\n    shim.logger.trace('CAT headers from untrusted application %s', accountId);\n    return;\n  } // It's good! Pull out the data we care about.\n\n\n  segment.catId = appData[0];\n  segment.catTransaction = appData[1];\n\n  if (appData.length >= 6) {\n    segment.addAttribute('transaction_guid', appData[5]);\n  }\n\n  shim.logger.trace('Got inbound response CAT headers for transaction %s from %s', segment.transaction.id, appData[5]);\n}\n/**\n * Creates a function that binds transactions to the execution of the function.\n *\n * The created transaction may be nested within an existing transaction if\n * `spec.type` is not the same as the current transaction's type.\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim used for the binding.\n *\n * @param {function} fn\n *  The function link with the transaction.\n *\n * @param {string} name\n *  The name of the wrapped function.\n *\n * @param {TransactionSpec} spec\n *  The spec for the transaction to create.\n *\n * @return {function} A function which wraps `fn` and creates potentially nested\n *  transactions linked to its execution.\n */\n\n\nfunction _makeNestedTransWrapper(shim, fn, name, spec) {\n  return function nestedTransactionWrapper() {\n    if (!shim.agent.canCollectData()) {\n      return fn.apply(this, arguments);\n    } // Reuse existing transactions only if the type matches.\n\n\n    var transaction = shim.tracer.getTransaction();\n    var segment = shim.tracer.segment; // Only create a new transaction if we either do not have a current\n    // transaction _or_ the current transaction is not of the type we want.\n\n    if (!transaction || spec.type !== transaction.type) {\n      shim.logger.trace('Creating new nested %s transaction for %s', spec.type, name);\n      transaction = new Transaction(shim.agent);\n      transaction.type = spec.type;\n      segment = transaction.trace.root;\n    }\n\n    return shim.applySegment(fn, segment, false, this, arguments);\n  };\n}\n/**\n * Creates a function that binds transactions to the execution of the function.\n *\n * A transaction will only be created if there is not a currently active one.\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim used for the binding.\n *\n * @param {function} fn\n *  The function link with the transaction.\n *\n * @param {string} name\n *  The name of the wrapped function.\n *\n * @param {TransactionSpec} spec\n *  The spec for the transaction to create.\n *\n * @return {function} A function which wraps `fn` and potentially creates a new\n *  transaction linked to the function's execution.\n */\n\n\nfunction _makeTransWrapper(shim, fn, name, spec) {\n  return function transactionWrapper() {\n    // Don't nest transactions, reuse existing ones!\n    const existingTransaction = shim.tracer.getTransaction();\n\n    if (!shim.agent.canCollectData() || existingTransaction) {\n      return fn.apply(this, arguments);\n    }\n\n    shim.logger.trace('Creating new %s transaction for %s', spec.type, name);\n    var transaction = new Transaction(shim.agent);\n    transaction.type = spec.type;\n    return shim.applySegment(fn, transaction.trace.root, false, this, arguments);\n  };\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/shim/transaction-shim.js"],"names":["cat","require","hashes","logger","child","component","Shim","Transaction","util","DISTRIBUTED_TRACE_HEADER","HTTP_CAT_ID_HEADER","MQ_CAT_ID_HEADER","MATCH_CAT_ID_HEADER","RegExp","HTTP_CAT_TRANSACTION_HEADER","MQ_CAT_TRANSACTION_HEADER","MATCH_CAT_TRANSACTION_HEADER","HTTP_CAT_APP_DATA_HEADER","MQ_CAT_APP_DATA_HEADER","MATCH_CAT_APP_DATA_HEADER","TRANSACTION_TYPES_SET","TYPES_SET","TRANSPORT_TYPES_SET","TransactionShim","agent","moduleName","resolvedName","call","_logger","module","exports","inherits","TRANSACTION_TYPES","TYPES","Object","keys","forEach","defineTypeEnum","type","defineProperty","prototype","TRANSPORT_TYPES","bindCreateTransaction","pushTransactionName","popTransactionName","setTransactionName","handleCATHeaders","insertCATRequestHeaders","insertCATReplyHeader","nodule","property","spec","isObject","isArray","error","stack","Error","wrap","makeTransWrapper","shim","fn","name","isFunction","debug","makeWrapper","nest","_makeNestedTransWrapper","_makeTransWrapper","pathSegment","tx","tracer","getTransaction","nameState","appendPath","popPath","setPartialName","headers","segment","transportType","config","cross_application_tracer","enabled","trace","encoding_key","warn","getSegment","transaction","isActive","UNKNOWN","distributed_tracing","payload","acceptDistributedTracePayload","catId","transactionData","appData","key","test","handleCatHeaders","incomingCatId","id","_handleCATReplyHeader","useAlternateHeaderNames","crossAppTracingEnabled","distributedTracingEnabled","dtPayload","createDistributedTracePayload","httpSafe","transHeader","idHeader","obfuscatedId","pathHash","calculatePathHash","applications","getFullName","referringPathHash","pushPathHash","catData","obfuscateNameUsingKey","JSON","stringify","tripId","e","contentLength","toLowerCase","txName","cross_process_id","queueTime","catResponseTime","parse","deobfuscateNameUsingKey","length","isString","accountId","parseInt","split","trustedIds","trusted_account_ids","indexOf","catTransaction","addAttribute","nestedTransactionWrapper","canCollectData","apply","arguments","root","applySegment","transactionWrapper","existingTransaction"],"mappings":"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","sourcesContent":["'use strict'\n\nvar cat = require('../util/cat')\nvar hashes = require('../util/hashes')\nvar logger = require('../logger').child({component: 'TransactionShim'})\nvar Shim = require('./shim')\nvar Transaction = require('../transaction')\nvar util = require('util')\n\nconst DISTRIBUTED_TRACE_HEADER = 'newrelic'\nconst HTTP_CAT_ID_HEADER = 'X-NewRelic-Id'\nconst MQ_CAT_ID_HEADER = 'NewRelicID'\nconst MATCH_CAT_ID_HEADER = new RegExp(\n  '^(?:' + HTTP_CAT_ID_HEADER + '|' + MQ_CAT_ID_HEADER + ')$',\n  'i'\n)\nconst HTTP_CAT_TRANSACTION_HEADER = 'X-NewRelic-Transaction'\nconst MQ_CAT_TRANSACTION_HEADER = 'NewRelicTransaction'\nconst MATCH_CAT_TRANSACTION_HEADER = new RegExp(\n  '^(?:' + HTTP_CAT_TRANSACTION_HEADER + '|' + MQ_CAT_TRANSACTION_HEADER + ')$',\n  'i'\n)\nconst HTTP_CAT_APP_DATA_HEADER = 'X-NewRelic-App-Data'\nconst MQ_CAT_APP_DATA_HEADER = 'NewRelicAppData'\nconst MATCH_CAT_APP_DATA_HEADER = new RegExp(\n  '^(?:' + HTTP_CAT_APP_DATA_HEADER + '|' + MQ_CAT_APP_DATA_HEADER + ')$',\n  'i'\n)\n\nconst TRANSACTION_TYPES_SET = Transaction.TYPES_SET\nconst TRANSPORT_TYPES_SET = Transaction.TRANSPORT_TYPES_SET\n\n/**\n * Constructs a transaction managing shim.\n *\n * @constructor\n * @extends Shim\n * @classdesc\n *  A helper class for working with transactions.\n *\n * @param {Agent}   agent         - The agent the shim will use.\n * @param {string}  moduleName    - The name of the module being instrumented.\n * @param {string}  resolvedName  - The full path to the loaded module.\n *\n * @see Shim\n * @see WebFrameworkShim\n */\nfunction TransactionShim(agent, moduleName, resolvedName) {\n  Shim.call(this, agent, moduleName, resolvedName)\n  this._logger = logger.child({module: moduleName})\n}\nmodule.exports = TransactionShim\nutil.inherits(TransactionShim, Shim)\n\n/**\n * Enumeration of transaction types.\n *\n * Each of these values is also exposed directly on the `TransactionShim` class\n * as static members.\n *\n * @readonly\n * @memberof TransactionShim.prototype\n * @enum {string}\n */\nTransactionShim.TRANSACTION_TYPES = Transaction.TYPES\nObject.keys(Transaction.TYPES).forEach(function defineTypeEnum(type) {\n  Shim.defineProperty(TransactionShim, type, Transaction.TYPES[type])\n  Shim.defineProperty(TransactionShim.prototype, type, Transaction.TYPES[type])\n})\n\n\n/**\n * Enumeration of possible transaction transport types used for distributed tracing.\n *\n * This enumeration is also exposed on the `TransactionShim` class.\n *\n * @readonly\n * @memberof TransactionShim.prototype\n * @enum {string}\n */\nShim.defineProperty(\n  TransactionShim,\n  'TRANSPORT_TYPES',\n  Transaction.TRANSPORT_TYPES\n)\nShim.defineProperty(\n  TransactionShim.prototype,\n  'TRANSPORT_TYPES',\n  Transaction.TRANSPORT_TYPES\n)\n\nTransactionShim.prototype.bindCreateTransaction = bindCreateTransaction\nTransactionShim.prototype.pushTransactionName = pushTransactionName\nTransactionShim.prototype.popTransactionName = popTransactionName\nTransactionShim.prototype.setTransactionName = setTransactionName\nTransactionShim.prototype.handleCATHeaders = handleCATHeaders\nTransactionShim.prototype.insertCATRequestHeaders = insertCATRequestHeaders\nTransactionShim.prototype.insertCATReplyHeader = insertCATReplyHeader\n\n// -------------------------------------------------------------------------- //\n\n/**\n * @interface TransactionSpec\n *\n * @description\n *  Describes the type of transaction to be created by the function being\n *  wrapped by {@link Shim#bindCreateTransaction}.\n *\n * @property {string} type\n *  The type of transaction to create. Must be one of the values from\n *  {@link Shim#TRANSACTION_TYPES}.\n *\n * @property {bool} [nest=false]\n *  Indicates if the transaction being created is allowed to be nested within\n *  another transaction of the same type. If `false`, the default, the transaction\n *  will only be created if there is no existing transaction, or the current\n *  transaction is of a different type. If `true`, the transaction will be\n *  created regardless of the current transaction's type.\n *\n * @see Shim#bindCreateTransaction\n * @see Shim#TRANSACTION_TYPES\n */\n\n// -------------------------------------------------------------------------- //\n\n/**\n * Wraps one or more functions such that new transactions are created when\n * invoked.\n *\n * - `bindCreateTransaction(nodule, property, spec)`\n * - `bindCreateTransaction(func, spec)`\n *\n * @memberof TransactionShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the property to wrap, or a single function to wrap.\n *\n * @param {string} [property]\n *  The property to wrap. If omitted, the `nodule` parameter is assumed to be\n *  the function to wrap.\n *\n * @param {TransactionSpec} spec\n *  The spec for creating the transaction.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its property.\n */\nfunction bindCreateTransaction(nodule, property, spec) {\n  if (this.isObject(property) && !this.isArray(property)) {\n    // bindCreateTransaction(nodule, spec)\n    spec = property\n    property = null\n  }\n\n  // Refuse to perform the wrapping if `spec.type` is not valid.\n  if (!TRANSACTION_TYPES_SET[spec.type]) {\n    this.logger.error(\n      {stack: (new Error()).stack},\n      'Invalid spec type \"%s\", must be one of %j.',\n      spec.type, Object.keys(TRANSACTION_TYPES_SET)\n    )\n    return nodule\n  }\n\n  // Perform the actual wrapping.\n  return this.wrap(nodule, property, function makeTransWrapper(shim, fn, name) {\n    if (!shim.isFunction(fn)) {\n      shim.logger.debug('Not wrapping \"%s\" with transaction, not a function.', name)\n      return fn\n    }\n\n    // Is this transaction supposed to be nested? Pick the right wrapper for the\n    // job.\n    var makeWrapper = spec.nest ? _makeNestedTransWrapper : _makeTransWrapper\n    return makeWrapper(shim, fn, name, spec)\n  })\n}\n\n/**\n * Pushes a new path segment onto the transaction naming stack.\n *\n * - `pushTransactionName(pathSegment)`\n *\n * Transactions are named for the middlware that sends the reponse. Some web\n * frameworks are capable of mounting middlware in complex routing stacks. In\n * order to maintain the correct name, transactions keep a stack of mount points\n * for each middlware/router/app/whatever. The instrumentation should push on\n * the mount path for wrapped things when route resolution enters and pop it\n * back off when resolution exits the item.\n *\n * @memberof TransactionShim.prototype\n *\n * @param {string} pathSegment - The path segment to add to the naming stack.\n */\nfunction pushTransactionName(pathSegment) {\n  var tx = this.tracer.getTransaction()\n  if (tx && tx.nameState) {\n    tx.nameState.appendPath(pathSegment)\n  }\n}\n\n/**\n * Pops one or more elements off the transaction naming stack.\n *\n * - `popTransactionName([pathSegment])`\n *\n * Ideally it is not necessary to ever provide the `pathSegment` parameter for\n * this function, but we do not live in an ideal world.\n *\n * @memberof TransactionShim.prototype\n *\n * @param {string} [pathSegment]\n *  Optional. Path segment to pop the stack repeatedly until a segment matching\n *  `pathSegment` is removed.\n */\nfunction popTransactionName(pathSegment) {\n  var tx = this.tracer.getTransaction()\n  if (tx && tx.nameState) {\n    tx.nameState.popPath(pathSegment)\n  }\n}\n\n/**\n * Sets the name to be used for this transaction.\n *\n * - `setTransactionName(name)`\n *\n * Either this _or_ the naming stack should be used. Do not use them together.\n *\n * @memberof TransactionShim.prototype\n *\n * @param {string} name - The name to use for the transaction.\n */\nfunction setTransactionName(name) {\n  var tx = this.tracer.getTransaction()\n  if (tx) {\n    tx.setPartialName(name)\n  }\n}\n\n/**\n * Retrieves whatever CAT headers may be in the given headers.\n *\n * - `handleCATHeaders(headers [, segment [, transportType]])`\n *\n * @memberof TransactionShim.prototype\n *\n * This will check for either header naming style, and both request and reply\n * CAT headers.\n *\n * @param {object} headers\n *  The request/response headers object to look in.\n *\n * @param {TraceSegment} [segment=null]\n *  The trace segment to associate the header data with. If no segment is\n *  provided then the currently active segment is used.\n *\n * @param {string} [transportType='Unknown']\n *  The transport type that brought the headers. Usually `HTTP` or `HTTPS`.\n */\nfunction handleCATHeaders(headers, segment, transportType) {\n  // Is CAT enabled?\n  if (!this.agent.config.cross_application_tracer.enabled) {\n    this.logger.trace('CAT disabled, not extracting header.')\n    return\n  }\n  if (!this.agent.config.encoding_key) {\n    this.logger.warn('Missing encoding key, not extracting CAT headers!')\n    return\n  } else if (!headers) {\n    this.logger.debug('No headers to search for CAT within')\n    return\n  }\n\n  // Check that we're in an active transaction.\n  segment = segment || this.getSegment()\n  if (!segment || !segment.transaction.isActive()) {\n    this.logger.trace('Not adding CAT reply header, not in an active transaction.')\n    return\n  }\n  var tx = segment.transaction\n\n  // Ensure this is a valid transport type.\n  transportType = transportType || Transaction.TRANSPORT_TYPES.UNKNOWN\n  if (!TRANSPORT_TYPES_SET[transportType]) {\n    this.logger.debug('Unknown transport type: %j', transportType)\n    transportType = Transaction.TRANSPORT_TYPES.UNKNOWN\n  }\n\n  if (this.agent.config.distributed_tracing.enabled) {\n    const payload = headers[DISTRIBUTED_TRACE_HEADER]\n    if (payload) {\n      tx.acceptDistributedTracePayload(payload, transportType)\n    }\n    return\n  }\n\n  // Hunt down the CAT headers.\n  var catId = null\n  var transactionData = null\n  var appData = null\n  for (var key in headers) { // eslint-disable-line guard-for-in\n    if (MATCH_CAT_ID_HEADER.test(key)) {\n      catId = headers[key]\n    } else if (MATCH_CAT_TRANSACTION_HEADER.test(key)) {\n      transactionData = headers[key]\n    } else if (MATCH_CAT_APP_DATA_HEADER.test(key)) {\n      appData = headers[key]\n    }\n    if (catId && transactionData && appData) {\n      break\n    }\n  }\n\n  if (catId && transactionData) {\n    cat.handleCatHeaders(catId, transactionData, this.agent.config.encoding_key, tx)\n    if (tx.incomingCatId) {\n      this.logger.trace(\n        'Got inbound CAT headers in transaction %s from %s',\n        tx.id,\n        tx.incomingCatId\n      )\n    }\n  }\n\n  if (appData) {\n    _handleCATReplyHeader(this, segment, appData)\n    // TODO: Handle adding ExternalTransaction metrics for this segment.\n  }\n}\n\n/**\n * Adds CAT headers for an outbound request.\n *\n * - `insertCATRequestHeaders(headers [, useAlternateHeaderNames])`\n *\n * @memberof TransactionShim.prototype\n *\n * @param {object} headers\n *  The outbound request headers object to inject our CAT headers into.\n *\n * @param {bool} [useAlternateHeaderNames=false]\n *  Indicates if HTTP-style headers should be used or alternate style. Some\n *  transport protocols are more strict on the characters allowed in headers\n *  and this option can be used to toggle use of pure-alpha header names.\n */\n// TODO: abstract header logic shared with wrapRequest in http instrumentation\nfunction insertCATRequestHeaders(headers, useAlternateHeaderNames) {\n  const crossAppTracingEnabled = this.agent.config.cross_application_tracer.enabled\n  const distributedTracingEnabled = this.agent.config.distributed_tracing.enabled\n\n  if (!distributedTracingEnabled && !crossAppTracingEnabled) {\n    this.logger.trace(\n      'Distributed Tracing and CAT are both disabled, not adding headers.'\n    )\n    return\n  }\n\n  if (!headers) {\n    this.logger.debug('Missing headers object, not adding headers!')\n    return\n  }\n\n  const tx = this.tracer.getTransaction()\n  if (!tx || !tx.isActive()) {\n    this.logger.trace('No active transaction found, not adding headers.')\n    return\n  }\n\n  if (distributedTracingEnabled) {\n    const dtPayload = tx.createDistributedTracePayload().httpSafe()\n    if (dtPayload) {\n      headers[DISTRIBUTED_TRACE_HEADER] = dtPayload\n      this.logger.trace('Added Distributed Tracing headers for transaction %s', tx.id)\n    }\n  } else {\n    if (!this.agent.config.encoding_key) {\n      this.logger.warn('Missing encoding key, not adding CAT headers!')\n      return\n    }\n\n    // Determine the names of the headers we'll add.\n    let transHeader = HTTP_CAT_TRANSACTION_HEADER\n    let idHeader = HTTP_CAT_ID_HEADER\n    if (useAlternateHeaderNames) {\n      idHeader = MQ_CAT_ID_HEADER\n      transHeader = MQ_CAT_TRANSACTION_HEADER\n    }\n\n    // Add in the application ID.\n    if (this.agent.config.obfuscatedId) {\n      headers[idHeader] = this.agent.config.obfuscatedId\n    }\n\n    // Generate an application path hash. This is essentially a snapshot of what\n    // the transaction would be named if it ended right now.\n    const pathHash = hashes.calculatePathHash(\n      this.agent.config.applications()[0],\n      tx.getFullName(),\n      tx.referringPathHash\n    )\n\n    tx.pushPathHash(pathHash)\n\n    try {\n      const catData = hashes.obfuscateNameUsingKey(\n        JSON.stringify([tx.id, false, tx.tripId || tx.id, pathHash]),\n        this.agent.config.encoding_key\n      )\n      if (catData) {\n        headers[transHeader] = catData\n        this.logger.trace('Added CAT headers for transaction %s', tx.id)\n      }\n    } catch (e) {\n      this.logger.warn({error: e.stack}, 'Failed to serialize CAT header!')\n    }\n  }\n}\n\n/**\n * Adds CAT headers for an outbound response.\n *\n * - `insertCATReplyHeaders(headers [, useAlternateHeaderNames])`\n *\n * @memberof TransactionShim.prototype\n *\n * @param {object} headers\n *  The outbound response headers object to inject our CAT headers into.\n *\n * @param {bool} [useAlternateHeaderNames=false]\n *  Indicates if HTTP-style headers should be used or alternate style. Some\n *  transport protocols are more strict on the characters allowed in headers\n *  and this option can be used to toggle use of pure-alpha header names.\n */\nfunction insertCATReplyHeader(headers, useAlternateHeaderNames) {\n  // Is CAT enabled?\n  var config = this.agent.config\n  if (!config.cross_application_tracer.enabled) {\n    this.logger.trace('CAT disabled, not adding CAT reply header.')\n    return\n  } else if (config.distributed_tracing.enabled) {\n    this.logger.warn('Distributed tracing is enabled, not adding CAT reply header.')\n    return\n  } else if (!config.encoding_key) {\n    this.logger.warn('Missing encoding key, not adding CAT reply header!')\n    return\n  } else if (!headers) {\n    this.logger.debug('Missing headers object, not adding CAT reply header!')\n    return\n  }\n\n  // Are we in a transaction?\n  var segment = this.getSegment()\n  if (!segment || !segment.transaction.isActive()) {\n    this.logger.trace('Not adding CAT reply header, not in an active transaction.')\n    return\n  }\n  var tx = segment.transaction\n\n  // Hunt down the content length.\n  // NOTE: In AMQP, content-type and content-encoding are guaranteed fields, but\n  // there is no content-length field or header. For that, content length will\n  // always be -1.\n  var contentLength = -1\n  for (var key in headers) {\n    if (key.toLowerCase() === 'content-length') {\n      contentLength = headers[key]\n      break\n    }\n  }\n\n  // Compose the obfuscated app data value.\n  var appData = null\n  var txName = tx.getFullName()\n  try {\n    appData = hashes.obfuscateNameUsingKey(JSON.stringify([\n      config.cross_process_id,\n      txName,\n      tx.queueTime / 1000,\n      tx.catResponseTime / 1000,\n      contentLength,\n      tx.id,\n      false\n    ]), config.encoding_key)\n  } catch (e) {\n    this.logger.warn({error: e.stack}, 'Failed to serialize CAT data for %s', txName)\n  }\n\n  // Add the header.\n  headers[\n    useAlternateHeaderNames ? MQ_CAT_APP_DATA_HEADER : HTTP_CAT_APP_DATA_HEADER\n  ] = appData\n  this.logger.trace('Added outbound response CAT headers for transaction %s', tx.id)\n}\n\n/**\n * Parses the given CAT response app-data and links the transaction to it.\n *\n * - `_handleCATReplyHeader(shim, segment, appData)`\n *\n * @private\n *\n * @param {TransactionShim} shim\n *  The shim to use in the process of extracting the app data.\n *\n * @param {!TraceSegment} segment\n *  The segment to attach the CAT data to.\n *\n * @param {string} appData\n *  The application data to parse and use.\n */\nfunction _handleCATReplyHeader(shim, segment, appData) {\n  // Attempt to parse the app data header.\n  var config = shim.agent.config\n  try {\n    appData = JSON.parse(\n      hashes.deobfuscateNameUsingKey(appData, config.encoding_key)\n    )\n  } catch (e) {\n    shim.logger.warn('Unparsable CAT application data header: %s', appData)\n    return\n  }\n\n  // Make sure the app data is of the expected format and that we trust the\n  // origin application.\n  if (!appData.length || !shim.isString(appData[0])) {\n    shim.logger.trace('Unknown format for CAT application data header.')\n    return\n  }\n  var accountId = parseInt(appData[0].split('#')[0], 10)\n  var trustedIds = config.trusted_account_ids\n  if (trustedIds && trustedIds.indexOf(accountId) === -1) {\n    shim.logger.trace('CAT headers from untrusted application %s', accountId)\n    return\n  }\n\n  // It's good! Pull out the data we care about.\n  segment.catId = appData[0]\n  segment.catTransaction = appData[1]\n  if (appData.length >= 6) {\n    segment.addAttribute('transaction_guid', appData[5])\n  }\n  shim.logger.trace(\n    'Got inbound response CAT headers for transaction %s from %s',\n    segment.transaction.id,\n    appData[5]\n  )\n}\n\n/**\n * Creates a function that binds transactions to the execution of the function.\n *\n * The created transaction may be nested within an existing transaction if\n * `spec.type` is not the same as the current transaction's type.\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim used for the binding.\n *\n * @param {function} fn\n *  The function link with the transaction.\n *\n * @param {string} name\n *  The name of the wrapped function.\n *\n * @param {TransactionSpec} spec\n *  The spec for the transaction to create.\n *\n * @return {function} A function which wraps `fn` and creates potentially nested\n *  transactions linked to its execution.\n */\nfunction _makeNestedTransWrapper(shim, fn, name, spec) {\n  return function nestedTransactionWrapper() {\n    if (!shim.agent.canCollectData()) {\n      return fn.apply(this, arguments)\n    }\n\n    // Reuse existing transactions only if the type matches.\n    var transaction = shim.tracer.getTransaction()\n    var segment = shim.tracer.segment\n\n    // Only create a new transaction if we either do not have a current\n    // transaction _or_ the current transaction is not of the type we want.\n    if (!transaction || spec.type !== transaction.type) {\n      shim.logger.trace('Creating new nested %s transaction for %s', spec.type, name)\n      transaction = new Transaction(shim.agent)\n      transaction.type = spec.type\n      segment = transaction.trace.root\n    }\n\n    return shim.applySegment(fn, segment, false, this, arguments)\n  }\n}\n\n/**\n * Creates a function that binds transactions to the execution of the function.\n *\n * A transaction will only be created if there is not a currently active one.\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim used for the binding.\n *\n * @param {function} fn\n *  The function link with the transaction.\n *\n * @param {string} name\n *  The name of the wrapped function.\n *\n * @param {TransactionSpec} spec\n *  The spec for the transaction to create.\n *\n * @return {function} A function which wraps `fn` and potentially creates a new\n *  transaction linked to the function's execution.\n */\nfunction _makeTransWrapper(shim, fn, name, spec) {\n  return function transactionWrapper() {\n    // Don't nest transactions, reuse existing ones!\n    const existingTransaction = shim.tracer.getTransaction()\n    if (!shim.agent.canCollectData() || existingTransaction) {\n      return fn.apply(this, arguments)\n    }\n\n    shim.logger.trace('Creating new %s transaction for %s', spec.type, name)\n    var transaction = new Transaction(shim.agent)\n    transaction.type = spec.type\n    return shim.applySegment(fn, transaction.trace.root, false, this, arguments)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}