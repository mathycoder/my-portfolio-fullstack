{"ast":null,"code":"'use strict';\n\nvar crypto = require('crypto');\n\nfunction encode(bytes, keyBytes) {\n  for (var i = 0; i < bytes.length; i++) {\n    // This is really dense but happens commonly so I'm in-lining some of what\n    // could be tossed into variables. It takes the current byte of bytes, then\n    // XORs it with the current byte of the key (which uses modulo to make sure\n    // to not overrun the end.)\n    bytes.writeUInt8(bytes.readUInt8(i) ^ keyBytes.readUInt8(i % keyBytes.length), i);\n  }\n\n  return bytes;\n}\n\nfunction obfuscateNameUsingKey(name, key) {\n  var encodedBytes = Buffer.from(name, 'utf-8');\n  var keyBytes = Buffer.from(key);\n  return encode(encodedBytes, keyBytes).toString('base64');\n}\n\nfunction deobfuscateNameUsingKey(name, key) {\n  var bytes = Buffer.from(name, 'base64');\n  var keyBytes = Buffer.from(key);\n  return encode(bytes, keyBytes).toString(\"utf-8\");\n}\n\nfunction calculatePathHash(appName, pathName, referingPathHash) {\n  if (typeof referingPathHash === 'string') {\n    referingPathHash = parseInt(referingPathHash, 16);\n  }\n\n  var rotated = (referingPathHash << 1 | referingPathHash >>> 31) >>> 0;\n  var hash = getHash(appName, pathName);\n  var result = (rotated ^ hash) >>> 0; // This is a trick to pad it out to 8 chars regardless of length.\n\n  var retval = ('00000000' + result.toString(16)).substr(-8);\n  return retval;\n}\n\nfunction getHash(appName, txName) {\n  var md5sum = crypto.createHash('md5');\n  md5sum.update(appName + ';' + txName, 'utf8');\n  var buf = md5sum.digest();\n\n  if (!(buf instanceof Buffer)) {\n    buf = Buffer.from(buf);\n  } // pull the low 4 bytes in network byte order\n\n\n  return buf.slice(buf.length - 4, buf.length).readUInt32BE(0);\n}\n\nfunction makeId() {\n  // 1e17 should always result in a whole number, but just in case we floor it\n  // so we don't end up with decimals. Then we make it hex because other agents\n  // use a hex based transaction id.\n  return Math.floor(Math.random() * 1e17).toString(16);\n}\n\nexports.obfuscateNameUsingKey = obfuscateNameUsingKey;\nexports.deobfuscateNameUsingKey = deobfuscateNameUsingKey;\nexports.calculatePathHash = calculatePathHash;\nexports.getHash = getHash;\nexports.makeId = makeId;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/util/hashes.js"],"names":["crypto","require","encode","bytes","keyBytes","i","length","writeUInt8","readUInt8","obfuscateNameUsingKey","name","key","encodedBytes","Buffer","from","toString","deobfuscateNameUsingKey","calculatePathHash","appName","pathName","referingPathHash","parseInt","rotated","hash","getHash","result","retval","substr","txName","md5sum","createHash","update","buf","digest","slice","readUInt32BE","makeId","Math","floor","random","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar crypto = require('crypto')\n\nfunction encode(bytes, keyBytes) {\n  for (var i = 0; i < bytes.length; i++) {\n    // This is really dense but happens commonly so I'm in-lining some of what\n    // could be tossed into variables. It takes the current byte of bytes, then\n    // XORs it with the current byte of the key (which uses modulo to make sure\n    // to not overrun the end.)\n    bytes.writeUInt8(bytes.readUInt8(i) ^ keyBytes.readUInt8(i % keyBytes.length), i)\n  }\n  return bytes\n}\n\nfunction obfuscateNameUsingKey(name, key) {\n  var encodedBytes = Buffer.from(name, 'utf-8')\n  var keyBytes = Buffer.from(key)\n  return encode(encodedBytes, keyBytes).toString('base64')\n}\n\nfunction deobfuscateNameUsingKey(name, key) {\n  var bytes = Buffer.from(name, 'base64')\n  var keyBytes = Buffer.from(key)\n\n  return encode(bytes, keyBytes).toString(\"utf-8\")\n}\n\nfunction calculatePathHash(appName, pathName, referingPathHash) {\n  if (typeof referingPathHash === 'string') {\n    referingPathHash = parseInt(referingPathHash, 16)\n  }\n  var rotated = ((referingPathHash << 1) | (referingPathHash >>> 31)) >>> 0\n  var hash = getHash(appName, pathName)\n\n  var result = (rotated ^ hash) >>> 0\n\n  // This is a trick to pad it out to 8 chars regardless of length.\n  var retval = ('00000000' + result.toString(16)).substr(-8)\n\n  return retval\n}\n\nfunction getHash(appName, txName) {\n  var md5sum = crypto.createHash('md5')\n  md5sum.update(appName + ';' + txName, 'utf8')\n  var buf = md5sum.digest()\n  if (!(buf instanceof Buffer)) {\n    buf = Buffer.from(buf)\n  }\n  // pull the low 4 bytes in network byte order\n  return buf.slice(buf.length - 4, buf.length).readUInt32BE(0)\n}\n\nfunction makeId() {\n  // 1e17 should always result in a whole number, but just in case we floor it\n  // so we don't end up with decimals. Then we make it hex because other agents\n  // use a hex based transaction id.\n  return Math.floor((Math.random() * 1e17)).toString(16)\n}\n\nexports.obfuscateNameUsingKey = obfuscateNameUsingKey\nexports.deobfuscateNameUsingKey = deobfuscateNameUsingKey\nexports.calculatePathHash = calculatePathHash\nexports.getHash = getHash\nexports.makeId = makeId\n"]},"metadata":{},"sourceType":"script"}