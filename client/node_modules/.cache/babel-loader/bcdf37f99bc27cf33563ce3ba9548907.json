{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar hashes = require('./hashes');\n\nvar logger = require('../logger').child({\n  component: 'cat'\n});\n\nmodule.exports.handleCatHeaders = handleCatHeaders;\nmodule.exports.parsedHeadersToTrans = parsedHeadersToTrans;\n\nfunction handleCatHeaders(incomingCatId, obfTransaction, encKey, transaction) {\n  var parsedCatId = null;\n\n  if (incomingCatId) {\n    parsedCatId = hashes.deobfuscateNameUsingKey(incomingCatId, encKey);\n  }\n\n  var externalTrans = null;\n\n  if (obfTransaction) {\n    try {\n      externalTrans = JSON.parse(hashes.deobfuscateNameUsingKey(obfTransaction, encKey));\n    } catch (e) {\n      logger.trace('Got an unparsable CAT header x-newrelic-transaction: %s', obfTransaction);\n    }\n  }\n\n  parsedHeadersToTrans(parsedCatId, externalTrans, transaction);\n}\n\nfunction parsedHeadersToTrans(parsedCatId, externalTrans, transaction) {\n  if (typeof parsedCatId === 'string') {\n    transaction.incomingCatId = parsedCatId;\n  }\n\n  if (util.isArray(externalTrans)) {\n    transaction.referringTransactionGuid = externalTrans[0];\n\n    if (typeof externalTrans[2] === 'string') {\n      transaction.tripId = externalTrans[2];\n    } else if (externalTrans[2]) {\n      transaction.invalidIncomingExternalTransaction = true;\n    }\n\n    if (_isValidReferringHash(externalTrans[3])) {\n      transaction.referringPathHash = externalTrans[3];\n    } else if (externalTrans[3]) {\n      transaction.invalidIncomingExternalTransaction = true;\n    }\n  }\n}\n\nfunction _isValidReferringHash(hash) {\n  return typeof hash === 'string';\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/util/cat.js"],"names":["util","require","hashes","logger","child","component","module","exports","handleCatHeaders","parsedHeadersToTrans","incomingCatId","obfTransaction","encKey","transaction","parsedCatId","deobfuscateNameUsingKey","externalTrans","JSON","parse","e","trace","isArray","referringTransactionGuid","tripId","invalidIncomingExternalTransaction","_isValidReferringHash","referringPathHash","hash"],"mappings":"AAAA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,WAAD,CAAP,CAAqBG,KAArB,CAA2B;AAACC,EAAAA,SAAS,EAAE;AAAZ,CAA3B,CAAb;;AAEAC,MAAM,CAACC,OAAP,CAAeC,gBAAf,GAAkCA,gBAAlC;AACAF,MAAM,CAACC,OAAP,CAAeE,oBAAf,GAAsCA,oBAAtC;;AAEA,SAASD,gBAAT,CAA0BE,aAA1B,EAAyCC,cAAzC,EAAyDC,MAAzD,EAAiEC,WAAjE,EAA8E;AAC5E,MAAIC,WAAW,GAAG,IAAlB;;AACA,MAAIJ,aAAJ,EAAmB;AACjBI,IAAAA,WAAW,GAAGZ,MAAM,CAACa,uBAAP,CACZL,aADY,EAEZE,MAFY,CAAd;AAID;;AAED,MAAII,aAAa,GAAG,IAApB;;AACA,MAAIL,cAAJ,EAAoB;AAClB,QAAI;AACFK,MAAAA,aAAa,GAAGC,IAAI,CAACC,KAAL,CACdhB,MAAM,CAACa,uBAAP,CAA+BJ,cAA/B,EAA+CC,MAA/C,CADc,CAAhB;AAGD,KAJD,CAIE,OAAOO,CAAP,EAAU;AACVhB,MAAAA,MAAM,CAACiB,KAAP,CACE,yDADF,EAEET,cAFF;AAID;AACF;;AAEDF,EAAAA,oBAAoB,CAACK,WAAD,EAAcE,aAAd,EAA6BH,WAA7B,CAApB;AACD;;AAED,SAASJ,oBAAT,CAA8BK,WAA9B,EAA2CE,aAA3C,EAA0DH,WAA1D,EAAuE;AACrE,MAAI,OAAOC,WAAP,KAAuB,QAA3B,EAAqC;AACnCD,IAAAA,WAAW,CAACH,aAAZ,GAA4BI,WAA5B;AACD;;AAED,MAAId,IAAI,CAACqB,OAAL,CAAaL,aAAb,CAAJ,EAAiC;AAC/BH,IAAAA,WAAW,CAACS,wBAAZ,GAAuCN,aAAa,CAAC,CAAD,CAApD;;AACA,QAAI,OAAOA,aAAa,CAAC,CAAD,CAApB,KAA4B,QAAhC,EAA0C;AACxCH,MAAAA,WAAW,CAACU,MAAZ,GAAqBP,aAAa,CAAC,CAAD,CAAlC;AACD,KAFD,MAEO,IAAIA,aAAa,CAAC,CAAD,CAAjB,EAAsB;AAC3BH,MAAAA,WAAW,CAACW,kCAAZ,GAAiD,IAAjD;AACD;;AAED,QAAIC,qBAAqB,CAACT,aAAa,CAAC,CAAD,CAAd,CAAzB,EAA6C;AAC3CH,MAAAA,WAAW,CAACa,iBAAZ,GAAgCV,aAAa,CAAC,CAAD,CAA7C;AACD,KAFD,MAEO,IAAIA,aAAa,CAAC,CAAD,CAAjB,EAAsB;AAC3BH,MAAAA,WAAW,CAACW,kCAAZ,GAAiD,IAAjD;AACD;AACF;AACF;;AAED,SAASC,qBAAT,CAA+BE,IAA/B,EAAqC;AACnC,SAAQ,OAAOA,IAAP,KAAgB,QAAxB;AACD","sourcesContent":["'use strict'\n\nvar util = require('util')\nvar hashes = require('./hashes')\nvar logger = require('../logger').child({component: 'cat'})\n\nmodule.exports.handleCatHeaders = handleCatHeaders\nmodule.exports.parsedHeadersToTrans = parsedHeadersToTrans\n\nfunction handleCatHeaders(incomingCatId, obfTransaction, encKey, transaction) {\n  var parsedCatId = null\n  if (incomingCatId) {\n    parsedCatId = hashes.deobfuscateNameUsingKey(\n      incomingCatId,\n      encKey\n    )\n  }\n\n  var externalTrans = null\n  if (obfTransaction) {\n    try {\n      externalTrans = JSON.parse(\n        hashes.deobfuscateNameUsingKey(obfTransaction, encKey)\n      )\n    } catch (e) {\n      logger.trace(\n        'Got an unparsable CAT header x-newrelic-transaction: %s',\n        obfTransaction\n      )\n    }\n  }\n\n  parsedHeadersToTrans(parsedCatId, externalTrans, transaction)\n}\n\nfunction parsedHeadersToTrans(parsedCatId, externalTrans, transaction) {\n  if (typeof parsedCatId === 'string') {\n    transaction.incomingCatId = parsedCatId\n  }\n\n  if (util.isArray(externalTrans)) {\n    transaction.referringTransactionGuid = externalTrans[0]\n    if (typeof externalTrans[2] === 'string') {\n      transaction.tripId = externalTrans[2]\n    } else if (externalTrans[2]) {\n      transaction.invalidIncomingExternalTransaction = true\n    }\n\n    if (_isValidReferringHash(externalTrans[3])) {\n      transaction.referringPathHash = externalTrans[3]\n    } else if (externalTrans[3]) {\n      transaction.invalidIncomingExternalTransaction = true\n    }\n  }\n}\n\nfunction _isValidReferringHash(hash) {\n  return (typeof hash === 'string')\n}\n"]},"metadata":{},"sourceType":"script"}