{"ast":null,"code":"'use strict';\n/**\n * Checks if a given string is within agent attribute limits.\n *\n * @param {string} str - Object key name or value\n * @param {number} limit - String byte limit\n */\n\nfunction isValidLength(str, limit) {\n  return Buffer.byteLength(str, 'utf8') <= limit;\n}\n/**\n * Returns the relative position of the end of the string (in bytes) and the limit.\n * >1 if the string is longer than the limit\n * 0 if the string is at the limit\n * <1 if the string is shorter than the limit\n *\n * @param {string} str\n * @param {number} limit - String byte limit\n */\n\n\nfunction compareLength(str, limit) {\n  return Buffer.byteLength(str) - limit;\n}\n/**\n * Trims a string value to given byte limit, if necessary.\n *\n * @private\n *\n * @param {string} val - The value to truncate to given byte limit.\n * @param {number} limit - The byte limit\n *\n * @return {string} The truncated value.\n */\n\n\nfunction truncate(val, limit) {\n  // First truncation handles the simple case of only one-byte characters.\n  val = val.substring(0, limit);\n\n  if (isValidLength(val, limit)) {\n    return val;\n  } // Our limitation is on byte length, and the string could contain multi-byte\n  // characters. Doing a byte-substring could chop a character in half. Instead\n  // we do a binary search over the byte length of the substrings.\n\n\n  var substrLen = val.length;\n  var delta = Math.ceil(substrLen / 2);\n  var cmpVal = compareLength(val.substring(0, substrLen), limit); // Continue the binary search till:\n  // 1) The string is the desired length (i.e. cmpVal = 0) OR\n  // 2) The desired string must split a character to acheive the desired byte length\n  //    In this case, we should cut the character that would be split.\n  //    (i.e. delta > 1 character OR the string is larger than the limit)\n\n  var substr;\n\n  while (cmpVal && (cmpVal > 0 || delta > 1)) {\n    substrLen = cmpVal < 0 ? substrLen + delta : substrLen - delta;\n    substr = val.substring(0, substrLen);\n    cmpVal = compareLength(substr, limit);\n    delta = Math.ceil(delta / 2);\n  }\n\n  return substr;\n}\n\nmodule.exports.isValidLength = isValidLength;\nmodule.exports.compareLength = compareLength;\nmodule.exports.truncate = truncate;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/util/byte-limit.js"],"names":["isValidLength","str","limit","Buffer","byteLength","compareLength","truncate","val","substring","substrLen","length","delta","Math","ceil","cmpVal","substr","module","exports"],"mappings":"AAAA;AAEA;;;;;;;AAMA,SAASA,aAAT,CAAuBC,GAAvB,EAA4BC,KAA5B,EAAmC;AACjC,SAAOC,MAAM,CAACC,UAAP,CAAkBH,GAAlB,EAAuB,MAAvB,KAAkCC,KAAzC;AACD;AAED;;;;;;;;;;;AASA,SAASG,aAAT,CAAuBJ,GAAvB,EAA4BC,KAA5B,EAAmC;AACjC,SAAOC,MAAM,CAACC,UAAP,CAAkBH,GAAlB,IAAyBC,KAAhC;AACD;AAED;;;;;;;;;;;;AAUA,SAASI,QAAT,CAAkBC,GAAlB,EAAuBL,KAAvB,EAA8B;AAC5B;AACAK,EAAAA,GAAG,GAAGA,GAAG,CAACC,SAAJ,CAAc,CAAd,EAAiBN,KAAjB,CAAN;;AACA,MAAIF,aAAa,CAACO,GAAD,EAAML,KAAN,CAAjB,EAA+B;AAC7B,WAAOK,GAAP;AACD,GAL2B,CAQ5B;AACA;AACA;;;AACA,MAAIE,SAAS,GAAGF,GAAG,CAACG,MAApB;AACA,MAAIC,KAAK,GAAGC,IAAI,CAACC,IAAL,CAAUJ,SAAS,GAAG,CAAtB,CAAZ;AACA,MAAIK,MAAM,GAAGT,aAAa,CAACE,GAAG,CAACC,SAAJ,CAAc,CAAd,EAAiBC,SAAjB,CAAD,EAA8BP,KAA9B,CAA1B,CAb4B,CAe5B;AACA;AACA;AACA;AACA;;AACA,MAAIa,MAAJ;;AACA,SAAOD,MAAM,KAAKA,MAAM,GAAG,CAAT,IAAcH,KAAK,GAAG,CAA3B,CAAb,EAA4C;AAC1CF,IAAAA,SAAS,GAAGK,MAAM,GAAG,CAAT,GAAaL,SAAS,GAAGE,KAAzB,GAAiCF,SAAS,GAAGE,KAAzD;AACAI,IAAAA,MAAM,GAAGR,GAAG,CAACC,SAAJ,CAAc,CAAd,EAAiBC,SAAjB,CAAT;AACAK,IAAAA,MAAM,GAAGT,aAAa,CAACU,MAAD,EAASb,KAAT,CAAtB;AACAS,IAAAA,KAAK,GAAGC,IAAI,CAACC,IAAL,CAAUF,KAAK,GAAG,CAAlB,CAAR;AACD;;AAED,SAAOI,MAAP;AACD;;AAEDC,MAAM,CAACC,OAAP,CAAejB,aAAf,GAA+BA,aAA/B;AACAgB,MAAM,CAACC,OAAP,CAAeZ,aAAf,GAA+BA,aAA/B;AACAW,MAAM,CAACC,OAAP,CAAeX,QAAf,GAA0BA,QAA1B","sourcesContent":["'use strict'\n\n/**\n * Checks if a given string is within agent attribute limits.\n *\n * @param {string} str - Object key name or value\n * @param {number} limit - String byte limit\n */\nfunction isValidLength(str, limit) {\n  return Buffer.byteLength(str, 'utf8') <= limit\n}\n\n/**\n * Returns the relative position of the end of the string (in bytes) and the limit.\n * >1 if the string is longer than the limit\n * 0 if the string is at the limit\n * <1 if the string is shorter than the limit\n *\n * @param {string} str\n * @param {number} limit - String byte limit\n */\nfunction compareLength(str, limit) {\n  return Buffer.byteLength(str) - limit\n}\n\n/**\n * Trims a string value to given byte limit, if necessary.\n *\n * @private\n *\n * @param {string} val - The value to truncate to given byte limit.\n * @param {number} limit - The byte limit\n *\n * @return {string} The truncated value.\n */\nfunction truncate(val, limit) {\n  // First truncation handles the simple case of only one-byte characters.\n  val = val.substring(0, limit)\n  if (isValidLength(val, limit)) {\n    return val\n  }\n\n\n  // Our limitation is on byte length, and the string could contain multi-byte\n  // characters. Doing a byte-substring could chop a character in half. Instead\n  // we do a binary search over the byte length of the substrings.\n  var substrLen = val.length\n  var delta = Math.ceil(substrLen / 2)\n  var cmpVal = compareLength(val.substring(0, substrLen), limit)\n\n  // Continue the binary search till:\n  // 1) The string is the desired length (i.e. cmpVal = 0) OR\n  // 2) The desired string must split a character to acheive the desired byte length\n  //    In this case, we should cut the character that would be split.\n  //    (i.e. delta > 1 character OR the string is larger than the limit)\n  var substr\n  while (cmpVal && (cmpVal > 0 || delta > 1)) {\n    substrLen = cmpVal < 0 ? substrLen + delta : substrLen - delta\n    substr = val.substring(0, substrLen)\n    cmpVal = compareLength(substr, limit)\n    delta = Math.ceil(delta / 2)\n  }\n\n  return substr\n}\n\nmodule.exports.isValidLength = isValidLength\nmodule.exports.compareLength = compareLength\nmodule.exports.truncate = truncate\n"]},"metadata":{},"sourceType":"script"}