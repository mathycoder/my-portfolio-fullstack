{"ast":null,"code":"'use strict';\n\nconst dbutil = require('../db/utils');\n\nconst hasOwnProperty = require('../util/properties').hasOwn;\n\nconst logger = require('../logger').child({\n  component: 'DatastoreShim'\n});\n\nconst metrics = require('../metrics/names');\n\nconst parseSql = require('../db/query-parsers/sql');\n\nconst ParsedStatement = require('../db/parsed-statement');\n\nconst Shim = require('./shim');\n\nconst urltils = require('../util/urltils');\n\nconst util = require('util');\n/**\n * An enumeration of well-known datastores so that new instrumentations can use\n * the same names we already use for first-party instrumentation.\n *\n * Each of these values is also exposed directly on the DatastoreShim class as\n * static members.\n *\n * @readonly\n * @memberof DatastoreShim\n * @enum {string}\n */\n\n\nconst DATASTORE_NAMES = {\n  CASSANDRA: 'Cassandra',\n  DYNAMODB: 'DynamoDB',\n  MEMCACHED: 'Memcache',\n  MONGODB: 'MongoDB',\n  MYSQL: 'MySQL',\n  NEPTUNE: 'Neptune',\n  POSTGRES: 'Postgres',\n  REDIS: 'Redis'\n};\n/**\n * Default value for unknown instance parameters.\n *\n * @readonly\n * @private\n */\n\nconst INSTANCE_UNKNOWN = 'unknown';\nconst defaultParsers = {\n  'SQL': parseSql\n};\n/**\n * Pre-defined query parsers for well-known languages.\n *\n * Each of these values is also exposed directly on the DatastoreShim class as\n * static members.\n *\n * @readonly\n * @memberof DatastoreShim\n * @enum {string}\n */\n\nconst QUERY_PARSERS = {\n  SQL_PARSER: 'SQL'\n};\n/**\n * Constructs a shim associated with the given agent instance, specialized for\n * instrumenting datastores.\n *\n * @constructor\n * @extends Shim\n * @classdesc\n *  A helper class for wrapping datastore modules.\n *\n * @param {Agent} agent\n *  The agent this shim will use.\n *\n * @param {string} moduleName\n *  The name of the module being instrumented.\n *\n * @param {string} resolvedName\n *  The full path to the loaded module.\n *\n * @param {string} [datastoreId]\n *  The name of the datastore being instrumented. If available, use one of the\n *  values from {@link DatastoreShim.DATASTORE_NAMES}.\n *  Calls {@link DatastoreShim#setDatastore} if datastoreId is\n *  specified.\n *\n * @see Shim\n * @see DatastoreShim.DATASTORE_NAMES\n */\n\nfunction DatastoreShim(agent, moduleName, resolvedName, datastoreId) {\n  Shim.call(this, agent, moduleName, resolvedName);\n  this._logger = logger.child({\n    module: moduleName\n  });\n\n  if (datastoreId) {\n    this.setDatastore(datastoreId);\n  }\n\n  this.queryParser = defaultParsers[this.SQL_PARSER];\n}\n\nmodule.exports = DatastoreShim;\nutil.inherits(DatastoreShim, Shim); // Add constants on the shim for the well-known datastores.\n\nDatastoreShim.DATASTORE_NAMES = DATASTORE_NAMES;\nObject.keys(DATASTORE_NAMES).forEach(function defineDatastoreMetricEnum(dsName) {\n  Shim.defineProperty(DatastoreShim, dsName, DATASTORE_NAMES[dsName]);\n  Shim.defineProperty(DatastoreShim.prototype, dsName, DATASTORE_NAMES[dsName]);\n}); // Add constants on the shim for the provided query parsers.\n\nDatastoreShim.QUERY_PARSERS = QUERY_PARSERS;\nObject.keys(QUERY_PARSERS).forEach(function defineQueryParserEnum(qpName) {\n  Shim.defineProperty(DatastoreShim, qpName, QUERY_PARSERS[qpName]);\n  Shim.defineProperty(DatastoreShim.prototype, qpName, QUERY_PARSERS[qpName]);\n});\nDatastoreShim.prototype.setDatastore = setDatastore;\nDatastoreShim.prototype.recordOperation = recordOperation;\nDatastoreShim.prototype.recordQuery = recordQuery;\nDatastoreShim.prototype.recordBatchQuery = recordBatchQuery;\nDatastoreShim.prototype.parseQuery = parseQuery;\nDatastoreShim.prototype.setParser = setParser;\nDatastoreShim.prototype.bindRowCallbackSegment = bindRowCallbackSegment;\nDatastoreShim.prototype.captureInstanceAttributes = captureInstanceAttributes;\nDatastoreShim.prototype.getDatabaseNameFromUseQuery = getDatabaseNameFromUseQuery; // -------------------------------------------------------------------------- //\n\n/**\n * @callback QuerySpecFunction\n *\n * @summary\n *  Used for determining information about a query when it can not be simply\n *  found in the arguments.\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Function} func\n *  The function being recorded.\n *\n * @param {string} name\n *  The name of the function.\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the function.\n *\n * @return {QuerySpec} The spec for how this query should be recorded.\n *\n * @see DatastoreShim#recordQuery\n * @see DatastoreShim#recordBatchQuery\n * @see QuerySpec\n */\n\n/**\n * @callback QueryFunction\n *\n * @summary\n *  Pulls the query argument out from an array of arguments.\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Function} func\n *  The function being recorded.\n *\n * @param {string} name\n *  The name of the function.\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the function.\n *\n * @return {string} The query string from the arguments list.\n *\n * @see QuerySpec\n * @see QuerySpecFunction\n */\n\n/**\n * @callback QueryParserFunction\n *\n * @summary\n *  Used to parse queries to extract the basic information about it.\n *\n * @param {string} query - The query to be parsed.\n *\n * @return {ParsedQueryData} An object containing the basic information about\n *  the query.\n *\n * @see DatastoreShim#setParser\n * @see ParsedQueryData\n */\n\n/**\n * @interface OperationSpec\n *\n * @description\n *  Describes the interface for an operation function.\n *\n * @property {string} [name]\n *  The name for this operation. If omitted, the operation function's name will\n *  used instead.\n *\n * @property {DatastoreParameters} [parameters]\n *  Extra parameters to be set on the metric for the operation.\n *\n * @property {bool} [record=true]\n *  Indicates if the operation should be recorded as a metric. A segment will be\n *  created even if this is `false`.\n *\n * @property {number|CallbackBindFunction} [callback]\n *  If a number, it is the offset in the arguments array for the operation's\n *  callback argument. If it is a function, it should perform the segment\n *  binding to the callback.\n *\n * @property {bool} [promise=false]\n *  If `true`, the return value will be wrapped as a Promise.\n *\n * @see DatastoreShim#recordOperation\n * @see QuerySpec\n * @see DatastoreParameters\n */\n\n/**\n * @interface QuerySpec\n * @extends OperationSpec\n *\n * @description\n *  Describes the interface for a query function. Extends {@link OperationSpec}\n *  with query-specific parameters.\n *\n * @property {bool} [stream=false]\n *  If `true`, the return value will be wrapped as a stream.\n *\n * @property {number|string|QueryFunction} query\n *  If a number, it is the offset in the arguments array for the query string\n *  argument. If a string, it is the query being executed. If a function, it\n *  will be passed the arguments and must return the query string.\n *\n * @see DatastoreShim#recordQuery\n * @see DatastoreShim#recordBatchQuery\n * @see QuerySpecFunction\n * @see QueryFunction\n * @see OperationSpec\n * @see DatastoreParameters\n */\n\n/**\n * @interface DatastoreParameters\n *\n * @description\n *  Extra parameters which may be added to an operation or query segment. All of\n *  these properties are optional.\n *\n * @property {string} host\n *  The host of the database server being interacted with. If provided, along\n *  with `port_path_or_id`, then an instance metric will also be generated for\n *  this database.\n *\n * @property {number|string} port_path_or_id\n *  The port number or path to domain socket used to connect to the database\n *  server.\n *\n * @property {string} database_name\n *  The name of the database being queried or operated on.\n *\n * @see OperationSpec\n * @see QuerySpec\n */\n\n/**\n * @interface ParsedQueryData\n *\n * @description\n *  Returned by a {@link QueryParserFunction}, this information is used to\n *  generate the name for recording datastore queries.\n *\n * @property {string} operation\n *  The datastore operation such as `SELECT` or `UPDATE`.\n *\n * @property {string} collection\n *  The collection being queried. This would be the table name from a SQL\n *  statement or the collection name in a MongoDB query.\n *\n * @property {string} [query]\n *  The query with any sensitive information redacted and comments removed.\n *\n * @see DatastoreShim#setParser\n * @see QueryParserFunction\n */\n// -------------------------------------------------------------------------- //\n\n/**\n * Sets the vendor the module implements.\n *\n * This is used to determine the names for metrics and segments. If a string is\n * passed, metric names will be generated using that name.\n *\n * This method *MUST* be called to use any methods that generate\n * segments or metrics.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {string} datastore\n *  The name of this datastore. Use one of the well-known constants listed in\n *  {@link DatastoreShim.DATASTORE_NAMES} if available for the datastore.\n *\n * @see DatastoreShim.DATASTORE_NAMES\n * @see DatastoreShim#recordBatchQuery\n * @see DatastoreShim#recordQuery\n * @see DatastoreShim#recordOperation\n * @see DatastoreShim#parseQuery\n */\n\nfunction setDatastore(datastore) {\n  this._metrics = {\n    PREFIX: datastore,\n    STATEMENT: metrics.DB.STATEMENT + '/' + datastore + '/',\n    OPERATION: metrics.DB.OPERATION + '/' + datastore + '/',\n    INSTANCE: metrics.DB.INSTANCE + '/' + datastore + '/',\n    ALL: metrics.DB.PREFIX + datastore + '/' + metrics.ALL\n  };\n  this._datastore = datastore;\n  this._logger = this._logger.child({\n    datastore: this._metrics.PREFIX\n  });\n  this.logger.trace({\n    metrics: this._metrics\n  }, 'Datastore metric names set');\n}\n/**\n * Sets the query parser used by this shim instance.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {string|QueryParserFunction} parser\n *  The string used to look up a default parser or the function used to parse\n *  queries. It is recommended that you use one of the well-known constants if\n *  available in the {@link DatastoreShim.QUERY_PARSERS}.\n *\n * @see DatastoreShim.QUERY_PARSERS\n * @see QueryParserFunction\n * @see ParsedQueryData\n */\n\n\nfunction setParser(parser) {\n  if (this.isString(parser)) {\n    var newParser = defaultParsers[parser];\n\n    if (newParser) {\n      this.queryParser = newParser;\n    } else {\n      this.logger.debug('Attempted to set the query parser to invalid parser %s, not setting new parser', parser);\n    }\n  } else if (this.isFunction(parser)) {\n    this.queryParser = parser;\n  } else {\n    this.logger.trace(\"Received invalid parser (%s)\", parser);\n  }\n}\n/**\n * Wraps the given properties as datastore operations that should be recorded.\n *\n * - `recordOperation(nodule, properties, opSpec)`\n * - `recordOperation(func, opSpec)`\n *\n * The resulting wrapped methods will record their actions using the datastore\n * `OPERATION` metric.\n *\n * NOTE: Calling this method before {@link DatastoreShim#setDatastore}\n * will result in an exception.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {OperationSpec|SegmentFunction} opSpec\n *  The spec for this operation function.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see OperationSpec\n * @see SegmentFunction\n */\n\n\nfunction recordOperation(nodule, properties, opSpec) {\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // operation(func, opSpec)\n    opSpec = properties;\n    properties = null;\n  }\n\n  if (!opSpec) {\n    opSpec = Object.create(null);\n  }\n\n  return this.record(nodule, properties, function opRecorder(shim, fn, fnName, args) {\n    shim.logger.trace('Recording datastore operation \"%s\"', fnName); // Derive the segment information.\n\n    var segDesc = null;\n\n    if (shim.isFunction(opSpec)) {\n      segDesc = opSpec.call(this, shim, fn, fnName, args);\n    } else {\n      segDesc = {\n        name: opSpec.name || fnName || 'other',\n        parameters: opSpec.parameters,\n        callback: opSpec.callback,\n        after: 'after' in opSpec ? opSpec.after : null,\n        promise: 'promise' in opSpec ? opSpec.promise : null,\n        record: opSpec.record,\n        opaque: opSpec.opaque || false\n      };\n    }\n\n    if (hasOwnProperty(segDesc, 'parameters')) {\n      _normalizeParameters.call(shim, segDesc.parameters);\n    } // Adjust the segment name with the metric prefix and add a recorder.\n\n\n    if (!hasOwnProperty(segDesc, 'record') || segDesc.record !== false) {\n      segDesc.name = shim._metrics.OPERATION + segDesc.name;\n      segDesc.recorder = _recordOperationMetrics.bind(shim);\n      segDesc.internal = true;\n    } // And done.\n\n\n    return segDesc;\n  });\n}\n/**\n * Wraps the given properties as datastore query that should be recorded.\n *\n * - `recordQuery(nodule, properties, querySpec)`\n * - `recordQuery(func, querySpec)`\n *\n * The resulting wrapped methods will record their actions using the datastore\n * `STATEMENT` metric.\n *\n * NOTE: Calling this method before {@link DatastoreShim#setDatastore}\n * will result in an exception.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {QuerySpec|QuerySpecFunction} querySpec\n *  The spec for this query function.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see DatastoreShim#recordBatchQuery\n * @see QuerySpec\n * @see QuerySpecFunction\n */\n\n\nfunction recordQuery(nodule, properties, querySpec) {\n  return _recordQuery.call(this, '', nodule, properties, querySpec);\n}\n/**\n * Just like {@link DatastoreShim#recordQuery}, but with a `batch` suffix for\n * the recorded metric.\n *\n * - `recordBatchQuery(nodule, properties, querySpec)`\n * - `recordBatchQuery(func, querySpec)`\n *\n * The resulting wrapped methods will record their actions using the datastore\n * `STATEMENT` metric with a `/batch` suffix.\n *\n * NOTE: Calling this method before {@link DatastoreShim#setDatastore}\n * will result in an exception.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {QuerySpec|QuerySpecFunction} querySpec\n *  The spec for this query function.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see DatastoreShim#recordQuery\n * @see QuerySpec\n * @see QuerySpecFunction\n */\n\n\nfunction recordBatchQuery(nodule, properties, querySpec) {\n  return _recordQuery.call(this, '/batch', nodule, properties, querySpec);\n}\n/**\n * Parses the given query to extract information for any metrics that will be\n * created.\n *\n * NOTE: Calling this method before {@link DatastoreShim#setDatastore}\n * will result in an exception.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {string} query - The query to parse.\n *\n * @param {Object} nodule - Context for the queryParse to run under.\n *\n * @return {ParsedStatement} The parsed query object.\n *\n * @see DatastoreShim#setParser\n */\n\n\nfunction parseQuery(query, nodule) {\n  var parsed = this.queryParser.call(nodule, query);\n  var collection = parsed.collection; // strip enclosing special characters from collection (table) name\n\n  if (typeof collection === 'string' && collection.length > 2) {\n    if (/^[\\[{'\"`]/.test(collection)) {\n      collection = collection.substr(1);\n    }\n\n    if (/[\\]}'\"`]$/.test(collection)) {\n      collection = collection.substr(0, collection.length - 1);\n    }\n  }\n\n  var queryRecorded = this.agent.config.transaction_tracer.record_sql === 'raw' || this.agent.config.transaction_tracer.record_sql === 'obfuscated';\n  return new ParsedStatement(this._metrics.PREFIX, parsed.operation, collection, queryRecorded ? parsed.query : null);\n}\n/**\n * Wraps the callback in an arguments array with one that is bound to a segment.\n *\n * - `bindRowCallbackSegment(args, cbIdx [, parentSegment])`\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {Array} args\n *  The arguments array to replace the callback in.\n *\n * @param {Number} cbIdx\n *  The index of the callback in the arguments array.\n *\n * @param {TraceSegment} [parentSegment]\n *  Optional. The segment to be the parent row callback's segment. Defaults to\n *  the segment active when the row callback is first called.\n */\n\n\nfunction bindRowCallbackSegment(args, cbIdx, parentSegment) {\n  var idx = this.normalizeIndex(args.length, cbIdx);\n\n  if (idx === null) {\n    this.logger.debug('Not binding row callback, invalid cbIdx %s', cbIdx);\n    return;\n  } // Pull out the callback and make sure it is a function.\n\n\n  var cb = args[idx];\n\n  if (!this.isFunction(cb)) {\n    this.logger.debug('Argument %d is not a function, not binding row callback', cbIdx);\n    return cb;\n  }\n\n  this.logger.trace('Wrapping argument %d as a row callback.', cbIdx); // We have a little state to maintain through potentially multiple calls.\n\n  var callCounter = 0;\n  var segment = null;\n  var segmentName = 'Callback: ' + this.getName(cb);\n  var shim = this;\n  var wrapper = this.bindSegment(function rowCallbackWrapper() {\n    // The first time this row callback is fired we want to touch the parent\n    // segment and create the callback segment.\n    if (++callCounter === 1) {\n      var realParent = parentSegment || shim.getSegment();\n      realParent && realParent.touch();\n      segment = shim.createSegment(segmentName, realParent);\n\n      if (segment) {\n        segment.async = false;\n      }\n    } // Update the segment name and run the actual callback.\n\n\n    if (segment) {\n      segment.addAttribute('count', callCounter);\n    }\n\n    return shim.applySegment(cb, segment, true, this, arguments);\n  }, parentSegment); // Mark this as wrapped and put it in the args array.\n\n  this.setInternalProperty(wrapper, '__NR_original', cb);\n  args[idx] = wrapper;\n}\n/**\n * Normalizes and adds datastore instance attributes to the current segment.\n *\n * If the current segment was not created by this shim then no action is taken.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {string}        host      - The name of the database host.\n * @param {number|string} port      - The port, path, or ID of the database server.\n * @param {string}        database  - The name of the database in use.\n */\n\n\nfunction captureInstanceAttributes(host, port, database) {\n  // See if we are currently in a segment created by us.\n  var segment = this.getSegment();\n\n  if (!segment || segment.shim !== this) {\n    this.logger.trace('Not adding db instance metric attributes to segment %j', segment && segment.name);\n    return;\n  }\n\n  this.logger.trace('Adding db instance attributes to segment %j', segment.name); // Normalize the instance attributes.\n\n  var attributes = _normalizeParameters.call(this, {\n    host,\n    port_path_or_id: port,\n    database_name: database\n  });\n\n  for (let key in attributes) {\n    if (attributes[key]) {\n      segment.addAttribute(key, attributes[key]);\n    }\n  }\n}\n/**\n * Parses the database name from a `USE` SQL query.\n *\n * @param {string} query - The SQL query to parse the database name from.\n *\n * @return {?string} The name of the database if it could be parsed, otherwise\n *  `null`.\n */\n\n\nfunction getDatabaseNameFromUseQuery(query) {\n  return dbutil.extractDatabaseChangeFromUse(query);\n} // -------------------------------------------------------------------------- //\n\n/**\n * Wraps the given properties as datastore query that should be recorded.\n *\n * - `_recordQuery(suffix, nodule, properties, querySpec)`\n * - `_recordQuery(suffix, func, querySpec)`\n *\n * The resulting wrapped methods will record their actions using the datastore\n * `STATEMENT` metric.\n *\n * @private\n * @this DatastoreShim\n *\n * @param {string} suffix\n *  Suffix to be added to the segment name.\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {QuerySpec|QueryFunction} querySpec\n *  The spec for this query function.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see DatastoreShim#recordQuery\n * @see DatastoreShim#recordBatchQuery\n * @see QuerySpec\n * @see QuerySpecFunction\n */\n\n\nfunction _recordQuery(suffix, nodule, properties, querySpec) {\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // _recordQuery(suffix, func, querySpec)\n    querySpec = properties;\n    properties = null;\n  }\n\n  if (!querySpec) {\n    this.logger.debug('Missing query spec for recordQuery, not wrapping.');\n    return nodule;\n  }\n\n  return this.record(nodule, properties, function queryRecord(shim, fn, fnName, args) {\n    shim.logger.trace('Determining query information for %j', fnName);\n    var queryDesc = querySpec;\n\n    if (shim.isFunction(querySpec)) {\n      queryDesc = querySpec.call(this, shim, fn, fnName, args);\n    } // If we're not actually recording this, then just return the segment\n    // descriptor now.\n\n\n    if (hasOwnProperty(queryDesc, 'record') && queryDesc.record === false) {\n      var parameters = _normalizeParameters.call(shim, queryDesc.parameters || Object.create(null));\n\n      return {\n        name: queryDesc.name || fnName,\n        parameters,\n        callback: 'callback' in queryDesc ? queryDesc.callback : null,\n        rowCallback: 'rowCallback' in queryDesc ? queryDesc.rowCallback : null,\n        stream: 'stream' in queryDesc ? queryDesc.stream : null,\n        after: 'after' in queryDesc ? queryDesc.after : null,\n        promise: 'promise' in queryDesc ? queryDesc.promise : null,\n        internal: 'internal' in queryDesc ? queryDesc.internal : false,\n        opaque: 'opaque' in queryDesc ? queryDesc.opaque : false\n      };\n    } // Fetch the query string.\n\n\n    var queryStr = _extractQueryStr.call(shim, fn, fnName, queryDesc, this, args);\n\n    if (!shim.isString(queryStr)) {\n      return null;\n    } // Parse the query and assemble the name.\n\n\n    var parsed = shim.parseQuery(queryStr, this);\n    var name = (parsed.collection || 'other') + '/' + parsed.operation + suffix;\n    shim.logger.trace('Found and parsed query %s -> %s', parsed.type, name); // Return the segment descriptor.\n\n    var parameters = _normalizeParameters.call(shim, queryDesc.parameters || Object.create(null));\n\n    return {\n      name: shim._metrics.STATEMENT + name,\n      parameters: parameters,\n      callback: 'callback' in queryDesc ? queryDesc.callback : null,\n      rowCallback: 'rowCallback' in queryDesc ? queryDesc.rowCallback : null,\n      stream: 'stream' in queryDesc ? queryDesc.stream : null,\n      after: 'after' in queryDesc ? queryDesc.after : null,\n      promise: 'promise' in queryDesc ? queryDesc.promise : null,\n      internal: 'internal' in queryDesc ? queryDesc.internal : true,\n      opaque: 'opaque' in queryDesc ? queryDesc.opaque : false,\n      recorder: function queryRecorder(segment, scope) {\n        if (segment) {\n          parsed.recordMetrics(segment, scope);\n        }\n      }\n    };\n  });\n}\n/**\n * Records all the metrics required for database operations.\n *\n * - `_recordOperationMetrics(segment [, scope])`\n *\n * @private\n * @this DatastoreShim\n * @implements {MetricFunction}\n *\n * @param {TraceSegment}  segment - The segment being recorded.\n * @param {string}        [scope] - The scope of the segment.\n *\n * @see DatastoreShim#recordOperation\n * @see MetricFunction\n */\n\n\nfunction _recordOperationMetrics(segment, scope) {\n  if (!segment) {\n    return;\n  }\n\n  var duration = segment.getDurationInMillis();\n  var exclusive = segment.getExclusiveDurationInMillis();\n  var transaction = segment.transaction;\n  var type = transaction.isWeb() ? 'allWeb' : 'allOther';\n  var operation = segment.name;\n\n  if (scope) {\n    transaction.measure(operation, scope, duration, exclusive);\n  }\n\n  transaction.measure(operation, null, duration, exclusive);\n  transaction.measure(metrics.DB.PREFIX + type, null, duration, exclusive);\n  transaction.measure(metrics.DB.ALL, null, duration, exclusive);\n  transaction.measure(this._metrics.ALL, null, duration, exclusive);\n  transaction.measure(metrics.DB.PREFIX + this._metrics.PREFIX + '/' + type, null, duration, exclusive);\n  const attributes = segment.getAttributes();\n\n  if (attributes.host && attributes.port_path_or_id) {\n    const instanceName = [metrics.DB.INSTANCE, this._metrics.PREFIX, attributes.host, attributes.port_path_or_id].join('/');\n    transaction.measure(instanceName, null, duration, exclusive);\n  }\n}\n/**\n * Extracts the query string from the arguments according to the given spec.\n *\n * - `_extractQueryStr(fn, fnName, spec, ctx, args)`\n *\n * @private\n * @this DatastoreShim\n *\n * @param {Function}  fn      - The query function to be executed.\n * @param {string}    fnName  - The name of the query function.\n * @param {QuerySpec} spec    - The query spec.\n * @param {*}         ctx     - The context of the query function's execution.\n * @param {Array}     args    - The arguments for the query function.\n *\n * @return {?string} The query from the arguments if found, otherwise `null`.\n */\n\n\nfunction _extractQueryStr(fn, fnName, spec, ctx, args) {\n  var queryStr = spec.query;\n\n  if (this.isNumber(queryStr)) {\n    var queryIdx = this.normalizeIndex(args.length, queryStr);\n\n    if (queryIdx === null) {\n      this.logger.debug('Invalid query index %d of %d', queryStr, args.length);\n      return null;\n    }\n\n    queryStr = args[queryIdx];\n  } else if (this.isFunction(queryStr)) {\n    queryStr = queryStr.call(ctx, this, fn, fnName, args);\n  }\n\n  return queryStr;\n}\n/**\n * Normalizes segment parameter values.\n *\n * - `_normalizeParameters([parameters])`\n *\n * Removes disabled parameters and corrects other values, such as changing host\n * from `localhost` to the actual host name.\n *\n * @private\n * @this DatastoreShim\n *\n * @param {object} [parameters={}] - The segment parameters to clean up.\n *\n * @return {object} - The normalized segment parameters.\n */\n\n\nfunction _normalizeParameters(parameters) {\n  parameters = parameters || Object.create(null);\n  var config = this.agent.config;\n  var dsTracerConf = config.datastore_tracer;\n  parameters.product = parameters.product || this._datastore; // Add database name if provided and enabled.\n\n  if (!dsTracerConf.database_name_reporting.enabled) {\n    delete parameters.database_name;\n  } else if (hasOwnProperty(parameters, 'database_name') && parameters.database_name !== false) {\n    parameters.database_name = typeof parameters.database_name === 'number' ? String(parameters.database_name) : parameters.database_name || INSTANCE_UNKNOWN;\n  } // Add instance information if enabled.\n\n\n  if (!dsTracerConf.instance_reporting.enabled) {\n    delete parameters.host;\n    delete parameters.port_path_or_id;\n  } else {\n    // Determine appropriate defaults for host and port.\n    if (hasOwnProperty(parameters, 'port_path_or_id')) {\n      parameters.port_path_or_id = String(parameters.port_path_or_id || INSTANCE_UNKNOWN);\n    }\n\n    if (hasOwnProperty(parameters, 'host')) {\n      if (parameters.host && urltils.isLocalhost(parameters.host)) {\n        parameters.host = config.getHostnameSafe(parameters.host);\n      } // Config's default name of a host is `UNKNOWN_BOX`.\n\n\n      if (!parameters.host || parameters.host === 'UNKNOWN_BOX') {\n        parameters.host = INSTANCE_UNKNOWN;\n      }\n    }\n  }\n\n  return parameters;\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/shim/datastore-shim.js"],"names":["dbutil","require","hasOwnProperty","hasOwn","logger","child","component","metrics","parseSql","ParsedStatement","Shim","urltils","util","DATASTORE_NAMES","CASSANDRA","DYNAMODB","MEMCACHED","MONGODB","MYSQL","NEPTUNE","POSTGRES","REDIS","INSTANCE_UNKNOWN","defaultParsers","QUERY_PARSERS","SQL_PARSER","DatastoreShim","agent","moduleName","resolvedName","datastoreId","call","_logger","module","setDatastore","queryParser","exports","inherits","Object","keys","forEach","defineDatastoreMetricEnum","dsName","defineProperty","prototype","defineQueryParserEnum","qpName","recordOperation","recordQuery","recordBatchQuery","parseQuery","setParser","bindRowCallbackSegment","captureInstanceAttributes","getDatabaseNameFromUseQuery","datastore","_metrics","PREFIX","STATEMENT","DB","OPERATION","INSTANCE","ALL","_datastore","trace","parser","isString","newParser","debug","isFunction","nodule","properties","opSpec","isObject","isArray","create","record","opRecorder","shim","fn","fnName","args","segDesc","name","parameters","callback","after","promise","opaque","_normalizeParameters","recorder","_recordOperationMetrics","bind","internal","querySpec","_recordQuery","query","parsed","collection","length","test","substr","queryRecorded","config","transaction_tracer","record_sql","operation","cbIdx","parentSegment","idx","normalizeIndex","cb","callCounter","segment","segmentName","getName","wrapper","bindSegment","rowCallbackWrapper","realParent","getSegment","touch","createSegment","async","addAttribute","applySegment","arguments","setInternalProperty","host","port","database","attributes","port_path_or_id","database_name","key","extractDatabaseChangeFromUse","suffix","queryRecord","queryDesc","rowCallback","stream","queryStr","_extractQueryStr","type","queryRecorder","scope","recordMetrics","duration","getDurationInMillis","exclusive","getExclusiveDurationInMillis","transaction","isWeb","measure","getAttributes","instanceName","join","spec","ctx","isNumber","queryIdx","dsTracerConf","datastore_tracer","product","database_name_reporting","enabled","String","instance_reporting","isLocalhost","getHostnameSafe"],"mappings":"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","sourcesContent":["'use strict'\n\nconst dbutil = require('../db/utils')\nconst hasOwnProperty = require('../util/properties').hasOwn\nconst logger = require('../logger').child({component: 'DatastoreShim'})\nconst metrics = require('../metrics/names')\nconst parseSql = require('../db/query-parsers/sql')\nconst ParsedStatement = require('../db/parsed-statement')\nconst Shim = require('./shim')\nconst urltils = require('../util/urltils')\nconst util = require('util')\n\n\n/**\n * An enumeration of well-known datastores so that new instrumentations can use\n * the same names we already use for first-party instrumentation.\n *\n * Each of these values is also exposed directly on the DatastoreShim class as\n * static members.\n *\n * @readonly\n * @memberof DatastoreShim\n * @enum {string}\n */\nconst DATASTORE_NAMES = {\n  CASSANDRA: 'Cassandra',\n  DYNAMODB: 'DynamoDB',\n  MEMCACHED: 'Memcache',\n  MONGODB: 'MongoDB',\n  MYSQL: 'MySQL',\n  NEPTUNE: 'Neptune',\n  POSTGRES: 'Postgres',\n  REDIS: 'Redis'\n}\n\n/**\n * Default value for unknown instance parameters.\n *\n * @readonly\n * @private\n */\nconst INSTANCE_UNKNOWN = 'unknown'\n\nconst defaultParsers = {\n  'SQL': parseSql\n}\n\n/**\n * Pre-defined query parsers for well-known languages.\n *\n * Each of these values is also exposed directly on the DatastoreShim class as\n * static members.\n *\n * @readonly\n * @memberof DatastoreShim\n * @enum {string}\n */\nconst QUERY_PARSERS = {\n  SQL_PARSER: 'SQL'\n}\n\n/**\n * Constructs a shim associated with the given agent instance, specialized for\n * instrumenting datastores.\n *\n * @constructor\n * @extends Shim\n * @classdesc\n *  A helper class for wrapping datastore modules.\n *\n * @param {Agent} agent\n *  The agent this shim will use.\n *\n * @param {string} moduleName\n *  The name of the module being instrumented.\n *\n * @param {string} resolvedName\n *  The full path to the loaded module.\n *\n * @param {string} [datastoreId]\n *  The name of the datastore being instrumented. If available, use one of the\n *  values from {@link DatastoreShim.DATASTORE_NAMES}.\n *  Calls {@link DatastoreShim#setDatastore} if datastoreId is\n *  specified.\n *\n * @see Shim\n * @see DatastoreShim.DATASTORE_NAMES\n */\nfunction DatastoreShim(agent, moduleName, resolvedName, datastoreId) {\n  Shim.call(this, agent, moduleName, resolvedName)\n  this._logger = logger.child({module: moduleName})\n  if (datastoreId) {\n    this.setDatastore(datastoreId)\n  }\n  this.queryParser = defaultParsers[this.SQL_PARSER]\n}\nmodule.exports = DatastoreShim\n\nutil.inherits(DatastoreShim, Shim)\n\n// Add constants on the shim for the well-known datastores.\nDatastoreShim.DATASTORE_NAMES = DATASTORE_NAMES\nObject.keys(DATASTORE_NAMES).forEach(function defineDatastoreMetricEnum(dsName) {\n  Shim.defineProperty(DatastoreShim, dsName, DATASTORE_NAMES[dsName])\n  Shim.defineProperty(DatastoreShim.prototype, dsName, DATASTORE_NAMES[dsName])\n})\n\n// Add constants on the shim for the provided query parsers.\nDatastoreShim.QUERY_PARSERS = QUERY_PARSERS\nObject.keys(QUERY_PARSERS).forEach(function defineQueryParserEnum(qpName) {\n  Shim.defineProperty(DatastoreShim, qpName, QUERY_PARSERS[qpName])\n  Shim.defineProperty(DatastoreShim.prototype, qpName, QUERY_PARSERS[qpName])\n})\n\nDatastoreShim.prototype.setDatastore = setDatastore\nDatastoreShim.prototype.recordOperation = recordOperation\nDatastoreShim.prototype.recordQuery = recordQuery\nDatastoreShim.prototype.recordBatchQuery = recordBatchQuery\nDatastoreShim.prototype.parseQuery = parseQuery\nDatastoreShim.prototype.setParser = setParser\nDatastoreShim.prototype.bindRowCallbackSegment = bindRowCallbackSegment\nDatastoreShim.prototype.captureInstanceAttributes = captureInstanceAttributes\nDatastoreShim.prototype.getDatabaseNameFromUseQuery = getDatabaseNameFromUseQuery\n\n// -------------------------------------------------------------------------- //\n\n/**\n * @callback QuerySpecFunction\n *\n * @summary\n *  Used for determining information about a query when it can not be simply\n *  found in the arguments.\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Function} func\n *  The function being recorded.\n *\n * @param {string} name\n *  The name of the function.\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the function.\n *\n * @return {QuerySpec} The spec for how this query should be recorded.\n *\n * @see DatastoreShim#recordQuery\n * @see DatastoreShim#recordBatchQuery\n * @see QuerySpec\n */\n\n/**\n * @callback QueryFunction\n *\n * @summary\n *  Pulls the query argument out from an array of arguments.\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Function} func\n *  The function being recorded.\n *\n * @param {string} name\n *  The name of the function.\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the function.\n *\n * @return {string} The query string from the arguments list.\n *\n * @see QuerySpec\n * @see QuerySpecFunction\n */\n\n/**\n * @callback QueryParserFunction\n *\n * @summary\n *  Used to parse queries to extract the basic information about it.\n *\n * @param {string} query - The query to be parsed.\n *\n * @return {ParsedQueryData} An object containing the basic information about\n *  the query.\n *\n * @see DatastoreShim#setParser\n * @see ParsedQueryData\n */\n\n/**\n * @interface OperationSpec\n *\n * @description\n *  Describes the interface for an operation function.\n *\n * @property {string} [name]\n *  The name for this operation. If omitted, the operation function's name will\n *  used instead.\n *\n * @property {DatastoreParameters} [parameters]\n *  Extra parameters to be set on the metric for the operation.\n *\n * @property {bool} [record=true]\n *  Indicates if the operation should be recorded as a metric. A segment will be\n *  created even if this is `false`.\n *\n * @property {number|CallbackBindFunction} [callback]\n *  If a number, it is the offset in the arguments array for the operation's\n *  callback argument. If it is a function, it should perform the segment\n *  binding to the callback.\n *\n * @property {bool} [promise=false]\n *  If `true`, the return value will be wrapped as a Promise.\n *\n * @see DatastoreShim#recordOperation\n * @see QuerySpec\n * @see DatastoreParameters\n */\n\n/**\n * @interface QuerySpec\n * @extends OperationSpec\n *\n * @description\n *  Describes the interface for a query function. Extends {@link OperationSpec}\n *  with query-specific parameters.\n *\n * @property {bool} [stream=false]\n *  If `true`, the return value will be wrapped as a stream.\n *\n * @property {number|string|QueryFunction} query\n *  If a number, it is the offset in the arguments array for the query string\n *  argument. If a string, it is the query being executed. If a function, it\n *  will be passed the arguments and must return the query string.\n *\n * @see DatastoreShim#recordQuery\n * @see DatastoreShim#recordBatchQuery\n * @see QuerySpecFunction\n * @see QueryFunction\n * @see OperationSpec\n * @see DatastoreParameters\n */\n\n/**\n * @interface DatastoreParameters\n *\n * @description\n *  Extra parameters which may be added to an operation or query segment. All of\n *  these properties are optional.\n *\n * @property {string} host\n *  The host of the database server being interacted with. If provided, along\n *  with `port_path_or_id`, then an instance metric will also be generated for\n *  this database.\n *\n * @property {number|string} port_path_or_id\n *  The port number or path to domain socket used to connect to the database\n *  server.\n *\n * @property {string} database_name\n *  The name of the database being queried or operated on.\n *\n * @see OperationSpec\n * @see QuerySpec\n */\n\n/**\n * @interface ParsedQueryData\n *\n * @description\n *  Returned by a {@link QueryParserFunction}, this information is used to\n *  generate the name for recording datastore queries.\n *\n * @property {string} operation\n *  The datastore operation such as `SELECT` or `UPDATE`.\n *\n * @property {string} collection\n *  The collection being queried. This would be the table name from a SQL\n *  statement or the collection name in a MongoDB query.\n *\n * @property {string} [query]\n *  The query with any sensitive information redacted and comments removed.\n *\n * @see DatastoreShim#setParser\n * @see QueryParserFunction\n */\n\n// -------------------------------------------------------------------------- //\n\n/**\n * Sets the vendor the module implements.\n *\n * This is used to determine the names for metrics and segments. If a string is\n * passed, metric names will be generated using that name.\n *\n * This method *MUST* be called to use any methods that generate\n * segments or metrics.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {string} datastore\n *  The name of this datastore. Use one of the well-known constants listed in\n *  {@link DatastoreShim.DATASTORE_NAMES} if available for the datastore.\n *\n * @see DatastoreShim.DATASTORE_NAMES\n * @see DatastoreShim#recordBatchQuery\n * @see DatastoreShim#recordQuery\n * @see DatastoreShim#recordOperation\n * @see DatastoreShim#parseQuery\n */\nfunction setDatastore(datastore) {\n  this._metrics = {\n    PREFIX: datastore,\n    STATEMENT: metrics.DB.STATEMENT + '/' + datastore + '/',\n    OPERATION: metrics.DB.OPERATION + '/' + datastore + '/',\n    INSTANCE: metrics.DB.INSTANCE + '/' + datastore + '/',\n    ALL: metrics.DB.PREFIX + datastore + '/' + metrics.ALL\n  }\n\n  this._datastore = datastore\n\n  this._logger = this._logger.child({datastore: this._metrics.PREFIX})\n  this.logger.trace({metrics: this._metrics}, 'Datastore metric names set')\n}\n\n/**\n * Sets the query parser used by this shim instance.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {string|QueryParserFunction} parser\n *  The string used to look up a default parser or the function used to parse\n *  queries. It is recommended that you use one of the well-known constants if\n *  available in the {@link DatastoreShim.QUERY_PARSERS}.\n *\n * @see DatastoreShim.QUERY_PARSERS\n * @see QueryParserFunction\n * @see ParsedQueryData\n */\nfunction setParser(parser) {\n  if (this.isString(parser)) {\n    var newParser = defaultParsers[parser]\n    if (newParser) {\n      this.queryParser = newParser\n    } else {\n      this.logger.debug(\n        'Attempted to set the query parser to invalid parser %s, not setting new parser',\n        parser\n      )\n    }\n  } else if (this.isFunction(parser)) {\n    this.queryParser = parser\n  } else {\n    this.logger.trace(\n      \"Received invalid parser (%s)\",\n      parser\n    )\n  }\n}\n\n/**\n * Wraps the given properties as datastore operations that should be recorded.\n *\n * - `recordOperation(nodule, properties, opSpec)`\n * - `recordOperation(func, opSpec)`\n *\n * The resulting wrapped methods will record their actions using the datastore\n * `OPERATION` metric.\n *\n * NOTE: Calling this method before {@link DatastoreShim#setDatastore}\n * will result in an exception.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {OperationSpec|SegmentFunction} opSpec\n *  The spec for this operation function.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see OperationSpec\n * @see SegmentFunction\n */\nfunction recordOperation(nodule, properties, opSpec) {\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // operation(func, opSpec)\n    opSpec = properties\n    properties = null\n  }\n  if (!opSpec) {\n    opSpec = Object.create(null)\n  }\n\n  return this.record(nodule, properties, function opRecorder(shim, fn, fnName, args) {\n    shim.logger.trace('Recording datastore operation \"%s\"', fnName)\n\n    // Derive the segment information.\n    var segDesc = null\n    if (shim.isFunction(opSpec)) {\n      segDesc = opSpec.call(this, shim, fn, fnName, args)\n    } else {\n      segDesc = {\n        name: opSpec.name || fnName || 'other',\n        parameters: opSpec.parameters,\n        callback: opSpec.callback,\n        after: 'after' in opSpec ? opSpec.after : null,\n        promise: 'promise' in opSpec ? opSpec.promise : null,\n        record: opSpec.record,\n        opaque: opSpec.opaque || false\n      }\n    }\n    if (hasOwnProperty(segDesc, 'parameters')) {\n      _normalizeParameters.call(shim, segDesc.parameters)\n    }\n\n    // Adjust the segment name with the metric prefix and add a recorder.\n    if (!hasOwnProperty(segDesc, 'record') || segDesc.record !== false) {\n      segDesc.name = shim._metrics.OPERATION + segDesc.name\n      segDesc.recorder = _recordOperationMetrics.bind(shim)\n\n      segDesc.internal = true\n    }\n\n    // And done.\n    return segDesc\n  })\n}\n\n/**\n * Wraps the given properties as datastore query that should be recorded.\n *\n * - `recordQuery(nodule, properties, querySpec)`\n * - `recordQuery(func, querySpec)`\n *\n * The resulting wrapped methods will record their actions using the datastore\n * `STATEMENT` metric.\n *\n * NOTE: Calling this method before {@link DatastoreShim#setDatastore}\n * will result in an exception.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {QuerySpec|QuerySpecFunction} querySpec\n *  The spec for this query function.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see DatastoreShim#recordBatchQuery\n * @see QuerySpec\n * @see QuerySpecFunction\n */\nfunction recordQuery(nodule, properties, querySpec) {\n  return _recordQuery.call(this, '', nodule, properties, querySpec)\n}\n\n/**\n * Just like {@link DatastoreShim#recordQuery}, but with a `batch` suffix for\n * the recorded metric.\n *\n * - `recordBatchQuery(nodule, properties, querySpec)`\n * - `recordBatchQuery(func, querySpec)`\n *\n * The resulting wrapped methods will record their actions using the datastore\n * `STATEMENT` metric with a `/batch` suffix.\n *\n * NOTE: Calling this method before {@link DatastoreShim#setDatastore}\n * will result in an exception.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {QuerySpec|QuerySpecFunction} querySpec\n *  The spec for this query function.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see DatastoreShim#recordQuery\n * @see QuerySpec\n * @see QuerySpecFunction\n */\nfunction recordBatchQuery(nodule, properties, querySpec) {\n  return _recordQuery.call(this, '/batch', nodule, properties, querySpec)\n}\n\n/**\n * Parses the given query to extract information for any metrics that will be\n * created.\n *\n * NOTE: Calling this method before {@link DatastoreShim#setDatastore}\n * will result in an exception.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {string} query - The query to parse.\n *\n * @param {Object} nodule - Context for the queryParse to run under.\n *\n * @return {ParsedStatement} The parsed query object.\n *\n * @see DatastoreShim#setParser\n */\nfunction parseQuery(query, nodule) {\n  var parsed = this.queryParser.call(nodule, query)\n\n  var collection = parsed.collection\n  // strip enclosing special characters from collection (table) name\n  if (typeof collection === 'string' && collection.length > 2) {\n    if (/^[\\[{'\"`]/.test(collection)) {\n      collection = collection.substr(1)\n    }\n    if (/[\\]}'\"`]$/.test(collection)) {\n      collection = collection.substr(0, collection.length - 1)\n    }\n  }\n\n  var queryRecorded = (\n    this.agent.config.transaction_tracer.record_sql === 'raw' ||\n    this.agent.config.transaction_tracer.record_sql === 'obfuscated'\n  )\n\n  return new ParsedStatement(\n    this._metrics.PREFIX,\n    parsed.operation,\n    collection,\n    queryRecorded ? parsed.query : null\n  )\n}\n\n/**\n * Wraps the callback in an arguments array with one that is bound to a segment.\n *\n * - `bindRowCallbackSegment(args, cbIdx [, parentSegment])`\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {Array} args\n *  The arguments array to replace the callback in.\n *\n * @param {Number} cbIdx\n *  The index of the callback in the arguments array.\n *\n * @param {TraceSegment} [parentSegment]\n *  Optional. The segment to be the parent row callback's segment. Defaults to\n *  the segment active when the row callback is first called.\n */\nfunction bindRowCallbackSegment(args, cbIdx, parentSegment) {\n  var idx = this.normalizeIndex(args.length, cbIdx)\n  if (idx === null) {\n    this.logger.debug('Not binding row callback, invalid cbIdx %s', cbIdx)\n    return\n  }\n\n  // Pull out the callback and make sure it is a function.\n  var cb = args[idx]\n  if (!this.isFunction(cb)) {\n    this.logger.debug('Argument %d is not a function, not binding row callback', cbIdx)\n    return cb\n  }\n  this.logger.trace('Wrapping argument %d as a row callback.', cbIdx)\n\n  // We have a little state to maintain through potentially multiple calls.\n  var callCounter = 0\n  var segment = null\n  var segmentName = 'Callback: ' + this.getName(cb)\n  var shim = this\n\n  var wrapper = this.bindSegment(function rowCallbackWrapper() {\n    // The first time this row callback is fired we want to touch the parent\n    // segment and create the callback segment.\n    if (++callCounter === 1) {\n      var realParent = parentSegment || shim.getSegment()\n      realParent && realParent.touch()\n      segment = shim.createSegment(segmentName, realParent)\n\n      if (segment) {\n        segment.async = false\n      }\n    }\n\n    // Update the segment name and run the actual callback.\n    if (segment) {\n      segment.addAttribute('count', callCounter)\n    }\n\n    return shim.applySegment(cb, segment, true, this, arguments)\n  }, parentSegment)\n\n  // Mark this as wrapped and put it in the args array.\n  this.setInternalProperty(wrapper, '__NR_original', cb)\n  args[idx] = wrapper\n}\n\n/**\n * Normalizes and adds datastore instance attributes to the current segment.\n *\n * If the current segment was not created by this shim then no action is taken.\n *\n * @memberof DatastoreShim.prototype\n *\n * @param {string}        host      - The name of the database host.\n * @param {number|string} port      - The port, path, or ID of the database server.\n * @param {string}        database  - The name of the database in use.\n */\nfunction captureInstanceAttributes(host, port, database) {\n  // See if we are currently in a segment created by us.\n  var segment = this.getSegment()\n  if (!segment || segment.shim !== this) {\n    this.logger.trace(\n      'Not adding db instance metric attributes to segment %j',\n      segment && segment.name\n    )\n    return\n  }\n  this.logger.trace('Adding db instance attributes to segment %j', segment.name)\n\n  // Normalize the instance attributes.\n  var attributes = _normalizeParameters.call(this, {\n    host,\n    port_path_or_id: port,\n    database_name: database\n  })\n\n  for (let key in attributes) {\n    if (attributes[key]) {\n      segment.addAttribute(key, attributes[key])\n    }\n  }\n}\n\n/**\n * Parses the database name from a `USE` SQL query.\n *\n * @param {string} query - The SQL query to parse the database name from.\n *\n * @return {?string} The name of the database if it could be parsed, otherwise\n *  `null`.\n */\nfunction getDatabaseNameFromUseQuery(query) {\n  return dbutil.extractDatabaseChangeFromUse(query)\n}\n\n// -------------------------------------------------------------------------- //\n\n/**\n * Wraps the given properties as datastore query that should be recorded.\n *\n * - `_recordQuery(suffix, nodule, properties, querySpec)`\n * - `_recordQuery(suffix, func, querySpec)`\n *\n * The resulting wrapped methods will record their actions using the datastore\n * `STATEMENT` metric.\n *\n * @private\n * @this DatastoreShim\n *\n * @param {string} suffix\n *  Suffix to be added to the segment name.\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {QuerySpec|QueryFunction} querySpec\n *  The spec for this query function.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see DatastoreShim#recordQuery\n * @see DatastoreShim#recordBatchQuery\n * @see QuerySpec\n * @see QuerySpecFunction\n */\nfunction _recordQuery(suffix, nodule, properties, querySpec) {\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // _recordQuery(suffix, func, querySpec)\n    querySpec = properties\n    properties = null\n  }\n  if (!querySpec) {\n    this.logger.debug('Missing query spec for recordQuery, not wrapping.')\n    return nodule\n  }\n\n  return this.record(nodule, properties, function queryRecord(shim, fn, fnName, args) {\n    shim.logger.trace('Determining query information for %j', fnName)\n\n    var queryDesc = querySpec\n    if (shim.isFunction(querySpec)) {\n      queryDesc = querySpec.call(this, shim, fn, fnName, args)\n    }\n\n    // If we're not actually recording this, then just return the segment\n    // descriptor now.\n    if (hasOwnProperty(queryDesc, 'record') && queryDesc.record === false) {\n      var parameters =\n        _normalizeParameters.call(shim, queryDesc.parameters || Object.create(null))\n      return {\n        name: queryDesc.name || fnName,\n        parameters,\n        callback:     'callback'    in queryDesc ? queryDesc.callback : null,\n        rowCallback:  'rowCallback' in queryDesc ? queryDesc.rowCallback : null,\n        stream:       'stream'      in queryDesc ? queryDesc.stream : null,\n        after:        'after'       in queryDesc ? queryDesc.after : null,\n        promise:      'promise'     in queryDesc ? queryDesc.promise : null,\n        internal:     'internal'    in queryDesc ? queryDesc.internal : false,\n        opaque:       'opaque'      in queryDesc ? queryDesc.opaque : false\n      }\n    }\n\n    // Fetch the query string.\n    var queryStr = _extractQueryStr.call(shim, fn, fnName, queryDesc, this, args)\n    if (!shim.isString(queryStr)) {\n      return null\n    }\n\n    // Parse the query and assemble the name.\n    var parsed = shim.parseQuery(queryStr, this)\n    var name = (parsed.collection || 'other') + '/' + parsed.operation + suffix\n    shim.logger.trace('Found and parsed query %s -> %s', parsed.type, name)\n\n    // Return the segment descriptor.\n    var parameters =\n      _normalizeParameters.call(shim, queryDesc.parameters || Object.create(null))\n    return {\n      name: shim._metrics.STATEMENT + name,\n      parameters: parameters,\n      callback:     'callback'    in queryDesc ? queryDesc.callback : null,\n      rowCallback:  'rowCallback' in queryDesc ? queryDesc.rowCallback : null,\n      stream:       'stream'      in queryDesc ? queryDesc.stream : null,\n      after:        'after'       in queryDesc ? queryDesc.after : null,\n      promise:      'promise'     in queryDesc ? queryDesc.promise : null,\n      internal:     'internal'    in queryDesc ? queryDesc.internal : true,\n      opaque:       'opaque'      in queryDesc ? queryDesc.opaque : false,\n      recorder: function queryRecorder(segment, scope) {\n        if (segment) {\n          parsed.recordMetrics(segment, scope)\n        }\n      }\n    }\n  })\n}\n\n/**\n * Records all the metrics required for database operations.\n *\n * - `_recordOperationMetrics(segment [, scope])`\n *\n * @private\n * @this DatastoreShim\n * @implements {MetricFunction}\n *\n * @param {TraceSegment}  segment - The segment being recorded.\n * @param {string}        [scope] - The scope of the segment.\n *\n * @see DatastoreShim#recordOperation\n * @see MetricFunction\n */\nfunction _recordOperationMetrics(segment, scope) {\n  if (!segment) {\n    return\n  }\n\n  var duration = segment.getDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var transaction = segment.transaction\n  var type = transaction.isWeb() ? 'allWeb' : 'allOther'\n  var operation = segment.name\n\n  if (scope) {\n    transaction.measure(operation, scope, duration, exclusive)\n  }\n\n  transaction.measure(operation, null, duration, exclusive)\n  transaction.measure(metrics.DB.PREFIX + type, null, duration, exclusive)\n  transaction.measure(metrics.DB.ALL, null, duration, exclusive)\n  transaction.measure(this._metrics.ALL, null, duration, exclusive)\n  transaction.measure(\n    metrics.DB.PREFIX + this._metrics.PREFIX + '/' + type,\n    null,\n    duration,\n    exclusive\n  )\n\n  const attributes = segment.getAttributes()\n  if (attributes.host && attributes.port_path_or_id ) {\n    const instanceName = [\n      metrics.DB.INSTANCE,\n      this._metrics.PREFIX,\n      attributes.host,\n      attributes.port_path_or_id\n    ].join('/')\n\n    transaction.measure(instanceName, null, duration, exclusive)\n  }\n}\n\n/**\n * Extracts the query string from the arguments according to the given spec.\n *\n * - `_extractQueryStr(fn, fnName, spec, ctx, args)`\n *\n * @private\n * @this DatastoreShim\n *\n * @param {Function}  fn      - The query function to be executed.\n * @param {string}    fnName  - The name of the query function.\n * @param {QuerySpec} spec    - The query spec.\n * @param {*}         ctx     - The context of the query function's execution.\n * @param {Array}     args    - The arguments for the query function.\n *\n * @return {?string} The query from the arguments if found, otherwise `null`.\n */\nfunction _extractQueryStr(fn, fnName, spec, ctx, args) {\n  var queryStr = spec.query\n  if (this.isNumber(queryStr)) {\n    var queryIdx = this.normalizeIndex(args.length, queryStr)\n    if (queryIdx === null) {\n      this.logger.debug('Invalid query index %d of %d', queryStr, args.length)\n      return null\n    }\n    queryStr = args[queryIdx]\n  } else if (this.isFunction(queryStr)) {\n    queryStr = queryStr.call(ctx, this, fn, fnName, args)\n  }\n\n  return queryStr\n}\n\n/**\n * Normalizes segment parameter values.\n *\n * - `_normalizeParameters([parameters])`\n *\n * Removes disabled parameters and corrects other values, such as changing host\n * from `localhost` to the actual host name.\n *\n * @private\n * @this DatastoreShim\n *\n * @param {object} [parameters={}] - The segment parameters to clean up.\n *\n * @return {object} - The normalized segment parameters.\n */\nfunction _normalizeParameters(parameters) {\n  parameters = parameters || Object.create(null)\n  var config = this.agent.config\n  var dsTracerConf = config.datastore_tracer\n\n  parameters.product = parameters.product || this._datastore\n\n  // Add database name if provided and enabled.\n  if (!dsTracerConf.database_name_reporting.enabled) {\n    delete parameters.database_name\n  } else if (\n    hasOwnProperty(parameters, 'database_name') &&\n    parameters.database_name !== false\n  ) {\n    parameters.database_name = typeof parameters.database_name === 'number'\n      ? String(parameters.database_name)\n      : (parameters.database_name || INSTANCE_UNKNOWN)\n  }\n\n  // Add instance information if enabled.\n  if (!dsTracerConf.instance_reporting.enabled) {\n    delete parameters.host\n    delete parameters.port_path_or_id\n  } else {\n    // Determine appropriate defaults for host and port.\n    if (hasOwnProperty(parameters, 'port_path_or_id')) {\n      parameters.port_path_or_id = String(parameters.port_path_or_id || INSTANCE_UNKNOWN)\n    }\n    if (hasOwnProperty(parameters, 'host')) {\n      if (parameters.host && urltils.isLocalhost(parameters.host)) {\n        parameters.host = config.getHostnameSafe(parameters.host)\n      }\n\n      // Config's default name of a host is `UNKNOWN_BOX`.\n      if (!parameters.host || parameters.host === 'UNKNOWN_BOX') {\n        parameters.host = INSTANCE_UNKNOWN\n      }\n    }\n  }\n\n  return parameters\n}\n"]},"metadata":{},"sourceType":"script"}