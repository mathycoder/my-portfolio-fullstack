{"ast":null,"code":"'use strict';\n\nconst async = require('async');\n\nconst logger = require('../logger').child({\n  component: 'transaction-event-aggregator'\n});\n\nconst EventAggregator = require('../aggregators/event-aggregator');\n\nconst NAMES = require('../metrics/names');\n\nconst SPLIT_THRESHOLD = 5000;\n\nclass TransactionEventAggregator extends EventAggregator {\n  constructor(opts, collector, metrics) {\n    opts = opts || {};\n    opts.method = opts.method || 'analytic_event_data';\n    opts.metricNames = NAMES.EVENTS;\n    super(opts, collector, metrics);\n    this.splitThreshold = opts.splitThreshold || SPLIT_THRESHOLD;\n  }\n\n  _toPayloadSync() {\n    // this is still used by traditional send when payloads not split\n    const events = this.events;\n\n    if (events.length === 0) {\n      logger.debug('No transaction events to send.');\n      return;\n    }\n\n    const metrics = {\n      reservoir_size: events.limit,\n      events_seen: events.seen\n    };\n    const eventData = events.toArray();\n    return [this.runId, metrics, eventData];\n  }\n\n  send() {\n    if (this.events.length < this.splitThreshold) {\n      return super.send();\n    } // TODO: log?\n\n\n    this.emit(`starting ${this.method} data send.`);\n    logger.debug('Splitting transaction events into multiple payloads');\n\n    const data = this._getMergeData();\n\n    this.clear();\n\n    const eventPayloadPairs = this._splitData(data);\n\n    this._sendMultiple(eventPayloadPairs, () => {\n      // TODO: Log?\n      this.emit(`finished ${this.method} data send.`);\n    });\n  }\n\n  _splitData(data) {\n    // TODO: update this to pull the priority off the event when DT is released\n    const events = data.getRawEvents();\n    const size = Math.floor(data.length / 2);\n    const limit = Math.floor(data.limit / 2);\n    const seen = Math.floor(data.seen / 2);\n    const firstHalfRawEvents = events.splice(0, size);\n    const firstMetrics = {\n      reservoir_size: limit,\n      events_seen: seen\n    };\n    const firstHalfEventData = firstHalfRawEvents.map(this._rawEventsToValues);\n    const firstPayload = [this.runId, firstMetrics, firstHalfEventData];\n    const secondHalfRawEvents = events;\n    const secondMetrics = {\n      reservoir_size: data.limit - limit,\n      events_seen: data.seen - seen\n    };\n    const secondHalfEventData = secondHalfRawEvents.map(this._rawEventsToValues);\n    const secondPayload = [this.runId, secondMetrics, secondHalfEventData];\n    const eventPayloadPairs = [{\n      rawData: firstHalfRawEvents,\n      payload: firstPayload\n    }, {\n      rawData: secondHalfRawEvents,\n      payload: secondPayload\n    }];\n    return eventPayloadPairs;\n  }\n\n  _rawEventsToValues(rawEvent) {\n    return rawEvent.value;\n  }\n\n  _sendMultiple(eventPayloadPairs, sendCallback) {\n    const self = this; // Send payloads one at a time\n\n    async.eachOfSeries(eventPayloadPairs, (payloadPair, index, asyncCallback) => {\n      logger.debug('Sending payload %d of %d to %s', index + 1, eventPayloadPairs.length, self.method);\n\n      self._sendSplitPayload(payloadPair.rawData, payloadPair.payload, error => {\n        if (error) {\n          logger.warn(error, 'An error occurred sending payload');\n        }\n\n        logger.trace('Finished sending payload %d of %d to %s', index + 1, eventPayloadPairs.length, self.method); // don't pass on error, allow next payload to attempt to send\n\n        asyncCallback();\n      });\n    }, function afterAllPayloadsSent() {\n      logger.debug('Finished sending %d payloads to %s', eventPayloadPairs.length, self.method);\n      sendCallback();\n    });\n  }\n\n  _sendSplitPayload(rawData, payload, callback) {\n    this.collector[this.method](payload, (error, response) => {\n      if (response && response.retainData) {\n        this._merge(rawData);\n      }\n\n      callback(error);\n    });\n  }\n\n}\n\nmodule.exports = TransactionEventAggregator;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/transaction/transaction-event-aggregator.js"],"names":["async","require","logger","child","component","EventAggregator","NAMES","SPLIT_THRESHOLD","TransactionEventAggregator","constructor","opts","collector","metrics","method","metricNames","EVENTS","splitThreshold","_toPayloadSync","events","length","debug","reservoir_size","limit","events_seen","seen","eventData","toArray","runId","send","emit","data","_getMergeData","clear","eventPayloadPairs","_splitData","_sendMultiple","getRawEvents","size","Math","floor","firstHalfRawEvents","splice","firstMetrics","firstHalfEventData","map","_rawEventsToValues","firstPayload","secondHalfRawEvents","secondMetrics","secondHalfEventData","secondPayload","rawData","payload","rawEvent","value","sendCallback","self","eachOfSeries","payloadPair","index","asyncCallback","_sendSplitPayload","error","warn","trace","afterAllPayloadsSent","callback","response","retainData","_merge","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAP,CAAqBE,KAArB,CAA2B;AAACC,EAAAA,SAAS,EAAE;AAAZ,CAA3B,CAAf;;AACA,MAAMC,eAAe,GAAGJ,OAAO,CAAC,iCAAD,CAA/B;;AAEA,MAAMK,KAAK,GAAGL,OAAO,CAAC,kBAAD,CAArB;;AAEA,MAAMM,eAAe,GAAG,IAAxB;;AAEA,MAAMC,0BAAN,SAAyCH,eAAzC,CAAyD;AACvDI,EAAAA,WAAW,CAACC,IAAD,EAAOC,SAAP,EAAkBC,OAAlB,EAA2B;AACpCF,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACAA,IAAAA,IAAI,CAACG,MAAL,GAAcH,IAAI,CAACG,MAAL,IAAe,qBAA7B;AACAH,IAAAA,IAAI,CAACI,WAAL,GAAmBR,KAAK,CAACS,MAAzB;AAEA,UAAML,IAAN,EAAYC,SAAZ,EAAuBC,OAAvB;AAEA,SAAKI,cAAL,GAAsBN,IAAI,CAACM,cAAL,IAAuBT,eAA7C;AACD;;AAEDU,EAAAA,cAAc,GAAG;AACf;AACA,UAAMC,MAAM,GAAG,KAAKA,MAApB;;AAEA,QAAIA,MAAM,CAACC,MAAP,KAAkB,CAAtB,EAAyB;AACvBjB,MAAAA,MAAM,CAACkB,KAAP,CAAa,gCAAb;AACA;AACD;;AAED,UAAMR,OAAO,GAAG;AACdS,MAAAA,cAAc,EAAEH,MAAM,CAACI,KADT;AAEdC,MAAAA,WAAW,EAAEL,MAAM,CAACM;AAFN,KAAhB;AAKA,UAAMC,SAAS,GAAGP,MAAM,CAACQ,OAAP,EAAlB;AAEA,WAAO,CAAC,KAAKC,KAAN,EAAaf,OAAb,EAAsBa,SAAtB,CAAP;AACD;;AAEDG,EAAAA,IAAI,GAAG;AACL,QAAI,KAAKV,MAAL,CAAYC,MAAZ,GAAqB,KAAKH,cAA9B,EAA8C;AAC5C,aAAO,MAAMY,IAAN,EAAP;AACD,KAHI,CAKL;;;AACA,SAAKC,IAAL,CAAW,YAAW,KAAKhB,MAAO,aAAlC;AAEAX,IAAAA,MAAM,CAACkB,KAAP,CAAa,qDAAb;;AAEA,UAAMU,IAAI,GAAG,KAAKC,aAAL,EAAb;;AAEA,SAAKC,KAAL;;AAEA,UAAMC,iBAAiB,GAAG,KAAKC,UAAL,CAAgBJ,IAAhB,CAA1B;;AAEA,SAAKK,aAAL,CAAmBF,iBAAnB,EAAsC,MAAM;AAC1C;AACA,WAAKJ,IAAL,CAAW,YAAW,KAAKhB,MAAO,aAAlC;AACD,KAHD;AAID;;AAEDqB,EAAAA,UAAU,CAACJ,IAAD,EAAO;AACf;AACA,UAAMZ,MAAM,GAAGY,IAAI,CAACM,YAAL,EAAf;AACA,UAAMC,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWT,IAAI,CAACX,MAAL,GAAc,CAAzB,CAAb;AACA,UAAMG,KAAK,GAAGgB,IAAI,CAACC,KAAL,CAAWT,IAAI,CAACR,KAAL,GAAa,CAAxB,CAAd;AACA,UAAME,IAAI,GAAGc,IAAI,CAACC,KAAL,CAAWT,IAAI,CAACN,IAAL,GAAY,CAAvB,CAAb;AAEA,UAAMgB,kBAAkB,GAAGtB,MAAM,CAACuB,MAAP,CAAc,CAAd,EAAiBJ,IAAjB,CAA3B;AACA,UAAMK,YAAY,GAAG;AACnBrB,MAAAA,cAAc,EAAEC,KADG;AAEnBC,MAAAA,WAAW,EAAEC;AAFM,KAArB;AAIA,UAAMmB,kBAAkB,GAAGH,kBAAkB,CAACI,GAAnB,CAAuB,KAAKC,kBAA5B,CAA3B;AACA,UAAMC,YAAY,GAAG,CAAC,KAAKnB,KAAN,EAAae,YAAb,EAA2BC,kBAA3B,CAArB;AAGA,UAAMI,mBAAmB,GAAG7B,MAA5B;AACA,UAAM8B,aAAa,GAAG;AACpB3B,MAAAA,cAAc,EAAES,IAAI,CAACR,KAAL,GAAaA,KADT;AAEpBC,MAAAA,WAAW,EAAEO,IAAI,CAACN,IAAL,GAAYA;AAFL,KAAtB;AAIA,UAAMyB,mBAAmB,GAAGF,mBAAmB,CAACH,GAApB,CAAwB,KAAKC,kBAA7B,CAA5B;AACA,UAAMK,aAAa,GAAG,CAAC,KAAKvB,KAAN,EAAaqB,aAAb,EAA4BC,mBAA5B,CAAtB;AAGA,UAAMhB,iBAAiB,GAAG,CACxB;AAAEkB,MAAAA,OAAO,EAAEX,kBAAX;AAA+BY,MAAAA,OAAO,EAAEN;AAAxC,KADwB,EAExB;AAAEK,MAAAA,OAAO,EAAEJ,mBAAX;AAAgCK,MAAAA,OAAO,EAAEF;AAAzC,KAFwB,CAA1B;AAKA,WAAOjB,iBAAP;AACD;;AAEDY,EAAAA,kBAAkB,CAACQ,QAAD,EAAW;AAC3B,WAAOA,QAAQ,CAACC,KAAhB;AACD;;AAEDnB,EAAAA,aAAa,CAACF,iBAAD,EAAoBsB,YAApB,EAAkC;AAC7C,UAAMC,IAAI,GAAG,IAAb,CAD6C,CAG7C;;AACAxD,IAAAA,KAAK,CAACyD,YAAN,CAAmBxB,iBAAnB,EAAsC,CAACyB,WAAD,EAAcC,KAAd,EAAqBC,aAArB,KAAuC;AAC3E1D,MAAAA,MAAM,CAACkB,KAAP,CACE,gCADF,EAEEuC,KAAK,GAAG,CAFV,EAGE1B,iBAAiB,CAACd,MAHpB,EAIEqC,IAAI,CAAC3C,MAJP;;AAOA2C,MAAAA,IAAI,CAACK,iBAAL,CAAuBH,WAAW,CAACP,OAAnC,EAA4CO,WAAW,CAACN,OAAxD,EAAkEU,KAAD,IAAW;AAC1E,YAAIA,KAAJ,EAAW;AACT5D,UAAAA,MAAM,CAAC6D,IAAP,CAAYD,KAAZ,EAAmB,mCAAnB;AACD;;AAED5D,QAAAA,MAAM,CAAC8D,KAAP,CACE,yCADF,EAEEL,KAAK,GAAG,CAFV,EAGE1B,iBAAiB,CAACd,MAHpB,EAIEqC,IAAI,CAAC3C,MAJP,EAL0E,CAY1E;;AACA+C,QAAAA,aAAa;AACd,OAdD;AAeD,KAvBD,EAuBG,SAASK,oBAAT,GAAgC;AACjC/D,MAAAA,MAAM,CAACkB,KAAP,CACE,oCADF,EAEEa,iBAAiB,CAACd,MAFpB,EAGEqC,IAAI,CAAC3C,MAHP;AAMA0C,MAAAA,YAAY;AACb,KA/BD;AAgCD;;AAEDM,EAAAA,iBAAiB,CAACV,OAAD,EAAUC,OAAV,EAAmBc,QAAnB,EAA6B;AAC5C,SAAKvD,SAAL,CAAe,KAAKE,MAApB,EAA4BuC,OAA5B,EAAqC,CAACU,KAAD,EAAQK,QAAR,KAAqB;AACxD,UAAIA,QAAQ,IAAIA,QAAQ,CAACC,UAAzB,EAAqC;AACnC,aAAKC,MAAL,CAAYlB,OAAZ;AACD;;AAEDe,MAAAA,QAAQ,CAACJ,KAAD,CAAR;AACD,KAND;AAOD;;AAvIsD;;AA0IzDQ,MAAM,CAACC,OAAP,GAAiB/D,0BAAjB","sourcesContent":["'use strict'\n\nconst async = require('async')\nconst logger = require('../logger').child({component: 'transaction-event-aggregator'})\nconst EventAggregator = require('../aggregators/event-aggregator')\n\nconst NAMES = require('../metrics/names')\n\nconst SPLIT_THRESHOLD = 5000\n\nclass TransactionEventAggregator extends EventAggregator {\n  constructor(opts, collector, metrics) {\n    opts = opts || {}\n    opts.method = opts.method || 'analytic_event_data'\n    opts.metricNames = NAMES.EVENTS\n\n    super(opts, collector, metrics)\n\n    this.splitThreshold = opts.splitThreshold || SPLIT_THRESHOLD\n  }\n\n  _toPayloadSync() {\n    // this is still used by traditional send when payloads not split\n    const events = this.events\n\n    if (events.length === 0) {\n      logger.debug('No transaction events to send.')\n      return\n    }\n\n    const metrics = {\n      reservoir_size: events.limit,\n      events_seen: events.seen\n    }\n\n    const eventData = events.toArray()\n\n    return [this.runId, metrics, eventData]\n  }\n\n  send() {\n    if (this.events.length < this.splitThreshold) {\n      return super.send()\n    }\n\n    // TODO: log?\n    this.emit(`starting ${this.method} data send.`)\n\n    logger.debug('Splitting transaction events into multiple payloads')\n\n    const data = this._getMergeData()\n\n    this.clear()\n\n    const eventPayloadPairs = this._splitData(data)\n\n    this._sendMultiple(eventPayloadPairs, () => {\n      // TODO: Log?\n      this.emit(`finished ${this.method} data send.`)\n    })\n  }\n\n  _splitData(data) {\n    // TODO: update this to pull the priority off the event when DT is released\n    const events = data.getRawEvents()\n    const size = Math.floor(data.length / 2)\n    const limit = Math.floor(data.limit / 2)\n    const seen = Math.floor(data.seen / 2)\n\n    const firstHalfRawEvents = events.splice(0, size)\n    const firstMetrics = {\n      reservoir_size: limit,\n      events_seen: seen\n    }\n    const firstHalfEventData = firstHalfRawEvents.map(this._rawEventsToValues)\n    const firstPayload = [this.runId, firstMetrics, firstHalfEventData]\n\n\n    const secondHalfRawEvents = events\n    const secondMetrics = {\n      reservoir_size: data.limit - limit,\n      events_seen: data.seen - seen\n    }\n    const secondHalfEventData = secondHalfRawEvents.map(this._rawEventsToValues)\n    const secondPayload = [this.runId, secondMetrics, secondHalfEventData]\n\n\n    const eventPayloadPairs = [\n      { rawData: firstHalfRawEvents, payload: firstPayload },\n      { rawData: secondHalfRawEvents, payload: secondPayload}\n    ]\n\n    return eventPayloadPairs\n  }\n\n  _rawEventsToValues(rawEvent) {\n    return rawEvent.value\n  }\n\n  _sendMultiple(eventPayloadPairs, sendCallback) {\n    const self = this\n\n    // Send payloads one at a time\n    async.eachOfSeries(eventPayloadPairs, (payloadPair, index, asyncCallback) => {\n      logger.debug(\n        'Sending payload %d of %d to %s',\n        index + 1,\n        eventPayloadPairs.length,\n        self.method\n      )\n\n      self._sendSplitPayload(payloadPair.rawData, payloadPair.payload, (error) => {\n        if (error) {\n          logger.warn(error, 'An error occurred sending payload')\n        }\n\n        logger.trace(\n          'Finished sending payload %d of %d to %s',\n          index + 1,\n          eventPayloadPairs.length,\n          self.method\n        )\n\n        // don't pass on error, allow next payload to attempt to send\n        asyncCallback()\n      })\n    }, function afterAllPayloadsSent() {\n      logger.debug(\n        'Finished sending %d payloads to %s',\n        eventPayloadPairs.length,\n        self.method\n      )\n\n      sendCallback()\n    })\n  }\n\n  _sendSplitPayload(rawData, payload, callback) {\n    this.collector[this.method](payload, (error, response) => {\n      if (response && response.retainData) {\n        this._merge(rawData)\n      }\n\n      callback(error)\n    })\n  }\n}\n\nmodule.exports = TransactionEventAggregator\n"]},"metadata":{},"sourceType":"script"}