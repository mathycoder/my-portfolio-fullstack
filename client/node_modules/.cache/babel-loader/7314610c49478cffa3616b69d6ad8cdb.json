{"ast":null,"code":"'use strict';\n\nconst util = require('util');\n\nconst logger = require('./lib/logger').child({\n  component: 'api'\n});\n\nconst recordWeb = require('./lib/metrics/recorders/http');\n\nconst recordBackground = require('./lib/metrics/recorders/other');\n\nconst customRecorder = require('./lib/metrics/recorders/custom');\n\nconst hashes = require('./lib/util/hashes');\n\nconst properties = require('./lib/util/properties');\n\nconst stringify = require('json-stringify-safe');\n\nconst shimmer = require('./lib/shimmer');\n\nconst shims = require('./lib/shim');\n\nconst isValidType = require('./lib/util/attribute-types');\n\nconst TransactionShim = require('./lib/shim/transaction-shim');\n\nconst TransactionHandle = require('./lib/transaction/handle');\n\nconst AwsLambda = require('./lib/serverless/aws-lambda');\n\nconst ATTR_DEST = require('./lib/config/attribute-filter').DESTINATIONS;\n\nconst MODULE_TYPE = require('./lib/shim/constants').MODULE_TYPE;\n\nconst NAMES = require('./lib/metrics/names');\n/*\n *\n * CONSTANTS\n *\n */\n\n\nconst RUM_STUB = \"<script type='text/javascript' %s>window.NREUM||(NREUM={});\" + \"NREUM.info = %s; %s</script>\"; // these messages are used in the _gracefail() method below in getBrowserTimingHeader\n\nconst RUM_ISSUES = ['NREUM: no browser monitoring headers generated; disabled', 'NREUM: transaction missing or ignored while generating browser monitoring headers', 'NREUM: config.browser_monitoring missing, something is probably wrong', 'NREUM: browser_monitoring headers need a transaction name', 'NREUM: browser_monitoring requires valid application_id', 'NREUM: browser_monitoring requires valid browser_key', 'NREUM: browser_monitoring requires js_agent_loader script', 'NREUM: browser_monitoring disabled by browser_monitoring.loader config']; // Can't overwrite internal parameters or all heck will break loose.\n\nconst CUSTOM_BLACKLIST = new Set(['nr_flatten_leading']);\nconst CUSTOM_EVENT_TYPE_REGEX = /^[a-zA-Z0-9:_ ]+$/;\n/**\n * The exported New Relic API. This contains all of the functions meant to be\n * used by New Relic customers. For now, that means transaction naming.\n *\n * You do not need to directly instantiate this class, as an instance of this is\n * the return from `require('newrelic')`.\n *\n * @constructor\n */\n\nfunction API(agent) {\n  this.agent = agent;\n  this.shim = new TransactionShim(agent, 'NewRelicAPI');\n  this.awsLambda = new AwsLambda(agent);\n}\n/**\n * Give the current transaction a custom name. Overrides any New Relic naming\n * rules set in configuration or from New Relic's servers.\n *\n * IMPORTANT: this function must be called when a transaction is active. New\n * Relic transactions are tied to web requests, so this method may be called\n * from within HTTP or HTTPS listener functions, Express routes, or other\n * contexts where a web request or response object are in scope.\n *\n * @param {string} name The name you want to give the web request in the New\n *                      Relic UI. Will be prefixed with 'Custom/' when sent.\n */\n\n\nAPI.prototype.setTransactionName = function setTransactionName(name) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/setTransactionName');\n  metric.incrementCallCount();\n  var transaction = this.agent.tracer.getTransaction();\n\n  if (!transaction) {\n    return logger.warn(\"No transaction found when setting name to '%s'.\", name);\n  }\n\n  if (!name) {\n    if (transaction && transaction.url) {\n      logger.error(\"Must include name in setTransactionName call for URL %s.\", transaction.url);\n    } else {\n      logger.error(\"Must include name in setTransactionName call.\");\n    }\n\n    return;\n  }\n\n  logger.trace('Setting transaction %s name to %s', transaction.id, name);\n  transaction.forceName = NAMES.CUSTOM + '/' + name;\n};\n/**\n * This method returns an object with the following methods:\n * - end: end the transaction that was active when `API#getTransaction`\n *   was called.\n *\n * - ignore: set the transaction that was active when\n *   `API#getTransaction` was called to be ignored.\n *\n * @returns {TransactionHandle} The transaction object with the `end` and\n *  `ignore` methods on it.\n */\n\n\nAPI.prototype.getTransaction = function getTransaction() {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/getTransaction');\n  metric.incrementCallCount();\n  var transaction = this.agent.tracer.getTransaction();\n\n  if (!transaction) {\n    logger.debug(\"No transaction found when calling API#getTransaction\");\n    return new TransactionHandle.Stub();\n  }\n\n  transaction.handledExternally = true;\n  return new TransactionHandle(transaction);\n};\n/**\n * This method returns an object with the following keys/data:\n * - `trace.id`: The current trace ID\n * - `span.id`: The current span ID\n * - `entity.name`: The application name specified in the connect request as\n *   app_name. If multiple application names are specified this will only be\n *   the first name\n * - `entity.type`: The string \"SERVICE\"\n * - `entity.guid`: The entity ID returned in the connect reply as entity_guid\n * - `hostname`: The hostname as specified in the connect request as\n *   utilization.full_hostname. If utilization.full_hostname is null or empty,\n *   this will be the hostname specified in the connect request as host.\n *\n * @returns {LinkingMetadata} The linking object with the data above\n */\n\n\nAPI.prototype.getLinkingMetadata = function getLinkingMetadata(omitSupportability) {\n  if (omitSupportability !== true) {\n    const metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/getLinkingMetadata');\n    metric.incrementCallCount();\n  }\n\n  const agent = this.agent;\n  const segment = agent.tracer.getSegment();\n  const config = agent.config;\n  const linkingMetadata = {\n    'entity.name': config.applications()[0],\n    'entity.type': 'SERVICE',\n    'hostname': config.getHostnameSafe()\n  };\n\n  if (config.distributed_tracing.enabled && segment) {\n    linkingMetadata['trace.id'] = segment.transaction.getTraceId();\n    const spanId = segment.getSpanId();\n\n    if (spanId) {\n      linkingMetadata['span.id'] = spanId;\n    }\n  } else {\n    logger.debug('getLinkingMetadata with no active transaction');\n  }\n\n  if (config.entity_guid) {\n    linkingMetadata['entity.guid'] = config.entity_guid;\n  }\n\n  return linkingMetadata;\n};\n/**\n * Specify the `Dispatcher` and `Dispatcher Version` environment values.\n * A dispatcher is typically the service responsible for brokering\n * the request with the process responsible for responding to the\n * request.  For example Node's `http` module would be the dispatcher\n * for incoming HTTP requests.\n *\n * @param {string} name The string you would like to report to New Relic\n *                      as the dispatcher.\n *\n * @param {string} [version] The dispatcher version you would like to\n *                           report to New Relic\n */\n\n\nAPI.prototype.setDispatcher = function setDispatcher(name, version) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/setDispatcher');\n  metric.incrementCallCount();\n\n  if (!name || typeof name !== 'string') {\n    logger.error(\"setDispatcher must be called with a name, and name must be a string.\");\n    return;\n  } // No objects allowed.\n\n\n  if (version && typeof version !== 'object') {\n    version = String(version);\n  } else {\n    logger.info('setDispatcher was called with an object as the version parameter');\n    version = null;\n  }\n\n  this.agent.environment.setDispatcher(name, version, true);\n};\n/**\n * Give the current transaction a name based on your own idea of what\n * constitutes a controller in your Node application. Also allows you to\n * optionally specify the action being invoked on the controller. If the action\n * is omitted, then the API will default to using the HTTP method used in the\n * request (e.g. GET, POST, DELETE). Overrides any New Relic naming rules set\n * in configuration or from New Relic's servers.\n *\n * IMPORTANT: this function must be called when a transaction is active. New\n * Relic transactions are tied to web requests, so this method may be called\n * from within HTTP or HTTPS listener functions, Express routes, or other\n * contexts where a web request or response object are in scope.\n *\n * @param {string} name   The name you want to give the controller in the New\n *                        Relic UI. Will be prefixed with 'Controller/' when\n *                        sent.\n * @param {string} action The action being invoked on the controller. Defaults\n *                        to the HTTP method used for the request.\n */\n\n\nAPI.prototype.setControllerName = function setControllerName(name, action) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/setControllerName');\n  metric.incrementCallCount();\n  var transaction = this.agent.tracer.getTransaction();\n\n  if (!transaction) {\n    return logger.warn(\"No transaction found when setting controller to %s.\", name);\n  }\n\n  if (!name) {\n    if (transaction && transaction.url) {\n      logger.error(\"Must include name in setControllerName call for URL %s.\", transaction.url);\n    } else {\n      logger.error(\"Must include name in setControllerName call.\");\n    }\n\n    return;\n  }\n\n  action = action || transaction.verb || 'GET';\n  transaction.forceName = NAMES.CONTROLLER + '/' + name + '/' + action;\n};\n/**\n * Add a custom attribute to the current transaction. Some attributes are\n * reserved (see CUSTOM_BLACKLIST for the current, very short list), and\n * as with most API methods, this must be called in the context of an\n * active transaction. Most recently set value wins.\n *\n * @param {string} key  The key you want displayed in the RPM UI.\n * @param {string} value The value you want displayed. Must be serializable.\n */\n\n\nAPI.prototype.addCustomAttribute = function addCustomAttribute(key, value) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/addCustomAttribute');\n  metric.incrementCallCount(); // If high security mode is on, custom attributes are disabled.\n\n  if (this.agent.config.high_security) {\n    logger.warnOnce('Custom attributes', 'Custom attributes are disabled by high security mode.');\n    return false;\n  } else if (!this.agent.config.api.custom_attributes_enabled) {\n    logger.debug('Config.api.custom_attributes_enabled set to false, not collecting value');\n    return false;\n  }\n\n  var transaction = this.agent.tracer.getTransaction();\n\n  if (!transaction) {\n    return logger.warn('No transaction found for custom attributes.');\n  }\n\n  var trace = transaction.trace;\n\n  if (!trace.custom) {\n    return logger.warn('Could not add attribute %s to nonexistent custom attributes.', key);\n  }\n\n  if (CUSTOM_BLACKLIST.has(key)) {\n    return logger.warn('Not overwriting value of NR-only attribute %s.', key);\n  }\n\n  trace.addCustomAttribute(key, value);\n};\n/**\n * Adds all custom attributes in an object to the current transaction.\n *\n * See documentation for newrelic.addCustomAttribute for more information on\n * setting custom attributes.\n *\n * An example of setting a custom attribute object:\n *\n *    newrelic.addCustomAttributes({test: 'value', test2: 'value2'});\n *\n * @param {object} [atts]\n * @param {string} [atts.KEY] The name you want displayed in the RPM UI.\n * @param {string} [atts.KEY.VALUE] The value you want displayed. Must be serializable.\n */\n\n\nAPI.prototype.addCustomAttributes = function addCustomAttributes(atts) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/addCustomAttributes');\n  metric.incrementCallCount();\n\n  for (var key in atts) {\n    if (!properties.hasOwn(atts, key)) {\n      continue;\n    }\n\n    this.addCustomAttribute(key, atts[key]);\n  }\n};\n\nAPI.prototype.setIgnoreTransaction = util.deprecate(setIgnoreTransaction, ['API#setIgnoreTransaction is being deprecated!', 'Please use TransactionHandle#ignore to ignore a transaction.', 'Use API#getTransaction to create a new TransactionHandle instance.'].join(' '));\n/**\n * Tell the tracer whether to ignore the current transaction. The most common\n * use for this will be to mark a transaction as ignored (maybe it's handling\n * a websocket polling channel, or maybe it's an external call you don't care\n * is slow), but it's also useful when you want a transaction that would\n * otherwise be ignored due to URL or transaction name normalization rules\n * to *not* be ignored.\n *\n * @param {boolean} ignored Ignore, or don't ignore, the current transaction.\n */\n\nfunction setIgnoreTransaction(ignored) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/setIgnoreTransaction');\n  metric.incrementCallCount();\n  var transaction = this.agent.tracer.getTransaction();\n\n  if (!transaction) {\n    return logger.warn(\"No transaction found to ignore.\");\n  }\n\n  transaction.setForceIgnore(ignored);\n}\n/**\n * Send errors to New Relic that you've already handled yourself. Should be an\n * `Error` or one of its subtypes, but the API will handle strings and objects\n * that have an attached `.message` or `.stack` property.\n *\n * NOTE: Errors that are recorded using this method do _not_ obey the\n * `ignore_status_codes` configuration.\n *\n * @param {Error} error\n *  The error to be traced.\n *\n * @param {object} [customAttributes]\n *  Optional. Any custom attributes to be displayed in the New Relic UI.\n */\n\n\nAPI.prototype.noticeError = function noticeError(error, customAttributes) {\n  const metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/noticeError');\n  metric.incrementCallCount();\n\n  if (!this.agent.config.api.notice_error_enabled) {\n    logger.debug('Config.api.notice_error_enabled set to false, not collecting error');\n    return false;\n  } // If high security mode is on or custom attributes are disabled,\n  // noticeError does not collect custom attributes.\n\n\n  if (this.agent.config.high_security) {\n    logger.debug('Passing custom attributes to notice error API is disabled in high security mode.');\n  } else if (!this.agent.config.api.custom_attributes_enabled) {\n    logger.debug('Config.api.custom_attributes_enabled set to false, ' + 'ignoring custom error attributes.');\n  }\n\n  if (typeof error === 'string') {\n    error = new Error(error);\n  }\n\n  const transaction = this.agent.tracer.getTransaction(); // Filter all object type valued attributes out\n\n  let filteredAttributes = customAttributes;\n\n  if (customAttributes) {\n    filteredAttributes = _filterAttributes(customAttributes, 'noticeError');\n  }\n\n  this.agent.errors.addUserError(transaction, error, filteredAttributes);\n};\n/**\n * If the URL for a transaction matches the provided pattern, name the\n * transaction with the provided name. If there are capture groups in the\n * pattern (which is a standard JavaScript regular expression, and can be\n * passed as either a RegExp or a string), then the substring matches ($1, $2,\n * etc.) are replaced in the name string. BE CAREFUL WHEN USING SUBSTITUTION.\n * If the replacement substrings are highly variable (i.e. are identifiers,\n * GUIDs, or timestamps), the rule will generate too many metrics and\n * potentially get your application blacklisted by New Relic.\n *\n * An example of a good rule with replacements:\n *\n *   newrelic.addNamingRule('^/storefront/(v[1-5])/(item|category|tag)',\n *                          'CommerceAPI/$1/$2')\n *\n * An example of a bad rule with replacements:\n *\n *   newrelic.addNamingRule('^/item/([0-9a-f]+)', 'Item/$1')\n *\n * Keep in mind that the original URL and any query parameters will be sent\n * along with the request, so slow transactions will still be identifiable.\n *\n * Naming rules can not be removed once added. They can also be added via the\n * agent's configuration. See configuration documentation for details.\n *\n * @param {RegExp} pattern The pattern to rename (with capture groups).\n * @param {string} name    The name to use for the transaction.\n */\n\n\nAPI.prototype.addNamingRule = function addNamingRule(pattern, name) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/addNamingRule');\n  metric.incrementCallCount();\n  if (!name) return logger.error(\"Simple naming rules require a replacement name.\");\n  this.agent.userNormalizer.addSimple(pattern, '/' + name);\n};\n/**\n * If the URL for a transaction matches the provided pattern, ignore the\n * transaction attached to that URL. Useful for filtering socket.io connections\n * and other long-polling requests out of your agents to keep them from\n * distorting an app's apdex or mean response time. Pattern may be a (standard\n * JavaScript) RegExp or a string.\n *\n * Example:\n *\n *   newrelic.addIgnoringRule('^/socket\\\\.io/')\n *\n * @param {RegExp} pattern The pattern to ignore.\n */\n\n\nAPI.prototype.addIgnoringRule = function addIgnoringRule(pattern) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/addIgnoringRule');\n  metric.incrementCallCount();\n  if (!pattern) return logger.error(\"Must include a URL pattern to ignore.\");\n  this.agent.userNormalizer.addSimple(pattern, null);\n};\n/**\n * Get the <script>...</script> header necessary for Browser Monitoring\n * This script must be manually injected into your templates, as high as possible\n * in the header, but _after_ any X-UA-COMPATIBLE HTTP-EQUIV meta tags.\n * Otherwise you may hurt IE!\n *\n * This method must be called _during_ a transaction, and must be called every\n * time you want to generate the headers.\n *\n * Do *not* reuse the headers between users, or even between requests.\n *\n * @param {string} [options.nonce] - Nonce to inject into `<script>` header.\n *\n * @returns {string} The `<script>` header to be injected.\n */\n\n\nAPI.prototype.getBrowserTimingHeader = function getBrowserTimingHeader(options) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/getBrowserTimingHeader');\n  metric.incrementCallCount();\n  var config = this.agent.config;\n  /**\n   * Gracefully fail.\n   *\n   * Output an HTML comment and log a warning the comment is meant to be\n   * innocuous to the end user.\n   *\n   * @param {number} num          - Error code from `RUM_ISSUES`.\n   * @param {bool} [quite=false]  - Be quiet about this failure.\n   *\n   * @see RUM_ISSUES\n   */\n\n  function _gracefail(num, quiet) {\n    if (quiet) {\n      logger.debug(RUM_ISSUES[num]);\n    } else {\n      logger.warn(RUM_ISSUES[num]);\n    }\n\n    return '<!-- NREUM: (' + num + ') -->';\n  }\n\n  var browser_monitoring = config.browser_monitoring; // config.browser_monitoring should always exist, but we don't want the agent\n  // to bail here if something goes wrong\n\n  if (!browser_monitoring) return _gracefail(2);\n  /* Can control header generation with configuration this setting is only\n   * available in the newrelic.js config file, it is not ever set by the\n   * server.\n   */\n\n  if (!browser_monitoring.enable) {\n    // It has been disabled by the user; no need to warn them about their own\n    // settings so fail quietly and gracefully.\n    return _gracefail(0, true);\n  }\n\n  var trans = this.agent.getTransaction(); // bail gracefully outside a transaction\n\n  if (!trans || trans.isIgnored()) return _gracefail(1);\n  var name = trans.getFullName();\n  /* If we're in an unnamed transaction, add a friendly warning this is to\n   * avoid people going crazy, trying to figure out why browser monitoring is\n   * not working when they're missing a transaction name.\n   */\n\n  if (!name) return _gracefail(3);\n  var time = trans.timer.getDurationInMillis();\n  /*\n   * Only the first 13 chars of the license should be used for hashing with\n   * the transaction name.\n   */\n\n  var key = config.license_key.substr(0, 13);\n  var appid = config.application_id;\n  /* This is only going to work if the agent has successfully handshaked with\n   * the collector. If the networks is bad, or there is no license key set in\n   * newrelic.js, there will be no application_id set.  We bail instead of\n   * outputting null/undefined configuration values.\n   */\n\n  if (!appid) return _gracefail(4);\n  /* If there is no browser_key, the server has likely decided to disable\n   * browser monitoring.\n   */\n\n  var licenseKey = browser_monitoring.browser_key;\n  if (!licenseKey) return _gracefail(5);\n  /* If there is no agent_loader script, there is no point\n   * in setting the rum data\n   */\n\n  var js_agent_loader = browser_monitoring.js_agent_loader;\n  if (!js_agent_loader) return _gracefail(6);\n  /* If rum is enabled, but then later disabled on the server,\n   * this is the only parameter that gets updated.\n   *\n   * This condition should only be met if rum is disabled during\n   * the lifetime of an application, and it should be picked up\n   * on the next ForceRestart by the collector.\n   */\n\n  var loader = browser_monitoring.loader;\n  if (loader === 'none') return _gracefail(7); // This hash gets written directly into the browser.\n\n  var rum_hash = {\n    agent: browser_monitoring.js_agent_file,\n    beacon: browser_monitoring.beacon,\n    errorBeacon: browser_monitoring.error_beacon,\n    licenseKey: licenseKey,\n    applicationID: appid,\n    applicationTime: time,\n    transactionName: hashes.obfuscateNameUsingKey(name, key),\n    queueTime: trans.queueTime,\n    ttGuid: trans.id,\n    // we don't use these parameters yet\n    agentToken: null\n  };\n  var attrs = Object.create(null);\n  const customAttrs = trans.trace.custom.get(ATTR_DEST.BROWSER_EVENT);\n\n  if (!properties.isEmpty(customAttrs)) {\n    attrs.u = customAttrs;\n  }\n\n  const agentAttrs = trans.trace.attributes.get(ATTR_DEST.BROWSER_EVENT);\n\n  if (!properties.isEmpty(agentAttrs)) {\n    attrs.a = agentAttrs;\n  }\n\n  if (!properties.isEmpty(attrs)) {\n    rum_hash.atts = hashes.obfuscateNameUsingKey(JSON.stringify(attrs), key);\n  } // if debugging, do pretty format of JSON\n\n\n  var tabs = config.browser_monitoring.debug ? 2 : 0;\n  var json = JSON.stringify(rum_hash, null, tabs); // set nonce attribute if passed in options\n\n  var nonce = options && options.nonce ? 'nonce=\"' + options.nonce + '\"' : ''; // the complete header to be written to the browser\n\n  var out = util.format(RUM_STUB, nonce, json, js_agent_loader);\n  logger.trace('generating RUM header', out);\n  return out;\n};\n/**\n * @callback startSegmentCallback\n * @param {function} cb\n *   The function to time with the created segment.\n * @return {Promise=} Returns a promise if cb returns a promise.\n */\n\n/**\n * Wraps the given handler in a segment which may optionally be turned into a\n * metric.\n *\n * @example\n *  newrelic.startSegment('mySegment', false, function handler() {\n *    // The returned promise here will signify the end of the segment.\n *    return myAsyncTask().then(myNextTask)\n *  })\n *\n * @param {string} name\n *  The name to give the new segment. This will also be the name of the metric.\n *\n * @param {bool} record\n *  Indicates if the segment should be recorded as a metric. Metrics will show\n *  up on the transaction breakdown table and server breakdown graph. Segments\n *  just show up in transaction traces.\n *\n * @param {startSegmentCallback} handler\n *  The function to track as a segment.\n *\n * @param {function} [callback]\n *  An optional callback for the handler. This will indicate the end of the\n *  timing if provided.\n *\n * @return {*} Returns the result of calling `handler`.\n */\n\n\nAPI.prototype.startSegment = function startSegment(name, record, handler, callback) {\n  this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/startSegment').incrementCallCount(); // Check that we have usable arguments.\n\n  if (!name || typeof handler !== 'function') {\n    logger.warn('Name and handler function are both required for startSegment');\n\n    if (typeof handler === 'function') {\n      return handler(callback);\n    }\n\n    return;\n  }\n\n  if (callback && typeof callback !== 'function') {\n    logger.warn('If using callback, it must be a function');\n    return handler(callback);\n  } // Are we inside a transaction?\n\n\n  if (!this.shim.getActiveSegment()) {\n    logger.debug('startSegment(%j) called outside of a transaction, not recording.', name);\n    return handler(callback);\n  } // Create the segment and call the handler.\n\n\n  var wrappedHandler = this.shim.record(handler, function handlerNamer(shim) {\n    return {\n      name: name,\n      recorder: record ? customRecorder : null,\n      callback: callback ? shim.FIRST : null,\n      promise: !callback\n    };\n  });\n  return wrappedHandler(callback);\n};\n/**\n * Creates and starts a web transaction to record work done in\n * the handle supplied. This transaction will run until the handle\n * synchronously returns UNLESS:\n * 1. The handle function returns a promise, where the end of the\n *    transaction will be tied to the end of the promise returned.\n * 2. {@link API#getTransaction} is called in the handle, flagging the\n *    transaction as externally handled.  In this case the transaction\n *    will be ended when {@link TransactionHandle#end} is called in the user's code.\n *\n * @example\n * var newrelic = require('newrelic')\n * newrelic.startWebTransaction('/some/url/path', function() {\n *   var transaction = newrelic.getTransaction()\n *   setTimeout(function() {\n *     // do some work\n *     transaction.end()\n *   }, 100)\n * })\n *\n * @param {string} url\n *  The URL of the transaction.  It is used to name and group related transactions in APM,\n *  so it should be a generic name and not iclude any variable parameters.\n *\n * @param {Function}  handle\n *  Function that represents the transaction work.\n */\n\n\nAPI.prototype.startWebTransaction = function startWebTransaction(url, handle) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/startWebTransaction');\n  metric.incrementCallCount();\n\n  if (typeof handle !== 'function') {\n    logger.warn('startWebTransaction called with a handle arg that is not a function');\n    return null;\n  }\n\n  if (!url) {\n    logger.warn('startWebTransaction called without a url, transaction not started');\n    return handle();\n  }\n\n  logger.debug('starting web transaction %s (%s).', url, handle && handle.name);\n  var shim = this.shim;\n  var tracer = this.agent.tracer;\n  var parent = tracer.getTransaction();\n  return tracer.transactionNestProxy('web', function startWebSegment() {\n    var tx = tracer.getTransaction();\n\n    if (!tx) {\n      return handle.apply(this, arguments);\n    }\n\n    if (tx === parent) {\n      logger.debug('not creating nested transaction %s using transaction %s', url, tx.id);\n      return tracer.addSegment(url, null, null, true, handle);\n    }\n\n    logger.debug('creating web transaction %s (%s) with transaction id: %s', url, handle && handle.name, tx.id);\n    tx.nameState.setName(NAMES.CUSTOM, null, NAMES.ACTION_DELIMITER, url);\n    tx.url = url;\n    tx.applyUserNamingRules(tx.url);\n    tx.baseSegment = tracer.createSegment(url, recordWeb);\n    tx.baseSegment.start();\n    var boundHandle = tracer.bindFunction(handle, tx.baseSegment);\n    var returnResult = boundHandle.call(this);\n\n    if (returnResult && shim.isPromise(returnResult)) {\n      returnResult = shim.interceptPromise(returnResult, tx.end.bind(tx));\n    } else if (!tx.handledExternally) {\n      logger.debug('Ending unhandled web transaction immediately.');\n      tx.end();\n    }\n\n    return returnResult;\n  })();\n};\n\nAPI.prototype.startBackgroundTransaction = startBackgroundTransaction;\n/**\n * Creates and starts a background transaction to record work done in\n * the handle supplied. This transaction will run until the handle\n * synchronously returns UNLESS:\n * 1. The handle function returns a promise, where the end of the\n *    transaction will be tied to the end of the promise returned.\n * 2. {@link API#getTransaction} is called in the handle, flagging the\n *    transaction as externally handled.  In this case the transaction\n *    will be ended when {@link TransactionHandle#end} is called in the user's code.\n *\n * @example\n * var newrelic = require('newrelic')\n * newrelic.startBackgroundTransaction('Red October', 'Subs', function() {\n *   var transaction = newrelic.getTransaction()\n *   setTimeout(function() {\n *     // do some work\n *     transaction.end()\n *   }, 100)\n * })\n *\n * @param {string} name\n *  The name of the transaction. It is used to name and group related\n *  transactions in APM, so it should be a generic name and not iclude any\n *  variable parameters.\n *\n * @param {string} [group]\n *  Optional, used for grouping background transactions in APM. For more\n *  information see:\n *  https://docs.newrelic.com/docs/apm/applications-menu/monitoring/transactions-page#txn-type-dropdown\n *\n * @param {Function} handle\n *  Function that represents the background work.\n *\n * @memberOf API#\n */\n\nfunction startBackgroundTransaction(name, group, handle) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/startBackgroundTransaction');\n  metric.incrementCallCount();\n\n  if (handle === undefined && typeof group === 'function') {\n    handle = group;\n    group = 'Nodejs';\n  }\n\n  if (typeof handle !== 'function') {\n    logger.warn('startBackgroundTransaction called with a handle that is not a function');\n    return null;\n  }\n\n  if (!name) {\n    logger.warn('startBackgroundTransaction called without a name');\n    return handle();\n  }\n\n  logger.debug('starting background transaction %s:%s (%s)', name, group, handle && handle.name);\n  var tracer = this.agent.tracer;\n  var shim = this.shim;\n  var txName = group + '/' + name;\n  var parent = tracer.getTransaction();\n  return tracer.transactionNestProxy('bg', function startBackgroundSegment() {\n    var tx = tracer.getTransaction();\n\n    if (!tx) {\n      return handle.apply(this, arguments);\n    }\n\n    if (tx === parent) {\n      logger.debug('not creating nested transaction %s using transaction %s', txName, tx.id);\n      return tracer.addSegment(txName, null, null, true, handle);\n    }\n\n    logger.debug('creating background transaction %s:%s (%s) with transaction id: %s', name, group, handle && handle.name, tx.id);\n    tx._partialName = txName;\n    tx.baseSegment = tracer.createSegment(name, recordBackground);\n    tx.baseSegment.partialName = group;\n    tx.baseSegment.start();\n    var boundHandle = tracer.bindFunction(handle, tx.baseSegment);\n    var returnResult = boundHandle.call(this);\n\n    if (returnResult && shim.isPromise(returnResult)) {\n      returnResult = shim.interceptPromise(returnResult, tx.end.bind(tx));\n    } else if (!tx.handledExternally) {\n      logger.debug('Ending unhandled background transaction immediately.');\n      tx.end();\n    }\n\n    return returnResult;\n  })();\n}\n/**\n * End the current web or background custom transaction. This method requires being in\n * the correct transaction context when called.\n */\n\n\nAPI.prototype.endTransaction = function endTransaction() {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/endTransaction');\n  metric.incrementCallCount();\n  var tracer = this.agent.tracer;\n  var tx = tracer.getTransaction();\n\n  if (tx) {\n    if (tx.baseSegment) {\n      if (tx.type === 'web') {\n        tx.finalizeNameFromUri(tx.url, 0);\n      }\n\n      tx.baseSegment.end();\n    }\n\n    tx.end();\n    logger.debug('ended transaction with id: %s and name: %s', tx.id, tx.name);\n  } else {\n    logger.debug('endTransaction() called while not in a transaction.');\n  }\n};\n/**\n * Record a custom metric, usually associated with a particular duration.\n * The `name` must be a string following standard metric naming rules. The `value` will\n * usually be a number, but it can also be an object.\n *   * When `value` is a numeric value, it should represent the magnitude of a measurement\n *     associated with an event; for example, the duration for a particular method call.\n *   * When `value` is an object, it must contain count, total, min, max, and sumOfSquares\n *     keys, all with number values. This form is useful to aggregate metrics on your own\n *     and report them periodically; for example, from a setInterval. These values will\n *     be aggregated with any previously collected values for the same metric. The names\n *     of these keys match the names of the keys used by the platform API.\n *\n * @param  {string} name  The name of the metric.\n * @param  {number|object} value\n */\n\n\nAPI.prototype.recordMetric = function recordMetric(name, value) {\n  const supportMetric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/recordMetric');\n  supportMetric.incrementCallCount();\n\n  if (typeof name !== 'string') {\n    logger.warn('Metric name must be a string');\n    return;\n  }\n\n  const metricName = NAMES.CUSTOM + NAMES.ACTION_DELIMITER + name;\n  const metric = this.agent.metrics.getOrCreateMetric(metricName);\n\n  if (typeof value === 'number') {\n    metric.recordValue(value);\n    return;\n  }\n\n  if (typeof value !== 'object') {\n    logger.warn('Metric value must be either a number, or a metric object');\n    return;\n  }\n\n  const stats = Object.create(null);\n  const required = ['count', 'total', 'min', 'max', 'sumOfSquares'];\n  const keyMap = {\n    count: 'callCount'\n  };\n\n  for (let i = 0, l = required.length; i < l; ++i) {\n    if (typeof value[required[i]] !== 'number') {\n      logger.warn('Metric object must include %s as a number', required[i]);\n      return;\n    }\n\n    const key = keyMap[required[i]] || required[i];\n    stats[key] = value[required[i]];\n  }\n\n  if (typeof value.totalExclusive === 'number') {\n    stats.totalExclusive = value.totalExclusive;\n  } else {\n    stats.totalExclusive = value.total;\n  }\n\n  metric.merge(stats);\n};\n/**\n * Create or update a custom metric that acts as a simple counter.\n * The count of the given metric will be incremented by the specified amount,\n * defaulting to 1.\n *\n * @param  {string} name  The name of the metric.\n * @param  {number} [value] The amount that the count of the metric should be incremented\n *                          by. Defaults to 1.\n */\n\n\nAPI.prototype.incrementMetric = function incrementMetric(name, value) {\n  const metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/incrementMetric');\n  metric.incrementCallCount();\n\n  if (!value && value !== 0) {\n    value = 1;\n  }\n\n  if (typeof value !== 'number' || value % 1 !== 0) {\n    logger.warn('Metric Increment value must be an integer');\n    return;\n  }\n\n  this.recordMetric(name, {\n    count: value,\n    total: 0,\n    min: 0,\n    max: 0,\n    sumOfSquares: 0\n  });\n};\n/**\n * Record custom event data which can be queried in New Relic Insights.\n *\n * @param  {string} eventType  The name of the event. It must be an alphanumeric string\n *                             less than 255 characters.\n * @param  {object} attributes Object of key and value pairs. The keys must be shorter\n *                             than 255 characters, and the values must be string, number,\n *                             or boolean.\n */\n\n\nAPI.prototype.recordCustomEvent = function recordCustomEvent(eventType, attributes) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/recordCustomEvent');\n  metric.incrementCallCount(); // If high security mode is on, custom events are disabled.\n\n  if (this.agent.config.high_security) {\n    logger.warnOnce(\"Custom Event\", \"Custom events are disabled by high security mode.\");\n    return false;\n  } else if (!this.agent.config.api.custom_events_enabled) {\n    logger.debug(\"Config.api.custom_events_enabled set to false, not collecting value\");\n    return false;\n  }\n\n  if (!this.agent.config.custom_insights_events.enabled) {\n    return;\n  } // Check all the arguments before bailing to give maximum information in a\n  // single invocation.\n\n\n  var fail = false;\n\n  if (!eventType || typeof eventType !== 'string') {\n    logger.warn('recordCustomEvent requires a string for its first argument, got %s (%s)', stringify(eventType), typeof eventType);\n    fail = true;\n  } else if (!CUSTOM_EVENT_TYPE_REGEX.test(eventType)) {\n    logger.warn('recordCustomEvent eventType of %s is invalid, it must match /%s/', eventType, CUSTOM_EVENT_TYPE_REGEX.source);\n    fail = true;\n  } else if (eventType.length > 255) {\n    logger.warn('recordCustomEvent eventType must have a length less than 256, got %s (%s)', eventType, eventType.length);\n    fail = true;\n  } // If they don't pass an attributes object, or the attributes argument is not\n  // an object, or if it is an object and but is actually an array, log a\n  // warning and set the fail bit.\n\n\n  if (!attributes || typeof attributes !== 'object' || Array.isArray(attributes)) {\n    logger.warn('recordCustomEvent requires an object for its second argument, got %s (%s)', stringify(attributes), typeof attributes);\n    fail = true;\n  } else if (_checkKeyLength(attributes, 255)) {\n    fail = true;\n  }\n\n  if (fail) {\n    return;\n  } // Filter all object type valued attributes out\n\n\n  const filteredAttributes = _filterAttributes(attributes, `${eventType} custom event`);\n\n  var instrinics = {\n    type: eventType,\n    timestamp: Date.now()\n  };\n  var tx = this.agent.getTransaction();\n  var priority = tx && tx.priority || Math.random();\n  this.agent.customEventAggregator.add([instrinics, filteredAttributes], priority);\n};\n/**\n * Registers an instrumentation function.\n *\n *  - `newrelic.instrument(moduleName, onRequire [,onError])`\n *  - `newrelic.instrument(options)`\n *\n * @param {object} options\n *  The options for this custom instrumentation.\n *\n * @param {string} options.moduleName\n *  The module name given to require to load the module\n *\n * @param {function}  options.onRequire\n *  The function to call when the module is required\n *\n * @param {function} [options.onError]\n *  If provided, should `onRequire` throw an error, the error will be passed to\n *  this function.\n */\n\n\nAPI.prototype.instrument = function instrument(moduleName, onRequire, onError) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/instrument');\n  metric.incrementCallCount();\n  var opts = moduleName;\n\n  if (typeof opts === 'string') {\n    opts = {\n      moduleName: moduleName,\n      onRequire: onRequire,\n      onError: onError\n    };\n  }\n\n  opts.type = MODULE_TYPE.GENERIC;\n  shimmer.registerInstrumentation(opts);\n};\n/**\n * Registers an instrumentation function.\n *\n * - `newrelic.instrumentConglomerate(moduleName, onRequire [, onError])`\n * - `newrelic.isntrumentConglomerate(options)`\n *\n * @param {object} options\n *  The options for this custom instrumentation.\n *\n * @param {string} options.moduleName\n *  The module name given to require to load the module\n *\n * @param {function} options.onRequire\n *  The function to call when the module is required\n *\n * @param {function} [options.onError]\n *  If provided, should `onRequire` throw an error, the error will be passed to\n *  this function.\n */\n\n\nAPI.prototype.instrumentConglomerate = function instrumentConglomerate(moduleName, onRequire, onError) {\n  this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/instrumentConglomerate').incrementCallCount();\n  let opts = moduleName;\n\n  if (typeof opts === 'string') {\n    opts = {\n      moduleName,\n      onRequire,\n      onError\n    };\n  }\n\n  opts.type = MODULE_TYPE.CONGLOMERATE;\n  shimmer.registerInstrumentation(opts);\n};\n/**\n * Registers an instrumentation function.\n *\n *  - `newrelic.instrumentDatastore(moduleName, onRequire [,onError])`\n *  - `newrelic.instrumentDatastore(options)`\n *\n * @param {object} options\n *  The options for this custom instrumentation.\n *\n * @param {string} options.moduleName\n *  The module name given to require to load the module\n *\n * @param {function} options.onRequire\n *  The function to call when the module is required\n *\n * @param {function} [options.onError]\n *  If provided, should `onRequire` throw an error, the error will be passed to\n *  this function.\n */\n\n\nAPI.prototype.instrumentDatastore = function instrumentDatastore(moduleName, onRequire, onError) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/instrumentDatastore');\n  metric.incrementCallCount();\n  var opts = moduleName;\n\n  if (typeof opts === 'string') {\n    opts = {\n      moduleName: moduleName,\n      onRequire: onRequire,\n      onError: onError\n    };\n  }\n\n  opts.type = MODULE_TYPE.DATASTORE;\n  shimmer.registerInstrumentation(opts);\n};\n/**\n * Applies an instrumentation to an already loaded module.\n *\n *    // oh no, express was loaded before newrelic\n *    const express   = require('express')\n *    const newrelic  = require('newrelic')\n *\n *    // phew, we can use instrumentLoadedModule to make\n *    // sure express is still instrumented\n *    newrelic.instrumentLoadedModule('express', express)\n *\n * @param {string} moduleName\n *  The module's name/identifier.  Will be normalized\n *  into an instrumentation key.\n *\n * @param {object} module\n *  The actual module object or function we're instrumenting\n */\n\n\nAPI.prototype.instrumentLoadedModule = function instrumentLoadedModule(moduleName, module) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/instrumentLoadedModule');\n  metric.incrementCallCount();\n  const instrumentationName = shimmer.getInstrumentationNameFromModuleName(moduleName);\n\n  if (!shimmer.registeredInstrumentations[instrumentationName]) {\n    logger.warn(\"No instrumentation registered for '%s'.\", instrumentationName);\n    return false;\n  }\n\n  const instrumentation = shimmer.registeredInstrumentations[instrumentationName];\n\n  if (!instrumentation.onRequire) {\n    logger.warn(\"No onRequire function registered for '%s'.\", instrumentationName);\n    return false;\n  }\n\n  const resolvedName = require.resolve(moduleName);\n\n  const shim = shims.createShimFromType(instrumentation.type, this.agent, moduleName, resolvedName);\n  instrumentation.onRequire(shim, module, moduleName);\n  return true;\n};\n/**\n * Registers an instrumentation function.\n *\n *  - `newrelic.instrumentWebframework(moduleName, onRequire [,onError])`\n *  - `newrelic.instrumentWebframework(options)`\n *\n * @param {object} options\n *  The options for this custom instrumentation.\n *\n * @param {string} options.moduleName\n *  The module name given to require to load the module\n *\n * @param {function}  options.onRequire\n *  The function to call when the module is required\n *\n * @param {function} [options.onError]\n *  If provided, should `onRequire` throw an error, the error will be passed to\n *  this function.\n */\n\n\nAPI.prototype.instrumentWebframework = function instrumentWebframework(moduleName, onRequire, onError) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/instrumentWebframework');\n  metric.incrementCallCount();\n  var opts = moduleName;\n\n  if (typeof opts === 'string') {\n    opts = {\n      moduleName: moduleName,\n      onRequire: onRequire,\n      onError: onError\n    };\n  }\n\n  opts.type = MODULE_TYPE.WEB_FRAMEWORK;\n  shimmer.registerInstrumentation(opts);\n};\n/**\n * Registers an instrumentation function for instrumenting message brokers.\n *\n *  - `newrelic.instrumentMessages(moduleName, onRequire [,onError])`\n *  - `newrelic.instrumentMessages(options)`\n *\n * @param {object} options\n *  The options for this custom instrumentation.\n *\n * @param {string} options.moduleName\n *  The module name given to require to load the module\n *\n * @param {function}  options.onRequire\n *  The function to call when the module is required\n *\n * @param {function} [options.onError]\n *  If provided, should `onRequire` throw an error, the error will be passed to\n *  this function.\n */\n\n\nAPI.prototype.instrumentMessages = function instrumentMessages(moduleName, onRequire, onError) {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/instrumentMessages');\n  metric.incrementCallCount();\n  var opts = moduleName;\n\n  if (typeof opts === 'string') {\n    opts = {\n      moduleName: moduleName,\n      onRequire: onRequire,\n      onError: onError\n    };\n  }\n\n  opts.type = MODULE_TYPE.MESSAGE;\n  shimmer.registerInstrumentation(opts);\n};\n/**\n * Returns the current trace and span id.\n *\n * @returns {*} The object containing the current trace and span ids\n */\n\n\nAPI.prototype.getTraceMetadata = function getTraceMetadata() {\n  var metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/getTraceMetadata');\n  metric.incrementCallCount();\n  const metadata = {};\n  const segment = this.agent.tracer.getSegment();\n\n  if (!segment) {\n    logger.debug(\"No transaction found when calling API#getTraceMetadata\");\n  } else if (!this.agent.config.distributed_tracing.enabled) {\n    logger.debug(\"Distributed tracing disabled when calling API#getTraceMetadata\");\n  } else {\n    metadata.traceId = segment.transaction.getTraceId();\n    const spanId = segment.getSpanId();\n\n    if (spanId) {\n      metadata.spanId = spanId;\n    }\n  }\n\n  return metadata;\n};\n/**\n * Shuts down the agent.\n *\n * @param {object} [options]\n *  Object with shut down options.\n *\n * @param {boolean} [options.collectPendingData=false]\n *  If true, the agent will send any pending data to the collector before\n *  shutting down.\n *\n * @param {number} [options.timeout=0]\n *  Time in milliseconds to wait before shutting down.\n *\n * @param {boolean} [options.waitForIdle=false]\n *  If true, the agent will not shut down until there are no active transactions.\n *\n * @param {function} [callback]\n *  Callback function that runs when agent stops.\n */\n\n\nAPI.prototype.shutdown = function shutdown(options, cb) {\n  this.agent.metrics.getOrCreateMetric(`${NAMES.SUPPORTABILITY.API}/shutdown`).incrementCallCount();\n  let callback = cb;\n\n  if (typeof options === 'function') {\n    // shutdown(cb)\n    callback = options;\n    options = {};\n  } else if (typeof callback !== 'function') {\n    // shutdown([options])\n    callback = () => {};\n  }\n\n  if (!options) {\n    // shutdown(null, cb)\n    options = {};\n  }\n\n  _doShutdown(this, options, callback);\n};\n\nfunction _doShutdown(api, options, callback) {\n  const agent = api.agent; // If we need to wait for idle and there are currently active transactions,\n  // listen for transactions ending and check if we're ready to go.\n\n  if (options.waitForIdle && agent.activeTransactions) {\n    options.waitForIdle = false; // To prevent recursive waiting.\n\n    agent.on('transactionFinished', function onTransactionFinished() {\n      if (agent.activeTransactions === 0) {\n        setImmediate(_doShutdown, api, options, callback);\n      }\n    });\n    return;\n  }\n\n  function afterHarvest(error) {\n    if (error) {\n      logger.error(error, 'An error occurred while running last harvest before shutdown.');\n    }\n\n    agent.stop(callback);\n  }\n\n  if (options.collectPendingData && agent._state !== 'started') {\n    if (typeof options.timeout === 'number') {\n      setTimeout(function shutdownTimeout() {\n        agent.stop(callback);\n      }, options.timeout).unref();\n    } else if (options.timeout) {\n      logger.warn('options.timeout should be of type \"number\". Got %s', typeof options.timeout);\n    }\n\n    agent.on('started', function shutdownHarvest() {\n      agent.forceHarvestAll(afterHarvest);\n    });\n    agent.on('errored', function logShutdownError(error) {\n      agent.stop(callback);\n\n      if (error) {\n        logger.error(error, 'The agent encountered an error after calling shutdown.');\n      }\n    });\n  } else if (options.collectPendingData) {\n    agent.forceHarvestAll(afterHarvest);\n  } else {\n    agent.stop(callback);\n  }\n}\n\nfunction _checkKeyLength(object, maxLength) {\n  var keys = Object.keys(object);\n  var badKey = false;\n  var len = keys.length;\n  var key = ''; // init to string because gotta go fast\n\n  for (var i = 0; i < len; i++) {\n    key = keys[i];\n\n    if (key.length > maxLength) {\n      logger.warn('recordCustomEvent requires keys to be less than 256 chars got %s (%s)', key, key.length);\n      badKey = true;\n    }\n  }\n\n  return badKey;\n}\n\nAPI.prototype.setLambdaHandler = function setLambdaHandler(handler) {\n  const metric = this.agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.API + '/setLambdaHandler');\n  metric.incrementCallCount();\n  return this.awsLambda.patchLambdaHandler(handler);\n};\n\nfunction _filterAttributes(attributes, name) {\n  const filteredAttributes = Object.create(null);\n  Object.keys(attributes).forEach(attributeKey => {\n    if (!isValidType(attributes[attributeKey])) {\n      logger.info(`Omitting attribute ${attributeKey} from ${name} call, type must ` + 'be boolean, number, or string');\n      return;\n    }\n\n    filteredAttributes[attributeKey] = attributes[attributeKey];\n  });\n  return filteredAttributes;\n}\n\nmodule.exports = API;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/api.js"],"names":["util","require","logger","child","component","recordWeb","recordBackground","customRecorder","hashes","properties","stringify","shimmer","shims","isValidType","TransactionShim","TransactionHandle","AwsLambda","ATTR_DEST","DESTINATIONS","MODULE_TYPE","NAMES","RUM_STUB","RUM_ISSUES","CUSTOM_BLACKLIST","Set","CUSTOM_EVENT_TYPE_REGEX","API","agent","shim","awsLambda","prototype","setTransactionName","name","metric","metrics","getOrCreateMetric","SUPPORTABILITY","incrementCallCount","transaction","tracer","getTransaction","warn","url","error","trace","id","forceName","CUSTOM","debug","Stub","handledExternally","getLinkingMetadata","omitSupportability","segment","getSegment","config","linkingMetadata","applications","getHostnameSafe","distributed_tracing","enabled","getTraceId","spanId","getSpanId","entity_guid","setDispatcher","version","String","info","environment","setControllerName","action","verb","CONTROLLER","addCustomAttribute","key","value","high_security","warnOnce","api","custom_attributes_enabled","custom","has","addCustomAttributes","atts","hasOwn","setIgnoreTransaction","deprecate","join","ignored","setForceIgnore","noticeError","customAttributes","notice_error_enabled","Error","filteredAttributes","_filterAttributes","errors","addUserError","addNamingRule","pattern","userNormalizer","addSimple","addIgnoringRule","getBrowserTimingHeader","options","_gracefail","num","quiet","browser_monitoring","enable","trans","isIgnored","getFullName","time","timer","getDurationInMillis","license_key","substr","appid","application_id","licenseKey","browser_key","js_agent_loader","loader","rum_hash","js_agent_file","beacon","errorBeacon","error_beacon","applicationID","applicationTime","transactionName","obfuscateNameUsingKey","queueTime","ttGuid","agentToken","attrs","Object","create","customAttrs","get","BROWSER_EVENT","isEmpty","u","agentAttrs","attributes","a","JSON","tabs","json","nonce","out","format","startSegment","record","handler","callback","getActiveSegment","wrappedHandler","handlerNamer","recorder","FIRST","promise","startWebTransaction","handle","parent","transactionNestProxy","startWebSegment","tx","apply","arguments","addSegment","nameState","setName","ACTION_DELIMITER","applyUserNamingRules","baseSegment","createSegment","start","boundHandle","bindFunction","returnResult","call","isPromise","interceptPromise","end","bind","startBackgroundTransaction","group","undefined","txName","startBackgroundSegment","_partialName","partialName","endTransaction","type","finalizeNameFromUri","recordMetric","supportMetric","metricName","recordValue","stats","required","keyMap","count","i","l","length","totalExclusive","total","merge","incrementMetric","min","max","sumOfSquares","recordCustomEvent","eventType","custom_events_enabled","custom_insights_events","fail","test","source","Array","isArray","_checkKeyLength","instrinics","timestamp","Date","now","priority","Math","random","customEventAggregator","add","instrument","moduleName","onRequire","onError","opts","GENERIC","registerInstrumentation","instrumentConglomerate","CONGLOMERATE","instrumentDatastore","DATASTORE","instrumentLoadedModule","module","instrumentationName","getInstrumentationNameFromModuleName","registeredInstrumentations","instrumentation","resolvedName","resolve","createShimFromType","instrumentWebframework","WEB_FRAMEWORK","instrumentMessages","MESSAGE","getTraceMetadata","metadata","traceId","shutdown","cb","_doShutdown","waitForIdle","activeTransactions","on","onTransactionFinished","setImmediate","afterHarvest","stop","collectPendingData","_state","timeout","setTimeout","shutdownTimeout","unref","shutdownHarvest","forceHarvestAll","logShutdownError","object","maxLength","keys","badKey","len","setLambdaHandler","patchLambdaHandler","forEach","attributeKey","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst util = require('util')\nconst logger = require('./lib/logger').child({component: 'api'})\nconst recordWeb = require('./lib/metrics/recorders/http')\nconst recordBackground = require('./lib/metrics/recorders/other')\nconst customRecorder = require('./lib/metrics/recorders/custom')\nconst hashes = require('./lib/util/hashes')\nconst properties = require('./lib/util/properties')\nconst stringify = require('json-stringify-safe')\nconst shimmer = require('./lib/shimmer')\nconst shims = require('./lib/shim')\nconst isValidType = require('./lib/util/attribute-types')\nconst TransactionShim = require('./lib/shim/transaction-shim')\nconst TransactionHandle = require('./lib/transaction/handle')\nconst AwsLambda = require('./lib/serverless/aws-lambda')\n\nconst ATTR_DEST = require('./lib/config/attribute-filter').DESTINATIONS\nconst MODULE_TYPE = require('./lib/shim/constants').MODULE_TYPE\nconst NAMES = require('./lib/metrics/names')\n/*\n *\n * CONSTANTS\n *\n */\nconst RUM_STUB = \"<script type='text/javascript' %s>window.NREUM||(NREUM={});\" +\n                \"NREUM.info = %s; %s</script>\"\n\n// these messages are used in the _gracefail() method below in getBrowserTimingHeader\nconst RUM_ISSUES = [\n  'NREUM: no browser monitoring headers generated; disabled',\n  'NREUM: transaction missing or ignored while generating browser monitoring headers',\n  'NREUM: config.browser_monitoring missing, something is probably wrong',\n  'NREUM: browser_monitoring headers need a transaction name',\n  'NREUM: browser_monitoring requires valid application_id',\n  'NREUM: browser_monitoring requires valid browser_key',\n  'NREUM: browser_monitoring requires js_agent_loader script',\n  'NREUM: browser_monitoring disabled by browser_monitoring.loader config'\n]\n\n// Can't overwrite internal parameters or all heck will break loose.\nconst CUSTOM_BLACKLIST = new Set([\n  'nr_flatten_leading'\n])\n\nconst CUSTOM_EVENT_TYPE_REGEX = /^[a-zA-Z0-9:_ ]+$/\n\n/**\n * The exported New Relic API. This contains all of the functions meant to be\n * used by New Relic customers. For now, that means transaction naming.\n *\n * You do not need to directly instantiate this class, as an instance of this is\n * the return from `require('newrelic')`.\n *\n * @constructor\n */\nfunction API(agent) {\n  this.agent = agent\n  this.shim = new TransactionShim(agent, 'NewRelicAPI')\n  this.awsLambda = new AwsLambda(agent)\n}\n\n/**\n * Give the current transaction a custom name. Overrides any New Relic naming\n * rules set in configuration or from New Relic's servers.\n *\n * IMPORTANT: this function must be called when a transaction is active. New\n * Relic transactions are tied to web requests, so this method may be called\n * from within HTTP or HTTPS listener functions, Express routes, or other\n * contexts where a web request or response object are in scope.\n *\n * @param {string} name The name you want to give the web request in the New\n *                      Relic UI. Will be prefixed with 'Custom/' when sent.\n */\nAPI.prototype.setTransactionName = function setTransactionName(name) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/setTransactionName'\n  )\n  metric.incrementCallCount()\n\n  var transaction = this.agent.tracer.getTransaction()\n  if (!transaction) {\n    return logger.warn(\"No transaction found when setting name to '%s'.\", name)\n  }\n\n  if (!name) {\n    if (transaction && transaction.url) {\n      logger.error(\n        \"Must include name in setTransactionName call for URL %s.\",\n        transaction.url\n      )\n    } else {\n      logger.error(\"Must include name in setTransactionName call.\")\n    }\n\n    return\n  }\n\n  logger.trace('Setting transaction %s name to %s', transaction.id, name)\n  transaction.forceName = NAMES.CUSTOM + '/' + name\n}\n\n/**\n * This method returns an object with the following methods:\n * - end: end the transaction that was active when `API#getTransaction`\n *   was called.\n *\n * - ignore: set the transaction that was active when\n *   `API#getTransaction` was called to be ignored.\n *\n * @returns {TransactionHandle} The transaction object with the `end` and\n *  `ignore` methods on it.\n */\nAPI.prototype.getTransaction = function getTransaction() {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/getTransaction'\n  )\n  metric.incrementCallCount()\n\n  var transaction = this.agent.tracer.getTransaction()\n  if (!transaction) {\n    logger.debug(\"No transaction found when calling API#getTransaction\")\n    return new TransactionHandle.Stub()\n  }\n\n  transaction.handledExternally = true\n\n  return new TransactionHandle(transaction)\n}\n\n/**\n * This method returns an object with the following keys/data:\n * - `trace.id`: The current trace ID\n * - `span.id`: The current span ID\n * - `entity.name`: The application name specified in the connect request as\n *   app_name. If multiple application names are specified this will only be\n *   the first name\n * - `entity.type`: The string \"SERVICE\"\n * - `entity.guid`: The entity ID returned in the connect reply as entity_guid\n * - `hostname`: The hostname as specified in the connect request as\n *   utilization.full_hostname. If utilization.full_hostname is null or empty,\n *   this will be the hostname specified in the connect request as host.\n *\n * @returns {LinkingMetadata} The linking object with the data above\n */\nAPI.prototype.getLinkingMetadata = function getLinkingMetadata(omitSupportability) {\n  if (omitSupportability !== true) {\n    const metric = this.agent.metrics.getOrCreateMetric(\n      NAMES.SUPPORTABILITY.API + '/getLinkingMetadata'\n    )\n    metric.incrementCallCount()\n  }\n\n  const agent = this.agent\n\n  const segment = agent.tracer.getSegment()\n  const config = agent.config\n\n  const linkingMetadata = {\n    'entity.name': config.applications()[0],\n    'entity.type': 'SERVICE',\n    'hostname': config.getHostnameSafe()\n  }\n\n  if (config.distributed_tracing.enabled && segment) {\n    linkingMetadata['trace.id'] = segment.transaction.getTraceId()\n    const spanId = segment.getSpanId()\n    if (spanId) {\n      linkingMetadata['span.id'] = spanId\n    }\n  } else {\n    logger.debug('getLinkingMetadata with no active transaction')\n  }\n\n  if (config.entity_guid) {\n    linkingMetadata['entity.guid'] = config.entity_guid\n  }\n\n  return linkingMetadata\n}\n\n/**\n * Specify the `Dispatcher` and `Dispatcher Version` environment values.\n * A dispatcher is typically the service responsible for brokering\n * the request with the process responsible for responding to the\n * request.  For example Node's `http` module would be the dispatcher\n * for incoming HTTP requests.\n *\n * @param {string} name The string you would like to report to New Relic\n *                      as the dispatcher.\n *\n * @param {string} [version] The dispatcher version you would like to\n *                           report to New Relic\n */\nAPI.prototype.setDispatcher = function setDispatcher(name, version) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/setDispatcher'\n  )\n  metric.incrementCallCount()\n\n  if (!name || typeof name !== 'string') {\n    logger.error(\"setDispatcher must be called with a name, and name must be a string.\")\n    return\n  }\n\n  // No objects allowed.\n  if (version && typeof version !== 'object') {\n    version = String(version)\n  } else {\n    logger.info('setDispatcher was called with an object as the version parameter')\n    version = null\n  }\n\n  this.agent.environment.setDispatcher(name, version, true)\n}\n\n/**\n * Give the current transaction a name based on your own idea of what\n * constitutes a controller in your Node application. Also allows you to\n * optionally specify the action being invoked on the controller. If the action\n * is omitted, then the API will default to using the HTTP method used in the\n * request (e.g. GET, POST, DELETE). Overrides any New Relic naming rules set\n * in configuration or from New Relic's servers.\n *\n * IMPORTANT: this function must be called when a transaction is active. New\n * Relic transactions are tied to web requests, so this method may be called\n * from within HTTP or HTTPS listener functions, Express routes, or other\n * contexts where a web request or response object are in scope.\n *\n * @param {string} name   The name you want to give the controller in the New\n *                        Relic UI. Will be prefixed with 'Controller/' when\n *                        sent.\n * @param {string} action The action being invoked on the controller. Defaults\n *                        to the HTTP method used for the request.\n */\nAPI.prototype.setControllerName = function setControllerName(name, action) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/setControllerName'\n  )\n  metric.incrementCallCount()\n\n  var transaction = this.agent.tracer.getTransaction()\n  if (!transaction) {\n    return logger.warn(\"No transaction found when setting controller to %s.\", name)\n  }\n\n  if (!name) {\n    if (transaction && transaction.url) {\n      logger.error(\n        \"Must include name in setControllerName call for URL %s.\",\n        transaction.url\n      )\n    } else {\n      logger.error(\"Must include name in setControllerName call.\")\n    }\n\n    return\n  }\n\n  action = action || transaction.verb || 'GET'\n  transaction.forceName = NAMES.CONTROLLER + '/' + name + '/' + action\n}\n\n\n/**\n * Add a custom attribute to the current transaction. Some attributes are\n * reserved (see CUSTOM_BLACKLIST for the current, very short list), and\n * as with most API methods, this must be called in the context of an\n * active transaction. Most recently set value wins.\n *\n * @param {string} key  The key you want displayed in the RPM UI.\n * @param {string} value The value you want displayed. Must be serializable.\n */\nAPI.prototype.addCustomAttribute = function addCustomAttribute(key, value) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/addCustomAttribute'\n  )\n  metric.incrementCallCount()\n\n  // If high security mode is on, custom attributes are disabled.\n  if (this.agent.config.high_security) {\n    logger.warnOnce(\n      'Custom attributes',\n      'Custom attributes are disabled by high security mode.'\n    )\n    return false\n  } else if (!this.agent.config.api.custom_attributes_enabled) {\n    logger.debug(\n      'Config.api.custom_attributes_enabled set to false, not collecting value'\n    )\n    return false\n  }\n\n  var transaction = this.agent.tracer.getTransaction()\n  if (!transaction) {\n    return logger.warn('No transaction found for custom attributes.')\n  }\n\n  var trace = transaction.trace\n  if (!trace.custom) {\n    return logger.warn(\n      'Could not add attribute %s to nonexistent custom attributes.',\n      key\n    )\n  }\n\n  if (CUSTOM_BLACKLIST.has(key)) {\n    return logger.warn('Not overwriting value of NR-only attribute %s.', key)\n  }\n\n  trace.addCustomAttribute(key, value)\n}\n\n/**\n * Adds all custom attributes in an object to the current transaction.\n *\n * See documentation for newrelic.addCustomAttribute for more information on\n * setting custom attributes.\n *\n * An example of setting a custom attribute object:\n *\n *    newrelic.addCustomAttributes({test: 'value', test2: 'value2'});\n *\n * @param {object} [atts]\n * @param {string} [atts.KEY] The name you want displayed in the RPM UI.\n * @param {string} [atts.KEY.VALUE] The value you want displayed. Must be serializable.\n */\nAPI.prototype.addCustomAttributes = function addCustomAttributes(atts) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/addCustomAttributes'\n  )\n  metric.incrementCallCount()\n\n  for (var key in atts) {\n    if (!properties.hasOwn(atts, key)) {\n      continue\n    }\n\n    this.addCustomAttribute(key, atts[key])\n  }\n}\n\nAPI.prototype.setIgnoreTransaction = util.deprecate(\n  setIgnoreTransaction, [\n    'API#setIgnoreTransaction is being deprecated!',\n    'Please use TransactionHandle#ignore to ignore a transaction.',\n    'Use API#getTransaction to create a new TransactionHandle instance.'\n  ].join(' ')\n)\n\n/**\n * Tell the tracer whether to ignore the current transaction. The most common\n * use for this will be to mark a transaction as ignored (maybe it's handling\n * a websocket polling channel, or maybe it's an external call you don't care\n * is slow), but it's also useful when you want a transaction that would\n * otherwise be ignored due to URL or transaction name normalization rules\n * to *not* be ignored.\n *\n * @param {boolean} ignored Ignore, or don't ignore, the current transaction.\n */\nfunction setIgnoreTransaction(ignored) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/setIgnoreTransaction'\n  )\n  metric.incrementCallCount()\n\n  var transaction = this.agent.tracer.getTransaction()\n  if (!transaction) {\n    return logger.warn(\"No transaction found to ignore.\")\n  }\n\n  transaction.setForceIgnore(ignored)\n}\n\n/**\n * Send errors to New Relic that you've already handled yourself. Should be an\n * `Error` or one of its subtypes, but the API will handle strings and objects\n * that have an attached `.message` or `.stack` property.\n *\n * NOTE: Errors that are recorded using this method do _not_ obey the\n * `ignore_status_codes` configuration.\n *\n * @param {Error} error\n *  The error to be traced.\n *\n * @param {object} [customAttributes]\n *  Optional. Any custom attributes to be displayed in the New Relic UI.\n */\nAPI.prototype.noticeError = function noticeError(error, customAttributes) {\n  const metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/noticeError'\n  )\n  metric.incrementCallCount()\n\n  if (!this.agent.config.api.notice_error_enabled) {\n    logger.debug(\n      'Config.api.notice_error_enabled set to false, not collecting error'\n    )\n    return false\n  }\n\n  // If high security mode is on or custom attributes are disabled,\n  // noticeError does not collect custom attributes.\n  if (this.agent.config.high_security) {\n    logger.debug(\n      'Passing custom attributes to notice error API is disabled in high security mode.'\n    )\n  } else if (!this.agent.config.api.custom_attributes_enabled) {\n    logger.debug(\n      'Config.api.custom_attributes_enabled set to false, ' +\n      'ignoring custom error attributes.'\n    )\n  }\n\n  if (typeof error === 'string') {\n    error = new Error(error)\n  }\n  const transaction = this.agent.tracer.getTransaction()\n\n  // Filter all object type valued attributes out\n  let filteredAttributes = customAttributes\n  if (customAttributes) {\n    filteredAttributes = _filterAttributes(customAttributes, 'noticeError')\n  }\n\n  this.agent.errors.addUserError(transaction, error, filteredAttributes)\n}\n\n/**\n * If the URL for a transaction matches the provided pattern, name the\n * transaction with the provided name. If there are capture groups in the\n * pattern (which is a standard JavaScript regular expression, and can be\n * passed as either a RegExp or a string), then the substring matches ($1, $2,\n * etc.) are replaced in the name string. BE CAREFUL WHEN USING SUBSTITUTION.\n * If the replacement substrings are highly variable (i.e. are identifiers,\n * GUIDs, or timestamps), the rule will generate too many metrics and\n * potentially get your application blacklisted by New Relic.\n *\n * An example of a good rule with replacements:\n *\n *   newrelic.addNamingRule('^/storefront/(v[1-5])/(item|category|tag)',\n *                          'CommerceAPI/$1/$2')\n *\n * An example of a bad rule with replacements:\n *\n *   newrelic.addNamingRule('^/item/([0-9a-f]+)', 'Item/$1')\n *\n * Keep in mind that the original URL and any query parameters will be sent\n * along with the request, so slow transactions will still be identifiable.\n *\n * Naming rules can not be removed once added. They can also be added via the\n * agent's configuration. See configuration documentation for details.\n *\n * @param {RegExp} pattern The pattern to rename (with capture groups).\n * @param {string} name    The name to use for the transaction.\n */\nAPI.prototype.addNamingRule = function addNamingRule(pattern, name) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/addNamingRule'\n  )\n  metric.incrementCallCount()\n\n\n  if (!name) return logger.error(\"Simple naming rules require a replacement name.\")\n\n  this.agent.userNormalizer.addSimple(pattern, '/' + name)\n}\n\n/**\n * If the URL for a transaction matches the provided pattern, ignore the\n * transaction attached to that URL. Useful for filtering socket.io connections\n * and other long-polling requests out of your agents to keep them from\n * distorting an app's apdex or mean response time. Pattern may be a (standard\n * JavaScript) RegExp or a string.\n *\n * Example:\n *\n *   newrelic.addIgnoringRule('^/socket\\\\.io/')\n *\n * @param {RegExp} pattern The pattern to ignore.\n */\nAPI.prototype.addIgnoringRule = function addIgnoringRule(pattern) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/addIgnoringRule'\n  )\n  metric.incrementCallCount()\n\n  if (!pattern) return logger.error(\"Must include a URL pattern to ignore.\")\n\n  this.agent.userNormalizer.addSimple(pattern, null)\n}\n\n/**\n * Get the <script>...</script> header necessary for Browser Monitoring\n * This script must be manually injected into your templates, as high as possible\n * in the header, but _after_ any X-UA-COMPATIBLE HTTP-EQUIV meta tags.\n * Otherwise you may hurt IE!\n *\n * This method must be called _during_ a transaction, and must be called every\n * time you want to generate the headers.\n *\n * Do *not* reuse the headers between users, or even between requests.\n *\n * @param {string} [options.nonce] - Nonce to inject into `<script>` header.\n *\n * @returns {string} The `<script>` header to be injected.\n */\nAPI.prototype.getBrowserTimingHeader = function getBrowserTimingHeader(options) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/getBrowserTimingHeader'\n  )\n  metric.incrementCallCount()\n\n  var config = this.agent.config\n\n  /**\n   * Gracefully fail.\n   *\n   * Output an HTML comment and log a warning the comment is meant to be\n   * innocuous to the end user.\n   *\n   * @param {number} num          - Error code from `RUM_ISSUES`.\n   * @param {bool} [quite=false]  - Be quiet about this failure.\n   *\n   * @see RUM_ISSUES\n   */\n  function _gracefail(num, quiet) {\n    if (quiet) {\n      logger.debug(RUM_ISSUES[num])\n    } else {\n      logger.warn(RUM_ISSUES[num])\n    }\n    return '<!-- NREUM: (' + num + ') -->'\n  }\n\n  var browser_monitoring = config.browser_monitoring\n\n  // config.browser_monitoring should always exist, but we don't want the agent\n  // to bail here if something goes wrong\n  if (!browser_monitoring) return _gracefail(2)\n\n  /* Can control header generation with configuration this setting is only\n   * available in the newrelic.js config file, it is not ever set by the\n   * server.\n   */\n  if (!browser_monitoring.enable) {\n    // It has been disabled by the user; no need to warn them about their own\n    // settings so fail quietly and gracefully.\n    return _gracefail(0, true)\n  }\n\n  var trans = this.agent.getTransaction()\n\n  // bail gracefully outside a transaction\n  if (!trans || trans.isIgnored()) return _gracefail(1)\n\n  var name = trans.getFullName()\n\n  /* If we're in an unnamed transaction, add a friendly warning this is to\n   * avoid people going crazy, trying to figure out why browser monitoring is\n   * not working when they're missing a transaction name.\n   */\n  if (!name) return _gracefail(3)\n\n  var time = trans.timer.getDurationInMillis()\n\n  /*\n   * Only the first 13 chars of the license should be used for hashing with\n   * the transaction name.\n   */\n  var key = config.license_key.substr(0, 13)\n  var appid = config.application_id\n\n  /* This is only going to work if the agent has successfully handshaked with\n   * the collector. If the networks is bad, or there is no license key set in\n   * newrelic.js, there will be no application_id set.  We bail instead of\n   * outputting null/undefined configuration values.\n   */\n  if (!appid) return _gracefail(4)\n\n  /* If there is no browser_key, the server has likely decided to disable\n   * browser monitoring.\n   */\n  var licenseKey = browser_monitoring.browser_key\n  if (!licenseKey) return _gracefail(5)\n\n  /* If there is no agent_loader script, there is no point\n   * in setting the rum data\n   */\n  var js_agent_loader = browser_monitoring.js_agent_loader\n  if (!js_agent_loader) return _gracefail(6)\n\n  /* If rum is enabled, but then later disabled on the server,\n   * this is the only parameter that gets updated.\n   *\n   * This condition should only be met if rum is disabled during\n   * the lifetime of an application, and it should be picked up\n   * on the next ForceRestart by the collector.\n   */\n  var loader = browser_monitoring.loader\n  if (loader === 'none') return _gracefail(7)\n\n  // This hash gets written directly into the browser.\n  var rum_hash = {\n    agent: browser_monitoring.js_agent_file,\n    beacon: browser_monitoring.beacon,\n    errorBeacon: browser_monitoring.error_beacon,\n    licenseKey: licenseKey,\n    applicationID: appid,\n    applicationTime: time,\n    transactionName: hashes.obfuscateNameUsingKey(name, key),\n    queueTime: trans.queueTime,\n    ttGuid: trans.id,\n\n    // we don't use these parameters yet\n    agentToken: null\n  }\n\n  var attrs = Object.create(null)\n\n  const customAttrs = trans.trace.custom.get(ATTR_DEST.BROWSER_EVENT)\n  if (!properties.isEmpty(customAttrs)) {\n    attrs.u = customAttrs\n  }\n\n  const agentAttrs = trans.trace.attributes.get(ATTR_DEST.BROWSER_EVENT)\n  if (!properties.isEmpty(agentAttrs)) {\n    attrs.a = agentAttrs\n  }\n\n  if (!properties.isEmpty(attrs)) {\n    rum_hash.atts = hashes.obfuscateNameUsingKey(JSON.stringify(attrs), key)\n  }\n\n  // if debugging, do pretty format of JSON\n  var tabs = config.browser_monitoring.debug ? 2 : 0\n  var json = JSON.stringify(rum_hash, null, tabs)\n\n  // set nonce attribute if passed in options\n  var nonce = options && options.nonce ? 'nonce=\"' + options.nonce + '\"' : ''\n\n  // the complete header to be written to the browser\n  var out = util.format(\n    RUM_STUB,\n    nonce,\n    json,\n    js_agent_loader\n  )\n\n  logger.trace('generating RUM header', out)\n\n  return out\n}\n\n/**\n * @callback startSegmentCallback\n * @param {function} cb\n *   The function to time with the created segment.\n * @return {Promise=} Returns a promise if cb returns a promise.\n */\n\n/**\n * Wraps the given handler in a segment which may optionally be turned into a\n * metric.\n *\n * @example\n *  newrelic.startSegment('mySegment', false, function handler() {\n *    // The returned promise here will signify the end of the segment.\n *    return myAsyncTask().then(myNextTask)\n *  })\n *\n * @param {string} name\n *  The name to give the new segment. This will also be the name of the metric.\n *\n * @param {bool} record\n *  Indicates if the segment should be recorded as a metric. Metrics will show\n *  up on the transaction breakdown table and server breakdown graph. Segments\n *  just show up in transaction traces.\n *\n * @param {startSegmentCallback} handler\n *  The function to track as a segment.\n *\n * @param {function} [callback]\n *  An optional callback for the handler. This will indicate the end of the\n *  timing if provided.\n *\n * @return {*} Returns the result of calling `handler`.\n */\nAPI.prototype.startSegment = function startSegment(name, record, handler, callback) {\n  this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/startSegment'\n  ).incrementCallCount()\n\n  // Check that we have usable arguments.\n  if (!name || typeof handler !== 'function') {\n    logger.warn('Name and handler function are both required for startSegment')\n    if (typeof handler === 'function') {\n      return handler(callback)\n    }\n    return\n  }\n  if (callback && typeof callback !== 'function') {\n    logger.warn('If using callback, it must be a function')\n    return handler(callback)\n  }\n\n  // Are we inside a transaction?\n  if (!this.shim.getActiveSegment()) {\n    logger.debug('startSegment(%j) called outside of a transaction, not recording.', name)\n    return handler(callback)\n  }\n\n  // Create the segment and call the handler.\n  var wrappedHandler = this.shim.record(handler, function handlerNamer(shim) {\n    return {\n      name: name,\n      recorder: record ? customRecorder : null,\n      callback: callback ? shim.FIRST : null,\n      promise: !callback\n    }\n  })\n\n  return wrappedHandler(callback)\n}\n\n/**\n * Creates and starts a web transaction to record work done in\n * the handle supplied. This transaction will run until the handle\n * synchronously returns UNLESS:\n * 1. The handle function returns a promise, where the end of the\n *    transaction will be tied to the end of the promise returned.\n * 2. {@link API#getTransaction} is called in the handle, flagging the\n *    transaction as externally handled.  In this case the transaction\n *    will be ended when {@link TransactionHandle#end} is called in the user's code.\n *\n * @example\n * var newrelic = require('newrelic')\n * newrelic.startWebTransaction('/some/url/path', function() {\n *   var transaction = newrelic.getTransaction()\n *   setTimeout(function() {\n *     // do some work\n *     transaction.end()\n *   }, 100)\n * })\n *\n * @param {string} url\n *  The URL of the transaction.  It is used to name and group related transactions in APM,\n *  so it should be a generic name and not iclude any variable parameters.\n *\n * @param {Function}  handle\n *  Function that represents the transaction work.\n */\nAPI.prototype.startWebTransaction = function startWebTransaction(url, handle) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/startWebTransaction'\n  )\n  metric.incrementCallCount()\n\n  if (typeof handle !== 'function') {\n    logger.warn('startWebTransaction called with a handle arg that is not a function')\n    return null\n  }\n\n  if (!url) {\n    logger.warn('startWebTransaction called without a url, transaction not started')\n    return handle()\n  }\n\n  logger.debug(\n    'starting web transaction %s (%s).',\n    url,\n    handle && handle.name\n  )\n\n  var shim = this.shim\n  var tracer = this.agent.tracer\n  var parent = tracer.getTransaction()\n\n  return tracer.transactionNestProxy('web', function startWebSegment() {\n    var tx = tracer.getTransaction()\n\n    if (!tx) {\n      return handle.apply(this, arguments)\n    }\n\n    if (tx === parent) {\n      logger.debug(\n        'not creating nested transaction %s using transaction %s',\n        url,\n        tx.id\n      )\n      return tracer.addSegment(url, null, null, true, handle)\n    }\n\n    logger.debug(\n      'creating web transaction %s (%s) with transaction id: %s',\n      url,\n      handle && handle.name,\n      tx.id\n    )\n    tx.nameState.setName(NAMES.CUSTOM, null, NAMES.ACTION_DELIMITER, url)\n    tx.url = url\n    tx.applyUserNamingRules(tx.url)\n    tx.baseSegment = tracer.createSegment(url, recordWeb)\n    tx.baseSegment.start()\n\n    var boundHandle = tracer.bindFunction(handle, tx.baseSegment)\n    var returnResult = boundHandle.call(this)\n    if (returnResult && shim.isPromise(returnResult)) {\n      returnResult = shim.interceptPromise(returnResult, tx.end.bind(tx))\n    } else if (!tx.handledExternally) {\n      logger.debug('Ending unhandled web transaction immediately.')\n      tx.end()\n    }\n    return returnResult\n  })()\n}\n\nAPI.prototype.startBackgroundTransaction = startBackgroundTransaction\n\n/**\n * Creates and starts a background transaction to record work done in\n * the handle supplied. This transaction will run until the handle\n * synchronously returns UNLESS:\n * 1. The handle function returns a promise, where the end of the\n *    transaction will be tied to the end of the promise returned.\n * 2. {@link API#getTransaction} is called in the handle, flagging the\n *    transaction as externally handled.  In this case the transaction\n *    will be ended when {@link TransactionHandle#end} is called in the user's code.\n *\n * @example\n * var newrelic = require('newrelic')\n * newrelic.startBackgroundTransaction('Red October', 'Subs', function() {\n *   var transaction = newrelic.getTransaction()\n *   setTimeout(function() {\n *     // do some work\n *     transaction.end()\n *   }, 100)\n * })\n *\n * @param {string} name\n *  The name of the transaction. It is used to name and group related\n *  transactions in APM, so it should be a generic name and not iclude any\n *  variable parameters.\n *\n * @param {string} [group]\n *  Optional, used for grouping background transactions in APM. For more\n *  information see:\n *  https://docs.newrelic.com/docs/apm/applications-menu/monitoring/transactions-page#txn-type-dropdown\n *\n * @param {Function} handle\n *  Function that represents the background work.\n *\n * @memberOf API#\n */\nfunction startBackgroundTransaction(name, group, handle) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/startBackgroundTransaction'\n  )\n  metric.incrementCallCount()\n\n  if (handle === undefined && typeof group === 'function') {\n    handle = group\n    group = 'Nodejs'\n  }\n\n  if (typeof handle !== 'function') {\n    logger.warn('startBackgroundTransaction called with a handle that is not a function')\n    return null\n  }\n\n  if (!name) {\n    logger.warn('startBackgroundTransaction called without a name')\n    return handle()\n  }\n\n  logger.debug(\n    'starting background transaction %s:%s (%s)',\n    name,\n    group,\n    handle && handle.name\n  )\n\n  var tracer = this.agent.tracer\n  var shim = this.shim\n  var txName = group + '/' + name\n  var parent = tracer.getTransaction()\n\n  return tracer.transactionNestProxy('bg', function startBackgroundSegment() {\n    var tx = tracer.getTransaction()\n\n    if (!tx) {\n      return handle.apply(this, arguments)\n    }\n\n    if (tx === parent) {\n      logger.debug(\n        'not creating nested transaction %s using transaction %s',\n        txName,\n        tx.id\n      )\n      return tracer.addSegment(txName, null, null, true, handle)\n    }\n\n    logger.debug(\n      'creating background transaction %s:%s (%s) with transaction id: %s',\n      name,\n      group,\n      handle && handle.name,\n      tx.id\n    )\n\n    tx._partialName = txName\n    tx.baseSegment = tracer.createSegment(name, recordBackground)\n    tx.baseSegment.partialName = group\n    tx.baseSegment.start()\n\n    var boundHandle = tracer.bindFunction(handle, tx.baseSegment)\n    var returnResult = boundHandle.call(this)\n    if (returnResult && shim.isPromise(returnResult)) {\n      returnResult = shim.interceptPromise(returnResult, tx.end.bind(tx))\n    } else if (!tx.handledExternally) {\n      logger.debug('Ending unhandled background transaction immediately.')\n      tx.end()\n    }\n    return returnResult\n  })()\n}\n\n/**\n * End the current web or background custom transaction. This method requires being in\n * the correct transaction context when called.\n */\nAPI.prototype.endTransaction = function endTransaction() {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/endTransaction'\n  )\n  metric.incrementCallCount()\n\n  var tracer = this.agent.tracer\n  var tx = tracer.getTransaction()\n\n  if (tx) {\n    if (tx.baseSegment) {\n      if (tx.type === 'web') {\n        tx.finalizeNameFromUri(tx.url, 0)\n      }\n      tx.baseSegment.end()\n    }\n    tx.end()\n    logger.debug('ended transaction with id: %s and name: %s', tx.id, tx.name)\n  } else {\n    logger.debug('endTransaction() called while not in a transaction.')\n  }\n}\n\n/**\n * Record a custom metric, usually associated with a particular duration.\n * The `name` must be a string following standard metric naming rules. The `value` will\n * usually be a number, but it can also be an object.\n *   * When `value` is a numeric value, it should represent the magnitude of a measurement\n *     associated with an event; for example, the duration for a particular method call.\n *   * When `value` is an object, it must contain count, total, min, max, and sumOfSquares\n *     keys, all with number values. This form is useful to aggregate metrics on your own\n *     and report them periodically; for example, from a setInterval. These values will\n *     be aggregated with any previously collected values for the same metric. The names\n *     of these keys match the names of the keys used by the platform API.\n *\n * @param  {string} name  The name of the metric.\n * @param  {number|object} value\n */\nAPI.prototype.recordMetric = function recordMetric(name, value) {\n  const supportMetric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/recordMetric'\n  )\n  supportMetric.incrementCallCount()\n\n  if (typeof name !== 'string') {\n    logger.warn('Metric name must be a string')\n    return\n  }\n\n  const metricName = NAMES.CUSTOM + NAMES.ACTION_DELIMITER + name\n  const metric = this.agent.metrics.getOrCreateMetric(metricName)\n\n  if (typeof value === 'number') {\n    metric.recordValue(value)\n    return\n  }\n\n  if (typeof value !== 'object') {\n    logger.warn('Metric value must be either a number, or a metric object')\n    return\n  }\n\n  const stats = Object.create(null)\n  const required = ['count', 'total', 'min', 'max', 'sumOfSquares']\n  const keyMap = {count: 'callCount'}\n\n  for (let i = 0, l = required.length; i < l; ++i) {\n    if (typeof value[required[i]] !== 'number') {\n      logger.warn('Metric object must include %s as a number', required[i])\n      return\n    }\n\n    const key = keyMap[required[i]] || required[i]\n    stats[key] = value[required[i]]\n  }\n\n  if (typeof value.totalExclusive === 'number') {\n    stats.totalExclusive = value.totalExclusive\n  } else {\n    stats.totalExclusive = value.total\n  }\n\n  metric.merge(stats)\n}\n\n/**\n * Create or update a custom metric that acts as a simple counter.\n * The count of the given metric will be incremented by the specified amount,\n * defaulting to 1.\n *\n * @param  {string} name  The name of the metric.\n * @param  {number} [value] The amount that the count of the metric should be incremented\n *                          by. Defaults to 1.\n */\nAPI.prototype.incrementMetric = function incrementMetric(name, value) {\n  const metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/incrementMetric'\n  )\n  metric.incrementCallCount()\n\n  if (!value && value !== 0) {\n    value = 1\n  }\n\n  if (typeof value !== 'number' || value % 1 !== 0) {\n    logger.warn('Metric Increment value must be an integer')\n    return\n  }\n\n  this.recordMetric(name, {\n    count: value,\n    total: 0,\n    min: 0,\n    max: 0,\n    sumOfSquares: 0\n  })\n}\n\n/**\n * Record custom event data which can be queried in New Relic Insights.\n *\n * @param  {string} eventType  The name of the event. It must be an alphanumeric string\n *                             less than 255 characters.\n * @param  {object} attributes Object of key and value pairs. The keys must be shorter\n *                             than 255 characters, and the values must be string, number,\n *                             or boolean.\n */\nAPI.prototype.recordCustomEvent = function recordCustomEvent(eventType, attributes) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/recordCustomEvent'\n  )\n  metric.incrementCallCount()\n\n  // If high security mode is on, custom events are disabled.\n  if (this.agent.config.high_security) {\n    logger.warnOnce(\n      \"Custom Event\",\n      \"Custom events are disabled by high security mode.\"\n    )\n    return false\n  } else if (!this.agent.config.api.custom_events_enabled) {\n    logger.debug(\n      \"Config.api.custom_events_enabled set to false, not collecting value\"\n    )\n    return false\n  }\n\n  if (!this.agent.config.custom_insights_events.enabled) {\n    return\n  }\n  // Check all the arguments before bailing to give maximum information in a\n  // single invocation.\n  var fail = false\n\n  if (!eventType || typeof eventType !== 'string') {\n    logger.warn(\n      'recordCustomEvent requires a string for its first argument, got %s (%s)',\n      stringify(eventType),\n      typeof eventType\n    )\n    fail = true\n  } else if (!CUSTOM_EVENT_TYPE_REGEX.test(eventType)) {\n    logger.warn(\n      'recordCustomEvent eventType of %s is invalid, it must match /%s/',\n      eventType,\n      CUSTOM_EVENT_TYPE_REGEX.source\n    )\n    fail = true\n  } else if (eventType.length > 255) {\n    logger.warn(\n      'recordCustomEvent eventType must have a length less than 256, got %s (%s)',\n      eventType,\n      eventType.length\n    )\n    fail = true\n  }\n  // If they don't pass an attributes object, or the attributes argument is not\n  // an object, or if it is an object and but is actually an array, log a\n  // warning and set the fail bit.\n  if (!attributes || typeof attributes !== 'object' || Array.isArray(attributes)) {\n    logger.warn(\n      'recordCustomEvent requires an object for its second argument, got %s (%s)',\n      stringify(attributes),\n      typeof attributes\n    )\n    fail = true\n  } else if (_checkKeyLength(attributes, 255)) {\n    fail = true\n  }\n\n  if (fail) {\n    return\n  }\n\n  // Filter all object type valued attributes out\n  const filteredAttributes = _filterAttributes(attributes, `${eventType} custom event`)\n\n  var instrinics = {\n    type: eventType,\n    timestamp: Date.now()\n  }\n\n  var tx = this.agent.getTransaction()\n  var priority = tx && tx.priority || Math.random()\n  this.agent.customEventAggregator.add([instrinics, filteredAttributes], priority)\n}\n\n/**\n * Registers an instrumentation function.\n *\n *  - `newrelic.instrument(moduleName, onRequire [,onError])`\n *  - `newrelic.instrument(options)`\n *\n * @param {object} options\n *  The options for this custom instrumentation.\n *\n * @param {string} options.moduleName\n *  The module name given to require to load the module\n *\n * @param {function}  options.onRequire\n *  The function to call when the module is required\n *\n * @param {function} [options.onError]\n *  If provided, should `onRequire` throw an error, the error will be passed to\n *  this function.\n */\nAPI.prototype.instrument = function instrument(moduleName, onRequire, onError) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/instrument'\n  )\n  metric.incrementCallCount()\n\n  var opts = moduleName\n  if (typeof opts === 'string') {\n    opts = {\n      moduleName: moduleName,\n      onRequire: onRequire,\n      onError: onError\n    }\n  }\n\n  opts.type = MODULE_TYPE.GENERIC\n  shimmer.registerInstrumentation(opts)\n}\n\n/**\n * Registers an instrumentation function.\n *\n * - `newrelic.instrumentConglomerate(moduleName, onRequire [, onError])`\n * - `newrelic.isntrumentConglomerate(options)`\n *\n * @param {object} options\n *  The options for this custom instrumentation.\n *\n * @param {string} options.moduleName\n *  The module name given to require to load the module\n *\n * @param {function} options.onRequire\n *  The function to call when the module is required\n *\n * @param {function} [options.onError]\n *  If provided, should `onRequire` throw an error, the error will be passed to\n *  this function.\n */\nAPI.prototype.instrumentConglomerate =\nfunction instrumentConglomerate(moduleName, onRequire, onError) {\n  this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/instrumentConglomerate'\n  ).incrementCallCount()\n\n  let opts = moduleName\n  if (typeof opts === 'string') {\n    opts = {moduleName, onRequire, onError}\n  }\n\n  opts.type = MODULE_TYPE.CONGLOMERATE\n  shimmer.registerInstrumentation(opts)\n}\n\n/**\n * Registers an instrumentation function.\n *\n *  - `newrelic.instrumentDatastore(moduleName, onRequire [,onError])`\n *  - `newrelic.instrumentDatastore(options)`\n *\n * @param {object} options\n *  The options for this custom instrumentation.\n *\n * @param {string} options.moduleName\n *  The module name given to require to load the module\n *\n * @param {function} options.onRequire\n *  The function to call when the module is required\n *\n * @param {function} [options.onError]\n *  If provided, should `onRequire` throw an error, the error will be passed to\n *  this function.\n */\nAPI.prototype.instrumentDatastore =\nfunction instrumentDatastore(moduleName, onRequire, onError) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/instrumentDatastore'\n  )\n  metric.incrementCallCount()\n\n  var opts = moduleName\n  if (typeof opts === 'string') {\n    opts = {\n      moduleName: moduleName,\n      onRequire: onRequire,\n      onError: onError\n    }\n  }\n\n  opts.type = MODULE_TYPE.DATASTORE\n  shimmer.registerInstrumentation(opts)\n}\n\n/**\n * Applies an instrumentation to an already loaded module.\n *\n *    // oh no, express was loaded before newrelic\n *    const express   = require('express')\n *    const newrelic  = require('newrelic')\n *\n *    // phew, we can use instrumentLoadedModule to make\n *    // sure express is still instrumented\n *    newrelic.instrumentLoadedModule('express', express)\n *\n * @param {string} moduleName\n *  The module's name/identifier.  Will be normalized\n *  into an instrumentation key.\n *\n * @param {object} module\n *  The actual module object or function we're instrumenting\n */\nAPI.prototype.instrumentLoadedModule =\nfunction instrumentLoadedModule(moduleName, module) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/instrumentLoadedModule'\n  )\n  metric.incrementCallCount()\n\n  const instrumentationName = shimmer.getInstrumentationNameFromModuleName(moduleName)\n  if (!shimmer.registeredInstrumentations[instrumentationName]) {\n    logger.warn(\"No instrumentation registered for '%s'.\", instrumentationName)\n    return false\n  }\n\n  const instrumentation = shimmer.registeredInstrumentations[instrumentationName]\n  if (!instrumentation.onRequire) {\n    logger.warn(\"No onRequire function registered for '%s'.\", instrumentationName)\n    return false\n  }\n\n  const resolvedName = require.resolve(moduleName)\n\n  const shim = shims.createShimFromType(\n    instrumentation.type,\n    this.agent,\n    moduleName,\n    resolvedName\n  )\n\n  instrumentation.onRequire(shim, module, moduleName)\n\n  return true\n}\n\n/**\n * Registers an instrumentation function.\n *\n *  - `newrelic.instrumentWebframework(moduleName, onRequire [,onError])`\n *  - `newrelic.instrumentWebframework(options)`\n *\n * @param {object} options\n *  The options for this custom instrumentation.\n *\n * @param {string} options.moduleName\n *  The module name given to require to load the module\n *\n * @param {function}  options.onRequire\n *  The function to call when the module is required\n *\n * @param {function} [options.onError]\n *  If provided, should `onRequire` throw an error, the error will be passed to\n *  this function.\n */\nAPI.prototype.instrumentWebframework =\nfunction instrumentWebframework(moduleName, onRequire, onError) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/instrumentWebframework'\n  )\n  metric.incrementCallCount()\n\n  var opts = moduleName\n  if (typeof opts === 'string') {\n    opts = {\n      moduleName: moduleName,\n      onRequire: onRequire,\n      onError: onError\n    }\n  }\n\n  opts.type = MODULE_TYPE.WEB_FRAMEWORK\n  shimmer.registerInstrumentation(opts)\n}\n\n/**\n * Registers an instrumentation function for instrumenting message brokers.\n *\n *  - `newrelic.instrumentMessages(moduleName, onRequire [,onError])`\n *  - `newrelic.instrumentMessages(options)`\n *\n * @param {object} options\n *  The options for this custom instrumentation.\n *\n * @param {string} options.moduleName\n *  The module name given to require to load the module\n *\n * @param {function}  options.onRequire\n *  The function to call when the module is required\n *\n * @param {function} [options.onError]\n *  If provided, should `onRequire` throw an error, the error will be passed to\n *  this function.\n */\nAPI.prototype.instrumentMessages =\nfunction instrumentMessages(moduleName, onRequire, onError) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/instrumentMessages'\n  )\n  metric.incrementCallCount()\n\n  var opts = moduleName\n  if (typeof opts === 'string') {\n    opts = {\n      moduleName: moduleName,\n      onRequire: onRequire,\n      onError: onError\n    }\n  }\n\n  opts.type = MODULE_TYPE.MESSAGE\n  shimmer.registerInstrumentation(opts)\n}\n\n/**\n * Returns the current trace and span id.\n *\n * @returns {*} The object containing the current trace and span ids\n */\nAPI.prototype.getTraceMetadata = function getTraceMetadata() {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/getTraceMetadata'\n  )\n  metric.incrementCallCount()\n\n  const metadata = {}\n\n  const segment = this.agent.tracer.getSegment()\n  if (!segment) {\n    logger.debug(\"No transaction found when calling API#getTraceMetadata\")\n  } else if (!this.agent.config.distributed_tracing.enabled) {\n    logger.debug(\"Distributed tracing disabled when calling API#getTraceMetadata\")\n  } else {\n    metadata.traceId = segment.transaction.getTraceId()\n\n    const spanId = segment.getSpanId()\n    if (spanId) {\n      metadata.spanId = spanId\n    }\n  }\n\n  return metadata\n}\n\n/**\n * Shuts down the agent.\n *\n * @param {object} [options]\n *  Object with shut down options.\n *\n * @param {boolean} [options.collectPendingData=false]\n *  If true, the agent will send any pending data to the collector before\n *  shutting down.\n *\n * @param {number} [options.timeout=0]\n *  Time in milliseconds to wait before shutting down.\n *\n * @param {boolean} [options.waitForIdle=false]\n *  If true, the agent will not shut down until there are no active transactions.\n *\n * @param {function} [callback]\n *  Callback function that runs when agent stops.\n */\nAPI.prototype.shutdown = function shutdown(options, cb) {\n  this.agent.metrics.getOrCreateMetric(`${NAMES.SUPPORTABILITY.API}/shutdown`)\n    .incrementCallCount()\n\n  let callback = cb\n  if (typeof options === 'function') {\n    // shutdown(cb)\n    callback = options\n    options = {}\n  } else if (typeof callback !== 'function') {\n    // shutdown([options])\n    callback = () => {}\n  }\n  if (!options) {\n    // shutdown(null, cb)\n    options = {}\n  }\n\n  _doShutdown(this, options, callback)\n}\n\nfunction _doShutdown(api, options, callback) {\n  const agent = api.agent\n\n  // If we need to wait for idle and there are currently active transactions,\n  // listen for transactions ending and check if we're ready to go.\n  if (options.waitForIdle && agent.activeTransactions) {\n    options.waitForIdle = false // To prevent recursive waiting.\n    agent.on('transactionFinished', function onTransactionFinished() {\n      if (agent.activeTransactions === 0) {\n        setImmediate(_doShutdown, api, options, callback)\n      }\n    })\n    return\n  }\n\n  function afterHarvest(error) {\n    if (error) {\n      logger.error(\n        error,\n        'An error occurred while running last harvest before shutdown.'\n      )\n    }\n    agent.stop(callback)\n  }\n\n  if (options.collectPendingData && agent._state !== 'started') {\n    if (typeof options.timeout === 'number') {\n      setTimeout(function shutdownTimeout() {\n        agent.stop(callback)\n      }, options.timeout).unref()\n    } else if (options.timeout) {\n      logger.warn(\n        'options.timeout should be of type \"number\". Got %s',\n        typeof options.timeout\n      )\n    }\n\n    agent.on('started', function shutdownHarvest() {\n      agent.forceHarvestAll(afterHarvest)\n    })\n\n    agent.on('errored', function logShutdownError(error) {\n      agent.stop(callback)\n      if (error) {\n        logger.error(\n          error,\n          'The agent encountered an error after calling shutdown.'\n        )\n      }\n    })\n  } else if (options.collectPendingData) {\n    agent.forceHarvestAll(afterHarvest)\n  } else {\n    agent.stop(callback)\n  }\n}\n\nfunction _checkKeyLength(object, maxLength) {\n  var keys = Object.keys(object)\n  var badKey = false\n  var len = keys.length\n  var key = '' // init to string because gotta go fast\n  for (var i = 0; i < len; i++) {\n    key = keys[i]\n    if (key.length > maxLength) {\n      logger.warn(\n        'recordCustomEvent requires keys to be less than 256 chars got %s (%s)',\n        key,\n        key.length\n      )\n      badKey = true\n    }\n  }\n  return badKey\n}\n\nAPI.prototype.setLambdaHandler = function setLambdaHandler(handler) {\n  const metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/setLambdaHandler'\n  )\n  metric.incrementCallCount()\n\n  return this.awsLambda.patchLambdaHandler(handler)\n}\n\nfunction _filterAttributes(attributes, name) {\n  const filteredAttributes = Object.create(null)\n  Object.keys(attributes).forEach((attributeKey) => {\n    if (!isValidType(attributes[attributeKey])) {\n      logger.info(\n        `Omitting attribute ${attributeKey} from ${name} call, type must ` +\n        'be boolean, number, or string'\n      )\n      return\n    }\n    filteredAttributes[attributeKey] = attributes[attributeKey]\n  })\n  return filteredAttributes\n}\n\nmodule.exports = API\n"]},"metadata":{},"sourceType":"script"}