{"ast":null,"code":"'use strict';\n\nvar logger = require('../../logger').child({\n  component: 'normalizer_rule'\n});\n/**\n * JavaScript just has to do things slightly differently.\n */\n\n\nvar replaceReplacer = function replaceReplacer(input) {\n  return input.replace(/\\\\/g, '$');\n};\n/**\n * Be liberal about accepting incomplete information, because we don't want\n * bad rules from the collector to crash client apps. Otherwise, this is a\n * fairly straightforward mapping of the concepts in metric normalization\n * rules into an object form.\n *\n * @param {Object} json A JavaScript object literal parsed out from the JSON\n *                      from the collector.\n */\n\n\nfunction NormalizerRule(json) {\n  if (!json) {\n    logger.debug(\"Received incompletely specified metric normalization rule from collector.\");\n    json = Object.create(null);\n  }\n\n  this.eachSegment = json.each_segment || false;\n  this.precedence = json.eval_order || 0;\n  this.isTerminal = json.terminate_chain || false;\n  this.replacement = replaceReplacer(json.replacement || '$0');\n  this.replaceAll = json.replace_all || false;\n  this.ignore = json.ignore || false;\n  this.matched = false;\n  var modifiers = 'i';\n  if (this.replaceAll) modifiers += 'g'; // don't allow this to fail\n\n  if (json.match_expression instanceof RegExp) {\n    this.pattern = _addRegExpFlags(json.match_expression, modifiers);\n  } else {\n    try {\n      this.pattern = new RegExp(json.match_expression || '^$', modifiers);\n    } catch (error) {\n      logger.warn(error, \"Problem compiling metric normalization rule pattern.\");\n      this.pattern = /^$/;\n    }\n  }\n}\n/**\n * Allow the higher-level functions to operate on input uniformly.\n *\n * @param {string} input URL to potentially be split.\n */\n\n\nNormalizerRule.prototype.getSegments = function getSegments(input) {\n  if (this.eachSegment) {\n    return input.split('/');\n  }\n\n  return [input];\n};\n/**\n * Check if a URL matches a rule.\n *\n * Does not set {NormalizerRule#matched}.\n *\n * @param {string} input - URL to match.\n *\n * @return {bool} - True if this rule matches the given input, otherwise false.\n */\n\n\nNormalizerRule.prototype.matches = function matches(input) {\n  var segments = this.getSegments(input);\n\n  for (var i = 0; i < segments.length; ++i) {\n    if (this.pattern.test(segments[i])) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Apply the substitutions, if any, to the input.\n *\n * Also sets {NormalizerRule#matched} to true if this rule did match the given\n * input.\n *\n * String.split will return empty segments when the path has a leading slash or\n * contains a run of slashes. Don't inadvertently substitute or drop these empty\n * segments, or the normalized path will be wrong.\n *\n * XXX In Node v0.8 and Node v0.10, `RegExp#test` advances internal state and\n * XXX tracks where it left off from the previous match. This has the side\n * XXX effect that reusing the same object may cause false negatives if you do\n * XXX not reset that state. The only way to reset the state is to set\n * XXX `RegExp#lastIndex` to `0`.\n *\n * @param {string} input - URL to normalize.\n *\n * @return {string?} - The normalized url, or `null` if this is an ignore rule\n *  that matched this url.\n */\n\n\nNormalizerRule.prototype.apply = function apply(input) {\n  // For ignore rules, just see if we match and return either `null` or the\n  // original input.\n  if (this.ignore) {\n    return (this.matched = this.matches(input)) ? null : input;\n  }\n\n  this.matched = false;\n  var result = this.getSegments(input).map(function applyMap(segment) {\n    // Discussion of why we use `lastIndex` in function documentation to\n    // prevent de-opt due to long function.\n    this.pattern.lastIndex = 0;\n\n    if (segment && this.pattern.test(segment)) {\n      this.matched = true;\n      return segment.replace(this.pattern, this.replacement);\n    }\n\n    return segment;\n  }, this).join('/');\n  return input[0] === '/' && result[0] !== '/' ? '/' + result : result;\n};\n\nNormalizerRule.prototype.toJSON = function toJSON() {\n  return {\n    eachSegment: this.eachSegment,\n    precedence: this.precedence,\n    isTerminal: this.isTerminal,\n    replacement: this.replacement,\n    replaceAll: this.replaceAll,\n    ignore: this.ignore,\n    pattern: this.pattern.source\n  };\n};\n/**\n * Merges the given flags with those already in a regular expression.\n *\n * @param {RegExp} re     - The regular expression to add flags to.\n * @param {string} flags  - The flags to add to the regex.\n *\n * @return {RegExp} - A regular expression with all the given flags added.\n */\n\n\nfunction _addRegExpFlags(re, flags) {\n  var foundMissing = false;\n  var reFlags = re.flags;\n\n  for (var i = 0; i < flags.length; ++i) {\n    if (reFlags.indexOf(flags[i]) === -1) {\n      foundMissing = true;\n      reFlags += flags[i];\n    }\n  }\n\n  return foundMissing ? new RegExp(re.source, reFlags) : re;\n}\n\nmodule.exports = NormalizerRule;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/metrics/normalizer/rule.js"],"names":["logger","require","child","component","replaceReplacer","input","replace","NormalizerRule","json","debug","Object","create","eachSegment","each_segment","precedence","eval_order","isTerminal","terminate_chain","replacement","replaceAll","replace_all","ignore","matched","modifiers","match_expression","RegExp","pattern","_addRegExpFlags","error","warn","prototype","getSegments","split","matches","segments","i","length","test","apply","result","map","applyMap","segment","lastIndex","join","toJSON","source","re","flags","foundMissing","reFlags","indexOf","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar logger = require('../../logger').child({component: 'normalizer_rule'})\n\n\n/**\n * JavaScript just has to do things slightly differently.\n */\nvar replaceReplacer = function replaceReplacer(input) {\n  return input.replace(/\\\\/g, '$')\n}\n\n/**\n * Be liberal about accepting incomplete information, because we don't want\n * bad rules from the collector to crash client apps. Otherwise, this is a\n * fairly straightforward mapping of the concepts in metric normalization\n * rules into an object form.\n *\n * @param {Object} json A JavaScript object literal parsed out from the JSON\n *                      from the collector.\n */\nfunction NormalizerRule(json) {\n  if (!json) {\n    logger.debug(\n      \"Received incompletely specified metric normalization rule from collector.\"\n    )\n    json = Object.create(null)\n  }\n\n  this.eachSegment = json.each_segment || false\n  this.precedence = json.eval_order || 0\n  this.isTerminal = json.terminate_chain || false\n  this.replacement = replaceReplacer(json.replacement || '$0')\n  this.replaceAll = json.replace_all || false\n  this.ignore = json.ignore || false\n  this.matched = false\n\n  var modifiers = 'i'\n  if (this.replaceAll) modifiers += 'g'\n\n  // don't allow this to fail\n  if (json.match_expression instanceof RegExp) {\n    this.pattern = _addRegExpFlags(json.match_expression, modifiers)\n  } else {\n    try {\n      this.pattern = new RegExp(json.match_expression || '^$', modifiers)\n    } catch (error) {\n      logger.warn(error, \"Problem compiling metric normalization rule pattern.\")\n      this.pattern = /^$/\n    }\n  }\n}\n\n/**\n * Allow the higher-level functions to operate on input uniformly.\n *\n * @param {string} input URL to potentially be split.\n */\nNormalizerRule.prototype.getSegments = function getSegments(input) {\n  if (this.eachSegment) {\n    return input.split('/')\n  }\n\n  return [input]\n}\n\n/**\n * Check if a URL matches a rule.\n *\n * Does not set {NormalizerRule#matched}.\n *\n * @param {string} input - URL to match.\n *\n * @return {bool} - True if this rule matches the given input, otherwise false.\n */\nNormalizerRule.prototype.matches = function matches(input) {\n  var segments = this.getSegments(input)\n\n  for (var i = 0; i < segments.length; ++i) {\n    if (this.pattern.test(segments[i])) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Apply the substitutions, if any, to the input.\n *\n * Also sets {NormalizerRule#matched} to true if this rule did match the given\n * input.\n *\n * String.split will return empty segments when the path has a leading slash or\n * contains a run of slashes. Don't inadvertently substitute or drop these empty\n * segments, or the normalized path will be wrong.\n *\n * XXX In Node v0.8 and Node v0.10, `RegExp#test` advances internal state and\n * XXX tracks where it left off from the previous match. This has the side\n * XXX effect that reusing the same object may cause false negatives if you do\n * XXX not reset that state. The only way to reset the state is to set\n * XXX `RegExp#lastIndex` to `0`.\n *\n * @param {string} input - URL to normalize.\n *\n * @return {string?} - The normalized url, or `null` if this is an ignore rule\n *  that matched this url.\n */\nNormalizerRule.prototype.apply = function apply(input) {\n  // For ignore rules, just see if we match and return either `null` or the\n  // original input.\n  if (this.ignore) {\n    return (this.matched = this.matches(input)) ? null : input\n  }\n\n  this.matched = false\n  var result = this.getSegments(input)\n    .map(function applyMap(segment) {\n      // Discussion of why we use `lastIndex` in function documentation to\n      // prevent de-opt due to long function.\n      this.pattern.lastIndex = 0\n      if (segment && this.pattern.test(segment)) {\n        this.matched = true\n        return segment.replace(this.pattern, this.replacement)\n      }\n      return segment\n    }, this)\n    .join('/')\n  return input[0] === '/' && result[0] !== '/' ? '/' + result : result\n}\n\nNormalizerRule.prototype.toJSON = function toJSON() {\n  return {\n    eachSegment: this.eachSegment,\n    precedence: this.precedence,\n    isTerminal: this.isTerminal,\n    replacement: this.replacement,\n    replaceAll: this.replaceAll,\n    ignore: this.ignore,\n    pattern: this.pattern.source\n  }\n}\n\n/**\n * Merges the given flags with those already in a regular expression.\n *\n * @param {RegExp} re     - The regular expression to add flags to.\n * @param {string} flags  - The flags to add to the regex.\n *\n * @return {RegExp} - A regular expression with all the given flags added.\n */\nfunction _addRegExpFlags(re, flags) {\n  var foundMissing = false\n  var reFlags = re.flags\n  for (var i = 0; i < flags.length; ++i) {\n    if (reFlags.indexOf(flags[i]) === -1) {\n      foundMissing = true\n      reFlags += flags[i]\n    }\n  }\n  return foundMissing ? new RegExp(re.source, reFlags) : re\n}\n\nmodule.exports = NormalizerRule\n"]},"metadata":{},"sourceType":"script"}