{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar logger = require('../logger').child({\n  component: 'metric_normalizer'\n});\n\nvar deepEqual = require('../util/deep-equal');\n\nvar Rule = require('./normalizer/rule');\n\nvar NAMES = require('../metrics/names.js');\n\nfunction url(normalized, path, config) {\n  if (normalized) return NAMES.NORMALIZED + normalized;\n\n  if (config.enforce_backstop) {\n    return NAMES.NORMALIZED + '/*';\n  }\n\n  return NAMES.URI + path;\n}\n\nfunction plain(normalized, path) {\n  if (normalized) {\n    return normalized;\n  }\n\n  return path;\n}\n/**\n * The collector keeps track of rules that should be applied to metric names,\n * and sends these rules to the agent at connection time. These rules can\n * either change the name of the metric or indicate that metrics associated with\n * this name (which is generally a URL path) should be ignored altogether.\n *\n * @param {object} config The agent's configuration blob, which has a parameter\n *                        that indicates whether to enforce the normalization\n *                        backstop.\n */\n\n\nfunction MetricNormalizer(config, type) {\n  if (!config) throw new Error(\"normalizer must be created with configuration.\");\n  if (!type) throw new Error(\"normalizer must be created with a type.\");\n  EventEmitter.call(this);\n  this.config = config;\n  this.type = type; // some mildly cheesy polymorphism to make normalizers work generically\n\n  if (type === 'URL') {\n    this.formatter = url;\n  } else {\n    this.formatter = plain;\n  }\n\n  this.rules = [];\n}\n\nutil.inherits(MetricNormalizer, EventEmitter); // -------------------------------------------------------------------------- //\n\n/**\n * @typedef {Object} NormalizationResults\n *\n * @property {bool}   matched - True if a rule was found that matched.\n * @property {bool}   ignore  - True if the given input should be ignored.\n * @property {string} value   - The normalized input value.\n */\n// -------------------------------------------------------------------------- //\n\n/**\n * Convert the raw, de-serialized JSON response into a set of\n * NormalizationRules.\n *\n * @param object json The de-serialized JSON response sent on collector\n *                    connection.\n */\n\nMetricNormalizer.prototype.load = function load(json) {\n  if (json) {\n    this.rules = [];\n    logger.debug(\"Received %s %s normalization rule(s) from the server\", json.length, this.type);\n    json.forEach(function cb_forEach(ruleJSON) {\n      // no need to add the same rule twice\n      var rule = new Rule(ruleJSON);\n\n      if (!this.rules.find(deepEqual.bind(null, rule))) {\n        this.rules.push(rule);\n        logger.trace(\"Loaded %s normalization rule: %s\", this.type, rule);\n      }\n    }, this);\n    /* I (FLN) always forget this, so making a note: JS sort is always\n     * IN-PLACE, even though it returns the sorted array.\n     */\n\n    this.rules.sort(function cb_sort(a, b) {\n      return a.precedence - b.precedence;\n    });\n    logger.debug(\"Loaded %s %s normalization rule(s).\", this.rules.length, this.type);\n  }\n};\n/**\n * Load any rules found in the configuration into a metric normalizer.\n *\n * Operates via side effects.\n */\n\n\nMetricNormalizer.prototype.loadFromConfig = function loadFromConfig() {\n  var rules = this.config.rules;\n\n  if (rules && rules.name && rules.name.length > 0) {\n    rules.name.forEach(function cb_forEach(rule) {\n      if (!rule.pattern) {\n        return logger.error({\n          rule: rule\n        }, \"Simple naming rules require a pattern.\");\n      }\n\n      if (!rule.name) {\n        return logger.error({\n          rule: rule\n        }, \"Simple naming rules require a replacement name.\");\n      }\n\n      var precedence = rule.precedence;\n      var terminal = rule.terminate_chain;\n      var json = {\n        match_expression: rule.pattern,\n        eval_order: typeof precedence === 'number' ? precedence : 500,\n        terminate_chain: typeof terminal === 'boolean' ? terminal : true,\n        replace_all: rule.replace_all,\n        replacement: rule.name,\n        ignore: false\n      }; // Find where the rule should be inserted and do so.\n\n      var reverse = this.config.feature_flag.reverse_naming_rules;\n      var insert = this.rules.findIndex(function findRule(r) {\n        return reverse ? r.precedence >= json.eval_order : r.precedence > json.eval_order;\n      });\n\n      if (insert === -1) {\n        this.rules.push(new Rule(json));\n      } else {\n        this.rules.splice(insert, 0, new Rule(json));\n      }\n    }, this);\n  }\n\n  if (rules && rules.ignore && rules.ignore.length > 0) {\n    rules.ignore.forEach(function cb_forEach(pattern) {\n      this.addSimple(pattern);\n    }, this);\n  }\n};\n/**\n * Add simple, user-provided rules to the head of the match list. These rules\n * will always be highest precedence, always will terminate matching, and\n * will always apply to the URL as a whole. If no name is provided, then\n * transactions attached to the matching URLs will be ignored.\n *\n *  - `addSimple(opts)`\n *  - `addSimple(pattern [, name])`\n *\n * @param {RegExp} pattern The pattern to rename (with capture groups).\n * @param {string} [name]  The name to use for the transaction.\n */\n\n\nMetricNormalizer.prototype.addSimple = function addSimple(pattern, name) {\n  if (!pattern) return logger.error(\"Simple naming rules require a pattern.\");\n  var json = {\n    match_expression: pattern,\n    eval_order: 0,\n    terminate_chain: true,\n    replace_all: false,\n    replacement: null,\n    ignore: false\n  };\n\n  if (name) {\n    json.replacement = name;\n  } else {\n    json.ignore = true;\n  }\n\n  this.rules.unshift(new Rule(json));\n};\n/**\n * Turn a (scrubbed) URL path into partial metric name.\n *\n * @param {string} path - The URL path to turn into a name.\n *\n * @returns {NormalizationResults} - The results of normalization.\n */\n\n\nMetricNormalizer.prototype.normalize = function normalize(path) {\n  var last = path;\n  var length = this.rules.length;\n  var normalized;\n  var matched = false;\n  var ignored = false; // Apply each of our rules in turn.\n\n  for (var i = 0; i < length; i++) {\n    var rule = this.rules[i];\n    var applied = rule.apply(last);\n\n    if (!rule.matched) {\n      continue;\n    }\n\n    if (rule.ignore) {\n      ignored = true;\n    } else {\n      matched = true;\n      normalized = applied; // emit event when a rule is matched\n      // we could also include an array of matched rules in the returned map, but\n      // that would increase memory overhead by creating additional array\n\n      this.emit('appliedRule', rule, normalized, last);\n      logger.trace({\n        rule: rule,\n        type: this.type\n      }, \"Normalized %s to %s.\", last, normalized);\n      last = normalized;\n    }\n\n    if (rule.isTerminal) {\n      logger.trace({\n        rule: rule\n      }, \"Terminating normalization.\");\n      break;\n    }\n  } // Return the normalized path.\n\n\n  return {\n    matched: matched,\n    ignore: ignored,\n    value: this.formatter(normalized, path, this.config)\n  };\n};\n\nmodule.exports = MetricNormalizer;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/metrics/normalizer.js"],"names":["EventEmitter","require","util","logger","child","component","deepEqual","Rule","NAMES","url","normalized","path","config","NORMALIZED","enforce_backstop","URI","plain","MetricNormalizer","type","Error","call","formatter","rules","inherits","prototype","load","json","debug","length","forEach","cb_forEach","ruleJSON","rule","find","bind","push","trace","sort","cb_sort","a","b","precedence","loadFromConfig","name","pattern","error","terminal","terminate_chain","match_expression","eval_order","replace_all","replacement","ignore","reverse","feature_flag","reverse_naming_rules","insert","findIndex","findRule","r","splice","addSimple","unshift","normalize","last","matched","ignored","i","applied","apply","emit","isTerminal","value","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar logger = require('../logger').child({component: 'metric_normalizer'})\nvar deepEqual = require('../util/deep-equal')\nvar Rule = require('./normalizer/rule')\nvar NAMES = require('../metrics/names.js')\n\n\nfunction url(normalized, path, config) {\n  if (normalized) return NAMES.NORMALIZED + normalized\n\n  if (config.enforce_backstop) {\n    return NAMES.NORMALIZED + '/*'\n  }\n\n  return NAMES.URI + path\n}\n\nfunction plain(normalized, path) {\n  if (normalized) {\n    return normalized\n  }\n\n  return path\n}\n\n/**\n * The collector keeps track of rules that should be applied to metric names,\n * and sends these rules to the agent at connection time. These rules can\n * either change the name of the metric or indicate that metrics associated with\n * this name (which is generally a URL path) should be ignored altogether.\n *\n * @param {object} config The agent's configuration blob, which has a parameter\n *                        that indicates whether to enforce the normalization\n *                        backstop.\n */\nfunction MetricNormalizer(config, type) {\n  if (!config) throw new Error(\"normalizer must be created with configuration.\")\n  if (!type) throw new Error(\"normalizer must be created with a type.\")\n\n  EventEmitter.call(this)\n\n  this.config = config\n  this.type = type\n  // some mildly cheesy polymorphism to make normalizers work generically\n  if (type === 'URL') {\n    this.formatter = url\n  } else {\n    this.formatter = plain\n  }\n\n  this.rules = []\n}\nutil.inherits(MetricNormalizer, EventEmitter)\n\n// -------------------------------------------------------------------------- //\n\n/**\n * @typedef {Object} NormalizationResults\n *\n * @property {bool}   matched - True if a rule was found that matched.\n * @property {bool}   ignore  - True if the given input should be ignored.\n * @property {string} value   - The normalized input value.\n */\n\n// -------------------------------------------------------------------------- //\n\n/**\n * Convert the raw, de-serialized JSON response into a set of\n * NormalizationRules.\n *\n * @param object json The de-serialized JSON response sent on collector\n *                    connection.\n */\nMetricNormalizer.prototype.load = function load(json) {\n  if (json) {\n    this.rules = []\n    logger.debug(\"Received %s %s normalization rule(s) from the server\",\n      json.length, this.type)\n\n    json.forEach(function cb_forEach(ruleJSON) {\n      // no need to add the same rule twice\n      var rule = new Rule(ruleJSON)\n      if (!this.rules.find(deepEqual.bind(null, rule))) {\n        this.rules.push(rule)\n        logger.trace(\"Loaded %s normalization rule: %s\", this.type, rule)\n      }\n    }, this)\n\n    /* I (FLN) always forget this, so making a note: JS sort is always\n     * IN-PLACE, even though it returns the sorted array.\n     */\n    this.rules.sort(function cb_sort(a, b) {\n      return a.precedence - b.precedence\n    })\n\n    logger.debug(\"Loaded %s %s normalization rule(s).\", this.rules.length, this.type)\n  }\n}\n\n/**\n * Load any rules found in the configuration into a metric normalizer.\n *\n * Operates via side effects.\n */\nMetricNormalizer.prototype.loadFromConfig = function loadFromConfig() {\n  var rules = this.config.rules\n\n  if (rules && rules.name && rules.name.length > 0) {\n    rules.name.forEach(function cb_forEach(rule) {\n      if (!rule.pattern) {\n        return logger.error(\n          {rule: rule},\n          \"Simple naming rules require a pattern.\"\n        )\n      }\n      if (!rule.name) {\n        return logger.error(\n          {rule: rule},\n          \"Simple naming rules require a replacement name.\"\n        )\n      }\n\n      var precedence = rule.precedence\n      var terminal = rule.terminate_chain\n      var json = {\n        match_expression: rule.pattern,\n        eval_order: (typeof precedence === 'number') ? precedence : 500,\n        terminate_chain: (typeof terminal === 'boolean') ? terminal : true,\n        replace_all: rule.replace_all,\n        replacement: rule.name,\n        ignore: false\n      }\n\n      // Find where the rule should be inserted and do so.\n      var reverse = this.config.feature_flag.reverse_naming_rules\n      var insert = this.rules.findIndex(function findRule(r) {\n        return reverse\n          ? r.precedence >= json.eval_order\n          : r.precedence > json.eval_order\n      })\n      if (insert === -1) {\n        this.rules.push(new Rule(json))\n      } else {\n        this.rules.splice(insert, 0, new Rule(json))\n      }\n    }, this)\n  }\n\n  if (rules && rules.ignore && rules.ignore.length > 0) {\n    rules.ignore.forEach(function cb_forEach(pattern) {\n      this.addSimple(pattern)\n    }, this)\n  }\n}\n\n/**\n * Add simple, user-provided rules to the head of the match list. These rules\n * will always be highest precedence, always will terminate matching, and\n * will always apply to the URL as a whole. If no name is provided, then\n * transactions attached to the matching URLs will be ignored.\n *\n *  - `addSimple(opts)`\n *  - `addSimple(pattern [, name])`\n *\n * @param {RegExp} pattern The pattern to rename (with capture groups).\n * @param {string} [name]  The name to use for the transaction.\n */\nMetricNormalizer.prototype.addSimple = function addSimple(pattern, name) {\n  if (!pattern) return logger.error(\"Simple naming rules require a pattern.\")\n\n  var json = {\n    match_expression: pattern,\n    eval_order: 0,\n    terminate_chain: true,\n    replace_all: false,\n    replacement: null,\n    ignore: false\n  }\n\n  if (name) {\n    json.replacement = name\n  } else {\n    json.ignore = true\n  }\n\n  this.rules.unshift(new Rule(json))\n}\n\n/**\n * Turn a (scrubbed) URL path into partial metric name.\n *\n * @param {string} path - The URL path to turn into a name.\n *\n * @returns {NormalizationResults} - The results of normalization.\n */\nMetricNormalizer.prototype.normalize = function normalize(path) {\n  var last = path\n  var length = this.rules.length\n  var normalized\n  var matched = false\n  var ignored = false\n\n  // Apply each of our rules in turn.\n  for (var i = 0; i < length; i++) {\n    var rule = this.rules[i]\n    var applied = rule.apply(last)\n    if (!rule.matched) {\n      continue\n    }\n\n    if (rule.ignore) {\n      ignored = true\n    } else {\n      matched = true\n      normalized = applied\n\n      // emit event when a rule is matched\n      // we could also include an array of matched rules in the returned map, but\n      // that would increase memory overhead by creating additional array\n      this.emit('appliedRule', rule, normalized, last)\n\n      logger.trace({rule: rule, type: this.type},\n        \"Normalized %s to %s.\", last, normalized)\n      last = normalized\n    }\n\n    if (rule.isTerminal) {\n      logger.trace({rule: rule}, \"Terminating normalization.\")\n      break\n    }\n  }\n\n  // Return the normalized path.\n  return {\n    matched: matched,\n    ignore: ignored,\n    value: this.formatter(normalized, path, this.config)\n  }\n}\n\nmodule.exports = MetricNormalizer\n"]},"metadata":{},"sourceType":"script"}