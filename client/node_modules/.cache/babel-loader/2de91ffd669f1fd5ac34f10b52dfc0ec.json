{"ast":null,"code":"'use strict';\n\nclass ExclusiveCalculator {\n  constructor(root) {\n    this.toProcess = [root]; // use a second stack to do a post-order traversal\n\n    this.parentStack = [];\n  }\n  /**\n   * Kicks off the exclusive duration calculation.  This is performed\n   * using a depth first, postorder traversal over the tree.\n   */\n\n\n  process() {\n    while (this.toProcess.length) {\n      const segment = this.toProcess.pop();\n      const children = segment.getChildren(); // when we hit a leaf, calc the exclusive time and report the time\n      // range to the parent\n\n      if (children.length === 0) {\n        segment._exclusiveDuration = segment.getDurationInMillis();\n\n        if (this.parentStack.length) {\n          this.finishLeaf(segment.timer.toRange());\n        }\n      } else {\n        // in the case we are processing an internal node, we just push it on the stack\n        // and push its children to be processed. all processing will be done after its\n        // children are all done (i.e. postorder)\n        this.parentStack.push({\n          childrenLeft: children.length,\n          segment: segment,\n          childPairs: []\n        });\n\n        for (var i = children.length - 1; i >= 0; --i) {\n          this.toProcess.push(children[i]);\n        }\n      }\n    }\n  }\n  /**\n   * Updates the immediate parent in the parent stack that a leaf node has\n   * been processed.  If the parent isn't expecting any more children to\n   * be processed, it pops the stack and propagates the processing to\n   * more distant predecessors.\n   *\n   * @param {Array} childRange An array of start and end time for the finished leaf node\n   */\n\n\n  finishLeaf(childRange) {\n    let parent = this.parentStack[this.parentStack.length - 1]; // push the current segment's range pair up to the parent's child pairs\n\n    parent.childPairs = merge(parent.childPairs, [childRange]); // decrement the number of children expected for the current parent; process the\n    // parent if it is not expecting any further children to finish (i.e. the number\n    // of children left to process is 0).\n\n    while (--parent.childrenLeft === 0) {\n      // pull off the finished parent and assign the exclusive duration\n      const _this$parentStack$pop = this.parentStack.pop(),\n            finishedParent = _this$parentStack$pop.segment,\n            childPairs = _this$parentStack$pop.childPairs;\n\n      const timer = finishedParent.timer;\n      const finishedEnd = timer.getDurationInMillis() + timer.start;\n      let duration = finishedParent.getDurationInMillis();\n\n      for (let i = 0; i < childPairs.length; ++i) {\n        const pair = childPairs[i]; // since these are non-overlapping and ordered by start time, the first one\n        // to start after the parent's end marks the end of the segments we care\n        // about.\n\n        if (pair[0] >= finishedEnd) {\n          break;\n        }\n\n        duration -= Math.min(pair[1], finishedEnd) - pair[0];\n      }\n\n      finishedParent._exclusiveDuration = duration;\n      parent = this.parentStack[this.parentStack.length - 1]; // since the parent was potentially a child of another segment, we need to\n      // rerun this for the parent's parent till we hit a parent with children yet\n      // to be processed.\n\n      if (parent) {\n        // merge the current child segments in with the finished parent's range\n        const inserted = merge(childPairs, [finishedParent.timer.toRange()]); // merge the finished parent's merged range into its parent's range\n\n        parent.childPairs = merge(parent.childPairs, inserted);\n      } else {\n        // in the case where the parent doesn't exist, we are done and can break out.\n        break;\n      }\n    }\n  }\n\n}\n\nfunction merge(first, second) {\n  if (!first.length) {\n    return second;\n  }\n\n  if (!second.length) {\n    return first;\n  }\n\n  const res = [];\n  var resIdx = 0;\n  var firstIdx = 0;\n  var secondIdx = 0; // N.B. this is destructive, it will be updating the end times for range arrays in\n  // the input arrays.  If we need to reuse these arrays for anything, this behavior\n  // must be changed.\n\n  var currInterval = first[firstIdx][0] < second[secondIdx][0] ? first[firstIdx++] : second[secondIdx++];\n\n  while (firstIdx < first.length && secondIdx < second.length) {\n    var next = first[firstIdx][0] < second[secondIdx][0] ? first[firstIdx++] : second[secondIdx++];\n\n    if (next[0] <= currInterval[1]) {\n      // if the segment overlaps, update the end of the current merged segment\n      currInterval[1] = Math.max(next[1], currInterval[1]);\n    } else {\n      // if there is no overlap, start a new merging segment and push the old one\n      res[resIdx++] = currInterval;\n      currInterval = next;\n    }\n  }\n\n  const firstIsRemainder = firstIdx !== first.length;\n  const remainder = firstIsRemainder ? first : second;\n  let remainderIdx = firstIsRemainder ? firstIdx : secondIdx; // merge the segments overlapping with the current interval\n\n  while (remainder[remainderIdx] && remainder[remainderIdx][0] <= currInterval[1]) {\n    currInterval[1] = Math.max(remainder[remainderIdx++][1], currInterval[1]);\n  }\n\n  res[resIdx++] = currInterval; // append the remaining non-overlapping ranges\n\n  for (; remainderIdx < remainder.length; ++remainderIdx) {\n    res[resIdx++] = remainder[remainderIdx];\n  }\n\n  return res;\n}\n\nmodule.exports = ExclusiveCalculator;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/transaction/trace/exclusive-time-calculator.js"],"names":["ExclusiveCalculator","constructor","root","toProcess","parentStack","process","length","segment","pop","children","getChildren","_exclusiveDuration","getDurationInMillis","finishLeaf","timer","toRange","push","childrenLeft","childPairs","i","childRange","parent","merge","finishedParent","finishedEnd","start","duration","pair","Math","min","inserted","first","second","res","resIdx","firstIdx","secondIdx","currInterval","next","max","firstIsRemainder","remainder","remainderIdx","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nclass ExclusiveCalculator {\n  constructor(root) {\n    this.toProcess = [root]\n    // use a second stack to do a post-order traversal\n    this.parentStack = []\n  }\n\n  /**\n   * Kicks off the exclusive duration calculation.  This is performed\n   * using a depth first, postorder traversal over the tree.\n   */\n  process() {\n    while (this.toProcess.length) {\n      const segment = this.toProcess.pop()\n      const children = segment.getChildren()\n      // when we hit a leaf, calc the exclusive time and report the time\n      // range to the parent\n      if (children.length === 0) {\n        segment._exclusiveDuration = segment.getDurationInMillis()\n        if (this.parentStack.length) {\n          this.finishLeaf(segment.timer.toRange())\n        }\n      } else {\n        // in the case we are processing an internal node, we just push it on the stack\n        // and push its children to be processed. all processing will be done after its\n        // children are all done (i.e. postorder)\n        this.parentStack.push({\n          childrenLeft: children.length,\n          segment: segment,\n          childPairs: []\n        })\n        for (var i = children.length - 1; i >= 0; --i) {\n          this.toProcess.push(children[i])\n        }\n      }\n    }\n  }\n\n  /**\n   * Updates the immediate parent in the parent stack that a leaf node has\n   * been processed.  If the parent isn't expecting any more children to\n   * be processed, it pops the stack and propagates the processing to\n   * more distant predecessors.\n   *\n   * @param {Array} childRange An array of start and end time for the finished leaf node\n   */\n  finishLeaf(childRange) {\n    let parent = this.parentStack[this.parentStack.length - 1]\n    // push the current segment's range pair up to the parent's child pairs\n    parent.childPairs = merge(parent.childPairs, [childRange])\n    // decrement the number of children expected for the current parent; process the\n    // parent if it is not expecting any further children to finish (i.e. the number\n    // of children left to process is 0).\n    while (--parent.childrenLeft === 0) {\n      // pull off the finished parent and assign the exclusive duration\n      const {segment: finishedParent, childPairs} = this.parentStack.pop()\n      const timer = finishedParent.timer\n      const finishedEnd = timer.getDurationInMillis() + timer.start\n      let duration = finishedParent.getDurationInMillis()\n      for (let i = 0; i < childPairs.length; ++i) {\n        const pair = childPairs[i]\n        // since these are non-overlapping and ordered by start time, the first one\n        // to start after the parent's end marks the end of the segments we care\n        // about.\n        if (pair[0] >= finishedEnd) {\n          break\n        }\n        duration -= Math.min(pair[1], finishedEnd) - pair[0]\n      }\n\n      finishedParent._exclusiveDuration = duration\n      parent = this.parentStack[this.parentStack.length - 1]\n      // since the parent was potentially a child of another segment, we need to\n      // rerun this for the parent's parent till we hit a parent with children yet\n      // to be processed.\n      if (parent) {\n        // merge the current child segments in with the finished parent's range\n        const inserted = merge(childPairs, [finishedParent.timer.toRange()])\n        // merge the finished parent's merged range into its parent's range\n        parent.childPairs = merge(parent.childPairs, inserted)\n      } else {\n        // in the case where the parent doesn't exist, we are done and can break out.\n        break\n      }\n    }\n  }\n}\n\nfunction merge(first, second) {\n  if (!first.length) {\n    return second\n  }\n\n  if (!second.length) {\n    return first\n  }\n\n  const res = []\n  var resIdx = 0\n  var firstIdx = 0\n  var secondIdx = 0\n  // N.B. this is destructive, it will be updating the end times for range arrays in\n  // the input arrays.  If we need to reuse these arrays for anything, this behavior\n  // must be changed.\n  var currInterval = first[firstIdx][0] < second[secondIdx][0]\n    ? first[firstIdx++]\n    : second[secondIdx++]\n\n  while (firstIdx < first.length && secondIdx < second.length) {\n    var next = first[firstIdx][0] < second[secondIdx][0]\n      ? first[firstIdx++]\n      : second[secondIdx++]\n    if (next[0] <= currInterval[1]) {\n      // if the segment overlaps, update the end of the current merged segment\n      currInterval[1] = Math.max(next[1], currInterval[1])\n    } else {\n      // if there is no overlap, start a new merging segment and push the old one\n      res[resIdx++] = currInterval\n      currInterval = next\n    }\n  }\n\n\n  const firstIsRemainder = firstIdx !== first.length\n  const remainder = firstIsRemainder ? first : second\n  let remainderIdx = firstIsRemainder ? firstIdx : secondIdx\n\n  // merge the segments overlapping with the current interval\n  while (remainder[remainderIdx] && remainder[remainderIdx][0] <= currInterval[1]) {\n    currInterval[1] = Math.max(remainder[remainderIdx++][1], currInterval[1])\n  }\n\n  res[resIdx++] = currInterval\n\n  // append the remaining non-overlapping ranges\n  for (;remainderIdx < remainder.length; ++remainderIdx) {\n    res[resIdx++] = remainder[remainderIdx]\n  }\n\n  return res\n}\n\nmodule.exports = ExclusiveCalculator\n"]},"metadata":{},"sourceType":"script"}