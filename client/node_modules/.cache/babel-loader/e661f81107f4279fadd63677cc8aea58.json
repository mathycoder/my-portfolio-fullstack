{"ast":null,"code":"'use strict';\n\nconst Stats = require('../stats');\n\nconst ApdexStats = require('../stats/apdex.js');\n\nconst NAMES = require('./names');\n/*\n *\n * CONSTANTS\n *\n */\n\n\nconst FROM_MILLIS = 1e-3;\n/**\n * A metric is a set of aggregated data (summary statistics) associated with a\n * metric name. Some metrics belong to scopes, which are typically the name of\n * a transaction or a background task. This class is a collection of mappings\n * from names (or scopes and names) to data, as well as functions for\n * manipulating those data directly. It also can produce a serialized\n * representation suitable for stringifying into JSON and sending to the\n * collector.\n *\n * There are several metrics collections in existence at any given time. Each\n * agent has one metrics collection, which is created at the beginning of each\n * harvest cycle. Each new transaction also gets its own metrics collection,\n * which is merged into the agent's metrics when the transaction is finalized.\n * This allows each set of metrics to be added to the harvest cycle atomically,\n * which guarantees that each transaction will not have its metrics split\n * across multiple harvest cycles. If delivery to the collector fails, the\n * metrics collection associated with the failed delivery can be merged back\n * into the metrics collection for the ongoing harvest cycle.\n *\n * Metrics can be remapped, which is a process by which they are assigned a\n * short, numerical ID by New Relic. This can shrink the serialized JSON\n * considerably. The mapping from transaction name (and scope) happens only\n * at serialization time, which allows the mappings from name to ID to happen\n * on the fly.\n *\n * @param {Number} apdexT The apdex-tolerating value, for use in creating apdex\n *                        statistics.\n * @param {MetricMapper} mapper The mapper that turns metric names into IDs.\n */\n\nfunction Metrics(apdexT, mapper, normalizer) {\n  if (apdexT == null || apdexT === '') {\n    throw new Error(\"metrics must be created with apdexT\");\n  }\n\n  if (!mapper) throw new Error(\"metrics must be created with a mapper\");\n  if (!normalizer) throw new Error(\"metrics must be created with a name normalizer\");\n  this.empty = true;\n  this.started = Date.now();\n  this.apdexT = apdexT;\n  this.mapper = mapper;\n  this.normalizer = normalizer;\n  this.unscoped = Object.create(null); // {name : stats}\n\n  this.scoped = Object.create(null); // {scope : {name : stats}}\n}\n/**\n * This is the preferred way for interacting with metrics. Set the duration\n * (and optionally the amount of that duration that was exclusive to that\n * particular metric and not any child operations to that metric) of an\n * operation. If there are no data for the name (and optional scope) existing,\n * the collection will create a set of data before recording the measurement.\n *\n * @param {string} name The name of the metric.\n * @param {string} scope (Optional) The scope to which the metric belongs.\n * @param {Number} duration The duration of the related operation, in milliseconds.\n * @param {Number} exclusive (Optional) The portion of the operation specific to this\n *                           metric.\n * @return {Stats} The aggregated data related to this metric.\n */\n\n\nMetrics.prototype.measureMilliseconds = measureMilliseconds;\n\nfunction measureMilliseconds(name, scope, duration, exclusive) {\n  var stats = this.getOrCreateMetric(name, scope);\n  stats.recordValueInMillis(duration, exclusive);\n  return stats;\n}\n/**\n * Set the size of an operation. If there are no data for the name existing,\n * the collection will create a set of data before recording the measurement.\n *\n * @param {string} name The name of the metric.\n * @param {Number} size The size of the related operation, in bytes.\n * @return {Stats} The aggregated data related to this metric.\n */\n\n\nMetrics.prototype.measureBytes = function measureBytes(name, size) {\n  var stats = this.getOrCreateMetric(name);\n  stats.recordValueInBytes(size);\n  return stats;\n};\n/**\n * Look up the mapping from a name (and optionally a scope) to a set of metric\n * data for that name, creating the data if they don't already exist.\n *\n * @param {string} name The name of the requested metric.\n * @param {string} scope (Optional) The scope to which the metric is bound.\n * @return {Stats} The aggregated data for that name.\n */\n\n\nMetrics.prototype.getOrCreateMetric = function getOrCreateMetric(name, scope) {\n  var resolved = this._resolve(scope);\n\n  var stats = resolved[name];\n\n  if (!stats) {\n    this.empty = false;\n    stats = resolved[name] = new Stats();\n  }\n\n  return stats;\n};\n/**\n * Look up the mapping from a name (and optionally a scope) to a set of metric\n * apdex data for that name, creating the data if they don't already exist.\n *\n * @param {string} name          The name of the requested metric.\n * @param {string} scope         The scope to which the metric is bound\n *                               (optional).\n * @param {number} overrideApdex A custom apdexT for this metric, in\n *                               milliseconds. This will be the same for\n *                               a given run, because key transaction metrics\n *                               are set at connect time via server-side\n *                               configuration.\n *\n * @return {ApdexStats} The aggregated data for that name.\n */\n\n\nMetrics.prototype.getOrCreateApdexMetric = getOrCreateApdexMetric;\n\nfunction getOrCreateApdexMetric(name, scope, overrideApdex) {\n  if (!name) throw new Error('Metrics must be named');\n\n  var resolved = this._resolve(scope);\n\n  if (!resolved[name]) {\n    this.empty = false; // Only use the given override to create the metric if this is not the\n    // global apdex AND we have a valid value.\n\n    var apdexT = name !== NAMES.APDEX && overrideApdex > 0 ? overrideApdex * FROM_MILLIS : this.apdexT;\n    resolved[name] = new ApdexStats(apdexT);\n  }\n\n  return resolved[name];\n}\n/**\n * Look up a metric, and don't create it if it doesn't exist. Can create scopes\n * as a byproduct, but this function is only intended for use in testing, so\n * it's not a big deal.\n *\n * @param {string} name Metric name.\n * @param {string} scope (Optional) The scope, if any, to which the metric\n *                       belongs.\n * @return {object} Either a stats aggregate, an apdex stats aggregate, or\n *                  undefined.\n */\n\n\nMetrics.prototype.getMetric = function getMetric(name, scope) {\n  if (!name) throw new Error('Metrics must be named');\n  return this._resolve(scope)[name];\n};\n/**\n * Convert this collection into a representation suitable for serialization\n * by JSON.stringify and delivery to the collector. Hope you like nested\n * arrays!\n *\n * @return {Object} Set of nested arrays containing metric information.\n */\n\n\nMetrics.prototype.toJSON = function toJSON() {\n  return this._toUnscopedData().concat(this._toScopedData());\n};\n/**\n * Combine two sets of metric data. Intended to be used as described above,\n * either when folding a transaction's metrics into the agent's metrics for\n * later harvest, or one harvest cycle's metrics into the next when a\n * delivery attempt to the collector fails. Among the more performance-\n * critical pieces of code in the agent, so some performance tuning would\n * probably be a good idea.\n *\n * @param {Metrics} other\n *  The collection to be folded into this one.\n *\n * @param {boolean} adjustStartTime\n *  If the start time for the timeslice should be adjusted.\n */\n\n\nMetrics.prototype.merge = function merge(other, adjustStartTime) {\n  this.empty = this.empty && other.empty;\n\n  if (adjustStartTime) {\n    this.started = Math.min(this.started, other.started);\n  }\n\n  _merge(this.unscoped, other.unscoped); // Loop through all scopes and merge them. Since we know `.scoped` has a `null`\n  // prototype we don't need to worry about own property checks.\n\n\n  for (var scope in other.scoped) {\n    // eslint-disable-line guard-for-in\n    _merge(this._resolve(scope), other.scoped[scope]);\n  }\n};\n\nfunction _merge(a, b) {\n  for (var name in b) {\n    if (a[name]) {\n      a[name].merge(b[name]);\n    } else {\n      a[name] = b[name];\n    }\n  }\n}\n/**\n * Look up the metric namespace belonging to a scope, creating it if it doesn't\n * already exist.\n *\n * @param {string} scope (Optional) The scope to look up.\n * @return {object} The namespace associated with the provided scope, or the\n *                  un-scoped metrics if the scope isn't set.\n */\n\n\nMetrics.prototype._resolve = function _resolve(scope) {\n  var resolved = this.unscoped;\n\n  if (scope) {\n    resolved = this.scoped[scope];\n\n    if (!resolved) {\n      resolved = this.scoped[scope] = Object.create(null);\n    }\n  }\n\n  return resolved;\n};\n/**\n * Map a metric to its nested-array representation, applying any name -> ID\n * mappings along the way. Split from _getScopedData for performance.\n *\n * @param {string} name The string to look up.\n */\n\n\nMetrics.prototype._getUnscopedData = function _getUnscopedData(name) {\n  if (!this.unscoped[name]) return;\n  var normalized = this.normalizer.normalize(name);\n  if (normalized.ignore || !normalized.value) return;\n  return [this.mapper.map(normalized.value), this.unscoped[name]];\n};\n/**\n * Map a metric to its nested-array representation, applying any name -> ID\n * mappings along the way. Split from _getUnscopedData for performance.\n *\n * @param {string} name The string to look up.\n */\n\n\nMetrics.prototype._getScopedData = function _getScopedData(name, scope) {\n  if (!this.scoped[scope][name]) return;\n  var normalized = this.normalizer.normalize(name);\n  if (normalized.ignore || !normalized.value) return;\n  return [this.mapper.map(normalized.value, scope), this.scoped[scope][name]];\n};\n/**\n * @return {object} A serializable version of the unscoped metrics. Intended\n *                  for use by toJSON.\n */\n\n\nMetrics.prototype._toUnscopedData = function _toUnscopedData() {\n  var metricData = [];\n  Object.keys(this.unscoped).forEach(function cb_forEach(name) {\n    var data = this._getUnscopedData(name);\n\n    if (data) metricData.push(data);\n  }, this);\n  return metricData;\n};\n/**\n * @return {object} A serializable version of the scoped metrics. Intended for\n *                  use by toJSON.\n */\n\n\nMetrics.prototype._toScopedData = function _toScopedData() {\n  var metricData = [];\n  Object.keys(this.scoped).forEach(function forEachScope(scope) {\n    Object.keys(this.scoped[scope]).forEach(function forEachMetric(name) {\n      var data = this._getScopedData(name, scope);\n\n      if (data) metricData.push(data);\n    }, this);\n  }, this);\n  return metricData;\n};\n\nmodule.exports = Metrics;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/metrics/index.js"],"names":["Stats","require","ApdexStats","NAMES","FROM_MILLIS","Metrics","apdexT","mapper","normalizer","Error","empty","started","Date","now","unscoped","Object","create","scoped","prototype","measureMilliseconds","name","scope","duration","exclusive","stats","getOrCreateMetric","recordValueInMillis","measureBytes","size","recordValueInBytes","resolved","_resolve","getOrCreateApdexMetric","overrideApdex","APDEX","getMetric","toJSON","_toUnscopedData","concat","_toScopedData","merge","other","adjustStartTime","Math","min","_merge","a","b","_getUnscopedData","normalized","normalize","ignore","value","map","_getScopedData","metricData","keys","forEach","cb_forEach","data","push","forEachScope","forEachMetric","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Stats = require('../stats')\nconst ApdexStats = require('../stats/apdex.js')\nconst NAMES = require('./names')\n\n\n/*\n *\n * CONSTANTS\n *\n */\nconst FROM_MILLIS = 1e-3\n\n/**\n * A metric is a set of aggregated data (summary statistics) associated with a\n * metric name. Some metrics belong to scopes, which are typically the name of\n * a transaction or a background task. This class is a collection of mappings\n * from names (or scopes and names) to data, as well as functions for\n * manipulating those data directly. It also can produce a serialized\n * representation suitable for stringifying into JSON and sending to the\n * collector.\n *\n * There are several metrics collections in existence at any given time. Each\n * agent has one metrics collection, which is created at the beginning of each\n * harvest cycle. Each new transaction also gets its own metrics collection,\n * which is merged into the agent's metrics when the transaction is finalized.\n * This allows each set of metrics to be added to the harvest cycle atomically,\n * which guarantees that each transaction will not have its metrics split\n * across multiple harvest cycles. If delivery to the collector fails, the\n * metrics collection associated with the failed delivery can be merged back\n * into the metrics collection for the ongoing harvest cycle.\n *\n * Metrics can be remapped, which is a process by which they are assigned a\n * short, numerical ID by New Relic. This can shrink the serialized JSON\n * considerably. The mapping from transaction name (and scope) happens only\n * at serialization time, which allows the mappings from name to ID to happen\n * on the fly.\n *\n * @param {Number} apdexT The apdex-tolerating value, for use in creating apdex\n *                        statistics.\n * @param {MetricMapper} mapper The mapper that turns metric names into IDs.\n */\nfunction Metrics(apdexT, mapper, normalizer) {\n  if (apdexT == null || apdexT === '') {\n    throw new Error(\"metrics must be created with apdexT\")\n  }\n  if (!mapper) throw new Error(\"metrics must be created with a mapper\")\n  if (!normalizer) throw new Error(\"metrics must be created with a name normalizer\")\n\n  this.empty = true\n  this.started = Date.now()\n  this.apdexT = apdexT\n  this.mapper = mapper\n  this.normalizer = normalizer\n  this.unscoped = Object.create(null) // {name : stats}\n  this.scoped = Object.create(null) // {scope : {name : stats}}\n}\n\n/**\n * This is the preferred way for interacting with metrics. Set the duration\n * (and optionally the amount of that duration that was exclusive to that\n * particular metric and not any child operations to that metric) of an\n * operation. If there are no data for the name (and optional scope) existing,\n * the collection will create a set of data before recording the measurement.\n *\n * @param {string} name The name of the metric.\n * @param {string} scope (Optional) The scope to which the metric belongs.\n * @param {Number} duration The duration of the related operation, in milliseconds.\n * @param {Number} exclusive (Optional) The portion of the operation specific to this\n *                           metric.\n * @return {Stats} The aggregated data related to this metric.\n */\nMetrics.prototype.measureMilliseconds = measureMilliseconds\n\nfunction measureMilliseconds(name, scope, duration, exclusive) {\n  var stats = this.getOrCreateMetric(name, scope)\n  stats.recordValueInMillis(duration, exclusive)\n  return stats\n}\n\n/**\n * Set the size of an operation. If there are no data for the name existing,\n * the collection will create a set of data before recording the measurement.\n *\n * @param {string} name The name of the metric.\n * @param {Number} size The size of the related operation, in bytes.\n * @return {Stats} The aggregated data related to this metric.\n */\nMetrics.prototype.measureBytes = function measureBytes(name, size) {\n  var stats = this.getOrCreateMetric(name)\n  stats.recordValueInBytes(size)\n  return stats\n}\n\n/**\n * Look up the mapping from a name (and optionally a scope) to a set of metric\n * data for that name, creating the data if they don't already exist.\n *\n * @param {string} name The name of the requested metric.\n * @param {string} scope (Optional) The scope to which the metric is bound.\n * @return {Stats} The aggregated data for that name.\n */\nMetrics.prototype.getOrCreateMetric = function getOrCreateMetric(name, scope) {\n  var resolved = this._resolve(scope)\n  var stats = resolved[name]\n  if (!stats) {\n    this.empty = false\n    stats = resolved[name] = new Stats()\n  }\n  return stats\n}\n\n/**\n * Look up the mapping from a name (and optionally a scope) to a set of metric\n * apdex data for that name, creating the data if they don't already exist.\n *\n * @param {string} name          The name of the requested metric.\n * @param {string} scope         The scope to which the metric is bound\n *                               (optional).\n * @param {number} overrideApdex A custom apdexT for this metric, in\n *                               milliseconds. This will be the same for\n *                               a given run, because key transaction metrics\n *                               are set at connect time via server-side\n *                               configuration.\n *\n * @return {ApdexStats} The aggregated data for that name.\n */\nMetrics.prototype.getOrCreateApdexMetric = getOrCreateApdexMetric\n\nfunction getOrCreateApdexMetric(name, scope, overrideApdex) {\n  if (!name) throw new Error('Metrics must be named')\n\n  var resolved = this._resolve(scope)\n\n  if (!resolved[name]) {\n    this.empty = false\n\n    // Only use the given override to create the metric if this is not the\n    // global apdex AND we have a valid value.\n    var apdexT = name !== NAMES.APDEX && overrideApdex > 0\n      ? (overrideApdex * FROM_MILLIS) : this.apdexT\n    resolved[name] = new ApdexStats(apdexT)\n  }\n  return resolved[name]\n}\n\n/**\n * Look up a metric, and don't create it if it doesn't exist. Can create scopes\n * as a byproduct, but this function is only intended for use in testing, so\n * it's not a big deal.\n *\n * @param {string} name Metric name.\n * @param {string} scope (Optional) The scope, if any, to which the metric\n *                       belongs.\n * @return {object} Either a stats aggregate, an apdex stats aggregate, or\n *                  undefined.\n */\nMetrics.prototype.getMetric = function getMetric(name, scope) {\n  if (!name) throw new Error('Metrics must be named')\n\n  return this._resolve(scope)[name]\n}\n\n/**\n * Convert this collection into a representation suitable for serialization\n * by JSON.stringify and delivery to the collector. Hope you like nested\n * arrays!\n *\n * @return {Object} Set of nested arrays containing metric information.\n */\nMetrics.prototype.toJSON = function toJSON() {\n  return this._toUnscopedData().concat(this._toScopedData())\n}\n\n/**\n * Combine two sets of metric data. Intended to be used as described above,\n * either when folding a transaction's metrics into the agent's metrics for\n * later harvest, or one harvest cycle's metrics into the next when a\n * delivery attempt to the collector fails. Among the more performance-\n * critical pieces of code in the agent, so some performance tuning would\n * probably be a good idea.\n *\n * @param {Metrics} other\n *  The collection to be folded into this one.\n *\n * @param {boolean} adjustStartTime\n *  If the start time for the timeslice should be adjusted.\n */\nMetrics.prototype.merge = function merge(other, adjustStartTime) {\n  this.empty = this.empty && other.empty\n  if (adjustStartTime) {\n    this.started = Math.min(this.started, other.started)\n  }\n  _merge(this.unscoped, other.unscoped)\n\n  // Loop through all scopes and merge them. Since we know `.scoped` has a `null`\n  // prototype we don't need to worry about own property checks.\n  for (var scope in other.scoped) { // eslint-disable-line guard-for-in\n    _merge(this._resolve(scope), other.scoped[scope])\n  }\n}\nfunction _merge(a, b) {\n  for (var name in b) {\n    if (a[name]) {\n      a[name].merge(b[name])\n    } else {\n      a[name] = b[name]\n    }\n  }\n}\n\n/**\n * Look up the metric namespace belonging to a scope, creating it if it doesn't\n * already exist.\n *\n * @param {string} scope (Optional) The scope to look up.\n * @return {object} The namespace associated with the provided scope, or the\n *                  un-scoped metrics if the scope isn't set.\n */\nMetrics.prototype._resolve = function _resolve(scope) {\n  var resolved = this.unscoped\n\n  if (scope) {\n    resolved = this.scoped[scope]\n    if (!resolved) {\n      resolved = this.scoped[scope] = Object.create(null)\n    }\n  }\n\n  return resolved\n}\n\n/**\n * Map a metric to its nested-array representation, applying any name -> ID\n * mappings along the way. Split from _getScopedData for performance.\n *\n * @param {string} name The string to look up.\n */\nMetrics.prototype._getUnscopedData = function _getUnscopedData(name) {\n  if (!this.unscoped[name]) return\n\n  var normalized = this.normalizer.normalize(name)\n  if (normalized.ignore || !normalized.value) return\n\n  return [this.mapper.map(normalized.value), this.unscoped[name]]\n}\n\n/**\n * Map a metric to its nested-array representation, applying any name -> ID\n * mappings along the way. Split from _getUnscopedData for performance.\n *\n * @param {string} name The string to look up.\n */\nMetrics.prototype._getScopedData = function _getScopedData(name, scope) {\n  if (!this.scoped[scope][name]) return\n\n  var normalized = this.normalizer.normalize(name)\n  if (normalized.ignore || !normalized.value) return\n\n  return [this.mapper.map(normalized.value, scope), this.scoped[scope][name]]\n}\n\n/**\n * @return {object} A serializable version of the unscoped metrics. Intended\n *                  for use by toJSON.\n */\nMetrics.prototype._toUnscopedData = function _toUnscopedData() {\n  var metricData = []\n\n  Object.keys(this.unscoped).forEach(function cb_forEach(name) {\n    var data = this._getUnscopedData(name)\n    if (data) metricData.push(data)\n  }, this)\n\n  return metricData\n}\n\n/**\n * @return {object} A serializable version of the scoped metrics. Intended for\n *                  use by toJSON.\n */\nMetrics.prototype._toScopedData = function _toScopedData() {\n  var metricData = []\n\n  Object.keys(this.scoped).forEach(function forEachScope(scope) {\n    Object.keys(this.scoped[scope]).forEach(function forEachMetric(name) {\n      var data = this._getScopedData(name, scope)\n      if (data) metricData.push(data)\n    }, this)\n  }, this)\n\n  return metricData\n}\n\nmodule.exports = Metrics\n"]},"metadata":{},"sourceType":"script"}