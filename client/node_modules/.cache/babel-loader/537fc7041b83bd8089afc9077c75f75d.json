{"ast":null,"code":"'use strict';\n\nconst Aggregator = require('./base-aggregator');\n\nconst logger = require('../logger').child({\n  component: 'event_aggregator'\n});\n\nconst PriorityQueue = require('../priority-queue');\n/**\n * Aggregates events up to a certain limit.\n *\n * @private\n * @class\n */\n\n\nclass EventAggregator extends Aggregator {\n  constructor(opts, collector, metricsAggregator) {\n    super(opts, collector); // EventEmitter inits an _events collection. So we have to avoid collision\n\n    this._items = new PriorityQueue(opts.limit);\n    this._metricNames = opts.metricNames;\n    this._metrics = metricsAggregator;\n  }\n\n  get seen() {\n    return this._items.seen;\n  }\n\n  get length() {\n    return this._items.length;\n  }\n\n  get overflow() {\n    return this._items.overflow();\n  }\n\n  get events() {\n    return this._items;\n  }\n\n  _merge() {\n    return this.mergeEvents.apply(this, arguments);\n  }\n\n  add() {\n    this._metrics.getOrCreateMetric(this._metricNames.SEEN).incrementCallCount();\n\n    const didAdd = this.addEvent.apply(this, arguments);\n\n    if (didAdd && this._items.overflow() === 0) {\n      this._metrics.getOrCreateMetric(this._metricNames.SENT).incrementCallCount();\n    } else {\n      this._metrics.getOrCreateMetric(this._metricNames.DROPPED).incrementCallCount();\n    }\n\n    return didAdd;\n  }\n\n  _getMergeData() {\n    return this._items;\n  }\n\n  clear() {\n    return this.clearEvents.apply(this, arguments);\n  }\n  /**\n   *\n   */\n\n\n  getQueue() {\n    return this._items;\n  }\n  /**\n   * Fetches all the span events aggregated.\n   *\n   * @return {array.<Event>} An array of span events from the aggregator.\n   */\n\n\n  getEvents() {\n    return this._items.toArray();\n  }\n  /**\n   * Resets the contents of the aggregator and all counters.\n   *\n   * @return {PriorityQueue} The old collection of aggregated events.\n   */\n\n\n  clearEvents() {\n    // ???: might be more efficient to clear here and come up with an efficient way to\n    // serialize the events and priorities\n    this._items = new PriorityQueue(this._items.limit);\n  }\n\n  reconfigure(config) {\n    super.reconfigure(config);\n    const newSettings = config.getAggregatorConfig(this.method);\n\n    if (newSettings) {\n      this.periodMs = newSettings.periodMs;\n      this.limit = newSettings.limit;\n\n      this._items.setLimit(this.limit);\n    } else {\n      this.periodMs = this.defaultPeriod;\n      this.limit = this.defaultLimit;\n    }\n  }\n\n  addEvent(event, priority) {\n    return this._items.add(event, priority);\n  }\n  /**\n   * Merges a set of events back into the aggregator.\n   *\n   * This should only be used after a failed harvest with the `PriorityQueue`\n   * returned from `EventAggregator#clearEvents`.\n   *\n   * @param {?PriorityQueue} events - The collection of events to re-merge.\n   */\n\n\n  mergeEvents(events) {\n    if (!events) {\n      return;\n    } // We calculate the number that will be merged for the log, but we try to\n    // add every event because we want the ones with the highest priority, not\n    // the first `n` events.\n\n\n    const toMerge = Math.min(events.length, this.limit - this.length);\n    logger.warn('Merging %d of %d events into %s for next harvest', toMerge, events.length, this.constructor.name);\n    const seen = events.length;\n    const sent = toMerge;\n    const dropped = seen - sent;\n\n    this._metrics.getOrCreateMetric(this._metricNames.SEEN).incrementCallCount(seen);\n\n    this._metrics.getOrCreateMetric(this._metricNames.SENT).incrementCallCount(sent);\n\n    if (dropped > 0) {\n      this._metrics.getOrCreateMetric(this._metricNames.DROPPED).incrementCallCount(dropped);\n    } // merge modifies incoming events collection.\n\n\n    this._items.merge(events);\n  }\n\n}\n\nmodule.exports = EventAggregator;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/aggregators/event-aggregator.js"],"names":["Aggregator","require","logger","child","component","PriorityQueue","EventAggregator","constructor","opts","collector","metricsAggregator","_items","limit","_metricNames","metricNames","_metrics","seen","length","overflow","events","_merge","mergeEvents","apply","arguments","add","getOrCreateMetric","SEEN","incrementCallCount","didAdd","addEvent","SENT","DROPPED","_getMergeData","clear","clearEvents","getQueue","getEvents","toArray","reconfigure","config","newSettings","getAggregatorConfig","method","periodMs","setLimit","defaultPeriod","defaultLimit","event","priority","toMerge","Math","min","warn","name","sent","dropped","merge","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Aggregator = require('./base-aggregator')\nconst logger = require('../logger').child({component: 'event_aggregator'})\nconst PriorityQueue = require('../priority-queue')\n\n/**\n * Aggregates events up to a certain limit.\n *\n * @private\n * @class\n */\nclass EventAggregator extends Aggregator {\n  constructor(opts, collector, metricsAggregator) {\n    super(opts, collector)\n    // EventEmitter inits an _events collection. So we have to avoid collision\n    this._items = new PriorityQueue(opts.limit)\n    this._metricNames = opts.metricNames\n    this._metrics = metricsAggregator\n  }\n\n  get seen() {\n    return this._items.seen\n  }\n\n  get length() {\n    return this._items.length\n  }\n\n  get overflow() {\n    return this._items.overflow()\n  }\n\n  get events() {\n    return this._items\n  }\n\n  _merge() {\n    return this.mergeEvents.apply(this, arguments)\n  }\n\n  add() {\n    this._metrics.getOrCreateMetric(this._metricNames.SEEN).incrementCallCount()\n\n    const didAdd = this.addEvent.apply(this, arguments)\n\n    if (didAdd && (this._items.overflow() === 0)) {\n      this._metrics.getOrCreateMetric(this._metricNames.SENT).incrementCallCount()\n    } else {\n      this._metrics.getOrCreateMetric(this._metricNames.DROPPED).incrementCallCount()\n    }\n\n    return didAdd\n  }\n\n  _getMergeData() {\n    return this._items\n  }\n\n  clear() {\n    return this.clearEvents.apply(this, arguments)\n  }\n\n  /**\n   *\n   */\n  getQueue() {\n    return this._items\n  }\n\n  /**\n   * Fetches all the span events aggregated.\n   *\n   * @return {array.<Event>} An array of span events from the aggregator.\n   */\n  getEvents() {\n    return this._items.toArray()\n  }\n\n  /**\n   * Resets the contents of the aggregator and all counters.\n   *\n   * @return {PriorityQueue} The old collection of aggregated events.\n   */\n  clearEvents() {\n    // ???: might be more efficient to clear here and come up with an efficient way to\n    // serialize the events and priorities\n    this._items = new PriorityQueue(this._items.limit)\n  }\n\n  reconfigure(config) {\n    super.reconfigure(config)\n    const newSettings = config.getAggregatorConfig(this.method)\n    if (newSettings) {\n      this.periodMs = newSettings.periodMs\n      this.limit = newSettings.limit\n      this._items.setLimit(this.limit)\n    } else {\n      this.periodMs = this.defaultPeriod\n      this.limit = this.defaultLimit\n    }\n  }\n\n  addEvent(event, priority) {\n    return this._items.add(event, priority)\n  }\n\n  /**\n   * Merges a set of events back into the aggregator.\n   *\n   * This should only be used after a failed harvest with the `PriorityQueue`\n   * returned from `EventAggregator#clearEvents`.\n   *\n   * @param {?PriorityQueue} events - The collection of events to re-merge.\n   */\n  mergeEvents(events) {\n    if (!events) {\n      return\n    }\n\n    // We calculate the number that will be merged for the log, but we try to\n    // add every event because we want the ones with the highest priority, not\n    // the first `n` events.\n    const toMerge = Math.min(events.length, this.limit - this.length)\n    logger.warn(\n      'Merging %d of %d events into %s for next harvest',\n      toMerge, events.length, this.constructor.name\n    )\n\n    const seen = events.length\n    const sent = toMerge\n    const dropped = seen - sent\n\n    this._metrics.getOrCreateMetric(this._metricNames.SEEN).incrementCallCount(seen)\n    this._metrics.getOrCreateMetric(this._metricNames.SENT).incrementCallCount(sent)\n\n    if (dropped > 0) {\n      this._metrics\n        .getOrCreateMetric(this._metricNames.DROPPED)\n        .incrementCallCount(dropped)\n    }\n\n    // merge modifies incoming events collection.\n    this._items.merge(events)\n  }\n}\n\nmodule.exports = EventAggregator\n"]},"metadata":{},"sourceType":"script"}