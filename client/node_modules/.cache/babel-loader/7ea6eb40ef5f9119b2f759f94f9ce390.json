{"ast":null,"code":"'use strict';\n\nvar logger = require('../logger').child({\n  component: 'mapper'\n});\n/**\n * To tighten up the metrics JSON, the collector will maintain a list of\n * mappings from metric names (which sometimes include scopes as well) to\n * numeric IDs. As the agent sends new metric names to the collector, the\n * collector will return corresponding metric IDs, in the expectation that the\n * agent will uses those IDs instead of the names going forward.\n *\n * @param {Array} raw A list of metric spec -> ID mappings represented as\n *                    2-element arrays: [{name : 'Metric', scope : 'Scope'}, 1]\n */\n\n\nfunction MetricMapper(raw) {\n  this.unscoped = Object.create(null);\n  this.scoped = Object.create(null);\n  this.length = 0;\n  this.load(raw);\n}\n/**\n * Parse the list of metric mappings returned on metric_data responses from the\n * collector. These continue to stream in as the agent runs, so keep adding to\n * the collection rather than resetting.\n *\n * https://hudson.newrelic.com/job/collector-master/javadoc/com/nr/collector/datatypes/MetricData.html\n *\n * @param {Array} raw A list of metric spec -> ID mappings represented as\n *                    2-element arrays: [{name : 'Metric', scope : 'Scope'}, 1]\n */\n\n\nMetricMapper.prototype.load = function load(raw) {\n  if (!(raw && raw.length)) {\n    logger.debug(\"No new metric mappings from server.\");\n    return;\n  }\n\n  for (var i = 0; i < raw.length; i++) {\n    var spec = raw[i][0];\n    var scope = spec.scope;\n    var name = spec.name;\n    var id = raw[i][1];\n    var resolved;\n\n    if (scope) {\n      if (!this.scoped[scope]) {\n        this.scoped[scope] = Object.create(null);\n      }\n\n      resolved = this.scoped[scope];\n    } else {\n      resolved = this.unscoped;\n    }\n\n    if (!resolved[name]) this.length++;\n    resolved[name] = id;\n    logger.trace(\"Metric spec %s has been mapped to ID %s.\", spec, id);\n  }\n\n  logger.debug(\"Parsed %d metric ids (%d total).\", raw.length, this.length);\n};\n/**\n * @param {String} name  The metric name.\n * @param {String} scope The scope for the metric, if set.\n *\n * @returns {object} Either a metric spec based on the parameters, or the\n *                   server-sent ID.\n */\n\n\nMetricMapper.prototype.map = function map(name, scope) {\n  if (scope) {\n    if (this.scoped[scope] && this.scoped[scope][name]) {\n      return this.scoped[scope][name];\n    }\n\n    return {\n      name: name,\n      scope: scope\n    };\n  }\n\n  if (this.unscoped[name]) {\n    return this.unscoped[name];\n  }\n\n  return {\n    name: name\n  };\n};\n\nmodule.exports = MetricMapper;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/metrics/mapper.js"],"names":["logger","require","child","component","MetricMapper","raw","unscoped","Object","create","scoped","length","load","prototype","debug","i","spec","scope","name","id","resolved","trace","map","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,WAAD,CAAP,CAAqBC,KAArB,CAA2B;AAACC,EAAAA,SAAS,EAAE;AAAZ,CAA3B,CAAb;AAGA;;;;;;;;;;;;AAUA,SAASC,YAAT,CAAsBC,GAAtB,EAA2B;AACzB,OAAKC,QAAL,GAAgBC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAhB;AACA,OAAKC,MAAL,GAAcF,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;AACA,OAAKE,MAAL,GAAc,CAAd;AAEA,OAAKC,IAAL,CAAUN,GAAV;AACD;AAED;;;;;;;;;;;;AAUAD,YAAY,CAACQ,SAAb,CAAuBD,IAAvB,GAA8B,SAASA,IAAT,CAAcN,GAAd,EAAmB;AAC/C,MAAI,EAAEA,GAAG,IAAIA,GAAG,CAACK,MAAb,CAAJ,EAA0B;AACxBV,IAAAA,MAAM,CAACa,KAAP,CAAa,qCAAb;AACA;AACD;;AAED,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,GAAG,CAACK,MAAxB,EAAgCI,CAAC,EAAjC,EAAqC;AACnC,QAAIC,IAAI,GAAGV,GAAG,CAACS,CAAD,CAAH,CAAO,CAAP,CAAX;AACA,QAAIE,KAAK,GAAGD,IAAI,CAACC,KAAjB;AACA,QAAIC,IAAI,GAAGF,IAAI,CAACE,IAAhB;AACA,QAAIC,EAAE,GAAGb,GAAG,CAACS,CAAD,CAAH,CAAO,CAAP,CAAT;AACA,QAAIK,QAAJ;;AAGA,QAAIH,KAAJ,EAAW;AACT,UAAI,CAAC,KAAKP,MAAL,CAAYO,KAAZ,CAAL,EAAyB;AACvB,aAAKP,MAAL,CAAYO,KAAZ,IAAqBT,MAAM,CAACC,MAAP,CAAc,IAAd,CAArB;AACD;;AACDW,MAAAA,QAAQ,GAAG,KAAKV,MAAL,CAAYO,KAAZ,CAAX;AACD,KALD,MAKO;AACLG,MAAAA,QAAQ,GAAG,KAAKb,QAAhB;AACD;;AAED,QAAI,CAACa,QAAQ,CAACF,IAAD,CAAb,EAAqB,KAAKP,MAAL;AACrBS,IAAAA,QAAQ,CAACF,IAAD,CAAR,GAAiBC,EAAjB;AACAlB,IAAAA,MAAM,CAACoB,KAAP,CAAa,0CAAb,EAAyDL,IAAzD,EAA+DG,EAA/D;AACD;;AACDlB,EAAAA,MAAM,CAACa,KAAP,CAAa,kCAAb,EAAiDR,GAAG,CAACK,MAArD,EAA6D,KAAKA,MAAlE;AACD,CA5BD;AA8BA;;;;;;;;;AAOAN,YAAY,CAACQ,SAAb,CAAuBS,GAAvB,GAA6B,SAASA,GAAT,CAAaJ,IAAb,EAAmBD,KAAnB,EAA0B;AACrD,MAAIA,KAAJ,EAAW;AACT,QAAI,KAAKP,MAAL,CAAYO,KAAZ,KAAsB,KAAKP,MAAL,CAAYO,KAAZ,EAAmBC,IAAnB,CAA1B,EAAoD;AAClD,aAAO,KAAKR,MAAL,CAAYO,KAAZ,EAAmBC,IAAnB,CAAP;AACD;;AACD,WAAO;AAACA,MAAAA,IAAI,EAAEA,IAAP;AAAaD,MAAAA,KAAK,EAAEA;AAApB,KAAP;AACD;;AAED,MAAI,KAAKV,QAAL,CAAcW,IAAd,CAAJ,EAAyB;AACvB,WAAO,KAAKX,QAAL,CAAcW,IAAd,CAAP;AACD;;AAED,SAAO;AAACA,IAAAA,IAAI,EAAEA;AAAP,GAAP;AACD,CAbD;;AAeAK,MAAM,CAACC,OAAP,GAAiBnB,YAAjB","sourcesContent":["'use strict'\n\nvar logger = require('../logger').child({component: 'mapper'})\n\n\n/**\n * To tighten up the metrics JSON, the collector will maintain a list of\n * mappings from metric names (which sometimes include scopes as well) to\n * numeric IDs. As the agent sends new metric names to the collector, the\n * collector will return corresponding metric IDs, in the expectation that the\n * agent will uses those IDs instead of the names going forward.\n *\n * @param {Array} raw A list of metric spec -> ID mappings represented as\n *                    2-element arrays: [{name : 'Metric', scope : 'Scope'}, 1]\n */\nfunction MetricMapper(raw) {\n  this.unscoped = Object.create(null)\n  this.scoped = Object.create(null)\n  this.length = 0\n\n  this.load(raw)\n}\n\n/**\n * Parse the list of metric mappings returned on metric_data responses from the\n * collector. These continue to stream in as the agent runs, so keep adding to\n * the collection rather than resetting.\n *\n * https://hudson.newrelic.com/job/collector-master/javadoc/com/nr/collector/datatypes/MetricData.html\n *\n * @param {Array} raw A list of metric spec -> ID mappings represented as\n *                    2-element arrays: [{name : 'Metric', scope : 'Scope'}, 1]\n */\nMetricMapper.prototype.load = function load(raw) {\n  if (!(raw && raw.length)) {\n    logger.debug(\"No new metric mappings from server.\")\n    return\n  }\n\n  for (var i = 0; i < raw.length; i++) {\n    var spec = raw[i][0]\n    var scope = spec.scope\n    var name = spec.name\n    var id = raw[i][1]\n    var resolved\n\n\n    if (scope) {\n      if (!this.scoped[scope]) {\n        this.scoped[scope] = Object.create(null)\n      }\n      resolved = this.scoped[scope]\n    } else {\n      resolved = this.unscoped\n    }\n\n    if (!resolved[name]) this.length++\n    resolved[name] = id\n    logger.trace(\"Metric spec %s has been mapped to ID %s.\", spec, id)\n  }\n  logger.debug(\"Parsed %d metric ids (%d total).\", raw.length, this.length)\n}\n\n/**\n * @param {String} name  The metric name.\n * @param {String} scope The scope for the metric, if set.\n *\n * @returns {object} Either a metric spec based on the parameters, or the\n *                   server-sent ID.\n */\nMetricMapper.prototype.map = function map(name, scope) {\n  if (scope) {\n    if (this.scoped[scope] && this.scoped[scope][name]) {\n      return this.scoped[scope][name]\n    }\n    return {name: name, scope: scope}\n  }\n\n  if (this.unscoped[name]) {\n    return this.unscoped[name]\n  }\n\n  return {name: name}\n}\n\nmodule.exports = MetricMapper\n"]},"metadata":{},"sourceType":"script"}