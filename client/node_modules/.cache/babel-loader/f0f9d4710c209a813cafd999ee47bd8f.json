{"ast":null,"code":"'use strict';\n\nvar Heap = require('@tyriar/fibonacci-heap').FibonacciHeap;\n\nfunction PriorityQueue(limit) {\n  this.limit = limit == null ? 10 : limit;\n  this.seen = 0;\n  this._data = new Heap();\n  Object.defineProperty(this, 'length', {\n    get: function getLength() {\n      return this._data._nodeCount;\n    }\n  });\n}\n\nPriorityQueue.prototype.overflow = function overflow() {\n  var diff = this.seen - this.limit;\n  return diff >= 0 ? diff : 0;\n};\n\nPriorityQueue.prototype.getMinimumPriority = function getMinimumPriority() {\n  return this.length < this.limit ? 0 : this._data.findMinimum().key;\n};\n\nPriorityQueue.prototype.add = function add(value, priority) {\n  this.seen++;\n\n  if (this.limit <= 0) {\n    return false;\n  }\n\n  priority = priority || Math.random();\n\n  if (this.length === this.limit) {\n    return this._replace(value, priority);\n  }\n\n  this._data.insert(priority, value);\n\n  return true;\n};\n\nPriorityQueue.prototype._replace = function _replace(value, priority) {\n  if (priority > this._data.findMinimum().key) {\n    this._data.insert(priority, value);\n\n    this._data.extractMinimum();\n\n    return true;\n  }\n\n  return false;\n};\n\nPriorityQueue.prototype.getRawEvents = function getRawEvents() {\n  var events = [];\n\n  var min = this._data.findMinimum();\n\n  if (min) {\n    _getRawEvents(min, events);\n  }\n\n  return events;\n\n  function _getRawEvents(head, evts) {\n    var current = head;\n\n    do {\n      evts.push({\n        value: current.value,\n        priority: current.key\n      });\n\n      if (current.child) {\n        _getRawEvents(current.child, evts);\n      }\n\n      current = current.next;\n    } while (current !== head);\n  }\n};\n\nPriorityQueue.prototype.toArray = function toArray() {\n  var nodes = [];\n\n  var min = this._data.findMinimum();\n\n  if (min) {\n    serializeHeap(min, nodes);\n  }\n\n  return nodes;\n\n  function serializeHeap(head, arr) {\n    var current = head;\n\n    do {\n      arr.push(current.value);\n\n      if (current.child) {\n        serializeHeap(current.child, arr);\n      }\n\n      current = current.next;\n    } while (current !== head);\n  }\n};\n\nPriorityQueue.prototype.setLimit = function setLimit(newLimit) {\n  this.limit = newLimit;\n\n  while (this.length > newLimit) {\n    this._data.extractMinimum();\n  }\n};\n\nPriorityQueue.prototype.merge = function merge(events) {\n  if (!events || !events.length) {\n    return;\n  }\n\n  if (events instanceof PriorityQueue) {\n    while (events.length) {\n      var current = events._data.extractMinimum();\n\n      this.add(current.value, current.key);\n    }\n  } else {\n    for (var i = 0; i < events.length; ++i) {\n      this.add(events[i].value, events[i].priority);\n    }\n  }\n};\n\nmodule.exports = PriorityQueue;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/priority-queue.js"],"names":["Heap","require","FibonacciHeap","PriorityQueue","limit","seen","_data","Object","defineProperty","get","getLength","_nodeCount","prototype","overflow","diff","getMinimumPriority","length","findMinimum","key","add","value","priority","Math","random","_replace","insert","extractMinimum","getRawEvents","events","min","_getRawEvents","head","evts","current","push","child","next","toArray","nodes","serializeHeap","arr","setLimit","newLimit","merge","i","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar Heap = require('@tyriar/fibonacci-heap').FibonacciHeap\n\nfunction PriorityQueue(limit) {\n  this.limit = limit == null ? 10 : limit\n  this.seen = 0\n  this._data = new Heap()\n\n  Object.defineProperty(this, 'length', {\n    get: function getLength() {\n      return this._data._nodeCount\n    }\n  })\n}\n\nPriorityQueue.prototype.overflow = function overflow() {\n  var diff = this.seen - this.limit\n  return diff >= 0 ? diff : 0\n}\n\nPriorityQueue.prototype.getMinimumPriority = function getMinimumPriority() {\n  return this.length < this.limit ? 0 : this._data.findMinimum().key\n}\n\nPriorityQueue.prototype.add = function add(value, priority) {\n  this.seen++\n  if (this.limit <= 0) {\n    return false\n  }\n  priority = priority || Math.random()\n  if (this.length === this.limit) {\n    return this._replace(value, priority)\n  }\n  this._data.insert(priority, value)\n  return true\n}\n\nPriorityQueue.prototype._replace = function _replace(value, priority) {\n  if (priority > this._data.findMinimum().key) {\n    this._data.insert(priority, value)\n    this._data.extractMinimum()\n    return true\n  }\n  return false\n}\n\nPriorityQueue.prototype.getRawEvents = function getRawEvents() {\n  var events = []\n  var min = this._data.findMinimum()\n\n  if (min) {\n    _getRawEvents(min, events)\n  }\n\n  return events\n\n  function _getRawEvents(head, evts) {\n    var current = head\n\n    do {\n      evts.push({value: current.value, priority: current.key})\n      if (current.child) {\n        _getRawEvents(current.child, evts)\n      }\n      current = current.next\n    } while (current !== head)\n  }\n}\n\nPriorityQueue.prototype.toArray = function toArray() {\n  var nodes = []\n  var min = this._data.findMinimum()\n\n  if (min) {\n    serializeHeap(min, nodes)\n  }\n\n  return nodes\n\n  function serializeHeap(head, arr) {\n    var current = head\n\n    do {\n      arr.push(current.value)\n      if (current.child) {\n        serializeHeap(current.child, arr)\n      }\n      current = current.next\n    } while (current !== head)\n  }\n}\n\nPriorityQueue.prototype.setLimit = function setLimit(newLimit) {\n  this.limit = newLimit\n  while (this.length > newLimit) {\n    this._data.extractMinimum()\n  }\n}\n\nPriorityQueue.prototype.merge = function merge(events) {\n  if (!events || !events.length) {\n    return\n  }\n\n  if (events instanceof PriorityQueue) {\n    while (events.length) {\n      var current = events._data.extractMinimum()\n      this.add(current.value, current.key)\n    }\n  } else {\n    for (var i = 0; i < events.length; ++i) {\n      this.add(events[i].value, events[i].priority)\n    }\n  }\n}\n\nmodule.exports = PriorityQueue\n"]},"metadata":{},"sourceType":"script"}