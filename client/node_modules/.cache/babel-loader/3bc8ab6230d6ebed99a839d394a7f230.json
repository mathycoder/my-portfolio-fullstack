{"ast":null,"code":"'use strict';\n\nconst logger = require('../logger').child({\n  component: 'new_relic_response'\n});\n/**\n * The collector has many ways of indicating failure, and isn't\n * necessarily consistent. Because there can either be a failure at\n * the network level, a nonstandard HTTP status code on the response,\n * or a JSON-encoded exception in the response body, there's a lot of\n * conditional logic in here that tries to grab as much information\n * about errors as possible, and to parse out the return value as often\n * as possible.\n *\n * @param string         name     Remote method name that was invoked.\n * @param ServerResponse response HTTP response stream\n * @param Function       callback Function that will be called with any\n *                                error, the value returned by the server\n *                                (if any), and the raw JSON of the\n *                                server's response.\n *\n * @returns Function Another callback that is meant to be invoked with\n *                   any errors from reading the response stream, as\n *                   well as a string containing the full response.\n */\n\n\nmodule.exports = function parse(name, response, callback) {\n  if (!callback) {\n    throw new TypeError('callback required!');\n  }\n\n  if (!name) {\n    return callback(new TypeError('collector method name required!'));\n  }\n\n  if (!response) {\n    return callback(new TypeError('HTTP response required!'));\n  }\n\n  return function parser(error, body) {\n    if (error) {\n      return setImmediate(() => callback(error));\n    }\n\n    let payload = null;\n\n    if (body) {\n      try {\n        const json = JSON.parse(body); // Can be super verbose, but useful for debugging.\n\n        logger.trace(json, 'Deserialized from collector:');\n        payload = json.return_value || payload;\n      } catch (err) {\n        logger.warn(err, 'Could not parse response from the collector: %s', body);\n      }\n    }\n\n    const res = {\n      status: response.statusCode,\n      payload\n    };\n    setImmediate(() => callback(null, res));\n  };\n};","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/collector/parse-response.js"],"names":["logger","require","child","component","module","exports","parse","name","response","callback","TypeError","parser","error","body","setImmediate","payload","json","JSON","trace","return_value","err","warn","res","status","statusCode"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,WAAD,CAAP,CAAqBC,KAArB,CAA2B;AAACC,EAAAA,SAAS,EAAE;AAAZ,CAA3B,CAAf;AAGA;;;;;;;;;;;;;;;;;;;;;;AAoBAC,MAAM,CAACC,OAAP,GAAiB,SAASC,KAAT,CAAeC,IAAf,EAAqBC,QAArB,EAA+BC,QAA/B,EAAyC;AACxD,MAAI,CAACA,QAAL,EAAe;AACb,UAAM,IAAIC,SAAJ,CAAc,oBAAd,CAAN;AACD;;AACD,MAAI,CAACH,IAAL,EAAW;AACT,WAAOE,QAAQ,CAAC,IAAIC,SAAJ,CAAc,iCAAd,CAAD,CAAf;AACD;;AACD,MAAI,CAACF,QAAL,EAAe;AACb,WAAOC,QAAQ,CAAC,IAAIC,SAAJ,CAAc,yBAAd,CAAD,CAAf;AACD;;AAED,SAAO,SAASC,MAAT,CAAgBC,KAAhB,EAAuBC,IAAvB,EAA6B;AAClC,QAAID,KAAJ,EAAW;AACT,aAAOE,YAAY,CAAC,MAAML,QAAQ,CAACG,KAAD,CAAf,CAAnB;AACD;;AAED,QAAIG,OAAO,GAAG,IAAd;;AAEA,QAAIF,IAAJ,EAAU;AACR,UAAI;AACF,cAAMG,IAAI,GAAGC,IAAI,CAACX,KAAL,CAAWO,IAAX,CAAb,CADE,CAGF;;AACAb,QAAAA,MAAM,CAACkB,KAAP,CAAaF,IAAb,EAAmB,8BAAnB;AAEAD,QAAAA,OAAO,GAAGC,IAAI,CAACG,YAAL,IAAqBJ,OAA/B;AACD,OAPD,CAOE,OAAOK,GAAP,EAAY;AACZpB,QAAAA,MAAM,CAACqB,IAAP,CAAYD,GAAZ,EAAiB,iDAAjB,EAAoEP,IAApE;AACD;AACF;;AAED,UAAMS,GAAG,GAAG;AACVC,MAAAA,MAAM,EAAEf,QAAQ,CAACgB,UADP;AAEVT,MAAAA;AAFU,KAAZ;AAKAD,IAAAA,YAAY,CAAC,MAAML,QAAQ,CAAC,IAAD,EAAOa,GAAP,CAAf,CAAZ;AACD,GA1BD;AA2BD,CAtCD","sourcesContent":["'use strict'\n\nconst logger = require('../logger').child({component: 'new_relic_response'})\n\n\n/**\n * The collector has many ways of indicating failure, and isn't\n * necessarily consistent. Because there can either be a failure at\n * the network level, a nonstandard HTTP status code on the response,\n * or a JSON-encoded exception in the response body, there's a lot of\n * conditional logic in here that tries to grab as much information\n * about errors as possible, and to parse out the return value as often\n * as possible.\n *\n * @param string         name     Remote method name that was invoked.\n * @param ServerResponse response HTTP response stream\n * @param Function       callback Function that will be called with any\n *                                error, the value returned by the server\n *                                (if any), and the raw JSON of the\n *                                server's response.\n *\n * @returns Function Another callback that is meant to be invoked with\n *                   any errors from reading the response stream, as\n *                   well as a string containing the full response.\n */\nmodule.exports = function parse(name, response, callback) {\n  if (!callback) {\n    throw new TypeError('callback required!')\n  }\n  if (!name) {\n    return callback(new TypeError('collector method name required!'))\n  }\n  if (!response) {\n    return callback(new TypeError('HTTP response required!'))\n  }\n\n  return function parser(error, body) {\n    if (error) {\n      return setImmediate(() => callback(error))\n    }\n\n    let payload = null\n\n    if (body) {\n      try {\n        const json = JSON.parse(body)\n\n        // Can be super verbose, but useful for debugging.\n        logger.trace(json, 'Deserialized from collector:')\n\n        payload = json.return_value || payload\n      } catch (err) {\n        logger.warn(err, 'Could not parse response from the collector: %s', body)\n      }\n    }\n\n    const res = {\n      status: response.statusCode,\n      payload\n    }\n\n    setImmediate(() => callback(null, res))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}