{"ast":null,"code":"'use strict';\n\nmodule.exports = parse;\nmodule.exports.fromString = fromString;\nmodule.exports.fromMap = fromMap; // this creates a copy of trim that can be used with map\n\nvar trim = Function.prototype.call.bind(String.prototype.trim);\n\nvar logger = require('../logger').child({\n  component: 'label-parser'\n});\n\nvar stringify = require('json-stringify-safe');\n\nfunction parse(labels) {\n  var results;\n\n  if (!labels) {\n    return [];\n  } else if (typeof labels === 'string') {\n    results = fromString(labels);\n  } else if (labels) {\n    results = fromMap(labels);\n  }\n\n  results.warnings.forEach(function logWarnings(messaage) {\n    logger.warn(messaage);\n  });\n  return results.labels;\n}\n\nfunction fromString(raw) {\n  var map = Object.create(null);\n\n  if (!raw) {\n    return {\n      labels: [],\n      warnings: []\n    };\n  }\n\n  var pairs = raw.split(';').map(trim);\n  var parts;\n\n  while (!pairs[pairs.length - 1]) {\n    pairs.pop();\n  }\n\n  while (!pairs[0]) {\n    pairs.shift();\n  }\n\n  for (var i = 0, l = pairs.length; i < l; ++i) {\n    parts = pairs[i].split(':').map(trim);\n\n    if (parts.length !== 2) {\n      return warn('Could not create a Label pair from ' + parts[i]);\n    } else if (!parts[0]) {\n      return warn('Label key can not be empty');\n    } else if (!parts[1]) {\n      return warn('Label value can not be empty');\n    }\n\n    map[parts[0]] = parts[1];\n  }\n\n  return fromMap(map);\n\n  function warn(message) {\n    return {\n      labels: [],\n      warnings: ['Invalid Label String: ' + raw, message]\n    };\n  }\n}\n\nfunction fromMap(map) {\n  var warnings = [];\n  var labels = [];\n  Object.keys(map).forEach(function processKeys(key) {\n    var type = truncate(key, 255);\n\n    if (!map[key] || typeof map[key] !== 'string') {\n      return warnings.push('Label value for ' + type + 'should be a string with a length between 1 and 255 characters');\n    }\n\n    var value = truncate(map[key], 255);\n\n    if (type !== key) {\n      warnings.push('Label key too long: ' + type);\n    }\n\n    if (value !== map[key]) {\n      warnings.push('Label value too long: ' + value);\n    }\n\n    labels.push({\n      label_type: type,\n      label_value: value\n    });\n  });\n\n  if (labels.length > 64) {\n    warnings.push('Too many Labels, list truncated to 64');\n    labels = labels.slice(0, 64);\n  }\n\n  if (warnings.length) {\n    try {\n      warnings.unshift('Partially Invalid Label Setting: ' + stringify(map));\n    } catch (err) {\n      logger.debug(err, 'Failed to stringify labels');\n    }\n  }\n\n  return {\n    labels: labels,\n    warnings: warnings\n  };\n}\n\nfunction truncate(str, max) {\n  var len = 0;\n  var chr;\n\n  for (var i = 0, l = str.length; i < l; ++i) {\n    chr = str.charCodeAt(i);\n\n    if (chr >= 0xD800 && chr <= 0xDBFF && i !== l) {\n      i += 1;\n    }\n\n    if (++len === max) {\n      break;\n    }\n  }\n\n  return str.slice(0, i + 1);\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/util/label-parser.js"],"names":["module","exports","parse","fromString","fromMap","trim","Function","prototype","call","bind","String","logger","require","child","component","stringify","labels","results","warnings","forEach","logWarnings","messaage","warn","raw","map","Object","create","pairs","split","parts","length","pop","shift","i","l","message","keys","processKeys","key","type","truncate","push","value","label_type","label_value","slice","unshift","err","debug","str","max","len","chr","charCodeAt"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = parse\nmodule.exports.fromString = fromString\nmodule.exports.fromMap = fromMap\n\n\n// this creates a copy of trim that can be used with map\nvar trim = Function.prototype.call.bind(String.prototype.trim)\nvar logger = require('../logger').child({component: 'label-parser'})\nvar stringify = require('json-stringify-safe')\n\nfunction parse(labels) {\n  var results\n\n  if (!labels) {\n    return []\n  } else if (typeof labels === 'string') {\n    results = fromString(labels)\n  } else if (labels) {\n    results = fromMap(labels)\n  }\n\n  results.warnings.forEach(function logWarnings(messaage) {\n    logger.warn(messaage)\n  })\n\n  return results.labels\n}\n\nfunction fromString(raw) {\n  var map = Object.create(null)\n\n  if (!raw) {\n    return {labels: [], warnings: []}\n  }\n\n  var pairs = raw.split(';').map(trim)\n  var parts\n\n\n  while (!pairs[pairs.length - 1]) {\n    pairs.pop()\n  }\n\n  while (!pairs[0]) {\n    pairs.shift()\n  }\n\n  for (var i = 0, l = pairs.length; i < l; ++i) {\n    parts = pairs[i].split(':').map(trim)\n\n    if (parts.length !== 2) {\n      return warn('Could not create a Label pair from ' + parts[i])\n    } else if (!parts[0]) {\n      return warn('Label key can not be empty')\n    } else if (!parts[1]) {\n      return warn('Label value can not be empty')\n    }\n\n    map[parts[0]] = parts[1]\n  }\n\n  return fromMap(map)\n\n  function warn(message) {\n    return {labels: [], warnings: [\n      'Invalid Label String: ' + raw,\n      message\n    ]}\n  }\n}\n\nfunction fromMap(map) {\n  var warnings = []\n  var labels = []\n\n  Object.keys(map).forEach(function processKeys(key) {\n    var type = truncate(key, 255)\n\n    if (!map[key] || typeof map[key] !== 'string') {\n      return warnings.push(\n        'Label value for ' + type +\n        'should be a string with a length between 1 and 255 characters'\n      )\n    }\n\n    var value = truncate(map[key], 255)\n\n    if (type !== key) {\n      warnings.push('Label key too long: ' + type)\n    }\n\n    if (value !== map[key]) {\n      warnings.push('Label value too long: ' + value)\n    }\n\n    labels.push({label_type: type, label_value: value})\n  })\n\n  if (labels.length > 64) {\n    warnings.push('Too many Labels, list truncated to 64')\n    labels = labels.slice(0, 64)\n  }\n\n  if (warnings.length) {\n    try {\n      warnings.unshift('Partially Invalid Label Setting: ' + stringify(map))\n    } catch (err) {\n      logger.debug(err, 'Failed to stringify labels')\n    }\n  }\n\n  return {labels: labels, warnings: warnings}\n}\n\nfunction truncate(str, max) {\n  var len = 0\n  var chr\n  for (var i = 0, l = str.length; i < l; ++i) {\n    chr = str.charCodeAt(i)\n    if (chr >= 0xD800 && chr <= 0xDBFF && i !== l) {\n      i += 1\n    }\n\n    if (++len === max) {\n      break\n    }\n  }\n\n  return str.slice(0, i + 1)\n}\n"]},"metadata":{},"sourceType":"script"}