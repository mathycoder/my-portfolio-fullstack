{"ast":null,"code":"'use strict';\n\nvar url = require('url');\n\nvar LOCALHOST_NAMES = {\n  \"localhost\": true,\n  \"127.0.0.1\": true,\n  \"0.0.0.0\": true,\n  \"0:0:0:0:0:0:0:1\": true,\n  \"::1\": true,\n  \"0:0:0:0:0:0:0:0\": true,\n  \"::\": true\n};\n/**\n * Utility functions for enforcing New Relic naming conditions on URLs,\n * and extracting and setting parameters on traces / web trace segments.\n */\n\nmodule.exports = {\n  /**\n   * Dictionary whose keys are all synonyms for localhost.\n   *\n   * @const\n   */\n  LOCALHOST_NAMES: LOCALHOST_NAMES,\n\n  /**\n   * Checks if the given name is in the dictionary of localhost names.\n   *\n   * @param {string} host - The hostname to lookup.\n   *\n   * @return {bool} - True if the given hostname is a synonym for localhost.\n   */\n  isLocalhost: function isLocahost(host) {\n    return LOCALHOST_NAMES[host] != null;\n  },\n\n  /**\n   * This was handed down from the prototype as the canonical list of status\n   * codes that short-circuit naming and normalization. The agent can be\n   * configured to mark HTTP status codes as not being errors.\n   *\n   * @param {Config} config The configuration containing the error list.\n   * @param {string} code   The HTTP status code to check.\n   *\n   * @returns {bool} Whether the status code should be ignored.\n   */\n  isError: function isError(config, code) {\n    return code >= 400 && !isIgnoredStatusCodeForErrors(config, code);\n  },\n\n  /**\n   * Returns true if the status code is an HTTP error, and it is configured to be ignored.\n   *\n   * @param {Config} config The configuration containing the error list.\n   * @param {string} code   The HTTP status code to check.\n   *\n   * @returns {bool} Whether the status code should be ignored.\n   */\n  isIgnoredError: function isIgnoredError(config, code) {\n    return code >= 400 && isIgnoredStatusCodeForErrors(config, code);\n  },\n\n  /**\n   * Returns true if the status code is configured to be expected\n   *\n   * @param {Config} config The configuration containing the error list.\n   * @param {string} code   The HTTP status code to check.\n   *\n   * @returns {bool} Whether the status code is expected.\n   *\n   */\n  isExpectedError: function isExpectedError(config, code) {\n    return isExpectedStatusCodeForErrors(config, code);\n  },\n\n  /**\n   * Get back the pieces of the URL that New Relic cares about. Apply these\n   * restrictions, in order:\n   *\n   * 1. Ensure that after parsing the URL, there's at least '/'\n   * 2. Strip off session trackers after ';' (a New Relic convention)\n   * 3. Remove trailing slash.\n   *\n   * @param {string} requestURL The URL fragment to be scrubbed.\n   * @return {string} The cleaned URL.\n   */\n  scrub: function scrub(requestURL) {\n    if (typeof requestURL === 'string') {\n      requestURL = url.parse(requestURL);\n    }\n\n    var path = requestURL.pathname;\n\n    if (path) {\n      path = path.split(';')[0];\n\n      if (path !== '/' && path.charAt(path.length - 1) === '/') {\n        path = path.substring(0, path.length - 1);\n      }\n    } else {\n      path = '/';\n    }\n\n    return path;\n  },\n\n  /**\n   * Extract query parameters, dealing with bare parameters and parameters with\n   * no value as appropriate:\n   *\n   * 'var1&var2=value' is not necessarily the same as 'var1=&var2=value'\n   *\n   * In my world, one is an assertion of presence, and the other is an empty\n   * variable. Some web frameworks behave this way as well, so don't lose\n   * information.\n   *\n   * @param {string} requestURL The URL to be parsed.\n   * @returns {object} The parameters parsed from the request\n   */\n  parseParameters: function parseParameters(requestURL) {\n    var parsed = requestURL;\n\n    if (typeof requestURL === 'string') {\n      parsed = url.parse(requestURL, true);\n    }\n\n    var parameters = Object.create(null);\n\n    if (parsed.query) {\n      var keys = Object.keys(parsed.query);\n\n      for (var i = 0, l = keys.length; i < l; ++i) {\n        var key = keys[i];\n\n        if (parsed.query[key] === '' && parsed.path.indexOf(key + '=') === -1) {\n          parameters[key] = true;\n        } else {\n          parameters[key] = parsed.query[key];\n        }\n      }\n    }\n\n    return parameters;\n  },\n\n  /**\n   * Performs the logic of `urltils.scrub` and `urltils.parseParameters` with\n   * only a single parse of the given URL.\n   *\n   * @param {string} requestURL - The URL to scrub and extra parameters from.\n   *\n   * @return {object} An object containing the scrubbed url at `.path` and the\n   *  parsed parameters at `.parameters`.\n   */\n  scrubAndParseParameters: function scrubAndParseParameters(requestURL) {\n    if (typeof requestURL === 'string') {\n      requestURL = url.parse(requestURL, true);\n    }\n\n    return {\n      protocol: requestURL.protocol,\n      path: this.scrub(requestURL),\n      parameters: this.parseParameters(requestURL)\n    };\n  },\n\n  /**\n   * Copy a set of request parameters from one object to another,\n   * but do not overwrite any existing parameters in destination,\n   * including parameters set to null or undefined.\n   *\n   * @param {object} source      Parameters to be copied (not changed).\n   * @param {object} destination Dictionary to which parameters are copied\n   *                             (mutated in place).\n   */\n  copyParameters: function copyParameters(source, destination) {\n    if (source && destination) {\n      var keys = Object.keys(source);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n\n        if (!(key in destination)) {\n          destination[key] = source[key];\n        }\n      }\n    }\n  },\n\n  /**\n   * Copy a set of request parameters from one object to another.\n   * Existing attributes on the `destination` will be overwritten.\n   *\n   * @param {object} source      Parameters to be copied (not changed).\n   * @param {object} destination Dictionary to which parameters are copied\n   *                             (mutated in place).\n   */\n  overwriteParameters: function overwriteParameters(source, destination) {\n    var keys = Object.keys(source);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      destination[key] = source[key];\n    }\n  }\n};\n\nfunction isIgnoredStatusCodeForErrors(config, code) {\n  var codes = [];\n\n  if (config && config.error_collector && config.error_collector.ignore_status_codes) {\n    codes = config.error_collector.ignore_status_codes;\n  }\n\n  return codes.indexOf(parseInt(code, 10)) >= 0;\n}\n\nfunction isExpectedStatusCodeForErrors(config, code) {\n  var codes = [];\n\n  if (config && config.error_collector && config.error_collector.expected_status_codes) {\n    codes = config.error_collector.expected_status_codes;\n  }\n\n  return codes.indexOf(parseInt(code, 10)) >= 0;\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/util/urltils.js"],"names":["url","require","LOCALHOST_NAMES","module","exports","isLocalhost","isLocahost","host","isError","config","code","isIgnoredStatusCodeForErrors","isIgnoredError","isExpectedError","isExpectedStatusCodeForErrors","scrub","requestURL","parse","path","pathname","split","charAt","length","substring","parseParameters","parsed","parameters","Object","create","query","keys","i","l","key","indexOf","scrubAndParseParameters","protocol","copyParameters","source","destination","overwriteParameters","codes","error_collector","ignore_status_codes","parseInt","expected_status_codes"],"mappings":"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","sourcesContent":["'use strict'\n\nvar url = require('url')\n\nvar LOCALHOST_NAMES = {\n  \"localhost\": true,\n  \"127.0.0.1\": true,\n  \"0.0.0.0\": true,\n  \"0:0:0:0:0:0:0:1\": true,\n  \"::1\": true,\n  \"0:0:0:0:0:0:0:0\": true,\n  \"::\": true\n}\n\n/**\n * Utility functions for enforcing New Relic naming conditions on URLs,\n * and extracting and setting parameters on traces / web trace segments.\n */\nmodule.exports = {\n  /**\n   * Dictionary whose keys are all synonyms for localhost.\n   *\n   * @const\n   */\n  LOCALHOST_NAMES: LOCALHOST_NAMES,\n\n  /**\n   * Checks if the given name is in the dictionary of localhost names.\n   *\n   * @param {string} host - The hostname to lookup.\n   *\n   * @return {bool} - True if the given hostname is a synonym for localhost.\n   */\n  isLocalhost: function isLocahost(host) {\n    return LOCALHOST_NAMES[host] != null\n  },\n\n  /**\n   * This was handed down from the prototype as the canonical list of status\n   * codes that short-circuit naming and normalization. The agent can be\n   * configured to mark HTTP status codes as not being errors.\n   *\n   * @param {Config} config The configuration containing the error list.\n   * @param {string} code   The HTTP status code to check.\n   *\n   * @returns {bool} Whether the status code should be ignored.\n   */\n  isError: function isError(config, code) {\n    return code >= 400 && !isIgnoredStatusCodeForErrors(config, code)\n  },\n\n  /**\n   * Returns true if the status code is an HTTP error, and it is configured to be ignored.\n   *\n   * @param {Config} config The configuration containing the error list.\n   * @param {string} code   The HTTP status code to check.\n   *\n   * @returns {bool} Whether the status code should be ignored.\n   */\n  isIgnoredError: function isIgnoredError(config, code) {\n    return code >= 400 && isIgnoredStatusCodeForErrors(config, code)\n  },\n\n  /**\n   * Returns true if the status code is configured to be expected\n   *\n   * @param {Config} config The configuration containing the error list.\n   * @param {string} code   The HTTP status code to check.\n   *\n   * @returns {bool} Whether the status code is expected.\n   *\n   */\n  isExpectedError: function isExpectedError(config, code) {\n    return isExpectedStatusCodeForErrors(config, code)\n  },\n\n  /**\n   * Get back the pieces of the URL that New Relic cares about. Apply these\n   * restrictions, in order:\n   *\n   * 1. Ensure that after parsing the URL, there's at least '/'\n   * 2. Strip off session trackers after ';' (a New Relic convention)\n   * 3. Remove trailing slash.\n   *\n   * @param {string} requestURL The URL fragment to be scrubbed.\n   * @return {string} The cleaned URL.\n   */\n  scrub: function scrub(requestURL) {\n    if (typeof requestURL === 'string') {\n      requestURL = url.parse(requestURL)\n    }\n\n    var path = requestURL.pathname\n\n    if (path) {\n      path = path.split(';')[0]\n\n      if (path !== '/' && path.charAt(path.length - 1) === '/') {\n        path = path.substring(0, path.length - 1)\n      }\n    } else {\n      path = '/'\n    }\n\n    return path\n  },\n\n  /**\n   * Extract query parameters, dealing with bare parameters and parameters with\n   * no value as appropriate:\n   *\n   * 'var1&var2=value' is not necessarily the same as 'var1=&var2=value'\n   *\n   * In my world, one is an assertion of presence, and the other is an empty\n   * variable. Some web frameworks behave this way as well, so don't lose\n   * information.\n   *\n   * @param {string} requestURL The URL to be parsed.\n   * @returns {object} The parameters parsed from the request\n   */\n  parseParameters: function parseParameters(requestURL) {\n    var parsed = requestURL\n\n    if (typeof requestURL === 'string') {\n      parsed = url.parse(requestURL, true)\n    }\n\n    var parameters = Object.create(null)\n\n    if (parsed.query) {\n      var keys = Object.keys(parsed.query)\n\n      for (var i = 0, l = keys.length; i < l; ++i) {\n        var key = keys[i]\n        if (parsed.query[key] === '' && parsed.path.indexOf(key + '=') === -1) {\n          parameters[key] = true\n        } else {\n          parameters[key] = parsed.query[key]\n        }\n      }\n    }\n\n    return parameters\n  },\n\n  /**\n   * Performs the logic of `urltils.scrub` and `urltils.parseParameters` with\n   * only a single parse of the given URL.\n   *\n   * @param {string} requestURL - The URL to scrub and extra parameters from.\n   *\n   * @return {object} An object containing the scrubbed url at `.path` and the\n   *  parsed parameters at `.parameters`.\n   */\n  scrubAndParseParameters: function scrubAndParseParameters(requestURL) {\n    if (typeof requestURL === 'string') {\n      requestURL = url.parse(requestURL, true)\n    }\n    return {\n      protocol: requestURL.protocol,\n      path: this.scrub(requestURL),\n      parameters: this.parseParameters(requestURL)\n    }\n  },\n\n  /**\n   * Copy a set of request parameters from one object to another,\n   * but do not overwrite any existing parameters in destination,\n   * including parameters set to null or undefined.\n   *\n   * @param {object} source      Parameters to be copied (not changed).\n   * @param {object} destination Dictionary to which parameters are copied\n   *                             (mutated in place).\n   */\n  copyParameters: function copyParameters(source, destination) {\n    if (source && destination) {\n      var keys = Object.keys(source)\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        if (!(key in destination)) {\n          destination[key] = source[key]\n        }\n      }\n    }\n  },\n\n  /**\n   * Copy a set of request parameters from one object to another.\n   * Existing attributes on the `destination` will be overwritten.\n   *\n   * @param {object} source      Parameters to be copied (not changed).\n   * @param {object} destination Dictionary to which parameters are copied\n   *                             (mutated in place).\n   */\n  overwriteParameters: function overwriteParameters(source, destination) {\n    var keys = Object.keys(source)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      destination[key] = source[key]\n    }\n  }\n}\n\nfunction isIgnoredStatusCodeForErrors(config, code) {\n  var codes = []\n  if (config &&\n      config.error_collector &&\n      config.error_collector.ignore_status_codes) {\n    codes = config.error_collector.ignore_status_codes\n  }\n  return codes.indexOf(parseInt(code, 10)) >= 0\n}\n\nfunction isExpectedStatusCodeForErrors(config, code) {\n  var codes = []\n  if (config &&\n      config.error_collector &&\n      config.error_collector.expected_status_codes) {\n    codes = config.error_collector.expected_status_codes\n  }\n  return codes.indexOf(parseInt(code, 10)) >= 0\n}\n"]},"metadata":{},"sourceType":"script"}