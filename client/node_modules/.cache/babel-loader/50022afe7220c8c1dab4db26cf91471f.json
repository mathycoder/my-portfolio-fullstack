{"ast":null,"code":"'use strict';\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === '[object Arguments]';\n}\n\nfunction slice(args) {\n  // Array.prototype.slice on arguments array-like is expensive\n  var l = args.length,\n      a = [],\n      i;\n\n  for (i = 0; i < l; i++) {\n    a[i] = args[i];\n  }\n\n  return a;\n}\n/**\n * This is a node-specific version of deepEquals, modeled on bits and pieces\n * of loads of other implementations of this algorithm, most notably the\n * one in the Node.js source and Underscore's. It doesn't throw and handles\n * cycles.\n *\n * Everybody who writes one of these functions puts the documentation\n * inline, which makes it incredibly hard to follow. Here's what this version\n * of the algorithm does, in order:\n *\n * 1. === only tests objects and and functions by reference. Null is an object.\n *    Any pair of identical entities failing this test are therefore objects\n *    (including null), which need a recursive compare by attribute.\n * 2. Since the only matching entities to get to this test must be objects, if\n *    a or b is not an object, they're clearly not the same. All unfiltered a\n *    and b getting are objects (including null).\n * 3. null is an object, but null === null. All unfiltered a and b are non-null\n *    objects.\n * 4. Buffers need to be special-cased because they live partially on the wrong\n *    side of the C++ / JavaScript barrier. Still, calling this on structures\n *    that can contain Buffers is a bad idea, because they can contain\n *    multiple megabytes of data and comparing them byte-by-byte is very\n *    expensive. buffertools is a better solution here, but this version of\n *    this code is dependency free.\n * 5. It's much faster to compare dates by numeric value than by lexical value.\n * 6. Same goes for Regexps.\n * 7. The parts of an arguments list most people care about are the arguments\n *    themselves, not the callee, which you shouldn't be looking at anyway.\n * 8. Objects are more complex:\n *    a. ensure that a and b are on the same constructor chain\n *    b. ensure that a and b have the same number of own properties (which is\n *       what Object.keys returns).\n *    c. ensure that cyclical references don't blow up the stack.\n *    d. ensure that all the key names match (faster)\n *    e. ensure that all of the associated values match, recursively (slower)\n *\n * (SOMEWHAT UNTESTED) ASSUMPTIONS:\n *\n * o Functions are only considered identical if they unify to the same\n *   reference. To anything else is to invite the wrath of the halting problem.\n * o V8 is smart enough to optimize treating an Array like any other kind of\n *   object.\n * o Users of this function are cool with mutually recursive data structures\n *   that are otherwise identical being treated as the same.\n */\n\n\nfunction deeper(a, b, ca, cb) {\n  if (a === b) {\n    return true;\n  } else if (typeof a !== 'object' || typeof b !== 'object') {\n    return false;\n  } else if (a === null || b === null) {\n    return false;\n  } else if (Buffer.isBuffer(a) && Buffer.isBuffer(b)) {\n    if (a.length !== b.length) return false; // potentially incredibly expensive\n\n    for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n\n    return true;\n  } else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  } else if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;\n  } else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) return false;\n    return deeper(slice(a), slice(b), ca, cb);\n  }\n\n  if (a.constructor !== b.constructor) return false;\n  var ka = Object.keys(a),\n      kb = Object.keys(b);\n  if (ka.length !== kb.length) return false;\n  var cal = ca.length;\n\n  while (cal--) if (ca[cal] === a) return cb[cal] === b;\n\n  ca.push(a);\n  cb.push(b);\n  ka.sort();\n  kb.sort();\n\n  for (var j = ka.length - 1; j >= 0; j--) if (ka[j] !== kb[j]) return false;\n\n  var key;\n\n  for (var k = ka.length - 1; k >= 0; k--) {\n    key = ka[k];\n    if (!deeper(a[key], b[key], ca, cb)) return false;\n  }\n\n  ca.pop();\n  cb.pop();\n  return true;\n}\n\nmodule.exports = function exports(a, b) {\n  return deeper(a, b, [], []);\n};","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/util/deep-equal.js"],"names":["isArguments","object","Object","prototype","toString","call","slice","args","l","length","a","i","deeper","b","ca","cb","Buffer","isBuffer","Date","getTime","RegExp","source","global","multiline","lastIndex","ignoreCase","constructor","ka","keys","kb","cal","push","sort","j","key","k","pop","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === '[object Arguments]'\n}\n\nfunction slice(args) {\n  // Array.prototype.slice on arguments array-like is expensive\n  var l = args.length, a = [], i\n  for (i = 0; i < l; i++) {\n    a[i] = args[i]\n  }\n  return a\n}\n\n/**\n * This is a node-specific version of deepEquals, modeled on bits and pieces\n * of loads of other implementations of this algorithm, most notably the\n * one in the Node.js source and Underscore's. It doesn't throw and handles\n * cycles.\n *\n * Everybody who writes one of these functions puts the documentation\n * inline, which makes it incredibly hard to follow. Here's what this version\n * of the algorithm does, in order:\n *\n * 1. === only tests objects and and functions by reference. Null is an object.\n *    Any pair of identical entities failing this test are therefore objects\n *    (including null), which need a recursive compare by attribute.\n * 2. Since the only matching entities to get to this test must be objects, if\n *    a or b is not an object, they're clearly not the same. All unfiltered a\n *    and b getting are objects (including null).\n * 3. null is an object, but null === null. All unfiltered a and b are non-null\n *    objects.\n * 4. Buffers need to be special-cased because they live partially on the wrong\n *    side of the C++ / JavaScript barrier. Still, calling this on structures\n *    that can contain Buffers is a bad idea, because they can contain\n *    multiple megabytes of data and comparing them byte-by-byte is very\n *    expensive. buffertools is a better solution here, but this version of\n *    this code is dependency free.\n * 5. It's much faster to compare dates by numeric value than by lexical value.\n * 6. Same goes for Regexps.\n * 7. The parts of an arguments list most people care about are the arguments\n *    themselves, not the callee, which you shouldn't be looking at anyway.\n * 8. Objects are more complex:\n *    a. ensure that a and b are on the same constructor chain\n *    b. ensure that a and b have the same number of own properties (which is\n *       what Object.keys returns).\n *    c. ensure that cyclical references don't blow up the stack.\n *    d. ensure that all the key names match (faster)\n *    e. ensure that all of the associated values match, recursively (slower)\n *\n * (SOMEWHAT UNTESTED) ASSUMPTIONS:\n *\n * o Functions are only considered identical if they unify to the same\n *   reference. To anything else is to invite the wrath of the halting problem.\n * o V8 is smart enough to optimize treating an Array like any other kind of\n *   object.\n * o Users of this function are cool with mutually recursive data structures\n *   that are otherwise identical being treated as the same.\n */\nfunction deeper(a, b, ca, cb) {\n  if (a === b) {\n    return true\n  } else if (typeof a !== 'object' || typeof b !== 'object') {\n    return false\n  } else if (a === null || b === null) {\n    return false\n  } else if (Buffer.isBuffer(a) && Buffer.isBuffer(b)) {\n    if (a.length !== b.length) return false\n\n    // potentially incredibly expensive\n    for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return false\n\n    return true\n  } else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime()\n  } else if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source &&\n           a.global === b.global &&\n           a.multiline === b.multiline &&\n           a.lastIndex === b.lastIndex &&\n           a.ignoreCase === b.ignoreCase\n  } else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) return false\n\n    return deeper(slice(a), slice(b), ca, cb)\n  }\n\n  if (a.constructor !== b.constructor) return false\n\n  var ka = Object.keys(a), kb = Object.keys(b)\n  if (ka.length !== kb.length) return false\n\n  var cal = ca.length\n  while (cal--) if (ca[cal] === a) return cb[cal] === b\n  ca.push(a); cb.push(b)\n\n  ka.sort(); kb.sort()\n  for (var j = ka.length - 1; j >= 0; j--) if (ka[j] !== kb[j]) return false\n\n  var key\n  for (var k = ka.length - 1; k >= 0; k--) {\n    key = ka[k]\n    if (!deeper(a[key], b[key], ca, cb)) return false\n  }\n\n  ca.pop(); cb.pop()\n\n  return true\n}\n\nmodule.exports = function exports(a, b) {\n  return deeper(a, b, [], [])\n}\n"]},"metadata":{},"sourceType":"script"}