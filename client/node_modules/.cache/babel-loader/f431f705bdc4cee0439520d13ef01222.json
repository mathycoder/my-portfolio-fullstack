{"ast":null,"code":"'use strict';\n\nconst a = require('async');\n\nconst logger = require('../logger').child({\n  component: 'query_tracer'\n});\n\nconst Aggregator = require('../aggregators/base-aggregator');\n\nconst SlowQuery = require('./slow-query');\n\nconst QuerySample = require('./query-sample');\n\nclass QueryTraceAggregator extends Aggregator {\n  constructor(opts, collector) {\n    opts = opts || {};\n    opts.method = opts.method || 'sql_trace_data';\n\n    if (!opts.config) {\n      throw new Error('config required by query trace aggregator');\n    }\n\n    super(opts, collector);\n    const config = opts.config;\n    this.samples = new Map();\n    this.config = config;\n  }\n\n  removeShortest() {\n    let shortest = null;\n\n    for (let sample of this.samples.values()) {\n      const trace = sample.trace;\n\n      if (!shortest || shortest.duration > trace.duration) {\n        shortest = trace;\n      }\n    }\n\n    this.samples.delete(shortest.normalized);\n  }\n\n  _merge(samples) {\n    for (let sample of samples.values()) {\n      let ownSample = this.samples.get(sample.trace.normalized);\n\n      if (ownSample) {\n        ownSample.merge(sample);\n      } else {\n        this.samples.set(sample.trace.normalized, sample);\n      }\n    }\n  }\n\n  add(segment, type, query, trace) {\n    const ttConfig = this.config.transaction_tracer; // If DT is enabled and the segment is part of a sampled transaction\n    // (i.e. we are creating a span event for this segment), then we need\n    // to collect the sql trace.\n\n    var slowQuery;\n\n    switch (ttConfig.record_sql) {\n      case 'raw':\n        slowQuery = new SlowQuery(segment, type, query, trace);\n        logger.trace('recording raw sql');\n        segment.addAttribute('sql', slowQuery.query, true);\n        break;\n\n      case 'obfuscated':\n        slowQuery = new SlowQuery(segment, type, query, trace);\n        logger.trace('recording obfuscated sql');\n        segment.addAttribute('sql_obfuscated', slowQuery.obfuscated, true);\n        break;\n\n      default:\n        logger.trace('not recording sql statement, transaction_tracer.record_sql was set to %s', ttConfig.record_sql);\n        return;\n    }\n\n    if (segment.getDurationInMillis() < ttConfig.explain_threshold) {\n      return;\n    }\n\n    slowQuery = slowQuery || new SlowQuery(segment, type, query, trace);\n    segment.addAttribute('backtrace', slowQuery.trace);\n\n    if (!this.config.slow_sql.enabled) {\n      return;\n    }\n\n    const ownSample = this.samples.get(slowQuery.normalized);\n\n    if (ownSample) {\n      return ownSample.aggregate(slowQuery);\n    }\n\n    this.samples.set(slowQuery.normalized, new QuerySample(this, slowQuery)); // Do not remove the shortest sample when in serverless mode, since\n    // sampling is disabled.\n\n    if (this.config.serverless_mode.enabled) {\n      return;\n    }\n\n    if (this.samples.size > this.config.slow_sql.max_samples) {\n      this.removeShortest();\n    }\n  }\n\n  _toPayload(cb) {\n    if (this.samples.size === 0) {\n      logger.debug('No query traces to send.');\n      return cb(null, null);\n    }\n\n    const runId = this.runId;\n    return this.prepareJSON((err, data) => cb(err, [runId, data]));\n  }\n\n  _toPayloadSync() {\n    if (this.samples.size > 0) {\n      return [this.runId, this.prepareJSONSync()];\n    }\n\n    logger.debug('No query traces to send.');\n  }\n\n  _getMergeData() {\n    return this.samples;\n  }\n\n  clear() {\n    this.samples = new Map();\n  }\n\n  prepareJSON(done) {\n    a.map(this.samples.values(), (sample, cb) => sample.prepareJSON(cb), done);\n  }\n\n  prepareJSONSync() {\n    return Array.from(this.samples.values()).map(sample => sample.prepareJSONSync());\n  }\n\n}\n\nmodule.exports = QueryTraceAggregator;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/db/query-trace-aggregator.js"],"names":["a","require","logger","child","component","Aggregator","SlowQuery","QuerySample","QueryTraceAggregator","constructor","opts","collector","method","config","Error","samples","Map","removeShortest","shortest","sample","values","trace","duration","delete","normalized","_merge","ownSample","get","merge","set","add","segment","type","query","ttConfig","transaction_tracer","slowQuery","record_sql","addAttribute","obfuscated","getDurationInMillis","explain_threshold","slow_sql","enabled","aggregate","serverless_mode","size","max_samples","_toPayload","cb","debug","runId","prepareJSON","err","data","_toPayloadSync","prepareJSONSync","_getMergeData","clear","done","map","Array","from","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst a = require('async')\nconst logger = require('../logger').child({component: 'query_tracer'})\nconst Aggregator = require('../aggregators/base-aggregator')\nconst SlowQuery = require('./slow-query')\nconst QuerySample = require('./query-sample')\n\nclass QueryTraceAggregator extends Aggregator {\n  constructor(opts, collector) {\n    opts = opts || {}\n    opts.method = opts.method || 'sql_trace_data'\n    if (!opts.config) {\n      throw new Error('config required by query trace aggregator')\n    }\n    super(opts, collector)\n    \n    const config = opts.config\n    this.samples = new Map()\n    \n    this.config = config\n  }\n\n  removeShortest() {\n    let shortest = null\n    for (let sample of this.samples.values()) {\n      const trace = sample.trace\n      if (!shortest || shortest.duration > trace.duration) {\n        shortest = trace\n      }\n    }\n  \n    this.samples.delete(shortest.normalized)\n  }\n\n  _merge(samples) {\n    for (let sample of samples.values()) {\n      let ownSample = this.samples.get(sample.trace.normalized)\n      if (ownSample) {\n        ownSample.merge(sample)\n      } else {\n        this.samples.set(sample.trace.normalized, sample)\n      }\n    }\n  }\n\n  add(segment, type, query, trace) {\n    const ttConfig = this.config.transaction_tracer\n\n    // If DT is enabled and the segment is part of a sampled transaction\n    // (i.e. we are creating a span event for this segment), then we need\n    // to collect the sql trace.\n    var slowQuery\n    switch (ttConfig.record_sql) {\n      case 'raw':\n        slowQuery = new SlowQuery(segment, type, query, trace)\n        logger.trace('recording raw sql')\n        segment.addAttribute('sql', slowQuery.query, true)\n        break\n      case 'obfuscated':\n        slowQuery = new SlowQuery(segment, type, query, trace)\n        logger.trace('recording obfuscated sql')\n        segment.addAttribute('sql_obfuscated', slowQuery.obfuscated, true)\n        break\n      default:\n        logger.trace(\n          'not recording sql statement, transaction_tracer.record_sql was set to %s',\n          ttConfig.record_sql\n        )\n        return\n    }\n  \n    if (segment.getDurationInMillis() < ttConfig.explain_threshold) {\n      return\n    }\n  \n    slowQuery = slowQuery || new SlowQuery(segment, type, query, trace)\n  \n    segment.addAttribute('backtrace', slowQuery.trace)\n  \n    if (!this.config.slow_sql.enabled) {\n      return\n    }\n  \n    const ownSample = this.samples.get(slowQuery.normalized)\n    if (ownSample) {\n      return ownSample.aggregate(slowQuery)\n    }\n  \n    this.samples.set(slowQuery.normalized, new QuerySample(this, slowQuery))\n  \n    // Do not remove the shortest sample when in serverless mode, since\n    // sampling is disabled.\n    if (this.config.serverless_mode.enabled) {\n      return\n    }\n  \n    if (this.samples.size > this.config.slow_sql.max_samples) {\n      this.removeShortest()\n    }\n  }\n\n  _toPayload(cb) {\n    if (this.samples.size === 0) {\n      logger.debug('No query traces to send.')\n      return cb(null, null)\n    }\n\n    const runId = this.runId\n\n    return this.prepareJSON((err, data) => cb(err, [runId, data]))\n  }\n\n  _toPayloadSync() {\n    if (this.samples.size > 0) {\n      return [this.runId, this.prepareJSONSync()]\n    }\n\n    logger.debug('No query traces to send.')\n  }\n\n  _getMergeData() {\n    return this.samples\n  }\n\n  clear() {\n    this.samples = new Map()\n  }\n\n  prepareJSON(done) {\n    a.map(this.samples.values(), (sample, cb) => sample.prepareJSON(cb), done)\n  }\n\n  prepareJSONSync() {\n    return Array.from(this.samples.values()).map((sample) => sample.prepareJSONSync())\n  }\n}\n\nmodule.exports = QueryTraceAggregator\n"]},"metadata":{},"sourceType":"script"}