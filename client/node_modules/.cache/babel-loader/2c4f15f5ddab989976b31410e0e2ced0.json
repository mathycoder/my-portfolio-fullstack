{"ast":null,"code":"'use strict';\n\nconst errorsModule = require('./index');\n\nconst logger = require('../logger').child({\n  component: 'error_tracer'\n});\n\nconst urltils = require('../util/urltils');\n\nconst errorHelper = require('./helper');\n\nconst createError = errorsModule.createError;\nconst createEvent = errorsModule.createEvent;\n\nconst NAMES = require('../metrics/names');\n/**\n * ErrorCollector is responsible for collecting JS errors and errored-out HTTP\n * transactions, and for converting them to error traces and error events expected\n * by the collector.\n *\n * @private\n * @class\n */\n\n\nclass ErrorCollector {\n  constructor(config, traceAggregator, eventAggregator, metrics) {\n    this.config = config;\n    this.traceAggregator = traceAggregator;\n    this.eventAggregator = eventAggregator;\n    this.metrics = metrics;\n    this.seenObjectsByTransaction = Object.create(null);\n    this.seenStringsByTransaction = Object.create(null);\n    this.traceAggregator.on('starting error_data data send.', this._onSendErrorTrace.bind(this));\n  }\n\n  _onSendErrorTrace() {\n    // Clear dupe checking each time error traces attempt to send.\n    this._clearSeenErrors();\n  }\n\n  start() {\n    // TODO: Log? Return true/false?\n    const errorCollectorEnabled = this.config.error_collector && this.config.error_collector.enabled;\n\n    if (!errorCollectorEnabled) {\n      return;\n    }\n\n    if (errorCollectorEnabled && this.config.collect_errors) {\n      this.traceAggregator.start();\n    }\n\n    if (this.config.error_collector.capture_events) {\n      this.eventAggregator.start();\n    }\n  }\n\n  stop() {\n    this.traceAggregator.stop();\n    this.eventAggregator.stop();\n  }\n  /**\n   *\n   * This function takes an exception and determines whether the exception\n   * has been seen before by this aggregator.  This function mutates the\n   * book keeping structures to reflect the exception has been seen.\n   *\n   * @param {?Transaction}  transaction -\n   * @param {Error}         exception   - The error to be checked.\n   */\n\n\n  _haveSeen(transaction, exception) {\n    const txId = transaction ? transaction.id : 'Unknown';\n\n    if (typeof exception === 'object') {\n      if (!this.seenObjectsByTransaction[txId]) {\n        this.seenObjectsByTransaction[txId] = new WeakSet();\n      }\n\n      var seenObjects = this.seenObjectsByTransaction[txId];\n\n      if (seenObjects.has(exception)) {\n        return true;\n      } // TODO: Refactor usage of `_haveSeen` so that we don't have the side effect\n      // of marking the exception as seen when we're just testing for if we've\n      // seen it!\n\n\n      seenObjects.add(exception);\n    } else {\n      // typeof exception !== 'object'\n      if (!this.seenStringsByTransaction[txId]) {\n        this.seenStringsByTransaction[txId] = Object.create(null);\n      }\n\n      var seenStrings = this.seenStringsByTransaction[txId];\n\n      if (seenStrings[exception]) {\n        return true;\n      }\n\n      seenStrings[exception] = true;\n    }\n\n    return false;\n  }\n  /**\n   * Every finished transaction goes through this handler, so do as little as\n   * possible.\n   *\n   * @param {Transaction} transaction\n   *\n   * @return {number} The number of unexpected errors\n   */\n\n\n  onTransactionFinished(transaction) {\n    if (!transaction) throw new Error('Error collector got a blank transaction.');\n\n    if (transaction.ignore) {\n      return;\n    } // TODO: Prob shouldn't do any work if errors fully disabled.\n    // collect user errors even if status code is ignored\n\n\n    let collectedErrors = 0;\n    let expectedErrors = 0; // errors from noticeError are currently exempt from\n    // ignore and exclude rules\n\n    if (transaction.userErrors.length) {\n      for (let i = 0; i < transaction.userErrors.length; i++) {\n        const exception = transaction.userErrors[i];\n\n        if (this._collect(transaction, exception[0], exception[1], exception[2])) {\n          ++collectedErrors;\n        }\n      }\n    }\n\n    const isErroredTransaction = urltils.isError(this.config, transaction.statusCode);\n    const isExpectedErrorStatusCode = urltils.isExpectedError(this.config, transaction.statusCode); // collect other exceptions only if status code is not ignored\n\n    if (transaction.exceptions.length) {\n      for (let i = 0; i < transaction.exceptions.length; i++) {\n        const exception = transaction.exceptions[i];\n\n        if (this.collect(transaction, exception[0], exception[1], exception[2])) {\n          ++collectedErrors; // if we could collect it, then check if expected\n\n          if (isExpectedErrorStatusCode || errorHelper.isExpectedException(transaction, exception[0], this.config, urltils)) {\n            ++expectedErrors;\n          }\n        }\n      }\n    } else if (isErroredTransaction && this.collect(transaction)) {\n      ++collectedErrors;\n\n      if (isExpectedErrorStatusCode) {\n        ++expectedErrors;\n      }\n    }\n\n    const unexpectedErrors = collectedErrors - expectedErrors; // the metric should be incremented only if the error was not expected\n\n    if (unexpectedErrors > 0) {\n      this.metrics.getOrCreateMetric(NAMES.ERRORS.PREFIX + transaction.getFullName()).incrementCallCount(unexpectedErrors);\n    }\n  }\n  /**\n   * This function collects the error right away when transaction is not supplied.\n   * Otherwise it delays collecting the error until the transaction ends.\n   *\n   * NOTE: this interface is unofficial and may change in future.\n   *\n   * @param {?Transaction} transaction\n   *  Transaction associated with the error.\n   *\n   * @param {Error} exception\n   *  The error to be traced.\n   *\n   * @param {object} customAttributes\n   *  Any custom attributes associated with the request (optional).\n   */\n\n\n  add(transaction, exception, customAttributes) {\n    if (!exception) {\n      return;\n    }\n\n    const timestamp = Date.now();\n\n    if (transaction) {\n      transaction.addException(exception, customAttributes, timestamp);\n    } else {\n      this.collect(transaction, exception, customAttributes, timestamp);\n    }\n  }\n  /**\n   * This function is used to collect errors specifically added using the\n   * `API#noticeError()` method.\n   *\n   * Similarly to add(), it collects the error right away when transaction is\n   * not supplied. Otherwise it delays collecting the error until the transaction\n   * ends. The reason for separating the API errors from other exceptions is that\n   * different ignore rules apply to them.\n   *\n   * NOTE: this interface is unofficial and may change in future.\n   *\n   * @param {?Transaction} transaction\n   *  Transaction associated with the error.\n   *\n   * @param {Error} exception\n   *  The error to be traced.\n   *\n   * @param {object} [customAttributes=null]\n   *  Any custom attributes associated with the request (optional).\n   */\n\n\n  addUserError(transaction, exception, customAttributes) {\n    if (!exception) return;\n    var timestamp = Date.now();\n\n    if (transaction) {\n      transaction.addUserError(exception, customAttributes, timestamp);\n    } else {\n      this._collect(transaction, exception, customAttributes, timestamp);\n    }\n  }\n  /**\n   * Wrapper for _collect, include logic for whether an error should\n   * be ignored or not.  Exists to allow userErrors to bypass ignore\n   * logic.\n   *\n   * NOTE: this interface is unofficial and may change in future.\n   *\n   * @param {?Transaction} transaction\n   *  Transaction associated with the error.\n   *\n   * @param {?Error} exception\n   *  The error to be traced.\n   *\n   * @param {?object} customAttributes\n   *  Any custom attributes associated with the request.\n   *\n   * @param {number} timestamp\n   *\n   * @return {bool} True if the error was collected.\n   */\n\n\n  collect(transaction, exception, customAttributes, timestamp) {\n    if (errorHelper.shouldIgnoreError(transaction, exception, this.config)) {\n      logger.trace(\"Ignoring error\");\n      return;\n    }\n\n    return this._collect(transaction, exception, customAttributes, timestamp);\n  }\n  /**\n   * Collects the error and also creates the error event.\n   *\n   * @private\n   *\n   * This function uses an array of seen exceptions to ensure errors don't get\n   * double-counted. It can also be used as an unofficial means of marking that\n   * user errors shouldn't be traced.\n   *\n   * For an error to be traced, at least one of the transaction or the error\n   * must be present.\n   *\n   * NOTE: this interface is unofficial and may change in future.\n   *\n   * @param {?Transaction} transaction\n   *  Transaction associated with the error.\n   *\n   * @param {?Error} exception\n   *  The error to be traced.\n   *\n   * @param {?object} customAttributes\n   *  Any custom attributes associated with the request.\n   *\n   * @param {number} timestamp\n   *\n   * @return {bool} True if the error was collected.\n   */\n\n\n  _collect(transaction, exception, customAttributes, timestamp) {\n    if (exception) {\n      if (this._haveSeen(transaction, exception)) {\n        return false;\n      }\n\n      if (typeof exception !== 'string' && !exception.message && !exception.stack) {\n        logger.trace(exception, 'Got error that is not an instance of Error or string.');\n        exception = null;\n      }\n    }\n\n    if (!exception && (!transaction || !transaction.statusCode || transaction.error)) {\n      return false;\n    } // allow enabling & disabling the error tracer at runtime\n    // TODO: it would be better to check config in the public add() to prevents collecting\n    // errors on the transaction unnecessarily. Should we allow the work above or\n    // short-circuit sooner?\n\n\n    if (!this.config.collect_errors || !this.config.error_collector || !this.config.error_collector.enabled) {\n      return false;\n    }\n\n    if (exception) {\n      logger.trace(exception, 'Got exception to trace:');\n    }\n\n    const error = createError(transaction, exception, customAttributes, this.config);\n    const isExpectedError = true === error[4].intrinsics['error.expected'];\n\n    if (isExpectedError) {\n      this.metrics.getOrCreateMetric(NAMES.ERRORS.EXPECTED).incrementCallCount();\n    } else {\n      this.metrics.getOrCreateMetric(NAMES.ERRORS.ALL).incrementCallCount();\n\n      if (transaction) {\n        if (transaction.isWeb()) {\n          this.metrics.getOrCreateMetric(NAMES.ERRORS.WEB).incrementCallCount();\n        } else {\n          this.metrics.getOrCreateMetric(NAMES.ERRORS.OTHER).incrementCallCount();\n        }\n      }\n    }\n\n    this.traceAggregator.add(error);\n\n    if (this.config.error_collector.capture_events === true) {\n      const priority = transaction && transaction.priority || Math.random();\n      const event = createEvent(transaction, error, timestamp, this.config);\n      this.eventAggregator.add(event, priority);\n    }\n\n    return true;\n  } // TODO: ideally, this becomes unnecessary\n\n\n  clearAll() {\n    this.traceAggregator.clear();\n    this.eventAggregator.clear();\n\n    this._clearSeenErrors();\n  }\n\n  _clearSeenErrors() {\n    this.seenStringsByTransaction = Object.create(null);\n    this.seenObjectsByTransaction = Object.create(null);\n  }\n\n  reconfigure(config) {\n    this.config = config;\n    this.traceAggregator.reconfigure(config);\n    this.eventAggregator.reconfigure(config);\n    const errorCollectorEnabled = this.config.error_collector && this.config.error_collector.enabled;\n\n    if (!errorCollectorEnabled) {\n      this.stop();\n      return;\n    }\n\n    if (this.config.collect_errors === false) {\n      this.traceAggregator.stop();\n    }\n\n    if (this.config.error_collector.capture_events === false) {\n      this.eventAggregator.stop();\n    }\n  }\n\n}\n\nmodule.exports = ErrorCollector;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/errors/error-collector.js"],"names":["errorsModule","require","logger","child","component","urltils","errorHelper","createError","createEvent","NAMES","ErrorCollector","constructor","config","traceAggregator","eventAggregator","metrics","seenObjectsByTransaction","Object","create","seenStringsByTransaction","on","_onSendErrorTrace","bind","_clearSeenErrors","start","errorCollectorEnabled","error_collector","enabled","collect_errors","capture_events","stop","_haveSeen","transaction","exception","txId","id","WeakSet","seenObjects","has","add","seenStrings","onTransactionFinished","Error","ignore","collectedErrors","expectedErrors","userErrors","length","i","_collect","isErroredTransaction","isError","statusCode","isExpectedErrorStatusCode","isExpectedError","exceptions","collect","isExpectedException","unexpectedErrors","getOrCreateMetric","ERRORS","PREFIX","getFullName","incrementCallCount","customAttributes","timestamp","Date","now","addException","addUserError","shouldIgnoreError","trace","message","stack","error","intrinsics","EXPECTED","ALL","isWeb","WEB","OTHER","priority","Math","random","event","clearAll","clear","reconfigure","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errorsModule = require('./index')\n\nconst logger = require('../logger').child({component: 'error_tracer'})\nconst urltils = require('../util/urltils')\nconst errorHelper = require('./helper')\nconst createError = errorsModule.createError\nconst createEvent = errorsModule.createEvent\n\nconst NAMES = require('../metrics/names')\n\n/**\n * ErrorCollector is responsible for collecting JS errors and errored-out HTTP\n * transactions, and for converting them to error traces and error events expected\n * by the collector.\n *\n * @private\n * @class\n */\nclass ErrorCollector {\n  constructor(config, traceAggregator, eventAggregator, metrics) {\n    this.config = config\n    this.traceAggregator = traceAggregator\n    this.eventAggregator = eventAggregator\n    this.metrics = metrics\n\n    this.seenObjectsByTransaction = Object.create(null)\n    this.seenStringsByTransaction = Object.create(null)\n\n    this.traceAggregator.on(\n      'starting error_data data send.',\n      this._onSendErrorTrace.bind(this)\n    )\n  }\n\n  _onSendErrorTrace() {\n    // Clear dupe checking each time error traces attempt to send.\n    this._clearSeenErrors()\n  }\n\n  start() {\n    // TODO: Log? Return true/false?\n\n    const errorCollectorEnabled =\n      this.config.error_collector && this.config.error_collector.enabled\n\n    if (!errorCollectorEnabled) {\n      return\n    }\n\n    if (errorCollectorEnabled && this.config.collect_errors) {\n      this.traceAggregator.start()\n    }\n\n    if (this.config.error_collector.capture_events) {\n      this.eventAggregator.start()\n    }\n  }\n\n  stop() {\n    this.traceAggregator.stop()\n    this.eventAggregator.stop()\n  }\n\n  /**\n   *\n   * This function takes an exception and determines whether the exception\n   * has been seen before by this aggregator.  This function mutates the\n   * book keeping structures to reflect the exception has been seen.\n   *\n   * @param {?Transaction}  transaction -\n   * @param {Error}         exception   - The error to be checked.\n   */\n  _haveSeen(transaction, exception) {\n    const txId = transaction ? transaction.id : 'Unknown'\n\n    if (typeof exception === 'object') {\n      if (!this.seenObjectsByTransaction[txId]) {\n        this.seenObjectsByTransaction[txId] = new WeakSet()\n      }\n\n      var seenObjects = this.seenObjectsByTransaction[txId]\n      if (seenObjects.has(exception)) {\n        return true\n      }\n\n      // TODO: Refactor usage of `_haveSeen` so that we don't have the side effect\n      // of marking the exception as seen when we're just testing for if we've\n      // seen it!\n      seenObjects.add(exception)\n    } else { // typeof exception !== 'object'\n      if (!this.seenStringsByTransaction[txId]) {\n        this.seenStringsByTransaction[txId] = Object.create(null)\n      }\n\n      var seenStrings = this.seenStringsByTransaction[txId]\n      if (seenStrings[exception]) {\n        return true\n      }\n\n      seenStrings[exception] = true\n    }\n    return false\n  }\n\n  /**\n   * Every finished transaction goes through this handler, so do as little as\n   * possible.\n   *\n   * @param {Transaction} transaction\n   *\n   * @return {number} The number of unexpected errors\n   */\n  onTransactionFinished(transaction) {\n    if (!transaction) throw new Error('Error collector got a blank transaction.')\n    if (transaction.ignore) {\n      return\n    }\n\n    // TODO: Prob shouldn't do any work if errors fully disabled.\n\n    // collect user errors even if status code is ignored\n    let collectedErrors = 0\n    let expectedErrors = 0\n\n    // errors from noticeError are currently exempt from\n    // ignore and exclude rules\n    if (transaction.userErrors.length) {\n      for (let i = 0; i < transaction.userErrors.length; i++) {\n        const exception = transaction.userErrors[i]\n        if (this._collect(transaction, exception[0], exception[1], exception[2])) {\n          ++collectedErrors\n        }\n      }\n    }\n\n    const isErroredTransaction = urltils.isError(this.config, transaction.statusCode)\n    const isExpectedErrorStatusCode = urltils.isExpectedError(\n      this.config,\n      transaction.statusCode\n    )\n\n    // collect other exceptions only if status code is not ignored\n    if (transaction.exceptions.length) {\n      for (let i = 0; i < transaction.exceptions.length; i++) {\n        const exception = transaction.exceptions[i]\n        if (this.collect(transaction, exception[0], exception[1], exception[2])) {\n          ++collectedErrors\n          // if we could collect it, then check if expected\n          if (isExpectedErrorStatusCode ||\n            errorHelper.isExpectedException(\n              transaction,\n              exception[0],\n              this.config,\n              urltils\n            )\n          ) {\n            ++expectedErrors\n          }\n        }\n      }\n    } else if (isErroredTransaction && this.collect(transaction)) {\n      ++collectedErrors\n      if (isExpectedErrorStatusCode) {\n        ++expectedErrors\n      }\n    }\n\n    const unexpectedErrors = collectedErrors - expectedErrors\n\n    // the metric should be incremented only if the error was not expected\n    if (unexpectedErrors > 0) {\n      this.metrics\n        .getOrCreateMetric(NAMES.ERRORS.PREFIX + transaction.getFullName())\n        .incrementCallCount(unexpectedErrors)\n    }\n  }\n\n  /**\n   * This function collects the error right away when transaction is not supplied.\n   * Otherwise it delays collecting the error until the transaction ends.\n   *\n   * NOTE: this interface is unofficial and may change in future.\n   *\n   * @param {?Transaction} transaction\n   *  Transaction associated with the error.\n   *\n   * @param {Error} exception\n   *  The error to be traced.\n   *\n   * @param {object} customAttributes\n   *  Any custom attributes associated with the request (optional).\n   */\n  add(transaction, exception, customAttributes) {\n    if (!exception) {\n      return\n    }\n\n    const timestamp = Date.now()\n\n    if (transaction) {\n      transaction.addException(exception, customAttributes, timestamp)\n    } else {\n      this.collect(transaction, exception, customAttributes, timestamp)\n    }\n  }\n\n  /**\n   * This function is used to collect errors specifically added using the\n   * `API#noticeError()` method.\n   *\n   * Similarly to add(), it collects the error right away when transaction is\n   * not supplied. Otherwise it delays collecting the error until the transaction\n   * ends. The reason for separating the API errors from other exceptions is that\n   * different ignore rules apply to them.\n   *\n   * NOTE: this interface is unofficial and may change in future.\n   *\n   * @param {?Transaction} transaction\n   *  Transaction associated with the error.\n   *\n   * @param {Error} exception\n   *  The error to be traced.\n   *\n   * @param {object} [customAttributes=null]\n   *  Any custom attributes associated with the request (optional).\n   */\n  addUserError(transaction, exception, customAttributes) {\n    if (!exception) return\n\n    var timestamp = Date.now()\n\n    if (transaction) {\n      transaction.addUserError(exception, customAttributes, timestamp)\n    } else {\n      this._collect(transaction, exception, customAttributes, timestamp)\n    }\n  }\n\n  /**\n   * Wrapper for _collect, include logic for whether an error should\n   * be ignored or not.  Exists to allow userErrors to bypass ignore\n   * logic.\n   *\n   * NOTE: this interface is unofficial and may change in future.\n   *\n   * @param {?Transaction} transaction\n   *  Transaction associated with the error.\n   *\n   * @param {?Error} exception\n   *  The error to be traced.\n   *\n   * @param {?object} customAttributes\n   *  Any custom attributes associated with the request.\n   *\n   * @param {number} timestamp\n   *\n   * @return {bool} True if the error was collected.\n   */\n  collect(transaction, exception, customAttributes, timestamp) {\n    if (errorHelper.shouldIgnoreError(transaction, exception, this.config)) {\n      logger.trace(\"Ignoring error\")\n      return\n    }\n    return this._collect(transaction, exception, customAttributes, timestamp)\n  }\n\n  /**\n   * Collects the error and also creates the error event.\n   *\n   * @private\n   *\n   * This function uses an array of seen exceptions to ensure errors don't get\n   * double-counted. It can also be used as an unofficial means of marking that\n   * user errors shouldn't be traced.\n   *\n   * For an error to be traced, at least one of the transaction or the error\n   * must be present.\n   *\n   * NOTE: this interface is unofficial and may change in future.\n   *\n   * @param {?Transaction} transaction\n   *  Transaction associated with the error.\n   *\n   * @param {?Error} exception\n   *  The error to be traced.\n   *\n   * @param {?object} customAttributes\n   *  Any custom attributes associated with the request.\n   *\n   * @param {number} timestamp\n   *\n   * @return {bool} True if the error was collected.\n   */\n  _collect(transaction, exception, customAttributes, timestamp) {\n    if (exception) {\n      if (this._haveSeen(transaction, exception)) {\n        return false\n      }\n\n      if (typeof exception !== 'string' && !exception.message && !exception.stack) {\n        logger.trace(exception, 'Got error that is not an instance of Error or string.')\n        exception = null\n      }\n    }\n\n    if (!exception && (!transaction || !transaction.statusCode || transaction.error)) {\n      return false\n    }\n\n    // allow enabling & disabling the error tracer at runtime\n    // TODO: it would be better to check config in the public add() to prevents collecting\n    // errors on the transaction unnecessarily. Should we allow the work above or\n    // short-circuit sooner?\n    if (\n      !this.config.collect_errors ||\n      !this.config.error_collector ||\n      !this.config.error_collector.enabled\n    ) {\n      return false\n    }\n\n    if (exception) {\n      logger.trace(exception, 'Got exception to trace:')\n    }\n\n    const error = createError(transaction, exception, customAttributes, this.config)\n\n    const isExpectedError = true === error[4].intrinsics['error.expected']\n\n    if (isExpectedError) {\n      this.metrics.getOrCreateMetric(NAMES.ERRORS.EXPECTED).incrementCallCount()\n    } else {\n      this.metrics.getOrCreateMetric(NAMES.ERRORS.ALL).incrementCallCount()\n\n      if (transaction) {\n        if (transaction.isWeb()) {\n          this.metrics.getOrCreateMetric(NAMES.ERRORS.WEB).incrementCallCount()\n        } else {\n          this.metrics.getOrCreateMetric(NAMES.ERRORS.OTHER).incrementCallCount()\n        }\n      }\n    }\n\n    this.traceAggregator.add(error)\n\n    if (this.config.error_collector.capture_events === true) {\n      const priority = transaction && transaction.priority || Math.random()\n      const event = createEvent(transaction, error, timestamp, this.config)\n      this.eventAggregator.add(event, priority)\n    }\n\n    return true\n  }\n\n  // TODO: ideally, this becomes unnecessary\n  clearAll() {\n    this.traceAggregator.clear()\n    this.eventAggregator.clear()\n\n    this._clearSeenErrors()\n  }\n\n  _clearSeenErrors() {\n    this.seenStringsByTransaction = Object.create(null)\n    this.seenObjectsByTransaction = Object.create(null)\n  }\n\n  reconfigure(config) {\n    this.config = config\n\n    this.traceAggregator.reconfigure(config)\n    this.eventAggregator.reconfigure(config)\n\n    const errorCollectorEnabled =\n      this.config.error_collector && this.config.error_collector.enabled\n\n    if (!errorCollectorEnabled) {\n      this.stop()\n      return\n    }\n\n    if (this.config.collect_errors === false) {\n      this.traceAggregator.stop()\n    }\n\n    if (this.config.error_collector.capture_events === false) {\n      this.eventAggregator.stop()\n    }\n  }\n}\n\nmodule.exports = ErrorCollector\n"]},"metadata":{},"sourceType":"script"}