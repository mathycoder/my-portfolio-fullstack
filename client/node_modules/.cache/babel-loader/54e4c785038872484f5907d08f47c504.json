{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst logger = require('../logger').child({\n  component: 'base_aggregator'\n});\n\nclass Aggregator extends EventEmitter {\n  constructor(opts, collector) {\n    super();\n    this.defaultPeriod = this.periodMs = opts.periodMs;\n    this.defaultLimit = this.limit = opts.limit;\n    this.runId = opts.runId;\n    this.isAsync = opts.isAsync || false;\n    this.method = opts.method;\n    this.collector = collector;\n    this.sendTimer = null;\n  }\n\n  start() {\n    logger.trace(`${this.method} aggregator started.`);\n\n    if (!this.sendTimer) {\n      this.sendTimer = setInterval(this.send.bind(this), this.periodMs);\n      this.sendTimer.unref();\n    }\n  }\n\n  stop() {\n    if (this.sendTimer) {\n      clearInterval(this.sendTimer);\n      this.sendTimer = null;\n      logger.trace(`${this.method} aggregator stopped.`);\n    }\n  }\n\n  _merge() {\n    throw new Error('merge is not implemented');\n  }\n\n  add() {\n    throw new Error('add is not implemented');\n  }\n\n  _toPayload(callback) {\n    try {\n      callback(null, this._toPayloadSync());\n    } catch (err) {\n      callback(err);\n    }\n  }\n\n  _toPayloadSync() {\n    throw new Error('toPayloadSync is not implemented');\n  }\n\n  _getMergeData() {\n    throw new Error('getData is not implemented');\n  }\n\n  clear() {\n    throw new Error('clear not implemented');\n  }\n\n  _afterSend() {// private hook called after send is finished\n  }\n\n  _runSend(data, payload) {\n    if (!payload) {\n      this._afterSend(false);\n\n      this.emit(`finished ${this.method} data send.`);\n      return;\n    } // This can be synchronous for the serverless collector.\n\n\n    this.collector[this.method](payload, (error, response) => {\n      if (response && response.retainData) {\n        this._merge(data);\n      } // TODO: Log?\n\n\n      this._afterSend(true);\n\n      this.emit(`finished ${this.method} data send.`);\n    });\n  }\n\n  send() {\n    logger.info(`${this.method} Aggregator data send.`);\n    this.emit(`starting ${this.method} data send.`);\n\n    const data = this._getMergeData();\n\n    if (this.isAsync) {\n      this._toPayload((err, payload) => {\n        this._runSend(data, payload);\n      });\n    } else {\n      this._runSend(data, this._toPayloadSync());\n    }\n\n    this.clear();\n  }\n\n  reconfigure(config) {\n    this.runId = config.run_id;\n  }\n\n}\n\nmodule.exports = Aggregator;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/aggregators/base-aggregator.js"],"names":["EventEmitter","require","logger","child","component","Aggregator","constructor","opts","collector","defaultPeriod","periodMs","defaultLimit","limit","runId","isAsync","method","sendTimer","start","trace","setInterval","send","bind","unref","stop","clearInterval","_merge","Error","add","_toPayload","callback","_toPayloadSync","err","_getMergeData","clear","_afterSend","_runSend","data","payload","emit","error","response","retainData","info","reconfigure","config","run_id","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events').EventEmitter\nconst logger = require('../logger').child({component: 'base_aggregator'})\n\nclass Aggregator extends EventEmitter {\n  constructor(opts, collector) {\n    super()\n\n    this.defaultPeriod = this.periodMs = opts.periodMs\n    this.defaultLimit = this.limit = opts.limit\n    this.runId = opts.runId\n    this.isAsync = opts.isAsync || false\n    this.method = opts.method\n\n    this.collector = collector\n\n    this.sendTimer = null\n  }\n\n  start() {\n    logger.trace(`${this.method} aggregator started.`)\n\n    if (!this.sendTimer) {\n      this.sendTimer = setInterval(this.send.bind(this), this.periodMs)\n      this.sendTimer.unref()\n    }\n  }\n\n  stop() {\n    if (this.sendTimer) {\n      clearInterval(this.sendTimer)\n      this.sendTimer = null\n\n      logger.trace(`${this.method} aggregator stopped.`)\n    }\n  }\n\n  _merge() {\n    throw new Error('merge is not implemented')\n  }\n\n  add() {\n    throw new Error('add is not implemented')\n  }\n\n  _toPayload(callback) {\n    try {\n      callback(null, this._toPayloadSync())\n    } catch (err) {\n      callback(err)\n    }\n  }\n\n  _toPayloadSync() {\n    throw new Error('toPayloadSync is not implemented')\n  }\n\n  _getMergeData() {\n    throw new Error('getData is not implemented')\n  }\n\n  clear() {\n    throw new Error('clear not implemented')\n  }\n\n  _afterSend() {\n    // private hook called after send is finished\n  }\n\n  _runSend(data, payload) {\n    if (!payload) {\n      this._afterSend(false)\n      this.emit(`finished ${this.method} data send.`)\n      return\n    }\n\n    // This can be synchronous for the serverless collector.\n    this.collector[this.method](payload, (error, response) => {\n      if (response && response.retainData) {\n        this._merge(data)\n      }\n\n      // TODO: Log?\n      this._afterSend(true)\n      this.emit(`finished ${this.method} data send.`)\n    })\n  }\n\n  send() {\n    logger.info(`${this.method} Aggregator data send.`)\n    this.emit(`starting ${this.method} data send.`)\n\n    const data = this._getMergeData()\n    if (this.isAsync) {\n      this._toPayload((err, payload) => {\n        this._runSend(data, payload)\n      })\n    } else {\n      this._runSend(data, this._toPayloadSync())\n    }\n\n    this.clear()\n  }\n\n  reconfigure(config) {\n    this.runId = config.run_id\n  }\n}\n\nmodule.exports = Aggregator\n"]},"metadata":{},"sourceType":"script"}