{"ast":null,"code":"'use strict';\n/**\n\n * Explicit enumeration of the states a transaction can be in:\n *\n * PENDING upon instantiation (implicitly, no start time set)\n * RUNNING while timer is running (implicitly, start time is set but no stop\n *   time is set).\n * STOPPED timer has been completed (implicitly, start time and stop time\n *   are set, but the timer has not yet been harvested).\n * DEAD timer has been harvested and can only have its duration read.\n */\n\nvar PENDING = 1;\nvar RUNNING = 2;\nvar STOPPED = 3;\n\nfunction hrToMillis(hr) {\n  // process.hrTime gives you [second, nanosecond] duration pairs\n  return hr[0] * 1e3 + hr[1] / 1e6;\n}\n/**\n * A mildly tricky timer that tracks its own state and allows its duration\n * to be set manually.\n */\n\n\nfunction Timer() {\n  this.state = PENDING;\n  this.touched = false;\n  this.hrDuration = null;\n  this.hrstart = null;\n  this.start = null;\n  this.durationInMillis = null;\n}\n/**\n * Start measuring time elapsed.\n *\n * Uses process.hrtime if available, Date.now() otherwise.\n */\n\n\nTimer.prototype.begin = function begin() {\n  if (this.state > PENDING) return;\n  this.start = Date.now();\n  this.hrstart = process.hrtime();\n  this.state = RUNNING;\n};\n/**\n * End measurement.\n */\n\n\nTimer.prototype.end = function end() {\n  if (this.state > RUNNING) return;\n  if (this.state === PENDING) this.begin();\n  this.hrDuration = process.hrtime(this.hrstart);\n  this.touched = true;\n  this.state = STOPPED;\n};\n/**\n * Update the duration of the timer without ending it..\n */\n\n\nTimer.prototype.touch = function touch() {\n  this.touched = true;\n  if (this.state > RUNNING) return;\n  if (this.state === PENDING) this.begin();\n  this.hrDuration = process.hrtime(this.hrstart);\n};\n/**\n * End the segment if it is still running, if touched use that time instead of\n * \"now\". Returns a boolean indicating whether the end time changed.\n */\n\n\nTimer.prototype.softEnd = function softEnd() {\n  if (this.state > RUNNING) return false;\n  if (this.state === PENDING) this.begin();\n  this.state = STOPPED;\n  if (this.touched) return false;\n  this.hrDuration = process.hrtime(this.hrstart);\n  this.touched = true;\n  return true;\n};\n/**\n * @return {bool} Is this timer currently running?\n */\n\n\nTimer.prototype.isRunning = function isRunning() {\n  return this.state === RUNNING;\n};\n/**\n * @return {bool} Is this timer still alive?\n */\n\n\nTimer.prototype.isActive = function isActive() {\n  return this.state < STOPPED;\n};\n/**\n * @return {bool} Has the timer been touched or ended?\n */\n\n\nTimer.prototype.hasEnd = function hasEnd() {\n  return !!this.hrDuration;\n};\n/*\n * Sets duration and stops the timer, since the passed-in duration will take precendence\n * over the measured duration.\n * @param {number} duration The duration the timer should report.\n */\n\n\nTimer.prototype.overwriteDurationInMillis = overwriteDurationInMillis;\n\nfunction overwriteDurationInMillis(duration) {\n  this.touched = true;\n  this.durationInMillis = duration;\n  this.state = STOPPED;\n}\n/**\n * When testing, it's convenient to be able to control time. Stops the timer\n * as a byproduct.\n *\n * @param {number} duration How long the timer ran.\n * @param {number} start When the timer started running (optional).\n */\n\n\nTimer.prototype.setDurationInMillis = function setDurationInMillis(duration, start) {\n  if (this.state > RUNNING) {\n    return;\n  }\n\n  if (this.state === PENDING && !start && start !== 0) {\n    this.begin();\n  }\n\n  this.state = STOPPED;\n  this.durationInMillis = duration; // this assignment is incorrect, process.hrtime doesn't time from epoch, which\n  // is the assumption being made here.  since hrstart isn't used\n  // anywhere except to calculate duration, and we are setting duration\n  // this is fine.\n\n  this.hrstart = [Math.floor(start / 1e3), start % 1e3 * 1e6];\n\n  if (start != null) {\n    this.start = start;\n  }\n};\n/**\n * Returns how long the timer has been running (if it's still running) or\n * how long it ran (if it's been ended or touched).\n */\n\n\nTimer.prototype.getDurationInMillis = function getDurationInMillis() {\n  if (this.state === PENDING) return 0; // only set by setDurationInMillis\n\n  if (this.durationInMillis !== null && this.durationInMillis >= 0) {\n    return this.durationInMillis;\n  } // prioritize .end() and .touch()\n\n\n  if (this.hrDuration) {\n    return hrToMillis(this.hrDuration);\n  }\n\n  return hrToMillis(process.hrtime(this.hrstart));\n};\n/**\n * Get a single object containing the interval this timer was active.\n *\n * @return {Array} 2-tuple of start time in milliseconds, end time in\n *                 milliseconds.\n */\n\n\nTimer.prototype.toRange = function toRange() {\n  return [this.start, this.start + this.getDurationInMillis()];\n};\n/**\n * Abstract away the nonsense related to having both an\n * hrtime start time and a regular one, and always return\n * milliseconds since start.\n *\n * @param {Timer} other The point relative to which this timer started.\n * @return {number} The offset in (floating-point) milliseconds.\n */\n\n\nTimer.prototype.startedRelativeTo = function startedRelativeTo(other) {\n  if (this.hrstart && other.hrstart) {\n    var s = this.hrstart[0] - other.hrstart[0];\n    var ns = this.hrstart[1] - other.hrstart[1];\n    return hrToMillis([s, ns]);\n  }\n\n  return this.start - other.start;\n};\n/**\n * Returns true if this timer ends after the other.\n */\n\n\nTimer.prototype.endsAfter = function compare(other) {\n  return this.getDurationInMillis() + this.start > other.getDurationInMillis() + other.start;\n};\n\nmodule.exports = Timer;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/timer.js"],"names":["PENDING","RUNNING","STOPPED","hrToMillis","hr","Timer","state","touched","hrDuration","hrstart","start","durationInMillis","prototype","begin","Date","now","process","hrtime","end","touch","softEnd","isRunning","isActive","hasEnd","overwriteDurationInMillis","duration","setDurationInMillis","Math","floor","getDurationInMillis","toRange","startedRelativeTo","other","s","ns","endsAfter","compare","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n/**\n\n * Explicit enumeration of the states a transaction can be in:\n *\n * PENDING upon instantiation (implicitly, no start time set)\n * RUNNING while timer is running (implicitly, start time is set but no stop\n *   time is set).\n * STOPPED timer has been completed (implicitly, start time and stop time\n *   are set, but the timer has not yet been harvested).\n * DEAD timer has been harvested and can only have its duration read.\n */\nvar PENDING = 1\nvar RUNNING = 2\nvar STOPPED = 3\n\n\nfunction hrToMillis(hr) {\n  // process.hrTime gives you [second, nanosecond] duration pairs\n  return (hr[0] * 1e3) + (hr[1] / 1e6)\n}\n\n/**\n * A mildly tricky timer that tracks its own state and allows its duration\n * to be set manually.\n */\nfunction Timer() {\n  this.state = PENDING\n  this.touched = false\n  this.hrDuration = null\n  this.hrstart = null\n  this.start = null\n  this.durationInMillis = null\n}\n\n/**\n * Start measuring time elapsed.\n *\n * Uses process.hrtime if available, Date.now() otherwise.\n */\nTimer.prototype.begin = function begin() {\n  if (this.state > PENDING) return\n\n  this.start = Date.now()\n  this.hrstart = process.hrtime()\n  this.state = RUNNING\n}\n\n/**\n * End measurement.\n */\nTimer.prototype.end = function end() {\n  if (this.state > RUNNING) return\n  if (this.state === PENDING) this.begin()\n  this.hrDuration = process.hrtime(this.hrstart)\n  this.touched = true\n  this.state = STOPPED\n}\n\n/**\n * Update the duration of the timer without ending it..\n */\nTimer.prototype.touch = function touch() {\n  this.touched = true\n  if (this.state > RUNNING) return\n  if (this.state === PENDING) this.begin()\n\n  this.hrDuration = process.hrtime(this.hrstart)\n}\n\n/**\n * End the segment if it is still running, if touched use that time instead of\n * \"now\". Returns a boolean indicating whether the end time changed.\n */\nTimer.prototype.softEnd = function softEnd() {\n  if (this.state > RUNNING) return false\n  if (this.state === PENDING) this.begin()\n\n  this.state = STOPPED\n\n  if (this.touched) return false\n  this.hrDuration = process.hrtime(this.hrstart)\n  this.touched = true\n  return true\n}\n\n/**\n * @return {bool} Is this timer currently running?\n */\nTimer.prototype.isRunning = function isRunning() {\n  return this.state === RUNNING\n}\n\n/**\n * @return {bool} Is this timer still alive?\n */\nTimer.prototype.isActive = function isActive() {\n  return this.state < STOPPED\n}\n\n/**\n * @return {bool} Has the timer been touched or ended?\n */\nTimer.prototype.hasEnd = function hasEnd() {\n  return !!this.hrDuration\n}\n\n/*\n * Sets duration and stops the timer, since the passed-in duration will take precendence\n * over the measured duration.\n * @param {number} duration The duration the timer should report.\n */\nTimer.prototype.overwriteDurationInMillis = overwriteDurationInMillis\nfunction overwriteDurationInMillis(duration) {\n  this.touched = true\n  this.durationInMillis = duration\n  this.state = STOPPED\n}\n\n/**\n * When testing, it's convenient to be able to control time. Stops the timer\n * as a byproduct.\n *\n * @param {number} duration How long the timer ran.\n * @param {number} start When the timer started running (optional).\n */\nTimer.prototype.setDurationInMillis = function setDurationInMillis(duration, start) {\n  if (this.state > RUNNING) {\n    return\n  }\n\n  if (this.state === PENDING && !start && start !== 0) {\n    this.begin()\n  }\n\n  this.state = STOPPED\n  this.durationInMillis = duration\n\n  // this assignment is incorrect, process.hrtime doesn't time from epoch, which\n  // is the assumption being made here.  since hrstart isn't used\n  // anywhere except to calculate duration, and we are setting duration\n  // this is fine.\n  this.hrstart = [Math.floor(start / 1e3), start % 1e3 * 1e6]\n  if (start != null) {\n    this.start = start\n  }\n}\n\n/**\n * Returns how long the timer has been running (if it's still running) or\n * how long it ran (if it's been ended or touched).\n */\nTimer.prototype.getDurationInMillis = function getDurationInMillis() {\n  if (this.state === PENDING) return 0\n\n  // only set by setDurationInMillis\n  if (this.durationInMillis !== null && this.durationInMillis >= 0) {\n    return this.durationInMillis\n  }\n\n  // prioritize .end() and .touch()\n  if (this.hrDuration) {\n    return hrToMillis(this.hrDuration)\n  }\n\n  return hrToMillis(process.hrtime(this.hrstart))\n}\n\n/**\n * Get a single object containing the interval this timer was active.\n *\n * @return {Array} 2-tuple of start time in milliseconds, end time in\n *                 milliseconds.\n */\nTimer.prototype.toRange = function toRange() {\n  return [this.start, this.start + this.getDurationInMillis()]\n}\n\n/**\n * Abstract away the nonsense related to having both an\n * hrtime start time and a regular one, and always return\n * milliseconds since start.\n *\n * @param {Timer} other The point relative to which this timer started.\n * @return {number} The offset in (floating-point) milliseconds.\n */\nTimer.prototype.startedRelativeTo = function startedRelativeTo(other) {\n  if (this.hrstart && other.hrstart) {\n    var s = this.hrstart[0] - other.hrstart[0]\n    var ns = this.hrstart[1] - other.hrstart[1]\n\n\n    return hrToMillis([s, ns])\n  }\n\n  return this.start - other.start\n}\n\n/**\n * Returns true if this timer ends after the other.\n */\nTimer.prototype.endsAfter = function compare(other) {\n  return (this.getDurationInMillis() + this.start) >\n    (other.getDurationInMillis() + other.start)\n}\n\n\nmodule.exports = Timer\n"]},"metadata":{},"sourceType":"script"}