{"ast":null,"code":"'use strict';\n\nconst logger = require('../logger').child({\n  component: 'metric-aggregator'\n});\n\nconst Aggregator = require('../aggregators/base-aggregator');\n\nconst Metrics = require('../metrics');\n\nconst FROM_MILLIS = 1e-3;\n\nclass MetricAggregator extends Aggregator {\n  constructor(opts, collector) {\n    _isValidOrThrow(opts);\n\n    opts.method = opts.method || 'metric_data';\n    super(opts, collector);\n    this._apdexT = opts.apdexT;\n    this._mapper = opts.mapper;\n    this._normalizer = opts.normalizer;\n    this._metrics = new Metrics(this._apdexT, this._mapper, this._normalizer);\n  }\n\n  get empty() {\n    return this._metrics.empty;\n  }\n\n  get started() {\n    return this._metrics.started;\n  }\n\n  _toPayloadSync() {\n    if (this._metrics.empty) {\n      logger.debug('No metrics to send.');\n      return;\n    }\n\n    const beginSeconds = this._metrics.started * FROM_MILLIS;\n    const endSeconds = Date.now() * FROM_MILLIS;\n    const payload = [this.runId, beginSeconds, endSeconds, this._metrics.toJSON()];\n    return payload;\n  }\n\n  _getMergeData() {\n    return this._metrics;\n  }\n\n  _merge(metrics) {\n    if (!metrics) {\n      return;\n    } // Adjust start when merging due to server round-trip\n\n\n    this.merge(metrics, true);\n  }\n\n  merge(metrics, adjustStartTime) {\n    this._metrics.merge(metrics, adjustStartTime);\n  }\n\n  clear() {\n    this._metrics = new Metrics(this._apdexT, this._mapper, this._normalizer);\n  }\n  /**\n   * Look up the mapping from a name (and optionally a scope) to a set of metric\n   * data for that name, creating the data if they don't already exist.\n   *\n   * @param {string} name The name of the requested metric.\n   * @param {string} scope (Optional) The scope to which the metric is bound.\n   * @return {Stats} The aggregated data for that name.\n   */\n\n\n  getOrCreateMetric(name, scope) {\n    return this._metrics.getOrCreateMetric(name, scope);\n  }\n  /**\n   * This is the preferred way for interacting with metrics. Set the duration\n   * (and optionally the amount of that duration that was exclusive to that\n   * particular metric and not any child operations to that metric) of an\n   * operation. If there are no data for the name (and optional scope) existing,\n   * the collection will create a set of data before recording the measurement.\n   *\n   * @param {string} name The name of the metric.\n   * @param {string} scope (Optional) The scope to which the metric belongs.\n   * @param {Number} duration The duration of the related operation, in milliseconds.\n   * @param {Number} exclusive (Optional) The portion of the operation specific to this\n   *                           metric.\n   * @return {Stats} The aggregated data related to this metric.\n   */\n\n\n  measureMilliseconds(name, scope, duration, exclusive) {\n    return this._metrics.measureMilliseconds(name, scope, duration, exclusive);\n  }\n  /**\n   * Set the size of an operation. If there are no data for the name existing,\n   * the collection will create a set of data before recording the measurement.\n   *\n   * @param {string} name The name of the metric.\n   * @param {Number} size The size of the related operation, in bytes.\n   * @return {Stats} The aggregated data related to this metric.\n   */\n\n\n  measureBytes(name, size) {\n    return this._metrics.measureBytes(name, size);\n  }\n  /**\n   * Look up a metric, and don't create it if it doesn't exist. Can create scopes\n   * as a byproduct, but this function is only intended for use in testing, so\n   * it's not a big deal.\n   *\n   * @param {string} name Metric name.\n   * @param {string} scope (Optional) The scope, if any, to which the metric\n   *                       belongs.\n   * @return {object} Either a stats aggregate, an apdex stats aggregate, or\n   *                  undefined.\n   */\n\n\n  getMetric(name, scope) {\n    return this._metrics.getMetric(name, scope);\n  }\n  /**\n   * Look up the mapping from a name (and optionally a scope) to a set of metric\n   * apdex data for that name, creating the data if they don't already exist.\n   *\n   * @param {string} name          The name of the requested metric.\n   * @param {string} scope         The scope to which the metric is bound\n   *                               (optional).\n   * @param {number} overrideApdex A custom apdexT for this metric, in\n   *                               milliseconds. This will be the same for\n   *                               a given run, because key transaction metrics\n   *                               are set at connect time via server-side\n   *                               configuration.\n   *\n   * @return {ApdexStats} The aggregated data for that name.\n   */\n\n\n  getOrCreateApdexMetric(name, scope, overrideApdex) {\n    return this._metrics.getOrCreateApdexMetric(name, scope, overrideApdex);\n  }\n\n  reconfigure(config) {\n    super.reconfigure(config);\n    this._apdexT = config.apdex_t;\n    this._metrics.apdexT = this._apdexT;\n  }\n\n}\n\nfunction _isValidOrThrow(opts) {\n  if (!opts) {\n    throw new Error('Metric aggregator must be created with options.');\n  }\n\n  if (opts.apdexT == null || opts.apdexT === '') {\n    throw new Error(\"Metric aggregator must be created with apdexT\");\n  }\n\n  if (!opts.mapper) {\n    throw new Error(\"Metric aggregator must be created with a mapper\");\n  }\n\n  if (!opts.normalizer) {\n    throw new Error(\"Metric aggregator must be created with a name normalizer\");\n  }\n}\n\nmodule.exports = MetricAggregator;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/metrics/metric-aggregator.js"],"names":["logger","require","child","component","Aggregator","Metrics","FROM_MILLIS","MetricAggregator","constructor","opts","collector","_isValidOrThrow","method","_apdexT","apdexT","_mapper","mapper","_normalizer","normalizer","_metrics","empty","started","_toPayloadSync","debug","beginSeconds","endSeconds","Date","now","payload","runId","toJSON","_getMergeData","_merge","metrics","merge","adjustStartTime","clear","getOrCreateMetric","name","scope","measureMilliseconds","duration","exclusive","measureBytes","size","getMetric","getOrCreateApdexMetric","overrideApdex","reconfigure","config","apdex_t","Error","module","exports"],"mappings":"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","sourcesContent":["\n\n'use strict'\n\nconst logger = require('../logger').child({component: 'metric-aggregator'})\nconst Aggregator = require('../aggregators/base-aggregator')\nconst Metrics = require('../metrics')\n\nconst FROM_MILLIS = 1e-3\n\nclass MetricAggregator extends Aggregator {\n  constructor(opts, collector) {\n    _isValidOrThrow(opts)\n\n    opts.method = opts.method || 'metric_data'\n\n    super(opts, collector)\n\n    this._apdexT = opts.apdexT\n    this._mapper = opts.mapper\n    this._normalizer = opts.normalizer\n\n    this._metrics = new Metrics(this._apdexT, this._mapper, this._normalizer)\n  }\n\n  get empty() {\n    return this._metrics.empty\n  }\n\n  get started() {\n    return this._metrics.started\n  }\n\n  _toPayloadSync() {\n    if (this._metrics.empty) {\n      logger.debug('No metrics to send.')\n      return\n    }\n\n    const beginSeconds = this._metrics.started * FROM_MILLIS\n    const endSeconds = Date.now() * FROM_MILLIS\n\n    const payload = [\n      this.runId,\n      beginSeconds,\n      endSeconds,\n      this._metrics.toJSON()\n    ]\n\n    return payload\n  }\n\n  _getMergeData() {\n    return this._metrics\n  }\n\n  _merge(metrics) {\n    if (!metrics) {\n      return\n    }\n\n    // Adjust start when merging due to server round-trip\n    this.merge(metrics, true)\n  }\n\n  merge(metrics, adjustStartTime) {\n    this._metrics.merge(metrics, adjustStartTime)\n  }\n\n  clear() {\n    this._metrics = new Metrics(this._apdexT, this._mapper, this._normalizer)\n  }\n\n  /**\n   * Look up the mapping from a name (and optionally a scope) to a set of metric\n   * data for that name, creating the data if they don't already exist.\n   *\n   * @param {string} name The name of the requested metric.\n   * @param {string} scope (Optional) The scope to which the metric is bound.\n   * @return {Stats} The aggregated data for that name.\n   */\n  getOrCreateMetric(name, scope) {\n    return this._metrics.getOrCreateMetric(name, scope)\n  }\n\n  /**\n   * This is the preferred way for interacting with metrics. Set the duration\n   * (and optionally the amount of that duration that was exclusive to that\n   * particular metric and not any child operations to that metric) of an\n   * operation. If there are no data for the name (and optional scope) existing,\n   * the collection will create a set of data before recording the measurement.\n   *\n   * @param {string} name The name of the metric.\n   * @param {string} scope (Optional) The scope to which the metric belongs.\n   * @param {Number} duration The duration of the related operation, in milliseconds.\n   * @param {Number} exclusive (Optional) The portion of the operation specific to this\n   *                           metric.\n   * @return {Stats} The aggregated data related to this metric.\n   */\n  measureMilliseconds(name, scope, duration, exclusive) {\n    return this._metrics.measureMilliseconds(name, scope, duration, exclusive)\n  }\n\n  /**\n   * Set the size of an operation. If there are no data for the name existing,\n   * the collection will create a set of data before recording the measurement.\n   *\n   * @param {string} name The name of the metric.\n   * @param {Number} size The size of the related operation, in bytes.\n   * @return {Stats} The aggregated data related to this metric.\n   */\n  measureBytes(name, size) {\n    return this._metrics.measureBytes(name, size)\n  }\n\n  /**\n   * Look up a metric, and don't create it if it doesn't exist. Can create scopes\n   * as a byproduct, but this function is only intended for use in testing, so\n   * it's not a big deal.\n   *\n   * @param {string} name Metric name.\n   * @param {string} scope (Optional) The scope, if any, to which the metric\n   *                       belongs.\n   * @return {object} Either a stats aggregate, an apdex stats aggregate, or\n   *                  undefined.\n   */\n  getMetric(name, scope) {\n    return this._metrics.getMetric(name, scope)\n  }\n\n  /**\n   * Look up the mapping from a name (and optionally a scope) to a set of metric\n   * apdex data for that name, creating the data if they don't already exist.\n   *\n   * @param {string} name          The name of the requested metric.\n   * @param {string} scope         The scope to which the metric is bound\n   *                               (optional).\n   * @param {number} overrideApdex A custom apdexT for this metric, in\n   *                               milliseconds. This will be the same for\n   *                               a given run, because key transaction metrics\n   *                               are set at connect time via server-side\n   *                               configuration.\n   *\n   * @return {ApdexStats} The aggregated data for that name.\n   */\n  getOrCreateApdexMetric(name, scope, overrideApdex) {\n    return this._metrics.getOrCreateApdexMetric(name, scope, overrideApdex)\n  }\n\n  reconfigure(config) {\n    super.reconfigure(config)\n\n    this._apdexT = config.apdex_t\n    this._metrics.apdexT = this._apdexT\n  }\n}\n\nfunction _isValidOrThrow(opts) {\n  if (!opts) {\n    throw new Error('Metric aggregator must be created with options.')\n  }\n\n  if (opts.apdexT == null || opts.apdexT === '') {\n    throw new Error(\"Metric aggregator must be created with apdexT\")\n  }\n\n  if (!opts.mapper) {\n    throw new Error(\"Metric aggregator must be created with a mapper\")\n  }\n\n  if (!opts.normalizer) {\n    throw new Error(\"Metric aggregator must be created with a name normalizer\")\n  }\n}\n\nmodule.exports = MetricAggregator\n"]},"metadata":{},"sourceType":"script"}