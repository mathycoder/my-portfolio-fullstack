{"ast":null,"code":"'use strict';\n\nconst CollectorResponse = require('./response');\n\nconst logger = require('../logger').child({\n  component: 'serverless_collector'\n});\n\nconst zlib = require('zlib');\n\nconst fs = require('fs');\n\nconst stringify = require('json-stringify-safe');\n\nconst PAYLOAD_VERSION = 1;\nconst PAYLOAD_MARKER = 'NR_LAMBDA_MONITORING';\n\nclass ServerlessCollector {\n  /**\n   * Constructs a new serverless collector instance with the give agent.\n   *\n   * @constructor\n   * @classdesc\n   *  A helper class for wrapping modules with segments\n   *\n   * @param {Agent} agent - The agent this collector will use\n   */\n  constructor(agent) {\n    this._agent = agent;\n    this.enabled = true;\n    this.metadata = {\n      arn: null,\n      execution_environment: process.env.AWS_EXECUTION_ENV,\n      protocol_version: 16,\n      agent_version: agent.version\n    };\n    this.payload = {};\n  }\n  /**\n   * Sets the ARN to be sent up in the metadata.\n   */\n\n\n  setLambdaArn(arn) {\n    this.metadata.arn = arn;\n  }\n  /**\n   * Checks if the collector is currently collecting.\n   *\n   * @returns {boolean} If the collector is currently active.\n   */\n\n\n  isConnected() {\n    return this.enabled;\n  }\n  /**\n   * Halts data collection.\n   *\n   * @param {Function} cb The callback to invoke upon disabling the collector.\n   */\n\n\n  shutdown(cb) {\n    logger.trace('Disabling serverless collector.');\n    this.enabled = false;\n    setImmediate(cb, null, CollectorResponse.success(null));\n  }\n  /**\n   * There is nothing to actually restart for serverless, so we do nothing.\n   */\n\n\n  restart(cb) {\n    setImmediate(cb, null, CollectorResponse.success(null));\n  }\n  /**\n   * Records metric data to be serialized.\n   *\n   * @param {Array} payload The metric data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n\n\n  metric_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.metric_data = payload;\n    }\n\n    cb(null, {\n      retainData: false\n    });\n  }\n  /**\n   * Records error trace data to be serialized.\n   *\n   * @param {Array} payload The error trace data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n\n\n  error_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.error_data = payload;\n    }\n\n    cb(null, {\n      retainData: false\n    });\n  }\n  /**\n   * Records error event data to be serialized.\n   *\n   * @param {Array} payload The error event data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n\n\n  error_event_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.error_event_data = payload;\n    }\n\n    cb(null, {\n      retainData: false\n    });\n  }\n  /**\n   * Records transaction trace data to be serialized.\n   *\n   * @param {Array} payload The transaction trace data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n\n\n  transaction_sample_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.transaction_sample_data = payload;\n    }\n\n    cb(null, {\n      retainData: false\n    });\n  }\n  /**\n   * Records transaction event data to be serialized.\n   *\n   * @param {Array} payload The transaction event data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n\n\n  analytic_event_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.analytic_event_data = payload;\n    }\n\n    cb(null, {\n      retainData: false\n    });\n  }\n  /**\n   * Records custom event data to be serialized.\n   *\n   * @param {Array} payload The custom event data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n\n\n  custom_event_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.custom_event_data = payload;\n    }\n\n    cb(null, {\n      retainData: false\n    });\n  }\n  /**\n   * Records SQL trace data to be serialized.\n   *\n   * @param {Array} payload The SQL trace data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n\n\n  sql_trace_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.sql_trace_data = payload;\n    }\n\n    cb(null, {\n      retainData: false\n    });\n  }\n  /**\n   * Records span event data to be serialized.\n   *\n   * @param {Array} payload The span event data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n\n\n  span_event_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.span_event_data = payload;\n    }\n\n    cb(null, {\n      retainData: false\n    });\n  }\n  /**\n   * Constructs, serializes, and prints the final consolidated payload to stdout.\n   *\n   * @param {Function} cb The callback to invoke when finished.\n   */\n\n\n  flushPayload(cb) {\n    if (!this.enabled) {\n      return cb && setImmediate(cb);\n    }\n\n    const toFlush = JSON.stringify({\n      metadata: this.metadata,\n      data: this.payload\n    });\n    const collector = this; // Per serverless spec, this payload is always gzipped\n\n    zlib.gzip(toFlush, function flushCompressed(err, compressed) {\n      collector.payload = {};\n\n      if (err) {\n        logger.warn('Encountered an error while attempting to compress payload', err);\n        return cb && cb(err);\n      }\n\n      collector._doFlush(compressed.toString('base64'));\n\n      cb && cb();\n    });\n  }\n  /**\n   * Constructs, serializes, and prints the final consolidated payload to\n   * stdout synchronously.\n   */\n\n\n  flushPayloadSync() {\n    if (!this.enabled) {\n      return;\n    }\n\n    const toFlush = stringify({\n      metadata: this.metadata,\n      data: this.payload\n    });\n\n    try {\n      // Per serverless spec, this payload is always gzipped\n      this._doFlush(zlib.gzipSync(toFlush).toString('base64'), true);\n    } catch (err) {\n      logger.warn('Encountered an error while attempting to compress payload', err);\n    } finally {\n      this.payload = Object.create(null);\n    }\n  }\n  /**\n   * Internal method to handle flushing to stdout.\n   *\n   * @private\n   *\n   * @param {string} payload The payload to flush.\n   * @param {boolean} sync Whether to write to stdout synchronously.\n   */\n\n\n  _doFlush(payload, sync = false) {\n    const serializedPayload = JSON.stringify([PAYLOAD_VERSION, PAYLOAD_MARKER, payload]) + '\\n';\n\n    if (sync) {\n      fs.writeSync(process.stdout.fd, serializedPayload);\n    } else {\n      process.stdout.write(serializedPayload);\n    }\n  }\n\n}\n\nmodule.exports = ServerlessCollector;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/collector/serverless.js"],"names":["CollectorResponse","require","logger","child","component","zlib","fs","stringify","PAYLOAD_VERSION","PAYLOAD_MARKER","ServerlessCollector","constructor","agent","_agent","enabled","metadata","arn","execution_environment","process","env","AWS_EXECUTION_ENV","protocol_version","agent_version","version","payload","setLambdaArn","isConnected","shutdown","cb","trace","setImmediate","success","restart","metric_data","retainData","error_data","error_event_data","transaction_sample_data","analytic_event_data","custom_event_data","sql_trace_data","span_event_data","flushPayload","toFlush","JSON","data","collector","gzip","flushCompressed","err","compressed","warn","_doFlush","toString","flushPayloadSync","gzipSync","Object","create","sync","serializedPayload","writeSync","stdout","fd","write","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CollectorResponse = require('./response')\nconst logger = require('../logger').child({component: 'serverless_collector'})\nconst zlib = require('zlib')\nconst fs = require('fs')\nconst stringify = require('json-stringify-safe')\n\nconst PAYLOAD_VERSION = 1\nconst PAYLOAD_MARKER = 'NR_LAMBDA_MONITORING'\n\nclass ServerlessCollector {\n  /**\n   * Constructs a new serverless collector instance with the give agent.\n   *\n   * @constructor\n   * @classdesc\n   *  A helper class for wrapping modules with segments\n   *\n   * @param {Agent} agent - The agent this collector will use\n   */\n  constructor(agent) {\n    this._agent = agent\n    this.enabled = true\n    this.metadata = {\n      arn: null,\n      execution_environment: process.env.AWS_EXECUTION_ENV,\n      protocol_version: 16,\n      agent_version: agent.version\n    }\n    this.payload = {}\n  }\n\n  /**\n   * Sets the ARN to be sent up in the metadata.\n   */\n  setLambdaArn(arn) {\n    this.metadata.arn = arn\n  }\n\n  /**\n   * Checks if the collector is currently collecting.\n   *\n   * @returns {boolean} If the collector is currently active.\n   */\n  isConnected() {\n    return this.enabled\n  }\n\n  /**\n   * Halts data collection.\n   *\n   * @param {Function} cb The callback to invoke upon disabling the collector.\n   */\n  shutdown(cb) {\n    logger.trace('Disabling serverless collector.')\n\n    this.enabled = false\n    setImmediate(cb, null, CollectorResponse.success(null))\n  }\n\n  /**\n   * There is nothing to actually restart for serverless, so we do nothing.\n   */\n  restart(cb) {\n    setImmediate(cb, null, CollectorResponse.success(null))\n  }\n\n  /**\n   * Records metric data to be serialized.\n   *\n   * @param {Array} payload The metric data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n  metric_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.metric_data = payload\n    }\n\n    cb(null, {retainData: false})\n  }\n\n  /**\n   * Records error trace data to be serialized.\n   *\n   * @param {Array} payload The error trace data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n  error_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.error_data = payload\n    }\n\n    cb(null, {retainData: false})\n  }\n\n  /**\n   * Records error event data to be serialized.\n   *\n   * @param {Array} payload The error event data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n  error_event_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.error_event_data = payload\n    }\n\n    cb(null, {retainData: false})\n  }\n\n  /**\n   * Records transaction trace data to be serialized.\n   *\n   * @param {Array} payload The transaction trace data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n  transaction_sample_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.transaction_sample_data = payload\n    }\n    cb(null, {retainData: false})\n  }\n\n  /**\n   * Records transaction event data to be serialized.\n   *\n   * @param {Array} payload The transaction event data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n  analytic_event_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.analytic_event_data = payload\n    }\n\n    cb(null, {retainData: false})\n  }\n\n  /**\n   * Records custom event data to be serialized.\n   *\n   * @param {Array} payload The custom event data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n  custom_event_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.custom_event_data = payload\n    }\n\n    cb(null, {retainData: false})\n  }\n\n  /**\n   * Records SQL trace data to be serialized.\n   *\n   * @param {Array} payload The SQL trace data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n  sql_trace_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.sql_trace_data = payload\n    }\n    cb(null, {retainData: false})\n  }\n\n  /**\n   * Records span event data to be serialized.\n   *\n   * @param {Array} payload The span event data payload to serialize.\n   * @param {Function} cb The callback to invoke when finished.\n   */\n  span_event_data(payload, cb) {\n    if (this.enabled) {\n      this.payload.span_event_data = payload\n    }\n    cb(null, {retainData: false})\n  }\n\n  /**\n   * Constructs, serializes, and prints the final consolidated payload to stdout.\n   *\n   * @param {Function} cb The callback to invoke when finished.\n   */\n  flushPayload(cb) {\n    if (!this.enabled) {\n      return cb && setImmediate(cb)\n    }\n\n    const toFlush = JSON.stringify({\n      metadata: this.metadata,\n      data: this.payload\n    })\n\n    const collector = this\n    // Per serverless spec, this payload is always gzipped\n    zlib.gzip(toFlush, function flushCompressed(err, compressed) {\n      collector.payload = {}\n\n      if (err) {\n        logger.warn('Encountered an error while attempting to compress payload', err)\n        return cb && cb(err)\n      }\n\n      collector._doFlush(compressed.toString('base64'))\n\n      cb && cb()\n    })\n  }\n\n  /**\n   * Constructs, serializes, and prints the final consolidated payload to\n   * stdout synchronously.\n   */\n  flushPayloadSync() {\n    if (!this.enabled) {\n      return\n    }\n\n    const toFlush = stringify({\n      metadata: this.metadata,\n      data: this.payload\n    })\n\n    try {\n      // Per serverless spec, this payload is always gzipped\n      this._doFlush(zlib.gzipSync(toFlush).toString('base64'), true)\n    } catch (err) {\n      logger.warn('Encountered an error while attempting to compress payload', err)\n    } finally {\n      this.payload = Object.create(null)\n    }\n  }\n\n  /**\n   * Internal method to handle flushing to stdout.\n   *\n   * @private\n   *\n   * @param {string} payload The payload to flush.\n   * @param {boolean} sync Whether to write to stdout synchronously.\n   */\n  _doFlush(payload, sync = false) {\n    const serializedPayload = JSON.stringify([\n      PAYLOAD_VERSION,\n      PAYLOAD_MARKER,\n      payload\n    ]) + '\\n'\n\n    if (sync) {\n      fs.writeSync(process.stdout.fd, serializedPayload)\n    } else {\n      process.stdout.write(serializedPayload)\n    }\n  }\n}\n\nmodule.exports = ServerlessCollector\n"]},"metadata":{},"sourceType":"script"}