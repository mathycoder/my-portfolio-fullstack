{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n/**\n * Pipe a readable stream into this sink that fulfills the Writable Stream\n * contract and the callback will be fired when the stream has been completely\n * read.\n */\n\n\nfunction StreamSink(callback) {\n  EventEmitter.call(this);\n  this.callback = callback;\n  this.sink = '';\n  this.writable = true;\n  var sink = this;\n  this.on('error', function handle_error(error) {\n    sink.writable = false;\n    callback(error);\n  });\n}\n\nutil.inherits(StreamSink, EventEmitter);\n\nStreamSink.prototype.write = function write(string) {\n  if (!this.writable) {\n    this.emit('error', new Error(\"Sink no longer writable!\"));\n    return false;\n  } // Explicitly copy buffer contents so we are sure to release references to\n  // the TLS slab buffer region.\n\n\n  this.sink += string.toString();\n  return true;\n};\n\nStreamSink.prototype.end = function end() {\n  this.writable = false;\n  this.callback(null, this.sink);\n};\n\nStreamSink.prototype.destroy = function destroy() {\n  this.emit('close');\n  this.writable = false;\n  delete this.sink;\n};\n\nmodule.exports = StreamSink;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/util/stream-sink.js"],"names":["EventEmitter","require","util","StreamSink","callback","call","sink","writable","on","handle_error","error","inherits","prototype","write","string","emit","Error","toString","end","destroy","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,YAArC;;AACA,IAAIE,IAAI,GAAGD,OAAO,CAAC,MAAD,CAAlB;AAGA;;;;;;;AAKA,SAASE,UAAT,CAAoBC,QAApB,EAA8B;AAC5BJ,EAAAA,YAAY,CAACK,IAAb,CAAkB,IAAlB;AAEA,OAAKD,QAAL,GAAgBA,QAAhB;AACA,OAAKE,IAAL,GAAY,EAAZ;AACA,OAAKC,QAAL,GAAgB,IAAhB;AAEA,MAAID,IAAI,GAAG,IAAX;AACA,OAAKE,EAAL,CAAQ,OAAR,EAAiB,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;AAC5CJ,IAAAA,IAAI,CAACC,QAAL,GAAgB,KAAhB;AACAH,IAAAA,QAAQ,CAACM,KAAD,CAAR;AACD,GAHD;AAID;;AACDR,IAAI,CAACS,QAAL,CAAcR,UAAd,EAA0BH,YAA1B;;AAEAG,UAAU,CAACS,SAAX,CAAqBC,KAArB,GAA6B,SAASA,KAAT,CAAeC,MAAf,EAAuB;AAClD,MAAI,CAAC,KAAKP,QAAV,EAAoB;AAClB,SAAKQ,IAAL,CAAU,OAAV,EAAmB,IAAIC,KAAJ,CAAU,0BAAV,CAAnB;AACA,WAAO,KAAP;AACD,GAJiD,CAMlD;AACA;;;AACA,OAAKV,IAAL,IAAaQ,MAAM,CAACG,QAAP,EAAb;AAEA,SAAO,IAAP;AACD,CAXD;;AAaAd,UAAU,CAACS,SAAX,CAAqBM,GAArB,GAA2B,SAASA,GAAT,GAAe;AACxC,OAAKX,QAAL,GAAgB,KAAhB;AAEA,OAAKH,QAAL,CAAc,IAAd,EAAoB,KAAKE,IAAzB;AACD,CAJD;;AAMAH,UAAU,CAACS,SAAX,CAAqBO,OAArB,GAA+B,SAASA,OAAT,GAAmB;AAChD,OAAKJ,IAAL,CAAU,OAAV;AACA,OAAKR,QAAL,GAAgB,KAAhB;AAEA,SAAO,KAAKD,IAAZ;AACD,CALD;;AAOAc,MAAM,CAACC,OAAP,GAAiBlB,UAAjB","sourcesContent":["'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\n\n\n/**\n * Pipe a readable stream into this sink that fulfills the Writable Stream\n * contract and the callback will be fired when the stream has been completely\n * read.\n */\nfunction StreamSink(callback) {\n  EventEmitter.call(this)\n\n  this.callback = callback\n  this.sink = ''\n  this.writable = true\n\n  var sink = this\n  this.on('error', function handle_error(error) {\n    sink.writable = false\n    callback(error)\n  })\n}\nutil.inherits(StreamSink, EventEmitter)\n\nStreamSink.prototype.write = function write(string) {\n  if (!this.writable) {\n    this.emit('error', new Error(\"Sink no longer writable!\"))\n    return false\n  }\n\n  // Explicitly copy buffer contents so we are sure to release references to\n  // the TLS slab buffer region.\n  this.sink += string.toString()\n\n  return true\n}\n\nStreamSink.prototype.end = function end() {\n  this.writable = false\n\n  this.callback(null, this.sink)\n}\n\nStreamSink.prototype.destroy = function destroy() {\n  this.emit('close')\n  this.writable = false\n\n  delete this.sink\n}\n\nmodule.exports = StreamSink\n"]},"metadata":{},"sourceType":"script"}