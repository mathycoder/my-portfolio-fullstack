{"ast":null,"code":"'use strict';\n\nconst a = require('async');\n\nconst logger = require('../../logger').child({\n  component: 'Transaction Trace Aggregator'\n});\n/*\n *\n * CONSTANTS\n *\n */\n\n\nconst TO_MILLIS = 1e3;\n\nconst TraceAggregator = require('../../aggregators/trace-aggregator');\n/**\n * Locus for the complicated logic surrounding the selection of slow\n * transaction traces for submission to the collector.\n *\n * @param {object} config Dictionary containing transaction tracing\n *                        parameters. Required.\n */\n\n\nclass TransactionTraceAggregator extends TraceAggregator {\n  constructor(opts, collector) {\n    opts = opts || {};\n    opts.method = opts.method || 'trace_sample_data';\n\n    if (!opts.config) {\n      throw new Error('config required by trace aggregator');\n    }\n\n    super(opts, collector);\n    /*\n    * From\n    *\n    * https://newrelic.atlassian.net/wiki/display/eng/Transaction+Trace+Collection+Improvements\n    *\n    * 5 Transaction Trace Guarantee\n    *\n    * For the initial experience problem, the Agent will sample up to 1\n    * transaction per minute until it has sampled 5 transactions. This\n    * guarantees that the agent will always report some transaction traces.\n    * There is no time out for this sampling period - the agent always\n    * samples until it has collected 5 transactions. The agent doesn't\n    * simply report the first 5 transactions that it sees because it's\n    * likely (particularly for a local dev test) that all 5 transactions\n    * would be associated with one request (a single web page and its\n    * resources).\n    */\n\n    const config = opts.config;\n    this.reported = 0;\n    this.config = config; // Setting up top n capacity.\n\n    this.capacity = 1;\n\n    if (config.transaction_tracer && config.transaction_tracer.top_n) {\n      this.capacity = config.transaction_tracer.top_n;\n    } // hidden class optimization\n\n\n    this.trace = null;\n    this.syntheticsTraces = [];\n    this.requestTimes = Object.create(null);\n    this.noTraceSubmitted = 0;\n  }\n  /**\n  * For every five harvest cycles (or \"minutes\"), if no new slow transactions\n  * have been added, reset the requestTime match and allow a new set of five\n  * to start populating the Top N Slow Trace list.\n  */\n\n\n  resetTimingTracker() {\n    this.requestTimes = Object.create(null);\n    this.noTraceSubmitted = 0;\n  }\n  /**\n  * Add a trace to the slow trace list, if and only if it fulfills the necessary\n  * criteria.\n  *\n  * @param {Transaction} transaction The transaction, which we need to check\n  *                                  apdexT, as well as getting the trace.\n  */\n\n\n  add(transaction) {\n    if (!transaction) {\n      return;\n    }\n\n    if (this.config.collect_traces && this.config.transaction_tracer && this.config.transaction_tracer.enabled && transaction && transaction.metrics) {\n      const trace = transaction.trace;\n      const name = transaction.getFullName();\n      const duration = trace.getDurationInMillis();\n      const apdexT = transaction.metrics.apdexT;\n\n      if (transaction.syntheticsData) {\n        this.addSyntheticsTrace(trace);\n      } else if (this.isBetter(name, duration, apdexT)) {\n        this.trace = trace; // because of the \"first 5\" rule, this may or may not be the slowest\n\n        if (!this.requestTimes[name] || this.requestTimes[name] < duration) {\n          this.requestTimes[name] = duration;\n        }\n      }\n    }\n  }\n\n  addSyntheticsTrace(trace) {\n    if (this.syntheticsTraces.length < 20) {\n      this.syntheticsTraces.push(trace);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n  * Reset the trace diversity settings.\n  */\n\n\n  clear() {\n    this.trace = null;\n    this.syntheticsTraces = [];\n  }\n\n  _merge(data) {\n    if (!data) {\n      return;\n    }\n\n    if (data.trace) {\n      this.add(data.trace.transaction);\n    }\n\n    if (data.synthetics) {\n      for (let i = 0; i < data.synthetics.length; ++i) {\n        const trace = data.synthetics[i];\n\n        if (!this.addSyntheticsTrace(trace)) {\n          break;\n        }\n      }\n    }\n  }\n\n  _getMergeData() {\n    return {\n      trace: this.trace,\n      synthetics: this.synthetricsTraces\n    };\n  }\n\n  getTraces() {\n    const traces = [].concat(this.syntheticsTraces);\n    const maxTraceSegments = this.config.max_trace_segments;\n\n    if (this.trace) {\n      const trace = this.trace;\n\n      if (trace.segmentsSeen > maxTraceSegments) {\n        logger.warn('Transaction %s (%s) contained %d segments, only collecting the first %d', trace.transaction.name, trace.transaction.id, trace.segmentsSeen, maxTraceSegments);\n      }\n\n      this.noTraceSubmitted = 0;\n      traces.push(trace);\n    } else if (++this.noTraceSubmitted >= 5) {\n      this.resetTimingTracker();\n    }\n\n    return traces.length === 0 ? null : traces;\n  }\n\n  _toPayloadSync() {\n    const traces = this.getTraces();\n\n    if (!traces) {\n      logger.debug('No transaction traces to send.');\n      return null;\n    }\n\n    return [this.runId, traces.map(trace => trace.generateJSONSync())];\n  }\n\n  _toPayload(callback) {\n    const traces = this.getTraces();\n\n    if (!traces) {\n      return callback(null, traces);\n    }\n\n    return a.map(traces, (trace, cb) => trace.generateJSON(cb), (err, encodedTraces) => callback(err, [this.runId, encodedTraces]));\n  }\n\n  _afterSend(successful) {\n    if (successful) {\n      ++this.reported;\n    }\n  }\n  /**\n  * Determine whether a new trace is more worth keeping than an old one.\n  * This gets called on every single transactionFinished event, so return as\n  * quickly as possible and call as few external functions as possible. On the\n  * converse, there's some complicated logic here, so spell things out.\n  *\n  * All specifications are from\n  * https://newrelic.atlassian.net/wiki/display/eng/Transaction+Trace+Collection+Improvements\n  *\n  * @param {string} name     Name of this transaction's key metric.\n  * @param {number} duration Time the transaction took, in milliseconds.\n  * @param {number} apdexT   Apdex tolerating threshold, in seconds.\n  */\n\n\n  isBetter(name, duration, apdexT) {\n    /* 1. If the transaction duration is below the tracing threshold, the\n    *    transaction is skipped.\n    *\n    * The threshold for slow traces defaults to apdex_f, which is 4 * apdex_t.\n    */\n    const config = this.config.transaction_tracer;\n    let isOverThreshold;\n\n    if (config && config.transaction_threshold != null && config.transaction_threshold !== 'apdex_f' && typeof config.transaction_threshold === 'number') {\n      isOverThreshold = duration >= config.transaction_threshold * TO_MILLIS;\n    } else {\n      isOverThreshold = duration >= 4 * TO_MILLIS * apdexT;\n    }\n\n    if (!isOverThreshold) return false;\n    /* 2. If the transaction duration is less than the duration of the current\n    *    slow transaction, the transaction is skipped.\n    */\n\n    let slowerThanExisting = true;\n\n    if (this.trace) {\n      slowerThanExisting = this.trace.getDurationInMillis() < duration;\n    }\n\n    if (!slowerThanExisting) return false;\n    /* We always gather some slow transactions at the start, regardless of\n    * the size of Top N. This changes the behavior of the rest of the\n    * decision-making process in some subtle ways.\n    */\n\n    const hasMetGuarantee = this.reported >= 5;\n    /* 3. If the transaction's name is in the transaction map and its duration\n    *    is less than the response time in the map, it is skipped.\n    */\n\n    let slowerThanCaptured = true;\n\n    if (hasMetGuarantee) {\n      if (this.requestTimes[name]) {\n        slowerThanCaptured = this.requestTimes[name] < duration;\n      }\n    }\n\n    if (!slowerThanCaptured) return false;\n    /* Not part of enumerated rules, but necessary for Top N support:\n    * Ensure this name is either already in the request time map\n    * or that the map still hasn't hit capacity.\n    */\n\n    if (hasMetGuarantee && !this.requestTimes[name] && Object.keys(this.requestTimes).length >= this.capacity) {\n      return false;\n    }\n    /* 4. The transaction is held as the slowest transaction.\n    */\n\n\n    return true;\n  }\n\n}\n\nmodule.exports = TransactionTraceAggregator;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/transaction/trace/aggregator.js"],"names":["a","require","logger","child","component","TO_MILLIS","TraceAggregator","TransactionTraceAggregator","constructor","opts","collector","method","config","Error","reported","capacity","transaction_tracer","top_n","trace","syntheticsTraces","requestTimes","Object","create","noTraceSubmitted","resetTimingTracker","add","transaction","collect_traces","enabled","metrics","name","getFullName","duration","getDurationInMillis","apdexT","syntheticsData","addSyntheticsTrace","isBetter","length","push","clear","_merge","data","synthetics","i","_getMergeData","synthetricsTraces","getTraces","traces","concat","maxTraceSegments","max_trace_segments","segmentsSeen","warn","id","_toPayloadSync","debug","runId","map","generateJSONSync","_toPayload","callback","cb","generateJSON","err","encodedTraces","_afterSend","successful","isOverThreshold","transaction_threshold","slowerThanExisting","hasMetGuarantee","slowerThanCaptured","keys","module","exports"],"mappings":"AAAA;;AACA,MAAMA,CAAC,GAAGC,OAAO,CAAC,OAAD,CAAjB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,cAAD,CAAP,CAAwBE,KAAxB,CAA8B;AAACC,EAAAA,SAAS,EAAE;AAAZ,CAA9B,CAAf;AAEA;;;;;;;AAKA,MAAMC,SAAS,GAAG,GAAlB;;AACA,MAAMC,eAAe,GAAGL,OAAO,CAAC,oCAAD,CAA/B;AAEA;;;;;;;;;AAOA,MAAMM,0BAAN,SAAyCD,eAAzC,CAAyD;AACvDE,EAAAA,WAAW,CAACC,IAAD,EAAOC,SAAP,EAAkB;AAC3BD,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACAA,IAAAA,IAAI,CAACE,MAAL,GAAcF,IAAI,CAACE,MAAL,IAAe,mBAA7B;;AACA,QAAI,CAACF,IAAI,CAACG,MAAV,EAAkB;AAChB,YAAM,IAAIC,KAAJ,CAAU,qCAAV,CAAN;AACD;;AAED,UAAMJ,IAAN,EAAYC,SAAZ;AACA;;;;;;;;;;;;;;;;;;AAmBA,UAAME,MAAM,GAAGH,IAAI,CAACG,MAApB;AACA,SAAKE,QAAL,GAAgB,CAAhB;AACA,SAAKF,MAAL,GAAcA,MAAd,CA7B2B,CA+B3B;;AACA,SAAKG,QAAL,GAAgB,CAAhB;;AACA,QAAIH,MAAM,CAACI,kBAAP,IACAJ,MAAM,CAACI,kBAAP,CAA0BC,KAD9B,EACqC;AACnC,WAAKF,QAAL,GAAgBH,MAAM,CAACI,kBAAP,CAA0BC,KAA1C;AACD,KApC0B,CAsC3B;;;AACA,SAAKC,KAAL,GAAa,IAAb;AACA,SAAKC,gBAAL,GAAwB,EAAxB;AACA,SAAKC,YAAL,GAAoBC,MAAM,CAACC,MAAP,CAAc,IAAd,CAApB;AACA,SAAKC,gBAAL,GAAwB,CAAxB;AACD;AAED;;;;;;;AAKAC,EAAAA,kBAAkB,GAAG;AACnB,SAAKJ,YAAL,GAAoBC,MAAM,CAACC,MAAP,CAAc,IAAd,CAApB;AACA,SAAKC,gBAAL,GAAwB,CAAxB;AACD;AAED;;;;;;;;;AAOAE,EAAAA,GAAG,CAACC,WAAD,EAAc;AACf,QAAI,CAACA,WAAL,EAAkB;AAChB;AACD;;AAED,QACE,KAAKd,MAAL,CAAYe,cAAZ,IACA,KAAKf,MAAL,CAAYI,kBADZ,IAEA,KAAKJ,MAAL,CAAYI,kBAAZ,CAA+BY,OAF/B,IAGAF,WAHA,IAIAA,WAAW,CAACG,OALd,EAME;AACA,YAAMX,KAAK,GAAGQ,WAAW,CAACR,KAA1B;AACA,YAAMY,IAAI,GAAGJ,WAAW,CAACK,WAAZ,EAAb;AACA,YAAMC,QAAQ,GAAGd,KAAK,CAACe,mBAAN,EAAjB;AACA,YAAMC,MAAM,GAAGR,WAAW,CAACG,OAAZ,CAAoBK,MAAnC;;AAEA,UAAIR,WAAW,CAACS,cAAhB,EAAgC;AAC9B,aAAKC,kBAAL,CAAwBlB,KAAxB;AACD,OAFD,MAEO,IAAI,KAAKmB,QAAL,CAAcP,IAAd,EAAoBE,QAApB,EAA8BE,MAA9B,CAAJ,EAA2C;AAChD,aAAKhB,KAAL,GAAaA,KAAb,CADgD,CAGhD;;AACA,YAAI,CAAC,KAAKE,YAAL,CAAkBU,IAAlB,CAAD,IAA4B,KAAKV,YAAL,CAAkBU,IAAlB,IAA0BE,QAA1D,EAAoE;AAClE,eAAKZ,YAAL,CAAkBU,IAAlB,IAA0BE,QAA1B;AACD;AACF;AACF;AACF;;AAEDI,EAAAA,kBAAkB,CAAClB,KAAD,EAAQ;AACxB,QAAI,KAAKC,gBAAL,CAAsBmB,MAAtB,GAA+B,EAAnC,EAAuC;AACrC,WAAKnB,gBAAL,CAAsBoB,IAAtB,CAA2BrB,KAA3B;AACA,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD;AAED;;;;;AAGAsB,EAAAA,KAAK,GAAG;AACN,SAAKtB,KAAL,GAAa,IAAb;AACA,SAAKC,gBAAL,GAAwB,EAAxB;AACD;;AAEDsB,EAAAA,MAAM,CAACC,IAAD,EAAO;AACX,QAAI,CAACA,IAAL,EAAW;AACT;AACD;;AACD,QAAIA,IAAI,CAACxB,KAAT,EAAgB;AACd,WAAKO,GAAL,CAASiB,IAAI,CAACxB,KAAL,CAAWQ,WAApB;AACD;;AACD,QAAIgB,IAAI,CAACC,UAAT,EAAqB;AACnB,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACC,UAAL,CAAgBL,MAApC,EAA4C,EAAEM,CAA9C,EAAiD;AAC/C,cAAM1B,KAAK,GAAGwB,IAAI,CAACC,UAAL,CAAgBC,CAAhB,CAAd;;AACA,YAAI,CAAC,KAAKR,kBAAL,CAAwBlB,KAAxB,CAAL,EAAqC;AACnC;AACD;AACF;AACF;AACF;;AAED2B,EAAAA,aAAa,GAAG;AACd,WAAO;AACL3B,MAAAA,KAAK,EAAE,KAAKA,KADP;AAELyB,MAAAA,UAAU,EAAE,KAAKG;AAFZ,KAAP;AAID;;AAEDC,EAAAA,SAAS,GAAG;AACV,UAAMC,MAAM,GAAG,GAAGC,MAAH,CAAU,KAAK9B,gBAAf,CAAf;AACA,UAAM+B,gBAAgB,GAAG,KAAKtC,MAAL,CAAYuC,kBAArC;;AACA,QAAI,KAAKjC,KAAT,EAAgB;AACd,YAAMA,KAAK,GAAG,KAAKA,KAAnB;;AACA,UAAIA,KAAK,CAACkC,YAAN,GAAqBF,gBAAzB,EAA2C;AACzChD,QAAAA,MAAM,CAACmD,IAAP,CACE,yEADF,EAEEnC,KAAK,CAACQ,WAAN,CAAkBI,IAFpB,EAGEZ,KAAK,CAACQ,WAAN,CAAkB4B,EAHpB,EAIEpC,KAAK,CAACkC,YAJR,EAKEF,gBALF;AAOD;;AACD,WAAK3B,gBAAL,GAAwB,CAAxB;AACAyB,MAAAA,MAAM,CAACT,IAAP,CAAYrB,KAAZ;AACD,KAbD,MAaO,IAAI,EAAE,KAAKK,gBAAP,IAA2B,CAA/B,EAAkC;AACvC,WAAKC,kBAAL;AACD;;AACD,WAAOwB,MAAM,CAACV,MAAP,KAAkB,CAAlB,GAAsB,IAAtB,GAA6BU,MAApC;AACD;;AAEDO,EAAAA,cAAc,GAAG;AACf,UAAMP,MAAM,GAAG,KAAKD,SAAL,EAAf;;AACA,QAAI,CAACC,MAAL,EAAa;AACX9C,MAAAA,MAAM,CAACsD,KAAP,CAAa,gCAAb;AACA,aAAO,IAAP;AACD;;AAED,WAAO,CACL,KAAKC,KADA,EAELT,MAAM,CAACU,GAAP,CAAYxC,KAAD,IAAWA,KAAK,CAACyC,gBAAN,EAAtB,CAFK,CAAP;AAID;;AAEDC,EAAAA,UAAU,CAACC,QAAD,EAAW;AACnB,UAAMb,MAAM,GAAG,KAAKD,SAAL,EAAf;;AACA,QAAI,CAACC,MAAL,EAAa;AACX,aAAOa,QAAQ,CAAC,IAAD,EAAOb,MAAP,CAAf;AACD;;AACD,WAAOhD,CAAC,CAAC0D,GAAF,CACLV,MADK,EAEL,CAAC9B,KAAD,EAAQ4C,EAAR,KAAe5C,KAAK,CAAC6C,YAAN,CAAmBD,EAAnB,CAFV,EAGL,CAACE,GAAD,EAAMC,aAAN,KAAwBJ,QAAQ,CAACG,GAAD,EAAM,CAAC,KAAKP,KAAN,EAAaQ,aAAb,CAAN,CAH3B,CAAP;AAKD;;AAEDC,EAAAA,UAAU,CAACC,UAAD,EAAa;AACrB,QAAIA,UAAJ,EAAgB;AACd,QAAE,KAAKrD,QAAP;AACD;AACF;AAED;;;;;;;;;;;;;;;AAaAuB,EAAAA,QAAQ,CAACP,IAAD,EAAOE,QAAP,EAAiBE,MAAjB,EAAyB;AAC/B;;;;;AAKA,UAAMtB,MAAM,GAAG,KAAKA,MAAL,CAAYI,kBAA3B;AACA,QAAIoD,eAAJ;;AAEA,QAAIxD,MAAM,IACNA,MAAM,CAACyD,qBAAP,IAAgC,IADhC,IAEAzD,MAAM,CAACyD,qBAAP,KAAiC,SAFjC,IAGA,OAAOzD,MAAM,CAACyD,qBAAd,KAAwC,QAH5C,EAGsD;AACpDD,MAAAA,eAAe,GAAGpC,QAAQ,IAAIpB,MAAM,CAACyD,qBAAP,GAA+BhE,SAA7D;AACD,KALD,MAKO;AACL+D,MAAAA,eAAe,GAAGpC,QAAQ,IAAI,IAAI3B,SAAJ,GAAgB6B,MAA9C;AACD;;AACD,QAAI,CAACkC,eAAL,EAAsB,OAAO,KAAP;AAEtB;;;;AAGA,QAAIE,kBAAkB,GAAG,IAAzB;;AACA,QAAI,KAAKpD,KAAT,EAAgB;AACdoD,MAAAA,kBAAkB,GAAG,KAAKpD,KAAL,CAAWe,mBAAX,KAAmCD,QAAxD;AACD;;AACD,QAAI,CAACsC,kBAAL,EAAyB,OAAO,KAAP;AAEzB;;;;;AAIA,UAAMC,eAAe,GAAG,KAAKzD,QAAL,IAAiB,CAAzC;AAEA;;;;AAGA,QAAI0D,kBAAkB,GAAG,IAAzB;;AACA,QAAID,eAAJ,EAAqB;AACnB,UAAI,KAAKnD,YAAL,CAAkBU,IAAlB,CAAJ,EAA6B;AAC3B0C,QAAAA,kBAAkB,GAAG,KAAKpD,YAAL,CAAkBU,IAAlB,IAA0BE,QAA/C;AACD;AACF;;AACD,QAAI,CAACwC,kBAAL,EAAyB,OAAO,KAAP;AAEzB;;;;;AAIA,QAAID,eAAe,IACf,CAAC,KAAKnD,YAAL,CAAkBU,IAAlB,CADD,IAEAT,MAAM,CAACoD,IAAP,CAAY,KAAKrD,YAAjB,EAA+BkB,MAA/B,IAAyC,KAAKvB,QAFlD,EAE4D;AAC1D,aAAO,KAAP;AACD;AAED;;;;AAEA,WAAO,IAAP;AACD;;AAjQsD;;AAoQzD2D,MAAM,CAACC,OAAP,GAAiBpE,0BAAjB","sourcesContent":["'use strict'\nconst a = require('async')\nconst logger = require('../../logger').child({component: 'Transaction Trace Aggregator'})\n\n/*\n *\n * CONSTANTS\n *\n */\nconst TO_MILLIS = 1e3\nconst TraceAggregator = require('../../aggregators/trace-aggregator')\n\n/**\n * Locus for the complicated logic surrounding the selection of slow\n * transaction traces for submission to the collector.\n *\n * @param {object} config Dictionary containing transaction tracing\n *                        parameters. Required.\n */\nclass TransactionTraceAggregator extends TraceAggregator {\n  constructor(opts, collector) {\n    opts = opts || {}\n    opts.method = opts.method || 'trace_sample_data'\n    if (!opts.config) {\n      throw new Error('config required by trace aggregator')\n    }\n\n    super(opts, collector)\n    /*\n    * From\n    *\n    * https://newrelic.atlassian.net/wiki/display/eng/Transaction+Trace+Collection+Improvements\n    *\n    * 5 Transaction Trace Guarantee\n    *\n    * For the initial experience problem, the Agent will sample up to 1\n    * transaction per minute until it has sampled 5 transactions. This\n    * guarantees that the agent will always report some transaction traces.\n    * There is no time out for this sampling period - the agent always\n    * samples until it has collected 5 transactions. The agent doesn't\n    * simply report the first 5 transactions that it sees because it's\n    * likely (particularly for a local dev test) that all 5 transactions\n    * would be associated with one request (a single web page and its\n    * resources).\n    */\n\n\n    const config = opts.config\n    this.reported = 0\n    this.config = config\n\n    // Setting up top n capacity.\n    this.capacity = 1\n    if (config.transaction_tracer &&\n        config.transaction_tracer.top_n) {\n      this.capacity = config.transaction_tracer.top_n\n    }\n\n    // hidden class optimization\n    this.trace = null\n    this.syntheticsTraces = []\n    this.requestTimes = Object.create(null)\n    this.noTraceSubmitted = 0\n  }\n\n  /**\n  * For every five harvest cycles (or \"minutes\"), if no new slow transactions\n  * have been added, reset the requestTime match and allow a new set of five\n  * to start populating the Top N Slow Trace list.\n  */\n  resetTimingTracker() {\n    this.requestTimes = Object.create(null)\n    this.noTraceSubmitted = 0\n  }\n\n  /**\n  * Add a trace to the slow trace list, if and only if it fulfills the necessary\n  * criteria.\n  *\n  * @param {Transaction} transaction The transaction, which we need to check\n  *                                  apdexT, as well as getting the trace.\n  */\n  add(transaction) {\n    if (!transaction) {\n      return\n    }\n\n    if (\n      this.config.collect_traces &&\n      this.config.transaction_tracer &&\n      this.config.transaction_tracer.enabled &&\n      transaction &&\n      transaction.metrics\n    ) {\n      const trace = transaction.trace\n      const name = transaction.getFullName()\n      const duration = trace.getDurationInMillis()\n      const apdexT = transaction.metrics.apdexT\n\n      if (transaction.syntheticsData) {\n        this.addSyntheticsTrace(trace)\n      } else if (this.isBetter(name, duration, apdexT)) {\n        this.trace = trace\n\n        // because of the \"first 5\" rule, this may or may not be the slowest\n        if (!this.requestTimes[name] || this.requestTimes[name] < duration) {\n          this.requestTimes[name] = duration\n        }\n      }\n    }\n  }\n\n  addSyntheticsTrace(trace) {\n    if (this.syntheticsTraces.length < 20) {\n      this.syntheticsTraces.push(trace)\n      return true\n    }\n    return false\n  }\n\n  /**\n  * Reset the trace diversity settings.\n  */\n  clear() {\n    this.trace = null\n    this.syntheticsTraces = []\n  }\n\n  _merge(data) {\n    if (!data) {\n      return\n    }\n    if (data.trace) {\n      this.add(data.trace.transaction)\n    }\n    if (data.synthetics) {\n      for (let i = 0; i < data.synthetics.length; ++i) {\n        const trace = data.synthetics[i]\n        if (!this.addSyntheticsTrace(trace)) {\n          break\n        }\n      }\n    }\n  }\n\n  _getMergeData() {\n    return {\n      trace: this.trace,\n      synthetics: this.synthetricsTraces\n    }\n  }\n\n  getTraces() {\n    const traces = [].concat(this.syntheticsTraces)\n    const maxTraceSegments = this.config.max_trace_segments\n    if (this.trace) {\n      const trace = this.trace\n      if (trace.segmentsSeen > maxTraceSegments) {\n        logger.warn(\n          'Transaction %s (%s) contained %d segments, only collecting the first %d',\n          trace.transaction.name,\n          trace.transaction.id,\n          trace.segmentsSeen,\n          maxTraceSegments\n        )\n      }\n      this.noTraceSubmitted = 0\n      traces.push(trace)\n    } else if (++this.noTraceSubmitted >= 5) {\n      this.resetTimingTracker()\n    }\n    return traces.length === 0 ? null : traces\n  }\n\n  _toPayloadSync() {\n    const traces = this.getTraces()\n    if (!traces) {\n      logger.debug('No transaction traces to send.')\n      return null\n    }\n\n    return [\n      this.runId,\n      traces.map((trace) => trace.generateJSONSync())\n    ]\n  }\n\n  _toPayload(callback) {\n    const traces = this.getTraces()\n    if (!traces) {\n      return callback(null, traces)\n    }\n    return a.map(\n      traces,\n      (trace, cb) => trace.generateJSON(cb),\n      (err, encodedTraces) => callback(err, [this.runId, encodedTraces])\n    )\n  }\n\n  _afterSend(successful) {\n    if (successful) {\n      ++this.reported\n    }\n  }\n\n  /**\n  * Determine whether a new trace is more worth keeping than an old one.\n  * This gets called on every single transactionFinished event, so return as\n  * quickly as possible and call as few external functions as possible. On the\n  * converse, there's some complicated logic here, so spell things out.\n  *\n  * All specifications are from\n  * https://newrelic.atlassian.net/wiki/display/eng/Transaction+Trace+Collection+Improvements\n  *\n  * @param {string} name     Name of this transaction's key metric.\n  * @param {number} duration Time the transaction took, in milliseconds.\n  * @param {number} apdexT   Apdex tolerating threshold, in seconds.\n  */\n  isBetter(name, duration, apdexT) {\n    /* 1. If the transaction duration is below the tracing threshold, the\n    *    transaction is skipped.\n    *\n    * The threshold for slow traces defaults to apdex_f, which is 4 * apdex_t.\n    */\n    const config = this.config.transaction_tracer\n    let isOverThreshold\n\n    if (config &&\n        config.transaction_threshold != null &&\n        config.transaction_threshold !== 'apdex_f' &&\n        typeof config.transaction_threshold === 'number') {\n      isOverThreshold = duration >= config.transaction_threshold * TO_MILLIS\n    } else {\n      isOverThreshold = duration >= 4 * TO_MILLIS * apdexT\n    }\n    if (!isOverThreshold) return false\n\n    /* 2. If the transaction duration is less than the duration of the current\n    *    slow transaction, the transaction is skipped.\n    */\n    let slowerThanExisting = true\n    if (this.trace) {\n      slowerThanExisting = this.trace.getDurationInMillis() < duration\n    }\n    if (!slowerThanExisting) return false\n\n    /* We always gather some slow transactions at the start, regardless of\n    * the size of Top N. This changes the behavior of the rest of the\n    * decision-making process in some subtle ways.\n    */\n    const hasMetGuarantee = this.reported >= 5\n\n    /* 3. If the transaction's name is in the transaction map and its duration\n    *    is less than the response time in the map, it is skipped.\n    */\n    let slowerThanCaptured = true\n    if (hasMetGuarantee) {\n      if (this.requestTimes[name]) {\n        slowerThanCaptured = this.requestTimes[name] < duration\n      }\n    }\n    if (!slowerThanCaptured) return false\n\n    /* Not part of enumerated rules, but necessary for Top N support:\n    * Ensure this name is either already in the request time map\n    * or that the map still hasn't hit capacity.\n    */\n    if (hasMetGuarantee &&\n        !this.requestTimes[name] &&\n        Object.keys(this.requestTimes).length >= this.capacity) {\n      return false\n    }\n\n    /* 4. The transaction is held as the slowest transaction.\n    */\n    return true\n  }\n}\n\nmodule.exports = TransactionTraceAggregator\n"]},"metadata":{},"sourceType":"script"}