{"ast":null,"code":"'use strict';\n\nconst logger = require('../logger');\n\nlet spanLogger = null;\n\nconst EventAggregator = require('../aggregators/event-aggregator');\n\nconst SpanEvent = require('./span-event');\n\nconst NAMES = require('../metrics/names');\n\nconst LIMIT = 1000;\n\nclass SpanEventAggregator extends EventAggregator {\n  constructor(opts, collector, metrics) {\n    opts = opts || {};\n    opts.method = opts.method || 'span_event_data';\n    opts.metricNames = opts.metricNames || NAMES.SPAN_EVENTS;\n    spanLogger = logger.child({\n      component: 'span_aggregator'\n    });\n    super(opts, collector, metrics);\n  }\n\n  _toPayloadSync() {\n    const events = this.events;\n\n    if (events.length === 0) {\n      spanLogger.debug('No span events to send.');\n      return;\n    }\n\n    const metrics = {\n      reservoir_size: events.limit,\n      events_seen: events.seen\n    };\n    const eventData = events.toArray();\n    return [this.runId, metrics, eventData];\n  }\n\n  send() {\n    if (spanLogger.traceEnabled()) {\n      spanLogger.trace({\n        spansCollected: this.length,\n        spansSeen: this.seen\n      }, 'Entity stats on span harvest');\n    }\n\n    super.send();\n  }\n  /**\n   * Attempts to add the given segment to the collection.\n   *\n   * @param {TraceSegment}  segment         - The segment to add.\n   * @param {string}        [parentId=null] - The GUID of the parent span.\n   *\n   * @return {bool} True if the segment was added, or false if it was discarded.\n   */\n\n\n  addSegment(segment, parentId) {\n    // Check if the priority would be accepted before creating the event object.\n    const tx = segment.transaction;\n\n    if (tx.priority < this._items.getMinimumPriority()) {\n      ++this.events.seen;\n\n      this._metrics.getOrCreateMetric(this._metricNames.SEEN).incrementCallCount();\n\n      return false;\n    }\n\n    const span = SpanEvent.fromSegment(segment, parentId || null);\n    return this.add(span, tx.priority);\n  }\n\n}\n\nmodule.exports = SpanEventAggregator;\nmodule.exports.LIMIT = LIMIT;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/spans/span-event-aggregator.js"],"names":["logger","require","spanLogger","EventAggregator","SpanEvent","NAMES","LIMIT","SpanEventAggregator","constructor","opts","collector","metrics","method","metricNames","SPAN_EVENTS","child","component","_toPayloadSync","events","length","debug","reservoir_size","limit","events_seen","seen","eventData","toArray","runId","send","traceEnabled","trace","spansCollected","spansSeen","addSegment","segment","parentId","tx","transaction","priority","_items","getMinimumPriority","_metrics","getOrCreateMetric","_metricNames","SEEN","incrementCallCount","span","fromSegment","add","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,WAAD,CAAtB;;AACA,IAAIC,UAAU,GAAG,IAAjB;;AACA,MAAMC,eAAe,GAAGF,OAAO,CAAC,iCAAD,CAA/B;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAMI,KAAK,GAAGJ,OAAO,CAAC,kBAAD,CAArB;;AACA,MAAMK,KAAK,GAAG,IAAd;;AAEA,MAAMC,mBAAN,SAAkCJ,eAAlC,CAAkD;AAChDK,EAAAA,WAAW,CAACC,IAAD,EAAOC,SAAP,EAAkBC,OAAlB,EAA2B;AACpCF,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACAA,IAAAA,IAAI,CAACG,MAAL,GAAcH,IAAI,CAACG,MAAL,IAAe,iBAA7B;AACAH,IAAAA,IAAI,CAACI,WAAL,GAAmBJ,IAAI,CAACI,WAAL,IAAoBR,KAAK,CAACS,WAA7C;AAEAZ,IAAAA,UAAU,GAAGF,MAAM,CAACe,KAAP,CAAa;AAACC,MAAAA,SAAS,EAAE;AAAZ,KAAb,CAAb;AAEA,UAAMP,IAAN,EAAYC,SAAZ,EAAuBC,OAAvB;AACD;;AAEDM,EAAAA,cAAc,GAAG;AACf,UAAMC,MAAM,GAAG,KAAKA,MAApB;;AAEA,QAAIA,MAAM,CAACC,MAAP,KAAkB,CAAtB,EAAyB;AACvBjB,MAAAA,UAAU,CAACkB,KAAX,CAAiB,yBAAjB;AACA;AACD;;AAED,UAAMT,OAAO,GAAG;AACdU,MAAAA,cAAc,EAAEH,MAAM,CAACI,KADT;AAEdC,MAAAA,WAAW,EAAEL,MAAM,CAACM;AAFN,KAAhB;AAIA,UAAMC,SAAS,GAAGP,MAAM,CAACQ,OAAP,EAAlB;AAEA,WAAO,CAAC,KAAKC,KAAN,EAAahB,OAAb,EAAsBc,SAAtB,CAAP;AACD;;AAEDG,EAAAA,IAAI,GAAG;AACL,QAAI1B,UAAU,CAAC2B,YAAX,EAAJ,EAA+B;AAC7B3B,MAAAA,UAAU,CAAC4B,KAAX,CAAiB;AACfC,QAAAA,cAAc,EAAE,KAAKZ,MADN;AAEfa,QAAAA,SAAS,EAAE,KAAKR;AAFD,OAAjB,EAGG,8BAHH;AAID;;AACD,UAAMI,IAAN;AACD;AAED;;;;;;;;;;AAQAK,EAAAA,UAAU,CAACC,OAAD,EAAUC,QAAV,EAAoB;AAC5B;AACA,UAAMC,EAAE,GAAGF,OAAO,CAACG,WAAnB;;AAEA,QAAID,EAAE,CAACE,QAAH,GAAc,KAAKC,MAAL,CAAYC,kBAAZ,EAAlB,EAAoD;AAClD,QAAE,KAAKtB,MAAL,CAAYM,IAAd;;AACA,WAAKiB,QAAL,CAAcC,iBAAd,CAAgC,KAAKC,YAAL,CAAkBC,IAAlD,EAAwDC,kBAAxD;;AAEA,aAAO,KAAP;AACD;;AACD,UAAMC,IAAI,GAAG1C,SAAS,CAAC2C,WAAV,CAAsBb,OAAtB,EAA+BC,QAAQ,IAAI,IAA3C,CAAb;AACA,WAAO,KAAKa,GAAL,CAASF,IAAT,EAAeV,EAAE,CAACE,QAAlB,CAAP;AACD;;AA1D+C;;AA6DlDW,MAAM,CAACC,OAAP,GAAiB3C,mBAAjB;AACA0C,MAAM,CAACC,OAAP,CAAe5C,KAAf,GAAuBA,KAAvB","sourcesContent":["'use strict'\n\nconst logger = require('../logger')\nlet spanLogger = null\nconst EventAggregator = require('../aggregators/event-aggregator')\nconst SpanEvent = require('./span-event')\nconst NAMES = require('../metrics/names')\nconst LIMIT = 1000\n\nclass SpanEventAggregator extends EventAggregator {\n  constructor(opts, collector, metrics) {\n    opts = opts || {}\n    opts.method = opts.method || 'span_event_data'\n    opts.metricNames = opts.metricNames || NAMES.SPAN_EVENTS\n\n    spanLogger = logger.child({component: 'span_aggregator'})\n\n    super(opts, collector, metrics)\n  }\n\n  _toPayloadSync() {\n    const events = this.events\n\n    if (events.length === 0) {\n      spanLogger.debug('No span events to send.')\n      return\n    }\n\n    const metrics = {\n      reservoir_size: events.limit,\n      events_seen: events.seen\n    }\n    const eventData = events.toArray()\n\n    return [this.runId, metrics, eventData]\n  }\n\n  send() {\n    if (spanLogger.traceEnabled()) {\n      spanLogger.trace({\n        spansCollected: this.length,\n        spansSeen: this.seen\n      }, 'Entity stats on span harvest')\n    }\n    super.send()\n  }\n\n  /**\n   * Attempts to add the given segment to the collection.\n   *\n   * @param {TraceSegment}  segment         - The segment to add.\n   * @param {string}        [parentId=null] - The GUID of the parent span.\n   *\n   * @return {bool} True if the segment was added, or false if it was discarded.\n   */\n  addSegment(segment, parentId) {\n    // Check if the priority would be accepted before creating the event object.\n    const tx = segment.transaction\n\n    if (tx.priority < this._items.getMinimumPriority()) {\n      ++this.events.seen\n      this._metrics.getOrCreateMetric(this._metricNames.SEEN).incrementCallCount()\n\n      return false\n    }\n    const span = SpanEvent.fromSegment(segment, parentId || null)\n    return this.add(span, tx.priority)\n  }\n}\n\nmodule.exports = SpanEventAggregator\nmodule.exports.LIMIT = LIMIT\n"]},"metadata":{},"sourceType":"script"}