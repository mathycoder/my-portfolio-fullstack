{"ast":null,"code":"'use strict'; // to avoid parsing the esprima code base we require it here\n// TODO: excise this with better internal file filtering\n\nconst esprima = require('esprima');\n\nconst ecg = require('escodegen');\n\nconst fileNameToken = {\n  type: 'Literal',\n  value: null\n};\nconst lineNumberTokenTemplate = {\n  type: 'Literal',\n  value: null\n};\n\nclass Mutator {\n  constructor(appliesTo, mutate) {\n    this.appliesTo = appliesTo;\n    this.mutate = mutate;\n    this.tokens = [];\n  }\n\n  add(token) {\n    this.tokens.push(token);\n  }\n\n  apply() {\n    this.tokens.forEach(this.mutate);\n  }\n\n}\n\nconst functionTypes = new Set(['ArrowFunctionExpression', 'FunctionExpression', 'AsyncFunction']);\nconst equalityCheckOps = new Set(['==', '===', '!=', '!==', 'instanceof']);\nconst variableTypes = new Set(['MemberExpression', 'Identifier']);\nconst callTypes = new Set(['CallExpression', 'NewExpression']);\nconst wrapTemplate = esprima.parse('__NR_wrap()').body[0].expression;\nconst unwrapTemplate = esprima.parse('__NR_unwrap()').body[0].expression;\nconst mutators = [new Mutator(function wrapAssignmentPredicate(token) {\n  return token.type === 'AssignmentExpression' && token.operator === '=' && functionTypes.has(token.right.type);\n}, function injectWrapAssignment(token) {\n  token.right = wrapToken(token.right);\n}), new Mutator(function wrapArgPredicate(token) {\n  return callTypes.has(token.type);\n}, function injectWrapArg(token) {\n  token.arguments = token.arguments.map(wrapToken);\n}), new Mutator(function unwrapPredicate(token) {\n  return token.type === 'BinaryExpression' && equalityCheckOps.has(token.operator);\n}, function injectUnwrap(token) {\n  token.left = unwrapToken(token.left);\n  token.right = unwrapToken(token.right);\n})];\n\nfunction wrapToken(argToken) {\n  const type = argToken.type;\n\n  if (!functionTypes.has(type) && !callTypes.has(type) && !variableTypes.has(type) || !argToken.loc) {\n    return argToken;\n  }\n\n  const wrapped = Object.assign({}, wrapTemplate);\n  const lineNumberToken = Object.assign({}, lineNumberTokenTemplate);\n  lineNumberToken.value = argToken.loc.start.line;\n  wrapped.arguments = [argToken, lineNumberToken, Object.assign({}, fileNameToken)];\n  return wrapped;\n}\n\nfunction unwrapToken(argToken) {\n  if (!variableTypes.has(argToken.type)) {\n    return argToken;\n  }\n\n  const wrapped = Object.assign({}, unwrapTemplate);\n  wrapped.arguments = [argToken];\n  return wrapped;\n}\n\nfunction inject(sourceCode, file) {\n  // wrap the incoming file code to make it more palatable for esprima.\n  // node likewise wraps the contents of the file in a function, so this\n  // replicates the behavior (e.g. allows for global returns)\n  sourceCode = 'function main() {' + sourceCode + '}';\n  const sourceRootBody = esprima.parse(sourceCode, {\n    loc: true\n  }).body[0].body.body;\n  const toRelax = [].concat(sourceRootBody);\n\n  while (toRelax.length) {\n    const currentToken = toRelax.pop();\n    mutators.forEach(m => {\n      if (m.appliesTo(currentToken)) {\n        m.add(currentToken);\n      }\n    });\n\n    for (let key of Object.keys(currentToken)) {\n      if (key === 'loc') continue;\n      const value = currentToken[key];\n\n      if (value && value instanceof Object) {\n        if (Array.isArray(value)) {\n          for (let t of value) {\n            if (t) {\n              toRelax.push(t);\n            }\n          }\n        } else {\n          toRelax.push(value);\n        }\n      }\n    }\n  } // TODO: make this less janky\n\n\n  fileNameToken.value = file;\n  mutators.forEach(m => m.apply());\n  fileNameToken.value = null; // create a new base level token that contains all the statements we\n  // want to pass back to node\n\n  const printed = ecg.generate({\n    type: 'Program',\n    body: sourceRootBody,\n    sourceType: 'script'\n  }, {\n    format: {\n      semicolons: false\n    }\n  });\n  return printed;\n}\n\nmodule.exports = {\n  inject\n};","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/injector.js"],"names":["esprima","require","ecg","fileNameToken","type","value","lineNumberTokenTemplate","Mutator","constructor","appliesTo","mutate","tokens","add","token","push","apply","forEach","functionTypes","Set","equalityCheckOps","variableTypes","callTypes","wrapTemplate","parse","body","expression","unwrapTemplate","mutators","wrapAssignmentPredicate","operator","has","right","injectWrapAssignment","wrapToken","wrapArgPredicate","injectWrapArg","arguments","map","unwrapPredicate","injectUnwrap","left","unwrapToken","argToken","loc","wrapped","Object","assign","lineNumberToken","start","line","inject","sourceCode","file","sourceRootBody","toRelax","concat","length","currentToken","pop","m","key","keys","Array","isArray","t","printed","generate","sourceType","format","semicolons","module","exports"],"mappings":"AAAA,a,CAEA;AACA;;AACA,MAAMA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,WAAD,CAAnB;;AACA,MAAME,aAAa,GAAG;AACpBC,EAAAA,IAAI,EAAE,SADc;AAEpBC,EAAAA,KAAK,EAAE;AAFa,CAAtB;AAIA,MAAMC,uBAAuB,GAAG;AAC9BF,EAAAA,IAAI,EAAE,SADwB;AAE9BC,EAAAA,KAAK,EAAE;AAFuB,CAAhC;;AAKA,MAAME,OAAN,CAAc;AACZC,EAAAA,WAAW,CAACC,SAAD,EAAYC,MAAZ,EAAoB;AAC7B,SAAKD,SAAL,GAAiBA,SAAjB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,MAAL,GAAc,EAAd;AACD;;AAEDC,EAAAA,GAAG,CAACC,KAAD,EAAQ;AACT,SAAKF,MAAL,CAAYG,IAAZ,CAAiBD,KAAjB;AACD;;AAEDE,EAAAA,KAAK,GAAG;AACN,SAAKJ,MAAL,CAAYK,OAAZ,CAAoB,KAAKN,MAAzB;AACD;;AAbW;;AAgBd,MAAMO,aAAa,GAAG,IAAIC,GAAJ,CAAQ,CAC5B,yBAD4B,EAE5B,oBAF4B,EAG5B,eAH4B,CAAR,CAAtB;AAMA,MAAMC,gBAAgB,GAAG,IAAID,GAAJ,CAAQ,CAC/B,IAD+B,EAE/B,KAF+B,EAG/B,IAH+B,EAI/B,KAJ+B,EAK/B,YAL+B,CAAR,CAAzB;AAQA,MAAME,aAAa,GAAG,IAAIF,GAAJ,CAAQ,CAC5B,kBAD4B,EAE5B,YAF4B,CAAR,CAAtB;AAKA,MAAMG,SAAS,GAAG,IAAIH,GAAJ,CAAQ,CACxB,gBADwB,EAExB,eAFwB,CAAR,CAAlB;AAKA,MAAMI,YAAY,GAAGtB,OAAO,CAACuB,KAAR,CAAc,aAAd,EAA6BC,IAA7B,CAAkC,CAAlC,EAAqCC,UAA1D;AACA,MAAMC,cAAc,GAAG1B,OAAO,CAACuB,KAAR,CAAc,eAAd,EAA+BC,IAA/B,CAAoC,CAApC,EAAuCC,UAA9D;AAEA,MAAME,QAAQ,GAAG,CACf,IAAIpB,OAAJ,CAAY,SAASqB,uBAAT,CAAiCf,KAAjC,EAAwC;AAClD,SAAOA,KAAK,CAACT,IAAN,KAAe,sBAAf,IACLS,KAAK,CAACgB,QAAN,KAAmB,GADd,IAELZ,aAAa,CAACa,GAAd,CAAkBjB,KAAK,CAACkB,KAAN,CAAY3B,IAA9B,CAFF;AAGD,CAJD,EAIG,SAAS4B,oBAAT,CAA8BnB,KAA9B,EAAqC;AACtCA,EAAAA,KAAK,CAACkB,KAAN,GAAcE,SAAS,CAACpB,KAAK,CAACkB,KAAP,CAAvB;AACD,CAND,CADe,EAQf,IAAIxB,OAAJ,CAAY,SAAS2B,gBAAT,CAA0BrB,KAA1B,EAAiC;AAC3C,SAAOQ,SAAS,CAACS,GAAV,CAAcjB,KAAK,CAACT,IAApB,CAAP;AACD,CAFD,EAEG,SAAS+B,aAAT,CAAuBtB,KAAvB,EAA8B;AAC/BA,EAAAA,KAAK,CAACuB,SAAN,GAAkBvB,KAAK,CAACuB,SAAN,CAAgBC,GAAhB,CAAoBJ,SAApB,CAAlB;AACD,CAJD,CARe,EAaf,IAAI1B,OAAJ,CAAY,SAAS+B,eAAT,CAAyBzB,KAAzB,EAAgC;AAC1C,SAAOA,KAAK,CAACT,IAAN,KAAe,kBAAf,IAAqCe,gBAAgB,CAACW,GAAjB,CAAqBjB,KAAK,CAACgB,QAA3B,CAA5C;AACD,CAFD,EAEG,SAASU,YAAT,CAAsB1B,KAAtB,EAA6B;AAC9BA,EAAAA,KAAK,CAAC2B,IAAN,GAAaC,WAAW,CAAC5B,KAAK,CAAC2B,IAAP,CAAxB;AACA3B,EAAAA,KAAK,CAACkB,KAAN,GAAcU,WAAW,CAAC5B,KAAK,CAACkB,KAAP,CAAzB;AACD,CALD,CAbe,CAAjB;;AAqBA,SAASE,SAAT,CAAmBS,QAAnB,EAA6B;AAC3B,QAAMtC,IAAI,GAAGsC,QAAQ,CAACtC,IAAtB;;AACA,MACE,CAACa,aAAa,CAACa,GAAd,CAAkB1B,IAAlB,CAAD,IACA,CAACiB,SAAS,CAACS,GAAV,CAAc1B,IAAd,CADD,IAEA,CAACgB,aAAa,CAACU,GAAd,CAAkB1B,IAAlB,CAFD,IAGA,CAACsC,QAAQ,CAACC,GAJZ,EAKE;AACA,WAAOD,QAAP;AACD;;AAED,QAAME,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBxB,YAAlB,CAAhB;AACA,QAAMyB,eAAe,GAAGF,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBxC,uBAAlB,CAAxB;AACAyC,EAAAA,eAAe,CAAC1C,KAAhB,GAAwBqC,QAAQ,CAACC,GAAT,CAAaK,KAAb,CAAmBC,IAA3C;AACAL,EAAAA,OAAO,CAACR,SAAR,GAAoB,CAACM,QAAD,EAAWK,eAAX,EAA4BF,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB3C,aAAlB,CAA5B,CAApB;AACA,SAAOyC,OAAP;AACD;;AAED,SAASH,WAAT,CAAqBC,QAArB,EAA+B;AAC7B,MAAI,CAACtB,aAAa,CAACU,GAAd,CAAkBY,QAAQ,CAACtC,IAA3B,CAAL,EAAuC;AACrC,WAAOsC,QAAP;AACD;;AAED,QAAME,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBpB,cAAlB,CAAhB;AACAkB,EAAAA,OAAO,CAACR,SAAR,GAAoB,CAACM,QAAD,CAApB;AACA,SAAOE,OAAP;AACD;;AAED,SAASM,MAAT,CAAgBC,UAAhB,EAA4BC,IAA5B,EAAkC;AAChC;AACA;AACA;AACAD,EAAAA,UAAU,GAAG,sBAAsBA,UAAtB,GAAmC,GAAhD;AACA,QAAME,cAAc,GAAGrD,OAAO,CAACuB,KAAR,CAAc4B,UAAd,EAA0B;AAACR,IAAAA,GAAG,EAAE;AAAN,GAA1B,EAAuCnB,IAAvC,CAA4C,CAA5C,EAA+CA,IAA/C,CAAoDA,IAA3E;AAEA,QAAM8B,OAAO,GAAG,GAAGC,MAAH,CAAUF,cAAV,CAAhB;;AAEA,SAAOC,OAAO,CAACE,MAAf,EAAuB;AACrB,UAAMC,YAAY,GAAGH,OAAO,CAACI,GAAR,EAArB;AAEA/B,IAAAA,QAAQ,CAACX,OAAT,CAAiB2C,CAAC,IAAI;AACpB,UAAIA,CAAC,CAAClD,SAAF,CAAYgD,YAAZ,CAAJ,EAA+B;AAC7BE,QAAAA,CAAC,CAAC/C,GAAF,CAAM6C,YAAN;AACD;AACF,KAJD;;AAMA,SAAK,IAAIG,GAAT,IAAgBf,MAAM,CAACgB,IAAP,CAAYJ,YAAZ,CAAhB,EAA2C;AACzC,UAAIG,GAAG,KAAK,KAAZ,EAAmB;AACnB,YAAMvD,KAAK,GAAGoD,YAAY,CAACG,GAAD,CAA1B;;AACA,UAAIvD,KAAK,IAAIA,KAAK,YAAYwC,MAA9B,EAAsC;AACpC,YAAIiB,KAAK,CAACC,OAAN,CAAc1D,KAAd,CAAJ,EAA0B;AACxB,eAAK,IAAI2D,CAAT,IAAc3D,KAAd,EAAqB;AACnB,gBAAI2D,CAAJ,EAAO;AACLV,cAAAA,OAAO,CAACxC,IAAR,CAAakD,CAAb;AACD;AACF;AACF,SAND,MAMO;AACLV,UAAAA,OAAO,CAACxC,IAAR,CAAaT,KAAb;AACD;AACF;AACF;AACF,GAjC+B,CAmChC;;;AACAF,EAAAA,aAAa,CAACE,KAAd,GAAsB+C,IAAtB;AACAzB,EAAAA,QAAQ,CAACX,OAAT,CAAiB2C,CAAC,IAAIA,CAAC,CAAC5C,KAAF,EAAtB;AACAZ,EAAAA,aAAa,CAACE,KAAd,GAAsB,IAAtB,CAtCgC,CAuChC;AACA;;AACA,QAAM4D,OAAO,GAAG/D,GAAG,CAACgE,QAAJ,CAAa;AAC3B9D,IAAAA,IAAI,EAAE,SADqB;AAE3BoB,IAAAA,IAAI,EAAE6B,cAFqB;AAG3Bc,IAAAA,UAAU,EAAE;AAHe,GAAb,EAIb;AACDC,IAAAA,MAAM,EAAE;AACNC,MAAAA,UAAU,EAAE;AADN;AADP,GAJa,CAAhB;AASA,SAAOJ,OAAP;AACD;;AAEDK,MAAM,CAACC,OAAP,GAAiB;AAAErB,EAAAA;AAAF,CAAjB","sourcesContent":["'use strict'\n\n// to avoid parsing the esprima code base we require it here\n// TODO: excise this with better internal file filtering\nconst esprima = require('esprima')\nconst ecg = require('escodegen')\nconst fileNameToken = {\n  type: 'Literal',\n  value: null\n}\nconst lineNumberTokenTemplate = {\n  type: 'Literal',\n  value: null\n}\n\nclass Mutator {\n  constructor(appliesTo, mutate) {\n    this.appliesTo = appliesTo\n    this.mutate = mutate\n    this.tokens = []\n  }\n\n  add(token) {\n    this.tokens.push(token)\n  }\n\n  apply() {\n    this.tokens.forEach(this.mutate)\n  }\n}\n\nconst functionTypes = new Set([\n  'ArrowFunctionExpression',\n  'FunctionExpression',\n  'AsyncFunction'\n])\n\nconst equalityCheckOps = new Set([\n  '==',\n  '===',\n  '!=',\n  '!==',\n  'instanceof'\n])\n\nconst variableTypes = new Set([\n  'MemberExpression',\n  'Identifier'\n])\n\nconst callTypes = new Set([\n  'CallExpression',\n  'NewExpression'\n])\n\nconst wrapTemplate = esprima.parse('__NR_wrap()').body[0].expression\nconst unwrapTemplate = esprima.parse('__NR_unwrap()').body[0].expression\n\nconst mutators = [\n  new Mutator(function wrapAssignmentPredicate(token) {\n    return token.type === 'AssignmentExpression' &&\n      token.operator === '=' &&\n      functionTypes.has(token.right.type)\n  }, function injectWrapAssignment(token) {\n    token.right = wrapToken(token.right)\n  }),\n  new Mutator(function wrapArgPredicate(token) {\n    return callTypes.has(token.type)\n  }, function injectWrapArg(token) {\n    token.arguments = token.arguments.map(wrapToken)\n  }),\n  new Mutator(function unwrapPredicate(token) {\n    return token.type === 'BinaryExpression' && equalityCheckOps.has(token.operator)\n  }, function injectUnwrap(token) {\n    token.left = unwrapToken(token.left)\n    token.right = unwrapToken(token.right)\n  })\n]\n\nfunction wrapToken(argToken) {\n  const type = argToken.type\n  if (\n    !functionTypes.has(type) &&\n    !callTypes.has(type) &&\n    !variableTypes.has(type) ||\n    !argToken.loc\n  ) {\n    return argToken\n  }\n\n  const wrapped = Object.assign({}, wrapTemplate)\n  const lineNumberToken = Object.assign({}, lineNumberTokenTemplate)\n  lineNumberToken.value = argToken.loc.start.line\n  wrapped.arguments = [argToken, lineNumberToken, Object.assign({}, fileNameToken)]\n  return wrapped\n}\n\nfunction unwrapToken(argToken) {\n  if (!variableTypes.has(argToken.type)) {\n    return argToken\n  }\n\n  const wrapped = Object.assign({}, unwrapTemplate)\n  wrapped.arguments = [argToken]\n  return wrapped\n}\n\nfunction inject(sourceCode, file) {\n  // wrap the incoming file code to make it more palatable for esprima.\n  // node likewise wraps the contents of the file in a function, so this\n  // replicates the behavior (e.g. allows for global returns)\n  sourceCode = 'function main() {' + sourceCode + '}'\n  const sourceRootBody = esprima.parse(sourceCode, {loc: true}).body[0].body.body\n\n  const toRelax = [].concat(sourceRootBody)\n\n  while (toRelax.length) {\n    const currentToken = toRelax.pop()\n\n    mutators.forEach(m => {\n      if (m.appliesTo(currentToken)) {\n        m.add(currentToken)\n      }\n    })\n\n    for (let key of Object.keys(currentToken)) {\n      if (key === 'loc') continue\n      const value = currentToken[key]\n      if (value && value instanceof Object) {\n        if (Array.isArray(value)) {\n          for (let t of value) {\n            if (t) {\n              toRelax.push(t)\n            }\n          }\n        } else {\n          toRelax.push(value)\n        }\n      }\n    }\n  }\n\n  // TODO: make this less janky\n  fileNameToken.value = file\n  mutators.forEach(m => m.apply())\n  fileNameToken.value = null\n  // create a new base level token that contains all the statements we\n  // want to pass back to node\n  const printed = ecg.generate({\n    type: 'Program',\n    body: sourceRootBody,\n    sourceType: 'script'\n  }, {\n    format: {\n      semicolons: false\n    }\n  })\n  return printed\n}\n\nmodule.exports = { inject }\n"]},"metadata":{},"sourceType":"script"}