{"ast":null,"code":"'use strict';\n\nvar NAMES = require('./metrics/names');\n\nvar logger = require('./logger').child({\n  component: 'sampler'\n});\n\nvar Timer = require('./timer');\n\nvar os = require('os');\n/*\n *\n * CONSTANTS\n *\n */\n\n\nvar MILLIS = 1e3;\nvar MICROS = 1e6;\nvar CPUS = os.cpus().length;\nvar SAMPLE_INTERVAL = 15 * MILLIS;\nvar samplers = [];\n\nfunction Sampler(sampler, interval) {\n  this.id = setInterval(sampler, interval);\n  this.id.unref();\n}\n\nSampler.prototype.stop = function stop() {\n  clearInterval(this.id);\n};\n\nfunction recordQueueTime(agent, timer) {\n  timer.end();\n  agent.metrics.measureMilliseconds(NAMES.EVENTS.WAIT, null, timer.getDurationInMillis());\n}\n\nfunction sampleMemory(agent) {\n  return function memorySampler() {\n    try {\n      var mem = process.memoryUsage();\n      agent.metrics.measureBytes(NAMES.MEMORY.PHYSICAL, mem.rss);\n      agent.metrics.measureBytes(NAMES.MEMORY.USED_HEAP, mem.heapUsed);\n      agent.metrics.measureBytes(NAMES.MEMORY.MAX_HEAP, mem.heapTotal);\n      agent.metrics.measureBytes(NAMES.MEMORY.FREE_HEAP, mem.heapTotal - mem.heapUsed);\n      agent.metrics.measureBytes(NAMES.MEMORY.USED_NONHEAP, mem.rss - mem.heapTotal);\n      logger.trace(mem, 'Recorded memory');\n    } catch (e) {\n      logger.debug('Could not record memory usage', e);\n    }\n  };\n}\n\nfunction checkEvents(agent) {\n  return function eventSampler() {\n    var timer = new Timer();\n    timer.begin();\n    setTimeout(recordQueueTime.bind(null, agent, timer), 0);\n  };\n}\n\nfunction getCpuSample(lastSample) {\n  try {\n    return process.cpuUsage(lastSample);\n  } catch (e) {\n    logger.debug('Could not record cpu usage', e);\n    return null;\n  }\n}\n\nfunction generateCPUMetricRecorder(agent) {\n  var lastSampleTime; // userTime and sysTime are in seconds\n\n  return function recordCPUMetrics(userTime, sysTime) {\n    var elapsedUptime;\n\n    if (!lastSampleTime) {\n      elapsedUptime = process.uptime();\n    } else {\n      elapsedUptime = (Date.now() - lastSampleTime) / MILLIS;\n    }\n\n    var totalCpuTime = CPUS * elapsedUptime;\n    lastSampleTime = Date.now();\n    var userUtil = userTime / totalCpuTime;\n    var sysUtil = sysTime / totalCpuTime;\n    recordValue(agent, NAMES.CPU.USER_TIME, userTime);\n    recordValue(agent, NAMES.CPU.SYSTEM_TIME, sysTime);\n    recordValue(agent, NAMES.CPU.USER_UTILIZATION, userUtil);\n    recordValue(agent, NAMES.CPU.SYSTEM_UTILIZATION, sysUtil);\n  };\n}\n\nfunction sampleCpu(agent) {\n  var lastSample;\n  var recordCPU = generateCPUMetricRecorder(agent);\n  return function cpuSampler() {\n    var cpuSample = getCpuSample(lastSample);\n    lastSample = getCpuSample();\n\n    if (lastSample == null) {\n      return;\n    }\n\n    recordCPU(cpuSample.user / MICROS, cpuSample.system / MICROS);\n  };\n}\n\nfunction sampleCpuNative(agent, nativeMetrics) {\n  var recordCPU = generateCPUMetricRecorder(agent);\n  nativeMetrics.on('usage', function collectResourceUsage(usage) {\n    recordCPU(usage.diff.ru_utime / MILLIS, usage.diff.ru_stime / MILLIS);\n  });\n  return function cpuSampler() {// NOOP?\n  };\n}\n\nfunction sampleLoop(agent, nativeMetrics) {\n  return function loopSampler() {\n    // Convert from microseconds to seconds\n    const loopMetrics = nativeMetrics.getLoopMetrics();\n    divideMetric(loopMetrics.usage, MICROS);\n    recordCompleteMetric(agent, NAMES.LOOP.USAGE, loopMetrics.usage);\n  };\n}\n\nfunction sampleGc(agent, nativeMetrics) {\n  return function gcSampler() {\n    const gcMetrics = nativeMetrics.getGCMetrics();\n    Object.keys(gcMetrics).forEach(function forEachGCType(gcType) {\n      // Convert from milliseconds to seconds.\n      const gc = gcMetrics[gcType];\n      divideMetric(gc.metrics, MILLIS);\n      recordCompleteMetric(agent, NAMES.GC.PAUSE_TIME, gc.metrics);\n\n      if (gc.type) {\n        recordCompleteMetric(agent, NAMES.GC.PREFIX + gc.type, gc.metrics);\n      } else {\n        logger.debug(gc, 'Unknown GC type %j', gc.typeId);\n      }\n    });\n  };\n}\n\nvar sampler = module.exports = {\n  state: 'stopped',\n  sampleMemory: sampleMemory,\n  checkEvents: checkEvents,\n  sampleCpu: sampleCpu,\n  sampleGc: sampleGc,\n  sampleLoop: sampleLoop,\n  nativeMetrics: null,\n  start: function start(agent) {\n    samplers.push(new Sampler(sampleMemory(agent), 5 * MILLIS));\n    samplers.push(new Sampler(checkEvents(agent), SAMPLE_INTERVAL)); // This requires a native module which may have failed to build.\n\n    if (agent.config.plugins.native_metrics.enabled && !this.nativeMetrics) {\n      try {\n        this.nativeMetrics = require('@newrelic/native-metrics')({\n          timeout: SAMPLE_INTERVAL\n        });\n      } catch (err) {\n        logger.info({\n          error: {\n            message: err.message,\n            stack: err.stack\n          }\n        }, 'Not adding native metric sampler.');\n        agent.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.DEPENDENCIES + '/NoNativeMetricsModule').incrementCallCount();\n      }\n    }\n\n    if (this.nativeMetrics) {\n      if (!this.nativeMetrics.bound) {\n        this.nativeMetrics.bind(SAMPLE_INTERVAL);\n      } // Add GC events if available.\n\n\n      if (this.nativeMetrics.gcEnabled) {\n        samplers.push(new Sampler(sampleGc(agent, this.nativeMetrics), SAMPLE_INTERVAL));\n      } // Add loop metrics if available.\n\n\n      if (this.nativeMetrics.loopEnabled) {\n        samplers.push(new Sampler(sampleLoop(agent, this.nativeMetrics), SAMPLE_INTERVAL));\n      }\n    } // Add CPU sampling using the built-in data if available, otherwise pulling\n    // from the native module.\n\n\n    if (process.cpuUsage) {\n      // introduced in 6.1.0\n      samplers.push(new Sampler(sampleCpu(agent), SAMPLE_INTERVAL));\n    } else if (this.nativeMetrics && this.nativeMetrics.usageEnabled) {\n      samplers.push(new Sampler(sampleCpuNative(agent, this.nativeMetrics), SAMPLE_INTERVAL));\n    } else {\n      logger.debug('Not adding CPU metric sampler.');\n    }\n\n    sampler.state = 'running';\n  },\n  stop: function stop() {\n    samplers.forEach(function forEachSampler(s) {\n      s.stop();\n    });\n    samplers = [];\n    sampler.state = 'stopped';\n\n    if (this.nativeMetrics) {\n      this.nativeMetrics.unbind();\n      this.nativeMetrics.removeAllListeners(); // Setting this.nativeMetrics to null allows us to config a new\n      // nativeMetrics object after the first start call.\n\n      this.nativeMetrics = null;\n    }\n  }\n};\n\nfunction recordValue(agent, metric, value) {\n  var stats = agent.metrics.getOrCreateMetric(metric);\n  stats.recordValue(value);\n  logger.trace('Recorded metric %s: %j', metric, value);\n}\n\nfunction recordCompleteMetric(agent, metricName, metric) {\n  var stats = agent.metrics.getOrCreateMetric(metricName);\n  stats.merge(metric);\n  logger.trace('Recorded metric %s: %j', metricName, metric);\n}\n\nfunction divideMetric(metric, divisor) {\n  metric.min /= divisor;\n  metric.max /= divisor;\n  metric.total /= divisor;\n  metric.sumOfSquares /= divisor * divisor;\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/sampler.js"],"names":["NAMES","require","logger","child","component","Timer","os","MILLIS","MICROS","CPUS","cpus","length","SAMPLE_INTERVAL","samplers","Sampler","sampler","interval","id","setInterval","unref","prototype","stop","clearInterval","recordQueueTime","agent","timer","end","metrics","measureMilliseconds","EVENTS","WAIT","getDurationInMillis","sampleMemory","memorySampler","mem","process","memoryUsage","measureBytes","MEMORY","PHYSICAL","rss","USED_HEAP","heapUsed","MAX_HEAP","heapTotal","FREE_HEAP","USED_NONHEAP","trace","e","debug","checkEvents","eventSampler","begin","setTimeout","bind","getCpuSample","lastSample","cpuUsage","generateCPUMetricRecorder","lastSampleTime","recordCPUMetrics","userTime","sysTime","elapsedUptime","uptime","Date","now","totalCpuTime","userUtil","sysUtil","recordValue","CPU","USER_TIME","SYSTEM_TIME","USER_UTILIZATION","SYSTEM_UTILIZATION","sampleCpu","recordCPU","cpuSampler","cpuSample","user","system","sampleCpuNative","nativeMetrics","on","collectResourceUsage","usage","diff","ru_utime","ru_stime","sampleLoop","loopSampler","loopMetrics","getLoopMetrics","divideMetric","recordCompleteMetric","LOOP","USAGE","sampleGc","gcSampler","gcMetrics","getGCMetrics","Object","keys","forEach","forEachGCType","gcType","gc","GC","PAUSE_TIME","type","PREFIX","typeId","module","exports","state","start","push","config","plugins","native_metrics","enabled","timeout","err","info","error","message","stack","getOrCreateMetric","SUPPORTABILITY","DEPENDENCIES","incrementCallCount","bound","gcEnabled","loopEnabled","usageEnabled","forEachSampler","s","unbind","removeAllListeners","metric","value","stats","metricName","merge","divisor","min","max","total","sumOfSquares"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,iBAAD,CAAnB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAP,CAAoBE,KAApB,CAA0B;AAACC,EAAAA,SAAS,EAAE;AAAZ,CAA1B,CAAb;;AACA,IAAIC,KAAK,GAAGJ,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIK,EAAE,GAAGL,OAAO,CAAC,IAAD,CAAhB;AAEA;;;;;;;AAKA,IAAIM,MAAM,GAAG,GAAb;AACA,IAAIC,MAAM,GAAG,GAAb;AACA,IAAIC,IAAI,GAAGH,EAAE,CAACI,IAAH,GAAUC,MAArB;AACA,IAAIC,eAAe,GAAG,KAAKL,MAA3B;AAEA,IAAIM,QAAQ,GAAG,EAAf;;AAEA,SAASC,OAAT,CAAiBC,OAAjB,EAA0BC,QAA1B,EAAoC;AAClC,OAAKC,EAAL,GAAUC,WAAW,CAACH,OAAD,EAAUC,QAAV,CAArB;AACA,OAAKC,EAAL,CAAQE,KAAR;AACD;;AAEDL,OAAO,CAACM,SAAR,CAAkBC,IAAlB,GAAyB,SAASA,IAAT,GAAgB;AACvCC,EAAAA,aAAa,CAAC,KAAKL,EAAN,CAAb;AACD,CAFD;;AAIA,SAASM,eAAT,CAAyBC,KAAzB,EAAgCC,KAAhC,EAAuC;AACrCA,EAAAA,KAAK,CAACC,GAAN;AACAF,EAAAA,KAAK,CAACG,OAAN,CAAcC,mBAAd,CAAkC5B,KAAK,CAAC6B,MAAN,CAAaC,IAA/C,EAAqD,IAArD,EAA2DL,KAAK,CAACM,mBAAN,EAA3D;AACD;;AAED,SAASC,YAAT,CAAsBR,KAAtB,EAA6B;AAC3B,SAAO,SAASS,aAAT,GAAyB;AAC9B,QAAI;AACF,UAAIC,GAAG,GAAGC,OAAO,CAACC,WAAR,EAAV;AACAZ,MAAAA,KAAK,CAACG,OAAN,CAAcU,YAAd,CAA2BrC,KAAK,CAACsC,MAAN,CAAaC,QAAxC,EAAkDL,GAAG,CAACM,GAAtD;AACAhB,MAAAA,KAAK,CAACG,OAAN,CAAcU,YAAd,CAA2BrC,KAAK,CAACsC,MAAN,CAAaG,SAAxC,EAAmDP,GAAG,CAACQ,QAAvD;AACAlB,MAAAA,KAAK,CAACG,OAAN,CAAcU,YAAd,CAA2BrC,KAAK,CAACsC,MAAN,CAAaK,QAAxC,EAAkDT,GAAG,CAACU,SAAtD;AACApB,MAAAA,KAAK,CAACG,OAAN,CAAcU,YAAd,CAA2BrC,KAAK,CAACsC,MAAN,CAAaO,SAAxC,EAAmDX,GAAG,CAACU,SAAJ,GAAgBV,GAAG,CAACQ,QAAvE;AACAlB,MAAAA,KAAK,CAACG,OAAN,CAAcU,YAAd,CAA2BrC,KAAK,CAACsC,MAAN,CAAaQ,YAAxC,EAAsDZ,GAAG,CAACM,GAAJ,GAAUN,GAAG,CAACU,SAApE;AACA1C,MAAAA,MAAM,CAAC6C,KAAP,CAAab,GAAb,EAAkB,iBAAlB;AACD,KARD,CAQE,OAAOc,CAAP,EAAU;AACV9C,MAAAA,MAAM,CAAC+C,KAAP,CAAa,+BAAb,EAA8CD,CAA9C;AACD;AACF,GAZD;AAaD;;AAED,SAASE,WAAT,CAAqB1B,KAArB,EAA4B;AAC1B,SAAO,SAAS2B,YAAT,GAAwB;AAC7B,QAAI1B,KAAK,GAAG,IAAIpB,KAAJ,EAAZ;AACAoB,IAAAA,KAAK,CAAC2B,KAAN;AACAC,IAAAA,UAAU,CAAC9B,eAAe,CAAC+B,IAAhB,CAAqB,IAArB,EAA2B9B,KAA3B,EAAkCC,KAAlC,CAAD,EAA2C,CAA3C,CAAV;AACD,GAJD;AAKD;;AAED,SAAS8B,YAAT,CAAsBC,UAAtB,EAAkC;AAChC,MAAI;AACF,WAAOrB,OAAO,CAACsB,QAAR,CAAiBD,UAAjB,CAAP;AACD,GAFD,CAEE,OAAOR,CAAP,EAAU;AACV9C,IAAAA,MAAM,CAAC+C,KAAP,CAAa,4BAAb,EAA2CD,CAA3C;AACA,WAAO,IAAP;AACD;AACF;;AAED,SAASU,yBAAT,CAAmClC,KAAnC,EAA0C;AACxC,MAAImC,cAAJ,CADwC,CAExC;;AACA,SAAO,SAASC,gBAAT,CAA0BC,QAA1B,EAAoCC,OAApC,EAA6C;AAClD,QAAIC,aAAJ;;AACA,QAAI,CAACJ,cAAL,EAAqB;AACnBI,MAAAA,aAAa,GAAG5B,OAAO,CAAC6B,MAAR,EAAhB;AACD,KAFD,MAEO;AACLD,MAAAA,aAAa,GAAG,CAACE,IAAI,CAACC,GAAL,KAAaP,cAAd,IAAgCpD,MAAhD;AACD;;AAED,QAAI4D,YAAY,GAAG1D,IAAI,GAAGsD,aAA1B;AAEAJ,IAAAA,cAAc,GAAGM,IAAI,CAACC,GAAL,EAAjB;AAEA,QAAIE,QAAQ,GAAGP,QAAQ,GAAGM,YAA1B;AACA,QAAIE,OAAO,GAAIP,OAAO,GAAGK,YAAzB;AAEAG,IAAAA,WAAW,CAAC9C,KAAD,EAAQxB,KAAK,CAACuE,GAAN,CAAUC,SAAlB,EAA6BX,QAA7B,CAAX;AACAS,IAAAA,WAAW,CAAC9C,KAAD,EAAQxB,KAAK,CAACuE,GAAN,CAAUE,WAAlB,EAA+BX,OAA/B,CAAX;AACAQ,IAAAA,WAAW,CAAC9C,KAAD,EAAQxB,KAAK,CAACuE,GAAN,CAAUG,gBAAlB,EAAoCN,QAApC,CAAX;AACAE,IAAAA,WAAW,CAAC9C,KAAD,EAAQxB,KAAK,CAACuE,GAAN,CAAUI,kBAAlB,EAAsCN,OAAtC,CAAX;AACD,GAnBD;AAoBD;;AAED,SAASO,SAAT,CAAmBpD,KAAnB,EAA0B;AACxB,MAAIgC,UAAJ;AACA,MAAIqB,SAAS,GAAGnB,yBAAyB,CAAClC,KAAD,CAAzC;AACA,SAAO,SAASsD,UAAT,GAAsB;AAC3B,QAAIC,SAAS,GAAGxB,YAAY,CAACC,UAAD,CAA5B;AACAA,IAAAA,UAAU,GAAGD,YAAY,EAAzB;;AAEA,QAAIC,UAAU,IAAI,IAAlB,EAAwB;AACtB;AACD;;AAEDqB,IAAAA,SAAS,CAACE,SAAS,CAACC,IAAV,GAAiBxE,MAAlB,EAA0BuE,SAAS,CAACE,MAAV,GAAmBzE,MAA7C,CAAT;AACD,GATD;AAUD;;AAED,SAAS0E,eAAT,CAAyB1D,KAAzB,EAAgC2D,aAAhC,EAA+C;AAC7C,MAAIN,SAAS,GAAGnB,yBAAyB,CAAClC,KAAD,CAAzC;AACA2D,EAAAA,aAAa,CAACC,EAAd,CAAiB,OAAjB,EAA0B,SAASC,oBAAT,CAA8BC,KAA9B,EAAqC;AAC7DT,IAAAA,SAAS,CAACS,KAAK,CAACC,IAAN,CAAWC,QAAX,GAAsBjF,MAAvB,EAA+B+E,KAAK,CAACC,IAAN,CAAWE,QAAX,GAAsBlF,MAArD,CAAT;AACD,GAFD;AAIA,SAAO,SAASuE,UAAT,GAAsB,CAC3B;AACD,GAFD;AAGD;;AAED,SAASY,UAAT,CAAoBlE,KAApB,EAA2B2D,aAA3B,EAA0C;AACxC,SAAO,SAASQ,WAAT,GAAuB;AAC5B;AACA,UAAMC,WAAW,GAAGT,aAAa,CAACU,cAAd,EAApB;AACAC,IAAAA,YAAY,CAACF,WAAW,CAACN,KAAb,EAAoB9E,MAApB,CAAZ;AAEAuF,IAAAA,oBAAoB,CAACvE,KAAD,EAAQxB,KAAK,CAACgG,IAAN,CAAWC,KAAnB,EAA0BL,WAAW,CAACN,KAAtC,CAApB;AACD,GAND;AAOD;;AAED,SAASY,QAAT,CAAkB1E,KAAlB,EAAyB2D,aAAzB,EAAwC;AACtC,SAAO,SAASgB,SAAT,GAAqB;AAC1B,UAAMC,SAAS,GAAGjB,aAAa,CAACkB,YAAd,EAAlB;AAEAC,IAAAA,MAAM,CAACC,IAAP,CAAYH,SAAZ,EAAuBI,OAAvB,CAA+B,SAASC,aAAT,CAAuBC,MAAvB,EAA+B;AAC5D;AACA,YAAMC,EAAE,GAAGP,SAAS,CAACM,MAAD,CAApB;AACAZ,MAAAA,YAAY,CAACa,EAAE,CAAChF,OAAJ,EAAapB,MAAb,CAAZ;AAEAwF,MAAAA,oBAAoB,CAACvE,KAAD,EAAQxB,KAAK,CAAC4G,EAAN,CAASC,UAAjB,EAA6BF,EAAE,CAAChF,OAAhC,CAApB;;AACA,UAAIgF,EAAE,CAACG,IAAP,EAAa;AACXf,QAAAA,oBAAoB,CAACvE,KAAD,EAAQxB,KAAK,CAAC4G,EAAN,CAASG,MAAT,GAAkBJ,EAAE,CAACG,IAA7B,EAAmCH,EAAE,CAAChF,OAAtC,CAApB;AACD,OAFD,MAEO;AACLzB,QAAAA,MAAM,CAAC+C,KAAP,CAAa0D,EAAb,EAAiB,oBAAjB,EAAuCA,EAAE,CAACK,MAA1C;AACD;AACF,KAXD;AAYD,GAfD;AAgBD;;AAED,IAAIjG,OAAO,GAAGkG,MAAM,CAACC,OAAP,GAAiB;AAC7BC,EAAAA,KAAK,EAAE,SADsB;AAE7BnF,EAAAA,YAAY,EAAEA,YAFe;AAG7BkB,EAAAA,WAAW,EAAEA,WAHgB;AAI7B0B,EAAAA,SAAS,EAAEA,SAJkB;AAK7BsB,EAAAA,QAAQ,EAAEA,QALmB;AAM7BR,EAAAA,UAAU,EAAEA,UANiB;AAO7BP,EAAAA,aAAa,EAAE,IAPc;AAS7BiC,EAAAA,KAAK,EAAE,SAASA,KAAT,CAAe5F,KAAf,EAAsB;AAC3BX,IAAAA,QAAQ,CAACwG,IAAT,CAAc,IAAIvG,OAAJ,CAAYkB,YAAY,CAACR,KAAD,CAAxB,EAAiC,IAAIjB,MAArC,CAAd;AACAM,IAAAA,QAAQ,CAACwG,IAAT,CAAc,IAAIvG,OAAJ,CAAYoC,WAAW,CAAC1B,KAAD,CAAvB,EAAgCZ,eAAhC,CAAd,EAF2B,CAI3B;;AACA,QAAIY,KAAK,CAAC8F,MAAN,CAAaC,OAAb,CAAqBC,cAArB,CAAoCC,OAApC,IAA+C,CAAC,KAAKtC,aAAzD,EAAwE;AACtE,UAAI;AACF,aAAKA,aAAL,GAAqBlF,OAAO,CAAC,0BAAD,CAAP,CAAoC;AACvDyH,UAAAA,OAAO,EAAE9G;AAD8C,SAApC,CAArB;AAGD,OAJD,CAIE,OAAO+G,GAAP,EAAY;AACZzH,QAAAA,MAAM,CAAC0H,IAAP,CACE;AAACC,UAAAA,KAAK,EAAE;AAACC,YAAAA,OAAO,EAAEH,GAAG,CAACG,OAAd;AAAuBC,YAAAA,KAAK,EAAEJ,GAAG,CAACI;AAAlC;AAAR,SADF,EAEE,mCAFF;AAIAvG,QAAAA,KAAK,CAACG,OAAN,CAAcqG,iBAAd,CACEhI,KAAK,CAACiI,cAAN,CAAqBC,YAArB,GAAoC,wBADtC,EAEEC,kBAFF;AAGD;AACF;;AAED,QAAI,KAAKhD,aAAT,EAAwB;AACtB,UAAI,CAAC,KAAKA,aAAL,CAAmBiD,KAAxB,EAA+B;AAC7B,aAAKjD,aAAL,CAAmB7B,IAAnB,CAAwB1C,eAAxB;AACD,OAHqB,CAKtB;;;AACA,UAAI,KAAKuE,aAAL,CAAmBkD,SAAvB,EAAkC;AAChCxH,QAAAA,QAAQ,CAACwG,IAAT,CAAc,IAAIvG,OAAJ,CAAYoF,QAAQ,CAAC1E,KAAD,EAAQ,KAAK2D,aAAb,CAApB,EAAiDvE,eAAjD,CAAd;AACD,OARqB,CAUtB;;;AACA,UAAI,KAAKuE,aAAL,CAAmBmD,WAAvB,EAAoC;AAClCzH,QAAAA,QAAQ,CAACwG,IAAT,CAAc,IAAIvG,OAAJ,CAAY4E,UAAU,CAAClE,KAAD,EAAQ,KAAK2D,aAAb,CAAtB,EAAmDvE,eAAnD,CAAd;AACD;AACF,KAnC0B,CAqC3B;AACA;;;AACA,QAAIuB,OAAO,CAACsB,QAAZ,EAAsB;AAAE;AACtB5C,MAAAA,QAAQ,CAACwG,IAAT,CAAc,IAAIvG,OAAJ,CAAY8D,SAAS,CAACpD,KAAD,CAArB,EAA8BZ,eAA9B,CAAd;AACD,KAFD,MAEO,IAAI,KAAKuE,aAAL,IAAsB,KAAKA,aAAL,CAAmBoD,YAA7C,EAA2D;AAChE1H,MAAAA,QAAQ,CAACwG,IAAT,CACE,IAAIvG,OAAJ,CAAYoE,eAAe,CAAC1D,KAAD,EAAQ,KAAK2D,aAAb,CAA3B,EAAwDvE,eAAxD,CADF;AAGD,KAJM,MAIA;AACLV,MAAAA,MAAM,CAAC+C,KAAP,CAAa,gCAAb;AACD;;AAEDlC,IAAAA,OAAO,CAACoG,KAAR,GAAgB,SAAhB;AACD,GA3D4B;AA6D7B9F,EAAAA,IAAI,EAAE,SAASA,IAAT,GAAgB;AACpBR,IAAAA,QAAQ,CAAC2F,OAAT,CAAiB,SAASgC,cAAT,CAAwBC,CAAxB,EAA2B;AAC1CA,MAAAA,CAAC,CAACpH,IAAF;AACD,KAFD;AAGAR,IAAAA,QAAQ,GAAG,EAAX;AACAE,IAAAA,OAAO,CAACoG,KAAR,GAAgB,SAAhB;;AACA,QAAI,KAAKhC,aAAT,EAAwB;AACtB,WAAKA,aAAL,CAAmBuD,MAAnB;AACA,WAAKvD,aAAL,CAAmBwD,kBAAnB,GAFsB,CAItB;AACA;;AACA,WAAKxD,aAAL,GAAqB,IAArB;AACD;AACF;AA3E4B,CAA/B;;AA8EA,SAASb,WAAT,CAAqB9C,KAArB,EAA4BoH,MAA5B,EAAoCC,KAApC,EAA2C;AACzC,MAAIC,KAAK,GAAGtH,KAAK,CAACG,OAAN,CAAcqG,iBAAd,CAAgCY,MAAhC,CAAZ;AACAE,EAAAA,KAAK,CAACxE,WAAN,CAAkBuE,KAAlB;AACA3I,EAAAA,MAAM,CAAC6C,KAAP,CAAa,wBAAb,EAAuC6F,MAAvC,EAA+CC,KAA/C;AACD;;AAED,SAAS9C,oBAAT,CAA8BvE,KAA9B,EAAqCuH,UAArC,EAAiDH,MAAjD,EAAyD;AACvD,MAAIE,KAAK,GAAGtH,KAAK,CAACG,OAAN,CAAcqG,iBAAd,CAAgCe,UAAhC,CAAZ;AACAD,EAAAA,KAAK,CAACE,KAAN,CAAYJ,MAAZ;AACA1I,EAAAA,MAAM,CAAC6C,KAAP,CAAa,wBAAb,EAAuCgG,UAAvC,EAAmDH,MAAnD;AACD;;AAED,SAAS9C,YAAT,CAAsB8C,MAAtB,EAA8BK,OAA9B,EAAuC;AACrCL,EAAAA,MAAM,CAACM,GAAP,IAAcD,OAAd;AACAL,EAAAA,MAAM,CAACO,GAAP,IAAcF,OAAd;AACAL,EAAAA,MAAM,CAACQ,KAAP,IAAgBH,OAAhB;AACAL,EAAAA,MAAM,CAACS,YAAP,IAAwBJ,OAAO,GAAGA,OAAlC;AACD","sourcesContent":["'use strict'\n\nvar NAMES = require('./metrics/names')\nvar logger = require('./logger').child({component: 'sampler'})\nvar Timer = require('./timer')\nvar os = require('os')\n\n/*\n *\n * CONSTANTS\n *\n */\nvar MILLIS = 1e3\nvar MICROS = 1e6\nvar CPUS = os.cpus().length\nvar SAMPLE_INTERVAL = 15 * MILLIS\n\nvar samplers = []\n\nfunction Sampler(sampler, interval) {\n  this.id = setInterval(sampler, interval)\n  this.id.unref()\n}\n\nSampler.prototype.stop = function stop() {\n  clearInterval(this.id)\n}\n\nfunction recordQueueTime(agent, timer) {\n  timer.end()\n  agent.metrics.measureMilliseconds(NAMES.EVENTS.WAIT, null, timer.getDurationInMillis())\n}\n\nfunction sampleMemory(agent) {\n  return function memorySampler() {\n    try {\n      var mem = process.memoryUsage()\n      agent.metrics.measureBytes(NAMES.MEMORY.PHYSICAL, mem.rss)\n      agent.metrics.measureBytes(NAMES.MEMORY.USED_HEAP, mem.heapUsed)\n      agent.metrics.measureBytes(NAMES.MEMORY.MAX_HEAP, mem.heapTotal)\n      agent.metrics.measureBytes(NAMES.MEMORY.FREE_HEAP, mem.heapTotal - mem.heapUsed)\n      agent.metrics.measureBytes(NAMES.MEMORY.USED_NONHEAP, mem.rss - mem.heapTotal)\n      logger.trace(mem, 'Recorded memory')\n    } catch (e) {\n      logger.debug('Could not record memory usage', e)\n    }\n  }\n}\n\nfunction checkEvents(agent) {\n  return function eventSampler() {\n    var timer = new Timer()\n    timer.begin()\n    setTimeout(recordQueueTime.bind(null, agent, timer), 0)\n  }\n}\n\nfunction getCpuSample(lastSample) {\n  try {\n    return process.cpuUsage(lastSample)\n  } catch (e) {\n    logger.debug('Could not record cpu usage', e)\n    return null\n  }\n}\n\nfunction generateCPUMetricRecorder(agent) {\n  var lastSampleTime\n  // userTime and sysTime are in seconds\n  return function recordCPUMetrics(userTime, sysTime) {\n    var elapsedUptime\n    if (!lastSampleTime) {\n      elapsedUptime = process.uptime()\n    } else {\n      elapsedUptime = (Date.now() - lastSampleTime) / MILLIS\n    }\n\n    var totalCpuTime = CPUS * elapsedUptime\n\n    lastSampleTime = Date.now()\n\n    var userUtil = userTime / totalCpuTime\n    var sysUtil  = sysTime / totalCpuTime\n\n    recordValue(agent, NAMES.CPU.USER_TIME, userTime)\n    recordValue(agent, NAMES.CPU.SYSTEM_TIME, sysTime)\n    recordValue(agent, NAMES.CPU.USER_UTILIZATION, userUtil)\n    recordValue(agent, NAMES.CPU.SYSTEM_UTILIZATION, sysUtil)\n  }\n}\n\nfunction sampleCpu(agent) {\n  var lastSample\n  var recordCPU = generateCPUMetricRecorder(agent)\n  return function cpuSampler() {\n    var cpuSample = getCpuSample(lastSample)\n    lastSample = getCpuSample()\n\n    if (lastSample == null) {\n      return\n    }\n\n    recordCPU(cpuSample.user / MICROS, cpuSample.system / MICROS)\n  }\n}\n\nfunction sampleCpuNative(agent, nativeMetrics) {\n  var recordCPU = generateCPUMetricRecorder(agent)\n  nativeMetrics.on('usage', function collectResourceUsage(usage) {\n    recordCPU(usage.diff.ru_utime / MILLIS, usage.diff.ru_stime / MILLIS)\n  })\n\n  return function cpuSampler() {\n    // NOOP?\n  }\n}\n\nfunction sampleLoop(agent, nativeMetrics) {\n  return function loopSampler() {\n    // Convert from microseconds to seconds\n    const loopMetrics = nativeMetrics.getLoopMetrics()\n    divideMetric(loopMetrics.usage, MICROS)\n\n    recordCompleteMetric(agent, NAMES.LOOP.USAGE, loopMetrics.usage)\n  }\n}\n\nfunction sampleGc(agent, nativeMetrics) {\n  return function gcSampler() {\n    const gcMetrics = nativeMetrics.getGCMetrics()\n\n    Object.keys(gcMetrics).forEach(function forEachGCType(gcType) {\n      // Convert from milliseconds to seconds.\n      const gc = gcMetrics[gcType]\n      divideMetric(gc.metrics, MILLIS)\n\n      recordCompleteMetric(agent, NAMES.GC.PAUSE_TIME, gc.metrics)\n      if (gc.type) {\n        recordCompleteMetric(agent, NAMES.GC.PREFIX + gc.type, gc.metrics)\n      } else {\n        logger.debug(gc, 'Unknown GC type %j', gc.typeId)\n      }\n    })\n  }\n}\n\nvar sampler = module.exports = {\n  state: 'stopped',\n  sampleMemory: sampleMemory,\n  checkEvents: checkEvents,\n  sampleCpu: sampleCpu,\n  sampleGc: sampleGc,\n  sampleLoop: sampleLoop,\n  nativeMetrics: null,\n\n  start: function start(agent) {\n    samplers.push(new Sampler(sampleMemory(agent), 5 * MILLIS))\n    samplers.push(new Sampler(checkEvents(agent), SAMPLE_INTERVAL))\n\n    // This requires a native module which may have failed to build.\n    if (agent.config.plugins.native_metrics.enabled && !this.nativeMetrics) {\n      try {\n        this.nativeMetrics = require('@newrelic/native-metrics')({\n          timeout: SAMPLE_INTERVAL\n        })\n      } catch (err) {\n        logger.info(\n          {error: {message: err.message, stack: err.stack}},\n          'Not adding native metric sampler.'\n        )\n        agent.metrics.getOrCreateMetric(\n          NAMES.SUPPORTABILITY.DEPENDENCIES + '/NoNativeMetricsModule'\n        ).incrementCallCount()\n      }\n    }\n\n    if (this.nativeMetrics) {\n      if (!this.nativeMetrics.bound) {\n        this.nativeMetrics.bind(SAMPLE_INTERVAL)\n      }\n\n      // Add GC events if available.\n      if (this.nativeMetrics.gcEnabled) {\n        samplers.push(new Sampler(sampleGc(agent, this.nativeMetrics), SAMPLE_INTERVAL))\n      }\n\n      // Add loop metrics if available.\n      if (this.nativeMetrics.loopEnabled) {\n        samplers.push(new Sampler(sampleLoop(agent, this.nativeMetrics), SAMPLE_INTERVAL))\n      }\n    }\n\n    // Add CPU sampling using the built-in data if available, otherwise pulling\n    // from the native module.\n    if (process.cpuUsage) { // introduced in 6.1.0\n      samplers.push(new Sampler(sampleCpu(agent), SAMPLE_INTERVAL))\n    } else if (this.nativeMetrics && this.nativeMetrics.usageEnabled) {\n      samplers.push(\n        new Sampler(sampleCpuNative(agent, this.nativeMetrics), SAMPLE_INTERVAL)\n      )\n    } else {\n      logger.debug('Not adding CPU metric sampler.')\n    }\n\n    sampler.state = 'running'\n  },\n\n  stop: function stop() {\n    samplers.forEach(function forEachSampler(s) {\n      s.stop()\n    })\n    samplers = []\n    sampler.state = 'stopped'\n    if (this.nativeMetrics) {\n      this.nativeMetrics.unbind()\n      this.nativeMetrics.removeAllListeners()\n\n      // Setting this.nativeMetrics to null allows us to config a new\n      // nativeMetrics object after the first start call.\n      this.nativeMetrics = null\n    }\n  }\n}\n\nfunction recordValue(agent, metric, value) {\n  var stats = agent.metrics.getOrCreateMetric(metric)\n  stats.recordValue(value)\n  logger.trace('Recorded metric %s: %j', metric, value)\n}\n\nfunction recordCompleteMetric(agent, metricName, metric) {\n  var stats = agent.metrics.getOrCreateMetric(metricName)\n  stats.merge(metric)\n  logger.trace('Recorded metric %s: %j', metricName, metric)\n}\n\nfunction divideMetric(metric, divisor) {\n  metric.min /= divisor\n  metric.max /= divisor\n  metric.total /= divisor\n  metric.sumOfSquares /= (divisor * divisor)\n}\n"]},"metadata":{},"sourceType":"script"}