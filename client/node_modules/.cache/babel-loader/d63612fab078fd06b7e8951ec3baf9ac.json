{"ast":null,"code":"'use strict';\n\nvar path = require('path');\n\nvar fs = require('./util/unwrapped-core').fs;\n\nvar logger = require('./logger').child({\n  component: 'shimmer'\n});\n\nvar INSTRUMENTATIONS = require('./instrumentations')();\n\nvar properties = require('./util/properties');\n\nvar shims = require('./shim');\n\nconst _require = require('./injector'),\n      inject = _require.inject;\n\nvar MODULE_TYPE = shims.constants.MODULE_TYPE;\nvar CORE_INSTRUMENTATION = {\n  child_process: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'child_process.js'\n  },\n  crypto: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'crypto.js'\n  },\n  // domain: {                     // XXX Do not include domains in this list! The\n  //   type: MODULE_TYPE.GENERIC,  // core instrumentations are run at startup by\n  //   file: 'domain.js'           // requiring each of their modules. Loading\n  // },                            // `domain` has side effects that we try to avoid.\n  dns: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'dns.js'\n  },\n  fs: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'fs.js'\n  },\n  http: {\n    type: MODULE_TYPE.TRANSACTION,\n    file: 'http.js'\n  },\n  https: {\n    type: MODULE_TYPE.TRANSACTION,\n    file: 'http.js'\n  },\n  inspector: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'inspector.js'\n  },\n  net: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'net.js'\n  },\n  timers: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'timers.js'\n  },\n  zlib: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'zlib.js'\n  }\n};\nconst FORCE_MODULE_RESOLUTION_WARNING = 'Unable to retrieve cached path for one or more modules ' + 'with an already loaded parent. Forcing resolution. ' + 'This should not occur during normal agent execution. ' + 'Module resolution performance my be impacted. ' + 'See trace-level logs for specific modules.';\n/**\n * Unwrapping is only likely to be used by test code, and is a fairly drastic\n * maneuver, but it should be pretty safe if there's a desire to reboot the\n * agent in flight.\n *\n * All of the wrapped methods are tracked in this variable and used by unwrapAll\n * below.\n */\n\nvar instrumented = [];\n\nfunction applyDebugState(shimmer, shim, nodule) {\n  if (shimmer.debug) {\n    shim.enableDebug();\n    instrumented.push(shim);\n    instrumented.push({\n      __NR_unwrap: function unwrapNodule() {\n        delete nodule.__NR_instrumented;\n        delete nodule.__NR_shim;\n      }\n    });\n    nodule.__NR_shim = shim;\n  }\n}\n/**\n * All instrumentation files must export the same interface: a single\n * initialization function that takes the agent and the module to be\n * instrumented.\n */\n\n\nfunction instrument(agent, nodule, moduleName, resolvedName) {\n  var instrumentation = shimmer.registeredInstrumentations[moduleName];\n\n  if (properties.hasOwn(nodule, '__NR_instrumented')) {\n    logger.trace('Already instrumented %s, skipping redundant instrumentation', moduleName);\n    return nodule;\n  }\n\n  var shim = shims.createShimFromType(instrumentation.type, agent, moduleName, resolvedName);\n  applyDebugState(shimmer, shim, nodule);\n\n  try {\n    if (instrumentation.onRequire(shim, nodule, moduleName) !== false) {\n      nodule = shim.getExport(nodule);\n      nodule.__NR_instrumented = true;\n    }\n  } catch (instrumentationError) {\n    if (instrumentation.onError) {\n      try {\n        instrumentation.onError(instrumentationError);\n      } catch (e) {\n        logger.warn(e, instrumentationError, 'Custom instrumentation for %s failed, then the onError handler threw an error', moduleName);\n      }\n    } else {\n      logger.warn(instrumentationError, 'Custom instrumentation for %s failed. Please report this to the ' + 'maintainers of the custom instrumentation.', moduleName);\n    }\n  }\n\n  return nodule;\n}\n\nfunction _firstPartyInstrumentation(agent, fileName, shim, nodule, moduleName) {\n  var fullPath = path.resolve(fileName);\n\n  if (!fs.existsSync(fileName)) {\n    return logger.warn('Tried to load instrumentation from %s, but file does not exist', fullPath);\n  }\n\n  try {\n    return require(fileName)(agent, nodule, moduleName, shim);\n  } catch (error) {\n    logger.warn(error, 'Failed to instrument module %s using %s', path.basename(fileName, '.js'), fullPath);\n  }\n}\n\nfunction _postLoad(agent, nodule, name, resolvedName) {\n  var instrumentation;\n  instrumentation = shimmer.getInstrumentationNameFromModuleName(name); // Check if this is a known instrumentation and then run it.\n\n  if (shimmer.registeredInstrumentations[instrumentation]) {\n    logger.trace('Instrumenting %s.', name);\n    return instrument(agent, nodule, instrumentation, resolvedName);\n  }\n\n  return nodule;\n}\n\nvar shimmer = module.exports = {\n  /**\n   * If debug isn't false, the agent will retain references to wrapped methods\n   * for the entire lifetime of the agent. Some instrumentation depends on\n   * wrapping functions on individual objects, and this will cause the agent\n   * to retain references to a large number of dead objects.\n   */\n  debug: false,\n\n  /**\n   * Detects if the given function has already been wrapped.\n   *\n   * @param {function} fn - The function to look for a wrapper on.\n   *\n   * @return {bool} True if `fn` exists and has an attached original, else false.\n   */\n  isWrapped: function isWrapped(fn) {\n    return !!(fn && fn.__NR_original);\n  },\n\n  /**\n   * Don't throw, but do log and bail out if wrapping fails.\n   *\n   * Provide an escape hatch by creating a closure around the original method\n   * and object / module wrapped into a helper function that will restore the\n   * original function / method. See Sinon for a systematic use of this\n   * pattern.\n   *\n   * @param {object} nodule Class or module containing the function to wrap.\n   * @param {object} noduleName Human-readable module / Class name. More\n   *                            helpful than you'd think.\n   * @param {string} methods One or more names of methods or functions to extract\n   *                         and wrap.\n   * @param {function} wrapper A generator that, when called, returns a\n   *                           wrapped version of the original function.\n   */\n  wrapMethod: function wrapMethod(nodule, noduleName, methods, wrapper) {\n    if (!methods) {\n      return logger.warn(new Error(), \"Must include a method name to wrap. Called from:\");\n    }\n\n    if (!noduleName) noduleName = '[unknown]';\n    if (!Array.isArray(methods)) methods = [methods];\n    methods.forEach(function cb_forEach(method) {\n      var fqmn = noduleName + '.' + method;\n\n      if (!nodule) {\n        return logger.debug(\"Can't wrap %s from nonexistent object.\", fqmn);\n      }\n\n      if (!wrapper) {\n        return logger.debug(\"Can't wrap %s without a wrapper generator.\", fqmn);\n      }\n\n      var original = nodule[method];\n      if (!original) return logger.trace(\"%s not defined, so not wrapping.\", fqmn);\n      if (original.__NR_unwrap) return logger.debug(\"%s already wrapped by agent.\", fqmn);\n      var wrapped = wrapper(original, method);\n      Object.keys(original).forEach(key => {\n        wrapped[key] = original[key];\n      });\n      wrapped.__NR_original = original;\n\n      wrapped.__NR_unwrap = function __NR_unwrap() {\n        nodule[method] = original;\n        logger.trace(\"Removed instrumentation from %s.\", fqmn);\n      };\n\n      nodule[method] = wrapped;\n      if (shimmer.debug) instrumented.push(wrapped);\n      logger.trace(\"Instrumented %s.\", fqmn);\n    });\n  },\n\n  /**\n   * Sometimes you gotta do some crazy stuff to get the job done. Instead of using\n   * regular monkeypatching, wrapDeprecated allows you to pass in a getter and setter\n   * and then uses defineProperty to replace the original property with an\n   * accessor. Note that responsibility for unwrapping is not handled by this\n   * function.\n   *\n   * @param {object}   nodule     Class or module containing the property to\n   *                              wrap.\n   * @param {object}   noduleName Human-readable module / Class name. More\n   *                              helpful than you'd think.\n   * @param {string}   property   The property to replace with the accessor.\n   * @param {function} options    Optional getter and setter to use for the accessor.\n   *\n   * @returns {object} The original value of the property.\n   */\n  wrapDeprecated: function wrapDeprecated(nodule, noduleName, property, options) {\n    if (!property) {\n      logger.warn(new Error(), \"Must include a function name to wrap. Called from:\");\n      return;\n    }\n\n    if (!noduleName) noduleName = '[unknown]';\n    var fqmn = noduleName + '.' + property;\n\n    if (!nodule) {\n      logger.debug(\"Can't wrap %s from nonexistent object.\", fqmn);\n      return;\n    }\n\n    var original = nodule[property];\n\n    if (!original) {\n      logger.trace(\"%s not defined, so not wrapping.\", fqmn);\n      return;\n    }\n\n    delete nodule[property];\n    var descriptor = {\n      configurable: true,\n      enumerable: true\n    };\n    if (options.get) descriptor.get = options.get;\n    if (options.set) descriptor.set = options.set;\n    Object.defineProperty(nodule, property, descriptor);\n    logger.trace(\"Instrumented %s.\", fqmn);\n\n    if (shimmer.debug) {\n      instrumented.push({\n        __NR_unwrap: function unwrapDeprecated() {\n          delete nodule[property];\n          nodule[property] = original;\n        }\n      });\n    }\n\n    return original;\n  },\n  unwrapMethod: function unwrapMethod(nodule, noduleName, method) {\n    if (!noduleName) noduleName = '[unknown]';\n    if (!method) return logger.debug(\"Must include a method name to unwrap. \" + \"Called from: %s\", new Error().stack);\n    var fqmn = noduleName + '.' + method;\n\n    if (!nodule) {\n      return logger.debug(\"Can't unwrap %s from nonexistent object.\", fqmn);\n    }\n\n    var wrapped = nodule[method]; // keep instrumented up to date\n\n    var pos = instrumented.indexOf(wrapped);\n    if (pos !== -1) instrumented.splice(pos, 1);\n    if (!wrapped) return logger.debug(\"%s not defined, so not unwrapping.\", fqmn);\n    if (!wrapped.__NR_unwrap) return logger.debug(\"%s isn't unwrappable.\", fqmn);\n\n    wrapped.__NR_unwrap();\n  },\n  unwrapAll: function unwrapAll() {\n    instrumented.forEach(function cb_forEach(wrapper) {\n      wrapper.__NR_unwrap();\n    });\n    instrumented = [];\n  },\n\n  /**\n   * Patch the module.load function so that we see modules loading and\n   * have an opportunity to patch them with instrumentation.\n   */\n  patchModule: function patchModule(agent) {\n    logger.trace(\"Wrapping module loader.\");\n\n    var Module = require('module');\n\n    var filepathMap = {}; // TODO: how do we unpatch this?\n\n    const diagConf = agent.config.diagnostics.code_injector;\n\n    if (diagConf.enabled) {\n      // XXX: this is required to handle unwrapping event listener removal\n      const EEProto = require('events').EventEmitter.prototype;\n\n      shimmer.wrapMethod(EEProto, 'EventEmitter.prototype', ['addListener', 'on', 'once', 'off', 'prependListener', 'prependOnceListener'], function wrapAddListener(addListener) {\n        return function wrappedAddListener(ev, listener) {\n          return addListener.call(this, ev, __NR_unwrap(listener));\n        };\n      });\n      shimmer.wrapMethod(EEProto, 'EventEmitter.prototype', 'removeListener', function wrapRemoveListener(removeListener) {\n        return function wrappedRemoveListener(ev, listener) {\n          return removeListener.call(this, ev, __NR_unwrap(listener));\n        };\n      });\n      const internalCodePattern = diagConf.internal_file_pattern;\n      const proto = Module.prototype;\n      shimmer.wrapMethod(proto, 'Module.prototype', '_compile', function wrapCompile(_compile) {\n        return function wrappedCompile(code, file) {\n          let injected;\n\n          try {\n            injected = internalCodePattern.test(file) ? code : inject(code, file);\n            return _compile.call(this, injected, file);\n          } catch (e) {\n            logger.debug('Unable to parse file:', file, e);\n            return _compile.call(this, code, file);\n          }\n        };\n      }); // TODO: use shimmer methods\n\n      global.tracer = agent.tracer;\n      global.__NR_wrap = __NR_wrap;\n\n      function __NR_wrap(f, lineNum, fileName) {\n        const scheduledSegment = agent.tracer.getSegment();\n\n        if (typeof f !== 'function' || !scheduledSegment || !scheduledSegment.transaction.isActive()) {\n          return f;\n        }\n\n        const scheduledTransaction = scheduledSegment.transaction;\n        return new Proxy(f, {\n          get: function getTrap(target, prop) {\n            // Allow for look up of the target\n            if (prop === '__NR_new_original') {\n              return target;\n            }\n\n            return target[prop];\n          },\n          construct: function constructTrap(Target, proxyArgs) {\n            const currentSegment = agent.tracer.getSegment();\n\n            if (scheduledTransaction.isActive() && (!currentSegment || currentSegment.transaction.id !== scheduledTransaction.id)) {\n              logger.info(`lost state in ${fileName} (line ${lineNum});`, `expected to be in transaction ${scheduledTransaction.id},`, `instead landed in ${currentSegment && currentSegment.transaction.id}`);\n            }\n\n            return new Target(...proxyArgs);\n          },\n          apply: function wrappedApply(target, thisArg, args) {\n            const currentSegment = agent.tracer.getSegment();\n\n            if (scheduledTransaction.isActive() && (!currentSegment || currentSegment.transaction.id !== scheduledTransaction.id)) {\n              logger.info(`lost state in ${fileName} (line ${lineNum});`, `expected to be in transaction ${scheduledTransaction.id},`, `instead landed in ${currentSegment && currentSegment.transaction.id}`);\n            }\n\n            return target.apply(thisArg, args);\n          }\n        });\n      }\n\n      global.__NR_unwrap = __NR_unwrap;\n\n      function __NR_unwrap(f) {\n        if (typeof f !== 'function' || !f || !f.__NR_new_original) {\n          return f;\n        }\n\n        return f.__NR_new_original;\n      }\n    }\n\n    shimmer.wrapMethod(Module, 'Module', '_resolveFilename', function wrapRes(resolve) {\n      return function wrappedResolveFilename(file) {\n        // This is triggered by the load call, so record the path that has been seen so\n        // we can examine it after the load call has returned.\n        const resolvedFilepath = resolve.apply(this, arguments);\n        filepathMap[file] = resolvedFilepath;\n        return resolvedFilepath;\n      };\n    });\n    shimmer.wrapMethod(Module, 'Module', '_load', function wrapLoad(load) {\n      return function wrappedLoad(request, parent, isMain) {\n        // _load() will invoke _resolveFilename() first time resolving a module.\n        const m = load.apply(this, arguments);\n        const fileName = resolveFileName(request, parent, isMain);\n        return _postLoad(agent, m, request, fileName);\n      };\n    });\n    /**\n     * Forces file name resolve for modules not in our cache when\n     * their parent has already been loaded/cached by Node.\n     * Provides a fall-back for unexpected cases that may occur.\n     * Also provides flexibilty for testing now that node 11+ caches these.\n     * @param {*} request\n     * @param {*} parent\n     * @param {*} isMain\n     */\n\n    function resolveFileName(request, parent, isMain) {\n      const cachedPath = filepathMap[request];\n\n      if (!cachedPath && parent && parent.loaded) {\n        logger.warnOnce('Force Resolution', FORCE_MODULE_RESOLUTION_WARNING);\n\n        if (logger.traceEnabled()) {\n          logger.trace(`No cached path found for ${request}. Forcing resolution.`);\n        } // Our patched _resolveFilename will cache. No need to here.\n\n\n        return Module._resolveFilename(request, parent, isMain);\n      }\n\n      return cachedPath;\n    }\n  },\n  unpatchModule: function unpatchModule() {\n    logger.trace(\"Unwrapping to previous module loader.\");\n\n    var Module = require('module');\n\n    shimmer.unwrapMethod(Module, 'Module', '_resolveFilename');\n    shimmer.unwrapMethod(Module, 'Module', '_load');\n  },\n  bootstrapInstrumentation: function bootstrapInstrumentation(agent) {\n    // Instrument global.\n    const globalShim = new shims.Shim(agent, 'globals', 'globals');\n    applyDebugState(shimmer, globalShim, global);\n    var globalsFilepath = path.join(__dirname, 'instrumentation', 'core', 'globals.js');\n\n    _firstPartyInstrumentation(agent, globalsFilepath, globalShim, global, 'globals'); // Instrument each of the core modules.\n\n\n    Object.keys(CORE_INSTRUMENTATION).forEach(function forEachCore(mojule) {\n      const core = CORE_INSTRUMENTATION[mojule];\n      const filePath = path.join(__dirname, 'instrumentation', 'core', core.file);\n      let uninstrumented = null;\n\n      try {\n        uninstrumented = require(mojule);\n      } catch (err) {\n        logger.trace('Could not load core module %s got error %s', mojule, err);\n      }\n\n      const shim = shims.createShimFromType(core.type, agent, mojule, mojule);\n      applyDebugState(shimmer, shim, core);\n\n      _firstPartyInstrumentation(agent, filePath, shim, uninstrumented, mojule);\n    }); // Register all the first-party instrumentations.\n\n    Object.keys(INSTRUMENTATIONS).forEach(function forEachInstrumentation(moduleName) {\n      var instrInfo = INSTRUMENTATIONS[moduleName];\n\n      if (instrInfo.module) {\n        // Because external instrumentations can change independent of\n        // the agent core, we don't want breakages in them to entirely\n        // disable the agent.\n        try {\n          var hooks = require(instrInfo.module + '/nr-hooks');\n\n          hooks.forEach(shimmer.registerInstrumentation);\n        } catch (e) {\n          logger.warn('Failed to load instrumentation for ' + instrInfo.module, e);\n          return;\n        }\n      } else if (moduleName === 'amqplib') {\n        // TODO: Remove this code when amqplib instrumentation is made external.\n        require('./instrumentation/amqplib').selfRegister(shimmer);\n      } else {\n        var fileName = path.join(__dirname, 'instrumentation', moduleName + '.js');\n        shimmer.registerInstrumentation({\n          moduleName: moduleName,\n          type: instrInfo.type,\n          onRequire: _firstPartyInstrumentation.bind(null, agent, fileName)\n        });\n      }\n    }); // Even though domain is a core module we add it as a registered\n    // instrumentation to be lazy-loaded because we do not want to cause domain\n    // usage.\n\n    var domainPath = path.join(__dirname, 'instrumentation/core/domain.js');\n    shimmer.registerInstrumentation({\n      moduleName: 'domain',\n      type: null,\n      onRequire: _firstPartyInstrumentation.bind(null, agent, domainPath)\n    });\n  },\n  registerInstrumentation: function registerInstrumentation(opts) {\n    shimmer.registeredInstrumentations[opts.moduleName] = opts;\n  },\n  registeredInstrumentations: Object.create(null),\n\n  /**\n   * NOT FOR USE IN PRODUCTION CODE\n   *\n   * If an instrumented module has a dependency on another instrumented module,\n   * and multiple tests are being run in a single test suite with their own\n   * setup and teardown between tests, it's possible transitive dependencies\n   * will be unwrapped in the module cache in-place (which needs to happen to\n   * prevent stale closures from channeling instrumentation data to incorrect\n   * agents, but which means the transitive dependencies won't get re-wrapped\n   * the next time the parent module is required).\n   *\n   * Since this only applies in test code, it's not worth the drastic\n   * monkeypatching to Module necessary to walk the list of child modules and\n   * re-wrap them.\n   *\n   * Use this to re-apply any applicable instrumentation.\n   */\n  reinstrument: function reinstrument(agent, modulePath) {\n    return _postLoad(agent, require(modulePath), modulePath);\n  },\n\n  /**\n   * Given a NodeJS module name, return the name/identifier of our\n   * instrumentation.  These two things are usually, but not always,\n   * the same.\n   */\n  getInstrumentationNameFromModuleName(moduleName) {\n    var instrumentation; // XXX When updating these special cases, also update `uninstrumented`.\n    // To allow for instrumenting both 'pg' and 'pg.js'.\n\n    if (moduleName === 'pg.js') {\n      instrumentation = 'pg';\n    }\n\n    if (moduleName === 'mysql2') {\n      // mysql2 (https://github.com/sidorares/node-mysql2) is a drop in replacement for\n      // mysql which conforms to the existing mysql API. If we see mysql2, treat it as\n      // mysql\n      instrumentation = 'mysql';\n    } else {\n      instrumentation = moduleName;\n    }\n\n    return instrumentation;\n  }\n\n};","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/shimmer.js"],"names":["path","require","fs","logger","child","component","INSTRUMENTATIONS","properties","shims","inject","MODULE_TYPE","constants","CORE_INSTRUMENTATION","child_process","type","GENERIC","file","crypto","dns","http","TRANSACTION","https","inspector","net","timers","zlib","FORCE_MODULE_RESOLUTION_WARNING","instrumented","applyDebugState","shimmer","shim","nodule","debug","enableDebug","push","__NR_unwrap","unwrapNodule","__NR_instrumented","__NR_shim","instrument","agent","moduleName","resolvedName","instrumentation","registeredInstrumentations","hasOwn","trace","createShimFromType","onRequire","getExport","instrumentationError","onError","e","warn","_firstPartyInstrumentation","fileName","fullPath","resolve","existsSync","error","basename","_postLoad","name","getInstrumentationNameFromModuleName","module","exports","isWrapped","fn","__NR_original","wrapMethod","noduleName","methods","wrapper","Error","Array","isArray","forEach","cb_forEach","method","fqmn","original","wrapped","Object","keys","key","wrapDeprecated","property","options","descriptor","configurable","enumerable","get","set","defineProperty","unwrapDeprecated","unwrapMethod","stack","pos","indexOf","splice","unwrapAll","patchModule","Module","filepathMap","diagConf","config","diagnostics","code_injector","enabled","EEProto","EventEmitter","prototype","wrapAddListener","addListener","wrappedAddListener","ev","listener","call","wrapRemoveListener","removeListener","wrappedRemoveListener","internalCodePattern","internal_file_pattern","proto","wrapCompile","_compile","wrappedCompile","code","injected","test","global","tracer","__NR_wrap","f","lineNum","scheduledSegment","getSegment","transaction","isActive","scheduledTransaction","Proxy","getTrap","target","prop","construct","constructTrap","Target","proxyArgs","currentSegment","id","info","apply","wrappedApply","thisArg","args","__NR_new_original","wrapRes","wrappedResolveFilename","resolvedFilepath","arguments","wrapLoad","load","wrappedLoad","request","parent","isMain","m","resolveFileName","cachedPath","loaded","warnOnce","traceEnabled","_resolveFilename","unpatchModule","bootstrapInstrumentation","globalShim","Shim","globalsFilepath","join","__dirname","forEachCore","mojule","core","filePath","uninstrumented","err","forEachInstrumentation","instrInfo","hooks","registerInstrumentation","selfRegister","bind","domainPath","opts","create","reinstrument","modulePath"],"mappings":"AAAA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIC,EAAE,GAAGD,OAAO,CAAC,uBAAD,CAAP,CAAiCC,EAA1C;;AACA,IAAIC,MAAM,GAAGF,OAAO,CAAC,UAAD,CAAP,CAAoBG,KAApB,CAA0B;AAACC,EAAAA,SAAS,EAAE;AAAZ,CAA1B,CAAb;;AACA,IAAIC,gBAAgB,GAAGL,OAAO,CAAC,oBAAD,CAAP,EAAvB;;AACA,IAAIM,UAAU,GAAGN,OAAO,CAAC,mBAAD,CAAxB;;AACA,IAAIO,KAAK,GAAGP,OAAO,CAAC,QAAD,CAAnB;;iBACmBA,OAAO,CAAC,YAAD,C;MAAlBQ,M,YAAAA,M;;AAER,IAAIC,WAAW,GAAGF,KAAK,CAACG,SAAN,CAAgBD,WAAlC;AAEA,IAAIE,oBAAoB,GAAG;AACzBC,EAAAA,aAAa,EAAE;AACbC,IAAAA,IAAI,EAAEJ,WAAW,CAACK,OADL;AAEbC,IAAAA,IAAI,EAAE;AAFO,GADU;AAKzBC,EAAAA,MAAM,EAAE;AACNH,IAAAA,IAAI,EAAEJ,WAAW,CAACK,OADZ;AAENC,IAAAA,IAAI,EAAE;AAFA,GALiB;AASzB;AACA;AACA;AACA;AACAE,EAAAA,GAAG,EAAE;AACHJ,IAAAA,IAAI,EAAEJ,WAAW,CAACK,OADf;AAEHC,IAAAA,IAAI,EAAE;AAFH,GAboB;AAiBzBd,EAAAA,EAAE,EAAE;AACFY,IAAAA,IAAI,EAAEJ,WAAW,CAACK,OADhB;AAEFC,IAAAA,IAAI,EAAE;AAFJ,GAjBqB;AAqBzBG,EAAAA,IAAI,EAAE;AACJL,IAAAA,IAAI,EAAEJ,WAAW,CAACU,WADd;AAEJJ,IAAAA,IAAI,EAAE;AAFF,GArBmB;AAyBzBK,EAAAA,KAAK,EAAE;AACLP,IAAAA,IAAI,EAAEJ,WAAW,CAACU,WADb;AAELJ,IAAAA,IAAI,EAAE;AAFD,GAzBkB;AA6BzBM,EAAAA,SAAS,EAAE;AACTR,IAAAA,IAAI,EAAEJ,WAAW,CAACK,OADT;AAETC,IAAAA,IAAI,EAAE;AAFG,GA7Bc;AAiCzBO,EAAAA,GAAG,EAAE;AACHT,IAAAA,IAAI,EAAEJ,WAAW,CAACK,OADf;AAEHC,IAAAA,IAAI,EAAE;AAFH,GAjCoB;AAqCzBQ,EAAAA,MAAM,EAAE;AACNV,IAAAA,IAAI,EAAEJ,WAAW,CAACK,OADZ;AAENC,IAAAA,IAAI,EAAE;AAFA,GArCiB;AAyCzBS,EAAAA,IAAI,EAAE;AACJX,IAAAA,IAAI,EAAEJ,WAAW,CAACK,OADd;AAEJC,IAAAA,IAAI,EAAE;AAFF;AAzCmB,CAA3B;AA+CA,MAAMU,+BAA+B,GACnC,4DACA,qDADA,GAEA,uDAFA,GAGA,gDAHA,GAIA,4CALF;AAOA;;;;;;;;;AAQA,IAAIC,YAAY,GAAG,EAAnB;;AAEA,SAASC,eAAT,CAAyBC,OAAzB,EAAkCC,IAAlC,EAAwCC,MAAxC,EAAgD;AAC9C,MAAIF,OAAO,CAACG,KAAZ,EAAmB;AACjBF,IAAAA,IAAI,CAACG,WAAL;AACAN,IAAAA,YAAY,CAACO,IAAb,CAAkBJ,IAAlB;AACAH,IAAAA,YAAY,CAACO,IAAb,CAAkB;AAACC,MAAAA,WAAW,EAAE,SAASC,YAAT,GAAwB;AACtD,eAAOL,MAAM,CAACM,iBAAd;AACA,eAAON,MAAM,CAACO,SAAd;AACD;AAHiB,KAAlB;AAIAP,IAAAA,MAAM,CAACO,SAAP,GAAmBR,IAAnB;AACD;AACF;AAED;;;;;;;AAKA,SAASS,UAAT,CAAoBC,KAApB,EAA2BT,MAA3B,EAAmCU,UAAnC,EAA+CC,YAA/C,EAA6D;AAC3D,MAAIC,eAAe,GAAGd,OAAO,CAACe,0BAAR,CAAmCH,UAAnC,CAAtB;;AACA,MAAIlC,UAAU,CAACsC,MAAX,CAAkBd,MAAlB,EAA0B,mBAA1B,CAAJ,EAAoD;AAClD5B,IAAAA,MAAM,CAAC2C,KAAP,CACE,6DADF,EAEEL,UAFF;AAIA,WAAOV,MAAP;AACD;;AAGD,MAAID,IAAI,GAAGtB,KAAK,CAACuC,kBAAN,CACTJ,eAAe,CAAC7B,IADP,EAET0B,KAFS,EAGTC,UAHS,EAITC,YAJS,CAAX;AAOAd,EAAAA,eAAe,CAACC,OAAD,EAAUC,IAAV,EAAgBC,MAAhB,CAAf;;AAEA,MAAI;AACF,QAAIY,eAAe,CAACK,SAAhB,CAA0BlB,IAA1B,EAAgCC,MAAhC,EAAwCU,UAAxC,MAAwD,KAA5D,EAAmE;AACjEV,MAAAA,MAAM,GAAGD,IAAI,CAACmB,SAAL,CAAelB,MAAf,CAAT;AACAA,MAAAA,MAAM,CAACM,iBAAP,GAA2B,IAA3B;AACD;AACF,GALD,CAKE,OAAOa,oBAAP,EAA6B;AAC7B,QAAIP,eAAe,CAACQ,OAApB,EAA6B;AAC3B,UAAI;AACFR,QAAAA,eAAe,CAACQ,OAAhB,CAAwBD,oBAAxB;AACD,OAFD,CAEE,OAAOE,CAAP,EAAU;AACVjD,QAAAA,MAAM,CAACkD,IAAP,CACED,CADF,EACKF,oBADL,EAEE,+EAFF,EAGET,UAHF;AAKD;AACF,KAVD,MAUO;AACLtC,MAAAA,MAAM,CAACkD,IAAP,CACEH,oBADF,EAEE,qEACA,4CAHF,EAIET,UAJF;AAMD;AACF;;AAED,SAAOV,MAAP;AACD;;AAED,SAASuB,0BAAT,CAAoCd,KAApC,EAA2Ce,QAA3C,EAAqDzB,IAArD,EAA2DC,MAA3D,EAAmEU,UAAnE,EAA+E;AAC7E,MAAIe,QAAQ,GAAGxD,IAAI,CAACyD,OAAL,CAAaF,QAAb,CAAf;;AACA,MAAI,CAACrD,EAAE,CAACwD,UAAH,CAAcH,QAAd,CAAL,EAA8B;AAC5B,WAAOpD,MAAM,CAACkD,IAAP,CACL,gEADK,EAELG,QAFK,CAAP;AAID;;AACD,MAAI;AACF,WAAOvD,OAAO,CAACsD,QAAD,CAAP,CAAkBf,KAAlB,EAAyBT,MAAzB,EAAiCU,UAAjC,EAA6CX,IAA7C,CAAP;AACD,GAFD,CAEE,OAAO6B,KAAP,EAAc;AACdxD,IAAAA,MAAM,CAACkD,IAAP,CACEM,KADF,EAEE,yCAFF,EAGE3D,IAAI,CAAC4D,QAAL,CAAcL,QAAd,EAAwB,KAAxB,CAHF,EAIEC,QAJF;AAMD;AACF;;AAED,SAASK,SAAT,CAAmBrB,KAAnB,EAA0BT,MAA1B,EAAkC+B,IAAlC,EAAwCpB,YAAxC,EAAsD;AACpD,MAAIC,eAAJ;AACAA,EAAAA,eAAe,GAAGd,OAAO,CAACkC,oCAAR,CAA6CD,IAA7C,CAAlB,CAFoD,CAIpD;;AACA,MAAIjC,OAAO,CAACe,0BAAR,CAAmCD,eAAnC,CAAJ,EAAyD;AACvDxC,IAAAA,MAAM,CAAC2C,KAAP,CAAa,mBAAb,EAAkCgB,IAAlC;AACA,WAAOvB,UAAU,CAACC,KAAD,EAAQT,MAAR,EAAgBY,eAAhB,EAAiCD,YAAjC,CAAjB;AACD;;AAED,SAAOX,MAAP;AACD;;AAED,IAAIF,OAAO,GAAGmC,MAAM,CAACC,OAAP,GAAiB;AAC7B;;;;;;AAMAjC,EAAAA,KAAK,EAAE,KAPsB;;AAS7B;;;;;;;AAOAkC,EAAAA,SAAS,EAAE,SAASA,SAAT,CAAmBC,EAAnB,EAAuB;AAChC,WAAO,CAAC,EAAEA,EAAE,IAAIA,EAAE,CAACC,aAAX,CAAR;AACD,GAlB4B;;AAoB7B;;;;;;;;;;;;;;;;AAgBAC,EAAAA,UAAU,EAAE,SAASA,UAAT,CAAoBtC,MAApB,EAA4BuC,UAA5B,EAAwCC,OAAxC,EAAiDC,OAAjD,EAA0D;AACpE,QAAI,CAACD,OAAL,EAAc;AACZ,aAAOpE,MAAM,CAACkD,IAAP,CACL,IAAIoB,KAAJ,EADK,EAEL,kDAFK,CAAP;AAID;;AAED,QAAI,CAACH,UAAL,EAAiBA,UAAU,GAAG,WAAb;AACjB,QAAI,CAACI,KAAK,CAACC,OAAN,CAAcJ,OAAd,CAAL,EAA6BA,OAAO,GAAG,CAACA,OAAD,CAAV;AAE7BA,IAAAA,OAAO,CAACK,OAAR,CAAgB,SAASC,UAAT,CAAoBC,MAApB,EAA4B;AAC1C,UAAIC,IAAI,GAAGT,UAAU,GAAG,GAAb,GAAmBQ,MAA9B;;AAEA,UAAI,CAAC/C,MAAL,EAAa;AACX,eAAO5B,MAAM,CAAC6B,KAAP,CAAa,wCAAb,EAAuD+C,IAAvD,CAAP;AACD;;AAED,UAAI,CAACP,OAAL,EAAc;AACZ,eAAOrE,MAAM,CAAC6B,KAAP,CAAa,4CAAb,EAA2D+C,IAA3D,CAAP;AACD;;AAED,UAAIC,QAAQ,GAAGjD,MAAM,CAAC+C,MAAD,CAArB;AAEA,UAAI,CAACE,QAAL,EAAe,OAAO7E,MAAM,CAAC2C,KAAP,CAAa,kCAAb,EAAiDiC,IAAjD,CAAP;AACf,UAAIC,QAAQ,CAAC7C,WAAb,EAA0B,OAAOhC,MAAM,CAAC6B,KAAP,CAAa,8BAAb,EAA6C+C,IAA7C,CAAP;AAE1B,UAAIE,OAAO,GAAGT,OAAO,CAACQ,QAAD,EAAWF,MAAX,CAArB;AACAI,MAAAA,MAAM,CAACC,IAAP,CAAYH,QAAZ,EAAsBJ,OAAtB,CAA+BQ,GAAD,IAAS;AACrCH,QAAAA,OAAO,CAACG,GAAD,CAAP,GAAeJ,QAAQ,CAACI,GAAD,CAAvB;AACD,OAFD;AAGAH,MAAAA,OAAO,CAACb,aAAR,GAAwBY,QAAxB;;AACAC,MAAAA,OAAO,CAAC9C,WAAR,GAAsB,SAASA,WAAT,GAAuB;AAC3CJ,QAAAA,MAAM,CAAC+C,MAAD,CAAN,GAAiBE,QAAjB;AACA7E,QAAAA,MAAM,CAAC2C,KAAP,CAAa,kCAAb,EAAiDiC,IAAjD;AACD,OAHD;;AAKAhD,MAAAA,MAAM,CAAC+C,MAAD,CAAN,GAAiBG,OAAjB;AACA,UAAIpD,OAAO,CAACG,KAAZ,EAAmBL,YAAY,CAACO,IAAb,CAAkB+C,OAAlB;AACnB9E,MAAAA,MAAM,CAAC2C,KAAP,CAAa,kBAAb,EAAiCiC,IAAjC;AACD,KA7BD;AA8BD,GA7E4B;;AA+E7B;;;;;;;;;;;;;;;;AAgBAM,EAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBtD,MAAxB,EAAgCuC,UAAhC,EAA4CgB,QAA5C,EAAsDC,OAAtD,EAA+D;AAC7E,QAAI,CAACD,QAAL,EAAe;AACbnF,MAAAA,MAAM,CAACkD,IAAP,CAAY,IAAIoB,KAAJ,EAAZ,EAAyB,oDAAzB;AACA;AACD;;AAED,QAAI,CAACH,UAAL,EAAiBA,UAAU,GAAG,WAAb;AAEjB,QAAIS,IAAI,GAAGT,UAAU,GAAG,GAAb,GAAmBgB,QAA9B;;AACA,QAAI,CAACvD,MAAL,EAAa;AACX5B,MAAAA,MAAM,CAAC6B,KAAP,CAAa,wCAAb,EAAuD+C,IAAvD;AACA;AACD;;AAED,QAAIC,QAAQ,GAAGjD,MAAM,CAACuD,QAAD,CAArB;;AACA,QAAI,CAACN,QAAL,EAAe;AACb7E,MAAAA,MAAM,CAAC2C,KAAP,CAAa,kCAAb,EAAiDiC,IAAjD;AACA;AACD;;AAED,WAAOhD,MAAM,CAACuD,QAAD,CAAb;AAEA,QAAIE,UAAU,GAAG;AACfC,MAAAA,YAAY,EAAE,IADC;AAEfC,MAAAA,UAAU,EAAE;AAFG,KAAjB;AAIA,QAAIH,OAAO,CAACI,GAAZ,EAAiBH,UAAU,CAACG,GAAX,GAAiBJ,OAAO,CAACI,GAAzB;AACjB,QAAIJ,OAAO,CAACK,GAAZ,EAAiBJ,UAAU,CAACI,GAAX,GAAiBL,OAAO,CAACK,GAAzB;AACjBV,IAAAA,MAAM,CAACW,cAAP,CAAsB9D,MAAtB,EAA8BuD,QAA9B,EAAwCE,UAAxC;AACArF,IAAAA,MAAM,CAAC2C,KAAP,CAAa,kBAAb,EAAiCiC,IAAjC;;AAEA,QAAIlD,OAAO,CAACG,KAAZ,EAAmB;AACjBL,MAAAA,YAAY,CAACO,IAAb,CAAkB;AAChBC,QAAAA,WAAW,EAAE,SAAS2D,gBAAT,GAA4B;AACvC,iBAAO/D,MAAM,CAACuD,QAAD,CAAb;AACAvD,UAAAA,MAAM,CAACuD,QAAD,CAAN,GAAmBN,QAAnB;AACD;AAJe,OAAlB;AAMD;;AAED,WAAOA,QAAP;AACD,GAxI4B;AA0I7Be,EAAAA,YAAY,EAAE,SAASA,YAAT,CAAsBhE,MAAtB,EAA8BuC,UAA9B,EAA0CQ,MAA1C,EAAkD;AAC9D,QAAI,CAACR,UAAL,EAAiBA,UAAU,GAAG,WAAb;AACjB,QAAI,CAACQ,MAAL,EAAa,OAAO3E,MAAM,CAAC6B,KAAP,CAAa,2CACA,iBADb,EACgC,IAAIyC,KAAJ,GAAYuB,KAD5C,CAAP;AAGb,QAAIjB,IAAI,GAAGT,UAAU,GAAG,GAAb,GAAmBQ,MAA9B;;AAEA,QAAI,CAAC/C,MAAL,EAAa;AACX,aAAO5B,MAAM,CAAC6B,KAAP,CAAa,0CAAb,EAAyD+C,IAAzD,CAAP;AACD;;AAED,QAAIE,OAAO,GAAGlD,MAAM,CAAC+C,MAAD,CAApB,CAX8D,CAa9D;;AACA,QAAImB,GAAG,GAAGtE,YAAY,CAACuE,OAAb,CAAqBjB,OAArB,CAAV;AACA,QAAIgB,GAAG,KAAK,CAAC,CAAb,EAAgBtE,YAAY,CAACwE,MAAb,CAAoBF,GAApB,EAAyB,CAAzB;AAEhB,QAAI,CAAChB,OAAL,EAAc,OAAO9E,MAAM,CAAC6B,KAAP,CAAa,oCAAb,EAAmD+C,IAAnD,CAAP;AACd,QAAI,CAACE,OAAO,CAAC9C,WAAb,EAA0B,OAAOhC,MAAM,CAAC6B,KAAP,CAAa,uBAAb,EAAsC+C,IAAtC,CAAP;;AAE1BE,IAAAA,OAAO,CAAC9C,WAAR;AACD,GA/J4B;AAiK7BiE,EAAAA,SAAS,EAAE,SAASA,SAAT,GAAqB;AAC9BzE,IAAAA,YAAY,CAACiD,OAAb,CAAqB,SAASC,UAAT,CAAoBL,OAApB,EAA6B;AAChDA,MAAAA,OAAO,CAACrC,WAAR;AACD,KAFD;AAGAR,IAAAA,YAAY,GAAG,EAAf;AACD,GAtK4B;;AAwK7B;;;;AAIA0E,EAAAA,WAAW,EAAE,SAASA,WAAT,CAAqB7D,KAArB,EAA4B;AACvCrC,IAAAA,MAAM,CAAC2C,KAAP,CAAa,yBAAb;;AACA,QAAIwD,MAAM,GAAGrG,OAAO,CAAC,QAAD,CAApB;;AACA,QAAIsG,WAAW,GAAG,EAAlB,CAHuC,CAKvC;;AACA,UAAMC,QAAQ,GAAGhE,KAAK,CAACiE,MAAN,CAAaC,WAAb,CAAyBC,aAA1C;;AACA,QAAIH,QAAQ,CAACI,OAAb,EAAsB;AACpB;AACA,YAAMC,OAAO,GAAG5G,OAAO,CAAC,QAAD,CAAP,CAAkB6G,YAAlB,CAA+BC,SAA/C;;AACAlF,MAAAA,OAAO,CAACwC,UAAR,CACEwC,OADF,EAEE,wBAFF,EAGE,CAAC,aAAD,EAAgB,IAAhB,EAAsB,MAAtB,EAA8B,KAA9B,EAAqC,iBAArC,EAAwD,qBAAxD,CAHF,EAIE,SAASG,eAAT,CAAyBC,WAAzB,EAAsC;AACpC,eAAO,SAASC,kBAAT,CAA4BC,EAA5B,EAAgCC,QAAhC,EAA0C;AAC/C,iBAAOH,WAAW,CAACI,IAAZ,CAAiB,IAAjB,EAAuBF,EAAvB,EAA2BhF,WAAW,CAACiF,QAAD,CAAtC,CAAP;AACD,SAFD;AAGD,OARH;AAUAvF,MAAAA,OAAO,CAACwC,UAAR,CACEwC,OADF,EAEE,wBAFF,EAGE,gBAHF,EAIE,SAASS,kBAAT,CAA4BC,cAA5B,EAA4C;AAC1C,eAAO,SAASC,qBAAT,CAA+BL,EAA/B,EAAmCC,QAAnC,EAA6C;AAClD,iBAAOG,cAAc,CAACF,IAAf,CAAoB,IAApB,EAA0BF,EAA1B,EAA8BhF,WAAW,CAACiF,QAAD,CAAzC,CAAP;AACD,SAFD;AAGD,OARH;AAUA,YAAMK,mBAAmB,GAAGjB,QAAQ,CAACkB,qBAArC;AACA,YAAMC,KAAK,GAAGrB,MAAM,CAACS,SAArB;AACAlF,MAAAA,OAAO,CAACwC,UAAR,CACEsD,KADF,EAEE,kBAFF,EAGE,UAHF,EAIE,SAASC,WAAT,CAAqBC,QAArB,EAA+B;AAC7B,eAAO,SAASC,cAAT,CAAwBC,IAAxB,EAA8B/G,IAA9B,EAAoC;AACzC,cAAIgH,QAAJ;;AACA,cAAI;AACFA,YAAAA,QAAQ,GAAGP,mBAAmB,CAACQ,IAApB,CAAyBjH,IAAzB,IAAiC+G,IAAjC,GAAwCtH,MAAM,CAACsH,IAAD,EAAO/G,IAAP,CAAzD;AACA,mBAAO6G,QAAQ,CAACR,IAAT,CAAc,IAAd,EAAoBW,QAApB,EAA8BhH,IAA9B,CAAP;AACD,WAHD,CAGE,OAAOoC,CAAP,EAAU;AACVjD,YAAAA,MAAM,CAAC6B,KAAP,CAAa,uBAAb,EAAsChB,IAAtC,EAA4CoC,CAA5C;AACA,mBAAOyE,QAAQ,CAACR,IAAT,CAAc,IAAd,EAAoBU,IAApB,EAA0B/G,IAA1B,CAAP;AACD;AACF,SATD;AAUD,OAfH,EAzBoB,CA2CpB;;AACAkH,MAAAA,MAAM,CAACC,MAAP,GAAgB3F,KAAK,CAAC2F,MAAtB;AACAD,MAAAA,MAAM,CAACE,SAAP,GAAmBA,SAAnB;;AACA,eAASA,SAAT,CAAmBC,CAAnB,EAAsBC,OAAtB,EAA+B/E,QAA/B,EAAyC;AACvC,cAAMgF,gBAAgB,GAAG/F,KAAK,CAAC2F,MAAN,CAAaK,UAAb,EAAzB;;AACA,YACE,OAAOH,CAAP,KAAa,UAAb,IACA,CAACE,gBADD,IAEA,CAACA,gBAAgB,CAACE,WAAjB,CAA6BC,QAA7B,EAHH,EAIE;AACA,iBAAOL,CAAP;AACD;;AAGD,cAAMM,oBAAoB,GAAGJ,gBAAgB,CAACE,WAA9C;AACA,eAAO,IAAIG,KAAJ,CAAUP,CAAV,EAAa;AAClB1C,UAAAA,GAAG,EAAE,SAASkD,OAAT,CAAiBC,MAAjB,EAAyBC,IAAzB,EAA+B;AAClC;AACA,gBAAIA,IAAI,KAAK,mBAAb,EAAkC;AAChC,qBAAOD,MAAP;AACD;;AACD,mBAAOA,MAAM,CAACC,IAAD,CAAb;AACD,WAPiB;AAQlBC,UAAAA,SAAS,EAAE,SAASC,aAAT,CAAuBC,MAAvB,EAA+BC,SAA/B,EAA0C;AACnD,kBAAMC,cAAc,GAAG5G,KAAK,CAAC2F,MAAN,CAAaK,UAAb,EAAvB;;AACA,gBACEG,oBAAoB,CAACD,QAArB,OAEE,CAACU,cAAD,IACAA,cAAc,CAACX,WAAf,CAA2BY,EAA3B,KAAkCV,oBAAoB,CAACU,EAHzD,CADF,EAME;AACAlJ,cAAAA,MAAM,CAACmJ,IAAP,CACG,iBAAgB/F,QAAS,UAAS+E,OAAQ,IAD7C,EAEG,iCAAgCK,oBAAoB,CAACU,EAAG,GAF3D,EAGG,qBAAoBD,cAAc,IAAIA,cAAc,CAACX,WAAf,CAA2BY,EAAG,EAHvE;AAKD;;AACD,mBAAO,IAAIH,MAAJ,CAAW,GAAGC,SAAd,CAAP;AACD,WAxBiB;AAyBlBI,UAAAA,KAAK,EAAE,SAASC,YAAT,CAAsBV,MAAtB,EAA8BW,OAA9B,EAAuCC,IAAvC,EAA6C;AAClD,kBAAMN,cAAc,GAAG5G,KAAK,CAAC2F,MAAN,CAAaK,UAAb,EAAvB;;AACA,gBACEG,oBAAoB,CAACD,QAArB,OAEE,CAACU,cAAD,IACAA,cAAc,CAACX,WAAf,CAA2BY,EAA3B,KAAkCV,oBAAoB,CAACU,EAHzD,CADF,EAME;AACAlJ,cAAAA,MAAM,CAACmJ,IAAP,CACG,iBAAgB/F,QAAS,UAAS+E,OAAQ,IAD7C,EAEG,iCAAgCK,oBAAoB,CAACU,EAAG,GAF3D,EAGG,qBAAoBD,cAAc,IAAIA,cAAc,CAACX,WAAf,CAA2BY,EAAG,EAHvE;AAKD;;AACD,mBAAOP,MAAM,CAACS,KAAP,CAAaE,OAAb,EAAsBC,IAAtB,CAAP;AACD;AAzCiB,SAAb,CAAP;AA2CD;;AAEDxB,MAAAA,MAAM,CAAC/F,WAAP,GAAqBA,WAArB;;AACA,eAASA,WAAT,CAAqBkG,CAArB,EAAwB;AACtB,YAAI,OAAOA,CAAP,KAAa,UAAb,IAA2B,CAACA,CAA5B,IAAiC,CAACA,CAAC,CAACsB,iBAAxC,EAA2D;AACzD,iBAAOtB,CAAP;AACD;;AAED,eAAOA,CAAC,CAACsB,iBAAT;AACD;AACF;;AAED9H,IAAAA,OAAO,CAACwC,UAAR,CAAmBiC,MAAnB,EAA2B,QAA3B,EAAqC,kBAArC,EAAyD,SAASsD,OAAT,CAAiBnG,OAAjB,EAA0B;AACjF,aAAO,SAASoG,sBAAT,CAAgC7I,IAAhC,EAAsC;AAC3C;AACA;AACA,cAAM8I,gBAAgB,GAAGrG,OAAO,CAAC8F,KAAR,CAAc,IAAd,EAAoBQ,SAApB,CAAzB;AACAxD,QAAAA,WAAW,CAACvF,IAAD,CAAX,GAAoB8I,gBAApB;AACA,eAAOA,gBAAP;AACD,OAND;AAOD,KARD;AAUAjI,IAAAA,OAAO,CAACwC,UAAR,CAAmBiC,MAAnB,EAA2B,QAA3B,EAAqC,OAArC,EAA8C,SAAS0D,QAAT,CAAkBC,IAAlB,EAAwB;AACpE,aAAO,SAASC,WAAT,CAAqBC,OAArB,EAA8BC,MAA9B,EAAsCC,MAAtC,EAA8C;AACnD;AACA,cAAMC,CAAC,GAAGL,IAAI,CAACV,KAAL,CAAW,IAAX,EAAiBQ,SAAjB,CAAV;AAEA,cAAMxG,QAAQ,GAAGgH,eAAe,CAACJ,OAAD,EAAUC,MAAV,EAAkBC,MAAlB,CAAhC;AACA,eAAOxG,SAAS,CAACrB,KAAD,EAAQ8H,CAAR,EAAWH,OAAX,EAAoB5G,QAApB,CAAhB;AACD,OAND;AAOD,KARD;AAUA;;;;;;;;;;AASA,aAASgH,eAAT,CAAyBJ,OAAzB,EAAkCC,MAAlC,EAA0CC,MAA1C,EAAkD;AAChD,YAAMG,UAAU,GAAGjE,WAAW,CAAC4D,OAAD,CAA9B;;AACA,UAAI,CAACK,UAAD,IAAeJ,MAAf,IAAyBA,MAAM,CAACK,MAApC,EAA4C;AAC1CtK,QAAAA,MAAM,CAACuK,QAAP,CAAgB,kBAAhB,EAAoChJ,+BAApC;;AAEA,YAAIvB,MAAM,CAACwK,YAAP,EAAJ,EAA2B;AACzBxK,UAAAA,MAAM,CAAC2C,KAAP,CAAc,4BAA2BqH,OAAQ,uBAAjD;AACD,SALyC,CAO1C;;;AACA,eAAO7D,MAAM,CAACsE,gBAAP,CAAwBT,OAAxB,EAAiCC,MAAjC,EAAyCC,MAAzC,CAAP;AACD;;AAED,aAAOG,UAAP;AACD;AACF,GAhV4B;AAkV7BK,EAAAA,aAAa,EAAE,SAASA,aAAT,GAAyB;AACtC1K,IAAAA,MAAM,CAAC2C,KAAP,CAAa,uCAAb;;AACA,QAAIwD,MAAM,GAAGrG,OAAO,CAAC,QAAD,CAApB;;AAEA4B,IAAAA,OAAO,CAACkE,YAAR,CAAqBO,MAArB,EAA6B,QAA7B,EAAuC,kBAAvC;AACAzE,IAAAA,OAAO,CAACkE,YAAR,CAAqBO,MAArB,EAA6B,QAA7B,EAAuC,OAAvC;AACD,GAxV4B;AA0V7BwE,EAAAA,wBAAwB,EAAE,SAASA,wBAAT,CAAkCtI,KAAlC,EAAyC;AACjE;AACA,UAAMuI,UAAU,GAAG,IAAIvK,KAAK,CAACwK,IAAV,CAAexI,KAAf,EAAsB,SAAtB,EAAiC,SAAjC,CAAnB;AACAZ,IAAAA,eAAe,CAACC,OAAD,EAAUkJ,UAAV,EAAsB7C,MAAtB,CAAf;AACA,QAAI+C,eAAe,GAAGjL,IAAI,CAACkL,IAAL,CAAUC,SAAV,EAAqB,iBAArB,EAAwC,MAAxC,EAAgD,YAAhD,CAAtB;;AACA7H,IAAAA,0BAA0B,CAACd,KAAD,EAAQyI,eAAR,EAAyBF,UAAzB,EAAqC7C,MAArC,EAA6C,SAA7C,CAA1B,CALiE,CAOjE;;;AACAhD,IAAAA,MAAM,CAACC,IAAP,CAAYvE,oBAAZ,EAAkCgE,OAAlC,CAA0C,SAASwG,WAAT,CAAqBC,MAArB,EAA6B;AACrE,YAAMC,IAAI,GAAG1K,oBAAoB,CAACyK,MAAD,CAAjC;AACA,YAAME,QAAQ,GAAGvL,IAAI,CAACkL,IAAL,CAAUC,SAAV,EAAqB,iBAArB,EAAwC,MAAxC,EAAgDG,IAAI,CAACtK,IAArD,CAAjB;AACA,UAAIwK,cAAc,GAAG,IAArB;;AAEA,UAAI;AACFA,QAAAA,cAAc,GAAGvL,OAAO,CAACoL,MAAD,CAAxB;AACD,OAFD,CAEE,OAAOI,GAAP,EAAY;AACZtL,QAAAA,MAAM,CAAC2C,KAAP,CACE,4CADF,EAEEuI,MAFF,EAGEI,GAHF;AAKD;;AAED,YAAM3J,IAAI,GAAGtB,KAAK,CAACuC,kBAAN,CAAyBuI,IAAI,CAACxK,IAA9B,EAAoC0B,KAApC,EAA2C6I,MAA3C,EAAmDA,MAAnD,CAAb;AACAzJ,MAAAA,eAAe,CAACC,OAAD,EAAUC,IAAV,EAAgBwJ,IAAhB,CAAf;;AACAhI,MAAAA,0BAA0B,CAACd,KAAD,EAAQ+I,QAAR,EAAkBzJ,IAAlB,EAAwB0J,cAAxB,EAAwCH,MAAxC,CAA1B;AACD,KAlBD,EARiE,CA4BjE;;AACAnG,IAAAA,MAAM,CAACC,IAAP,CAAY7E,gBAAZ,EAA8BsE,OAA9B,CAAsC,SAAS8G,sBAAT,CAAgCjJ,UAAhC,EAA4C;AAChF,UAAIkJ,SAAS,GAAGrL,gBAAgB,CAACmC,UAAD,CAAhC;;AACA,UAAIkJ,SAAS,CAAC3H,MAAd,EAAsB;AACpB;AACA;AACA;AACA,YAAI;AACF,cAAI4H,KAAK,GAAG3L,OAAO,CAAC0L,SAAS,CAAC3H,MAAV,GAAmB,WAApB,CAAnB;;AACA4H,UAAAA,KAAK,CAAChH,OAAN,CAAc/C,OAAO,CAACgK,uBAAtB;AACD,SAHD,CAGE,OAAOzI,CAAP,EAAU;AACVjD,UAAAA,MAAM,CAACkD,IAAP,CAAY,wCAAwCsI,SAAS,CAAC3H,MAA9D,EAAsEZ,CAAtE;AACA;AACD;AACF,OAXD,MAWO,IAAIX,UAAU,KAAK,SAAnB,EAA8B;AACnC;AACAxC,QAAAA,OAAO,CAAC,2BAAD,CAAP,CAAqC6L,YAArC,CAAkDjK,OAAlD;AACD,OAHM,MAGA;AACL,YAAI0B,QAAQ,GAAGvD,IAAI,CAACkL,IAAL,CAAUC,SAAV,EAAqB,iBAArB,EAAwC1I,UAAU,GAAG,KAArD,CAAf;AACAZ,QAAAA,OAAO,CAACgK,uBAAR,CAAgC;AAC9BpJ,UAAAA,UAAU,EAAEA,UADkB;AAE9B3B,UAAAA,IAAI,EAAE6K,SAAS,CAAC7K,IAFc;AAG9BkC,UAAAA,SAAS,EAAEM,0BAA0B,CAACyI,IAA3B,CAAgC,IAAhC,EAAsCvJ,KAAtC,EAA6Ce,QAA7C;AAHmB,SAAhC;AAKD;AACF,KAxBD,EA7BiE,CAuDjE;AACA;AACA;;AACA,QAAIyI,UAAU,GAAGhM,IAAI,CAACkL,IAAL,CAAUC,SAAV,EAAqB,gCAArB,CAAjB;AACAtJ,IAAAA,OAAO,CAACgK,uBAAR,CAAgC;AAC9BpJ,MAAAA,UAAU,EAAE,QADkB;AAE9B3B,MAAAA,IAAI,EAAE,IAFwB;AAG9BkC,MAAAA,SAAS,EAAEM,0BAA0B,CAACyI,IAA3B,CAAgC,IAAhC,EAAsCvJ,KAAtC,EAA6CwJ,UAA7C;AAHmB,KAAhC;AAKD,GA1Z4B;AA4Z7BH,EAAAA,uBAAuB,EAAE,SAASA,uBAAT,CAAiCI,IAAjC,EAAuC;AAC9DpK,IAAAA,OAAO,CAACe,0BAAR,CAAmCqJ,IAAI,CAACxJ,UAAxC,IAAsDwJ,IAAtD;AACD,GA9Z4B;AAga7BrJ,EAAAA,0BAA0B,EAAEsC,MAAM,CAACgH,MAAP,CAAc,IAAd,CAhaC;;AAka7B;;;;;;;;;;;;;;;;;AAiBAC,EAAAA,YAAY,EAAE,SAASA,YAAT,CAAsB3J,KAAtB,EAA6B4J,UAA7B,EAAyC;AACrD,WAAOvI,SAAS,CAACrB,KAAD,EAAQvC,OAAO,CAACmM,UAAD,CAAf,EAA6BA,UAA7B,CAAhB;AACD,GArb4B;;AAub7B;;;;;AAKArI,EAAAA,oCAAoC,CAACtB,UAAD,EAAa;AAC/C,QAAIE,eAAJ,CAD+C,CAE/C;AACA;;AACA,QAAIF,UAAU,KAAK,OAAnB,EAA4B;AAC1BE,MAAAA,eAAe,GAAG,IAAlB;AACD;;AAAC,QAAIF,UAAU,KAAK,QAAnB,EAA6B;AAC7B;AACA;AACA;AACAE,MAAAA,eAAe,GAAG,OAAlB;AACD,KALC,MAKK;AACLA,MAAAA,eAAe,GAAGF,UAAlB;AACD;;AACD,WAAOE,eAAP;AACD;;AA3c4B,CAA/B","sourcesContent":["'use strict'\n\nvar path = require('path')\nvar fs = require('./util/unwrapped-core').fs\nvar logger = require('./logger').child({component: 'shimmer'})\nvar INSTRUMENTATIONS = require('./instrumentations')()\nvar properties = require('./util/properties')\nvar shims = require('./shim')\nconst { inject } = require('./injector')\n\nvar MODULE_TYPE = shims.constants.MODULE_TYPE\n\nvar CORE_INSTRUMENTATION = {\n  child_process: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'child_process.js'\n  },\n  crypto: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'crypto.js'\n  },\n  // domain: {                     // XXX Do not include domains in this list! The\n  //   type: MODULE_TYPE.GENERIC,  // core instrumentations are run at startup by\n  //   file: 'domain.js'           // requiring each of their modules. Loading\n  // },                            // `domain` has side effects that we try to avoid.\n  dns: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'dns.js'\n  },\n  fs: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'fs.js'\n  },\n  http: {\n    type: MODULE_TYPE.TRANSACTION,\n    file: 'http.js'\n  },\n  https: {\n    type: MODULE_TYPE.TRANSACTION,\n    file: 'http.js'\n  },\n  inspector: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'inspector.js'\n  },\n  net: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'net.js'\n  },\n  timers: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'timers.js'\n  },\n  zlib: {\n    type: MODULE_TYPE.GENERIC,\n    file: 'zlib.js'\n  }\n}\n\nconst FORCE_MODULE_RESOLUTION_WARNING =\n  'Unable to retrieve cached path for one or more modules ' +\n  'with an already loaded parent. Forcing resolution. ' +\n  'This should not occur during normal agent execution. ' +\n  'Module resolution performance my be impacted. ' +\n  'See trace-level logs for specific modules.'\n\n/**\n * Unwrapping is only likely to be used by test code, and is a fairly drastic\n * maneuver, but it should be pretty safe if there's a desire to reboot the\n * agent in flight.\n *\n * All of the wrapped methods are tracked in this variable and used by unwrapAll\n * below.\n */\nvar instrumented = []\n\nfunction applyDebugState(shimmer, shim, nodule) {\n  if (shimmer.debug) {\n    shim.enableDebug()\n    instrumented.push(shim)\n    instrumented.push({__NR_unwrap: function unwrapNodule() {\n      delete nodule.__NR_instrumented\n      delete nodule.__NR_shim\n    }})\n    nodule.__NR_shim = shim\n  }\n}\n\n/**\n * All instrumentation files must export the same interface: a single\n * initialization function that takes the agent and the module to be\n * instrumented.\n */\nfunction instrument(agent, nodule, moduleName, resolvedName) {\n  var instrumentation = shimmer.registeredInstrumentations[moduleName]\n  if (properties.hasOwn(nodule, '__NR_instrumented')) {\n    logger.trace(\n      'Already instrumented %s, skipping redundant instrumentation',\n      moduleName\n    )\n    return nodule\n  }\n\n\n  var shim = shims.createShimFromType(\n    instrumentation.type,\n    agent,\n    moduleName,\n    resolvedName\n  )\n\n  applyDebugState(shimmer, shim, nodule)\n\n  try {\n    if (instrumentation.onRequire(shim, nodule, moduleName) !== false) {\n      nodule = shim.getExport(nodule)\n      nodule.__NR_instrumented = true\n    }\n  } catch (instrumentationError) {\n    if (instrumentation.onError) {\n      try {\n        instrumentation.onError(instrumentationError)\n      } catch (e) {\n        logger.warn(\n          e, instrumentationError,\n          'Custom instrumentation for %s failed, then the onError handler threw an error',\n          moduleName\n        )\n      }\n    } else {\n      logger.warn(\n        instrumentationError,\n        'Custom instrumentation for %s failed. Please report this to the ' +\n        'maintainers of the custom instrumentation.',\n        moduleName\n      )\n    }\n  }\n\n  return nodule\n}\n\nfunction _firstPartyInstrumentation(agent, fileName, shim, nodule, moduleName) {\n  var fullPath = path.resolve(fileName)\n  if (!fs.existsSync(fileName)) {\n    return logger.warn(\n      'Tried to load instrumentation from %s, but file does not exist',\n      fullPath\n    )\n  }\n  try {\n    return require(fileName)(agent, nodule, moduleName, shim)\n  } catch (error) {\n    logger.warn(\n      error,\n      'Failed to instrument module %s using %s',\n      path.basename(fileName, '.js'),\n      fullPath\n    )\n  }\n}\n\nfunction _postLoad(agent, nodule, name, resolvedName) {\n  var instrumentation\n  instrumentation = shimmer.getInstrumentationNameFromModuleName(name)\n\n  // Check if this is a known instrumentation and then run it.\n  if (shimmer.registeredInstrumentations[instrumentation]) {\n    logger.trace('Instrumenting %s.', name)\n    return instrument(agent, nodule, instrumentation, resolvedName)\n  }\n\n  return nodule\n}\n\nvar shimmer = module.exports = {\n  /**\n   * If debug isn't false, the agent will retain references to wrapped methods\n   * for the entire lifetime of the agent. Some instrumentation depends on\n   * wrapping functions on individual objects, and this will cause the agent\n   * to retain references to a large number of dead objects.\n   */\n  debug: false,\n\n  /**\n   * Detects if the given function has already been wrapped.\n   *\n   * @param {function} fn - The function to look for a wrapper on.\n   *\n   * @return {bool} True if `fn` exists and has an attached original, else false.\n   */\n  isWrapped: function isWrapped(fn) {\n    return !!(fn && fn.__NR_original)\n  },\n\n  /**\n   * Don't throw, but do log and bail out if wrapping fails.\n   *\n   * Provide an escape hatch by creating a closure around the original method\n   * and object / module wrapped into a helper function that will restore the\n   * original function / method. See Sinon for a systematic use of this\n   * pattern.\n   *\n   * @param {object} nodule Class or module containing the function to wrap.\n   * @param {object} noduleName Human-readable module / Class name. More\n   *                            helpful than you'd think.\n   * @param {string} methods One or more names of methods or functions to extract\n   *                         and wrap.\n   * @param {function} wrapper A generator that, when called, returns a\n   *                           wrapped version of the original function.\n   */\n  wrapMethod: function wrapMethod(nodule, noduleName, methods, wrapper) {\n    if (!methods) {\n      return logger.warn(\n        new Error(),\n        \"Must include a method name to wrap. Called from:\"\n      )\n    }\n\n    if (!noduleName) noduleName = '[unknown]'\n    if (!Array.isArray(methods)) methods = [methods]\n\n    methods.forEach(function cb_forEach(method) {\n      var fqmn = noduleName + '.' + method\n\n      if (!nodule) {\n        return logger.debug(\"Can't wrap %s from nonexistent object.\", fqmn)\n      }\n\n      if (!wrapper) {\n        return logger.debug(\"Can't wrap %s without a wrapper generator.\", fqmn)\n      }\n\n      var original = nodule[method]\n\n      if (!original) return logger.trace(\"%s not defined, so not wrapping.\", fqmn)\n      if (original.__NR_unwrap) return logger.debug(\"%s already wrapped by agent.\", fqmn)\n\n      var wrapped = wrapper(original, method)\n      Object.keys(original).forEach((key) => {\n        wrapped[key] = original[key]\n      })\n      wrapped.__NR_original = original\n      wrapped.__NR_unwrap = function __NR_unwrap() {\n        nodule[method] = original\n        logger.trace(\"Removed instrumentation from %s.\", fqmn)\n      }\n\n      nodule[method] = wrapped\n      if (shimmer.debug) instrumented.push(wrapped)\n      logger.trace(\"Instrumented %s.\", fqmn)\n    })\n  },\n\n  /**\n   * Sometimes you gotta do some crazy stuff to get the job done. Instead of using\n   * regular monkeypatching, wrapDeprecated allows you to pass in a getter and setter\n   * and then uses defineProperty to replace the original property with an\n   * accessor. Note that responsibility for unwrapping is not handled by this\n   * function.\n   *\n   * @param {object}   nodule     Class or module containing the property to\n   *                              wrap.\n   * @param {object}   noduleName Human-readable module / Class name. More\n   *                              helpful than you'd think.\n   * @param {string}   property   The property to replace with the accessor.\n   * @param {function} options    Optional getter and setter to use for the accessor.\n   *\n   * @returns {object} The original value of the property.\n   */\n  wrapDeprecated: function wrapDeprecated(nodule, noduleName, property, options) {\n    if (!property) {\n      logger.warn(new Error(), \"Must include a function name to wrap. Called from:\")\n      return\n    }\n\n    if (!noduleName) noduleName = '[unknown]'\n\n    var fqmn = noduleName + '.' + property\n    if (!nodule) {\n      logger.debug(\"Can't wrap %s from nonexistent object.\", fqmn)\n      return\n    }\n\n    var original = nodule[property]\n    if (!original) {\n      logger.trace(\"%s not defined, so not wrapping.\", fqmn)\n      return\n    }\n\n    delete nodule[property]\n\n    var descriptor = {\n      configurable: true,\n      enumerable: true\n    }\n    if (options.get) descriptor.get = options.get\n    if (options.set) descriptor.set = options.set\n    Object.defineProperty(nodule, property, descriptor)\n    logger.trace(\"Instrumented %s.\", fqmn)\n\n    if (shimmer.debug) {\n      instrumented.push({\n        __NR_unwrap: function unwrapDeprecated() {\n          delete nodule[property]\n          nodule[property] = original\n        }\n      })\n    }\n\n    return original\n  },\n\n  unwrapMethod: function unwrapMethod(nodule, noduleName, method) {\n    if (!noduleName) noduleName = '[unknown]'\n    if (!method) return logger.debug(\"Must include a method name to unwrap. \" +\n                                     \"Called from: %s\", new Error().stack)\n\n    var fqmn = noduleName + '.' + method\n\n    if (!nodule) {\n      return logger.debug(\"Can't unwrap %s from nonexistent object.\", fqmn)\n    }\n\n    var wrapped = nodule[method]\n\n    // keep instrumented up to date\n    var pos = instrumented.indexOf(wrapped)\n    if (pos !== -1) instrumented.splice(pos, 1)\n\n    if (!wrapped) return logger.debug(\"%s not defined, so not unwrapping.\", fqmn)\n    if (!wrapped.__NR_unwrap) return logger.debug(\"%s isn't unwrappable.\", fqmn)\n\n    wrapped.__NR_unwrap()\n  },\n\n  unwrapAll: function unwrapAll() {\n    instrumented.forEach(function cb_forEach(wrapper) {\n      wrapper.__NR_unwrap()\n    })\n    instrumented = []\n  },\n\n  /**\n   * Patch the module.load function so that we see modules loading and\n   * have an opportunity to patch them with instrumentation.\n   */\n  patchModule: function patchModule(agent) {\n    logger.trace(\"Wrapping module loader.\")\n    var Module = require('module')\n    var filepathMap = {}\n\n    // TODO: how do we unpatch this?\n    const diagConf = agent.config.diagnostics.code_injector\n    if (diagConf.enabled) {\n      // XXX: this is required to handle unwrapping event listener removal\n      const EEProto = require('events').EventEmitter.prototype\n      shimmer.wrapMethod(\n        EEProto,\n        'EventEmitter.prototype',\n        ['addListener', 'on', 'once', 'off', 'prependListener', 'prependOnceListener'],\n        function wrapAddListener(addListener) {\n          return function wrappedAddListener(ev, listener) {\n            return addListener.call(this, ev, __NR_unwrap(listener))\n          }\n        }\n      )\n      shimmer.wrapMethod(\n        EEProto,\n        'EventEmitter.prototype',\n        'removeListener',\n        function wrapRemoveListener(removeListener) {\n          return function wrappedRemoveListener(ev, listener) {\n            return removeListener.call(this, ev, __NR_unwrap(listener))\n          }\n        }\n      )\n      const internalCodePattern = diagConf.internal_file_pattern\n      const proto = Module.prototype\n      shimmer.wrapMethod(\n        proto,\n        'Module.prototype',\n        '_compile',\n        function wrapCompile(_compile) {\n          return function wrappedCompile(code, file) {\n            let injected\n            try {\n              injected = internalCodePattern.test(file) ? code : inject(code, file)\n              return _compile.call(this, injected, file)\n            } catch (e) {\n              logger.debug('Unable to parse file:', file, e)\n              return _compile.call(this, code, file)\n            }\n          }\n        }\n      )\n\n      // TODO: use shimmer methods\n      global.tracer = agent.tracer\n      global.__NR_wrap = __NR_wrap\n      function __NR_wrap(f, lineNum, fileName) {\n        const scheduledSegment = agent.tracer.getSegment()\n        if (\n          typeof f !== 'function' ||\n          !scheduledSegment ||\n          !scheduledSegment.transaction.isActive()\n        ) {\n          return f\n        }\n\n\n        const scheduledTransaction = scheduledSegment.transaction\n        return new Proxy(f, {\n          get: function getTrap(target, prop) {\n            // Allow for look up of the target\n            if (prop === '__NR_new_original') {\n              return target\n            }\n            return target[prop]\n          },\n          construct: function constructTrap(Target, proxyArgs) {\n            const currentSegment = agent.tracer.getSegment()\n            if (\n              scheduledTransaction.isActive() &&\n              (\n                !currentSegment ||\n                currentSegment.transaction.id !== scheduledTransaction.id\n              )\n            ) {\n              logger.info(\n                `lost state in ${fileName} (line ${lineNum});`,\n                `expected to be in transaction ${scheduledTransaction.id},`,\n                `instead landed in ${currentSegment && currentSegment.transaction.id}`\n              )\n            }\n            return new Target(...proxyArgs)\n          },\n          apply: function wrappedApply(target, thisArg, args) {\n            const currentSegment = agent.tracer.getSegment()\n            if (\n              scheduledTransaction.isActive() &&\n              (\n                !currentSegment ||\n                currentSegment.transaction.id !== scheduledTransaction.id\n              )\n            ) {\n              logger.info(\n                `lost state in ${fileName} (line ${lineNum});`,\n                `expected to be in transaction ${scheduledTransaction.id},`,\n                `instead landed in ${currentSegment && currentSegment.transaction.id}`\n              )\n            }\n            return target.apply(thisArg, args)\n          }\n        })\n      }\n\n      global.__NR_unwrap = __NR_unwrap\n      function __NR_unwrap(f) {\n        if (typeof f !== 'function' || !f || !f.__NR_new_original) {\n          return f\n        }\n\n        return f.__NR_new_original\n      }\n    }\n\n    shimmer.wrapMethod(Module, 'Module', '_resolveFilename', function wrapRes(resolve) {\n      return function wrappedResolveFilename(file) {\n        // This is triggered by the load call, so record the path that has been seen so\n        // we can examine it after the load call has returned.\n        const resolvedFilepath = resolve.apply(this, arguments)\n        filepathMap[file] = resolvedFilepath\n        return resolvedFilepath\n      }\n    })\n\n    shimmer.wrapMethod(Module, 'Module', '_load', function wrapLoad(load) {\n      return function wrappedLoad(request, parent, isMain) {\n        // _load() will invoke _resolveFilename() first time resolving a module.\n        const m = load.apply(this, arguments)\n\n        const fileName = resolveFileName(request, parent, isMain)\n        return _postLoad(agent, m, request, fileName)\n      }\n    })\n\n    /**\n     * Forces file name resolve for modules not in our cache when\n     * their parent has already been loaded/cached by Node.\n     * Provides a fall-back for unexpected cases that may occur.\n     * Also provides flexibilty for testing now that node 11+ caches these.\n     * @param {*} request\n     * @param {*} parent\n     * @param {*} isMain\n     */\n    function resolveFileName(request, parent, isMain) {\n      const cachedPath = filepathMap[request]\n      if (!cachedPath && parent && parent.loaded) {\n        logger.warnOnce('Force Resolution', FORCE_MODULE_RESOLUTION_WARNING)\n\n        if (logger.traceEnabled()) {\n          logger.trace(`No cached path found for ${request}. Forcing resolution.`)\n        }\n\n        // Our patched _resolveFilename will cache. No need to here.\n        return Module._resolveFilename(request, parent, isMain)\n      }\n\n      return cachedPath\n    }\n  },\n\n  unpatchModule: function unpatchModule() {\n    logger.trace(\"Unwrapping to previous module loader.\")\n    var Module = require('module')\n\n    shimmer.unwrapMethod(Module, 'Module', '_resolveFilename')\n    shimmer.unwrapMethod(Module, 'Module', '_load')\n  },\n\n  bootstrapInstrumentation: function bootstrapInstrumentation(agent) {\n    // Instrument global.\n    const globalShim = new shims.Shim(agent, 'globals', 'globals')\n    applyDebugState(shimmer, globalShim, global)\n    var globalsFilepath = path.join(__dirname, 'instrumentation', 'core', 'globals.js')\n    _firstPartyInstrumentation(agent, globalsFilepath, globalShim, global, 'globals')\n\n    // Instrument each of the core modules.\n    Object.keys(CORE_INSTRUMENTATION).forEach(function forEachCore(mojule) {\n      const core = CORE_INSTRUMENTATION[mojule]\n      const filePath = path.join(__dirname, 'instrumentation', 'core', core.file)\n      let uninstrumented = null\n\n      try {\n        uninstrumented = require(mojule)\n      } catch (err) {\n        logger.trace(\n          'Could not load core module %s got error %s',\n          mojule,\n          err\n        )\n      }\n\n      const shim = shims.createShimFromType(core.type, agent, mojule, mojule)\n      applyDebugState(shimmer, shim, core)\n      _firstPartyInstrumentation(agent, filePath, shim, uninstrumented, mojule)\n    })\n\n    // Register all the first-party instrumentations.\n    Object.keys(INSTRUMENTATIONS).forEach(function forEachInstrumentation(moduleName) {\n      var instrInfo = INSTRUMENTATIONS[moduleName]\n      if (instrInfo.module) {\n        // Because external instrumentations can change independent of\n        // the agent core, we don't want breakages in them to entirely\n        // disable the agent.\n        try {\n          var hooks = require(instrInfo.module + '/nr-hooks')\n          hooks.forEach(shimmer.registerInstrumentation)\n        } catch (e) {\n          logger.warn('Failed to load instrumentation for ' + instrInfo.module, e)\n          return\n        }\n      } else if (moduleName === 'amqplib') {\n        // TODO: Remove this code when amqplib instrumentation is made external.\n        require('./instrumentation/amqplib').selfRegister(shimmer)\n      } else {\n        var fileName = path.join(__dirname, 'instrumentation', moduleName + '.js')\n        shimmer.registerInstrumentation({\n          moduleName: moduleName,\n          type: instrInfo.type,\n          onRequire: _firstPartyInstrumentation.bind(null, agent, fileName)\n        })\n      }\n    })\n\n    // Even though domain is a core module we add it as a registered\n    // instrumentation to be lazy-loaded because we do not want to cause domain\n    // usage.\n    var domainPath = path.join(__dirname, 'instrumentation/core/domain.js')\n    shimmer.registerInstrumentation({\n      moduleName: 'domain',\n      type: null,\n      onRequire: _firstPartyInstrumentation.bind(null, agent, domainPath)\n    })\n  },\n\n  registerInstrumentation: function registerInstrumentation(opts) {\n    shimmer.registeredInstrumentations[opts.moduleName] = opts\n  },\n\n  registeredInstrumentations: Object.create(null),\n\n  /**\n   * NOT FOR USE IN PRODUCTION CODE\n   *\n   * If an instrumented module has a dependency on another instrumented module,\n   * and multiple tests are being run in a single test suite with their own\n   * setup and teardown between tests, it's possible transitive dependencies\n   * will be unwrapped in the module cache in-place (which needs to happen to\n   * prevent stale closures from channeling instrumentation data to incorrect\n   * agents, but which means the transitive dependencies won't get re-wrapped\n   * the next time the parent module is required).\n   *\n   * Since this only applies in test code, it's not worth the drastic\n   * monkeypatching to Module necessary to walk the list of child modules and\n   * re-wrap them.\n   *\n   * Use this to re-apply any applicable instrumentation.\n   */\n  reinstrument: function reinstrument(agent, modulePath) {\n    return _postLoad(agent, require(modulePath), modulePath)\n  },\n\n  /**\n   * Given a NodeJS module name, return the name/identifier of our\n   * instrumentation.  These two things are usually, but not always,\n   * the same.\n   */\n  getInstrumentationNameFromModuleName(moduleName) {\n    var instrumentation\n    // XXX When updating these special cases, also update `uninstrumented`.\n    // To allow for instrumenting both 'pg' and 'pg.js'.\n    if (moduleName === 'pg.js') {\n      instrumentation = 'pg'\n    } if (moduleName === 'mysql2') {\n      // mysql2 (https://github.com/sidorares/node-mysql2) is a drop in replacement for\n      // mysql which conforms to the existing mysql API. If we see mysql2, treat it as\n      // mysql\n      instrumentation = 'mysql'\n    } else {\n      instrumentation = moduleName\n    }\n    return instrumentation\n  }\n}\n"]},"metadata":{},"sourceType":"script"}