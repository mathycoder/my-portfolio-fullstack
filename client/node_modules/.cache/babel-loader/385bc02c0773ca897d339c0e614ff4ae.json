{"ast":null,"code":"'use strict';\n\nconst _require = require('../../config/attribute-filter'),\n      DESTINATIONS = _require.DESTINATIONS;\n\nconst logger = require('../../logger').child({\n  component: 'segment'\n});\n\nconst Timer = require('../../timer');\n\nconst urltils = require('../../util/urltils');\n\nconst hashes = require('../../util/hashes');\n\nconst Attributes = require('../../attributes');\n\nconst ExclusiveCalculator = require('./exclusive-time-calculator');\n\nconst NAMES = require('../../metrics/names');\n\nconst INSTANCE_UNKNOWN = 'unknown';\nconst STATE = {\n  EXTERNAL: 'EXTERNAL',\n  CALLBACK: 'CALLBACK'\n};\nconst ATTRIBUTE_SCOPE = 'segment';\n/**\n * Initializes the segment and binds the recorder to itself, if provided.\n *\n * @constructor\n * @classdesc\n * TraceSegments are inserted to track instrumented function calls. Each one is\n * bound to a transaction, given a name (used only internally to the framework\n * for now), and has one or more children (that are also part of the same\n * transaction), as well as an associated timer.\n *\n * @param {Transaction} transaction\n *  The transaction to which this segment will be bound.\n *\n * @param {string} name\n *  Human-readable name for this segment (e.g. 'http', 'net', 'express',\n *  'mysql', etc).\n *\n * @param {?function} recorder\n *  Callback that takes a segment and a scope name as attributes (intended to be\n *  used to record metrics related to the segment).\n */\n\nfunction TraceSegment(transaction, name, recorder) {\n  this.name = name;\n  this.transaction = transaction;\n  ++transaction.numSegments;\n  ++transaction.agent.totalActiveSegments;\n  ++transaction.agent.segmentsCreatedInHarvest;\n\n  if (recorder) {\n    transaction.addRecorder(recorder.bind(null, this));\n  }\n\n  this.attributes = new Attributes(ATTRIBUTE_SCOPE);\n  this.children = []; // Generate a unique id for use in span events.\n\n  this.id = hashes.makeId();\n  this.timer = new Timer();\n  this.internal = false;\n  this.opaque = false;\n  this.shim = null; // hidden class optimization\n\n  this.partialName = null;\n  this._exclusiveDuration = null;\n  this._collect = true;\n  this.host = null;\n  this.port = null;\n  this.state = STATE.EXTERNAL;\n  this.async = true;\n  this.ignore = false;\n  this.probe('new TraceSegment');\n}\n\nTraceSegment.prototype.addAttribute = function addAttribute(key, value, truncateExempt = false) {\n  this.attributes.addAttribute(DESTINATIONS.SEGMENT_SCOPE, key, value, truncateExempt);\n};\n\nTraceSegment.prototype.getAttributes = function getAttributes() {\n  return this.attributes.get(DESTINATIONS.TRANS_SEGMENT);\n};\n\nTraceSegment.prototype.getSpanId = function getSpanId() {\n  const conf = this.transaction.agent.config;\n  const enabled = conf.span_events.enabled && conf.distributed_tracing.enabled;\n\n  if (enabled) {\n    return this.id;\n  }\n\n  return null;\n};\n/**\n * @param {string} host\n *  The name of the host of the database. This will be normalized if the string\n *  represents localhost.\n *\n * @param {string|number} port\n *  The database's port, path to unix socket, or id.\n *\n * @param {string|number|bool} database\n *  The name or ID of the database that was connected to. Or `false` if there is\n *  no database name (i.e. Redis has no databases, only hosts).\n */\n\n\nTraceSegment.prototype.captureDBInstanceAttributes = captureDBInstanceAttributes;\n\nfunction captureDBInstanceAttributes(host, port, database) {\n  var config = this.transaction.agent.config;\n  var dsTracerConf = config.datastore_tracer; // Add database name if provided and enabled.\n\n  if (database !== false && dsTracerConf.database_name_reporting.enabled) {\n    this.addAttribute('database_name', typeof database === 'number' ? database : database || INSTANCE_UNKNOWN);\n  } // Add instance information if enabled.\n\n\n  if (dsTracerConf.instance_reporting.enabled) {\n    // Determine appropriate defaults for host and port.\n    port = port || INSTANCE_UNKNOWN;\n\n    if (host && urltils.isLocalhost(host)) {\n      host = config.getHostnameSafe(host);\n    }\n\n    if (!host || host === 'UNKNOWN_BOX') {\n      // Config's default name of a host.\n      host = INSTANCE_UNKNOWN;\n    }\n\n    this.addAttribute('host', host);\n    this.addAttribute('port_path_or_id', String(port));\n  }\n}\n\nTraceSegment.prototype.moveToCallbackState = function moveToCallbackState() {\n  this.state = STATE.CALLBACK;\n};\n\nTraceSegment.prototype.isInCallbackState = function isInCallbackState() {\n  return this.state === STATE.CALLBACK;\n};\n\nTraceSegment.prototype.probe = function probe(action) {\n  if (this.transaction.traceStacks) {\n    this.transaction.probe(action, {\n      segment: this.name\n    });\n  }\n};\n/**\n * For use when a transaction is ending.  The transaction segment should\n * be named after the transaction it belongs to (which is only known by\n * the end).\n */\n\n\nTraceSegment.prototype.setNameFromTransaction = function setNameFromTransaction() {\n  var transaction = this.transaction; // transaction name and transaciton segment name must match\n\n  this.name = transaction.getFullName(); // partialName is used to name apdex metrics when recording\n\n  this.partialName = transaction._partialName;\n};\n/**\n * Once a transaction is named, the web segment also needs to be updated to\n * match it (which implies this method must be called subsequent to\n * transaction.finalizeNameFromUri). To properly name apdex metrics during metric\n * recording, it's also necessary to copy the transaction's partial name. And\n * finally, marking the trace segment as being a web segment copies the\n * segment's parameters onto the transaction.\n */\n\n\nTraceSegment.prototype.markAsWeb = function markAsWeb() {\n  var transaction = this.transaction;\n  this.setNameFromTransaction();\n  var traceAttrs = transaction.trace.attributes.get(DESTINATIONS.TRANS_TRACE);\n  Object.keys(traceAttrs).forEach(key => {\n    if (!this.attributes.has(key)) {\n      this.addAttribute(key, traceAttrs[key]);\n    }\n  });\n};\n/**\n * A segment attached to something evented (such as a database\n * cursor) just finished an action, so set the timer to mark\n * the timer as having a stop time.\n */\n\n\nTraceSegment.prototype.touch = function touch() {\n  this.probe('Touched');\n  this.timer.touch();\n\n  this._updateRootTimer();\n};\n\nTraceSegment.prototype.overwriteDurationInMillis = overwriteDurationInMillis;\n\nfunction overwriteDurationInMillis(duration, start) {\n  this.timer.overwriteDurationInMillis(duration, start);\n}\n\nTraceSegment.prototype.start = function start() {\n  this.timer.begin();\n};\n/**\n * Stop timing the related action.\n */\n\n\nTraceSegment.prototype.end = function end() {\n  if (!this.timer.isActive()) return;\n  this.probe('Ended');\n  this.timer.end();\n\n  this._updateRootTimer();\n};\n\nTraceSegment.prototype.finalize = function finalize() {\n  if (this.timer.softEnd()) {\n    this._updateRootTimer(); // timer.softEnd() returns true if the timer was ended prematurely, so\n    // in that case we can name the segment as truncated\n\n\n    this.name = NAMES.TRUNCATED.PREFIX + this.name;\n  }\n\n  this.addAttribute('nr_exclusive_duration_millis', this.getExclusiveDurationInMillis());\n};\n/**\n * Helper to set the end of the root timer to this segment's root if it is later\n * in time.\n */\n\n\nTraceSegment.prototype._updateRootTimer = function _updateRootTimer() {\n  var root = this.transaction.trace.root;\n\n  if (this.timer.endsAfter(root.timer)) {\n    var newDuration = this.timer.start + this.getDurationInMillis() - root.timer.start;\n    root.overwriteDurationInMillis(newDuration);\n  }\n};\n/**\n * Test to see if underlying timer is still active\n *\n * @returns {boolean} true if no longer active, else false.\n */\n\n\nTraceSegment.prototype._isEnded = function _isEnded() {\n  return !this.timer.isActive() || this.timer.touched;\n};\n/**\n * Add a new segment to a scope implicitly bounded by this segment.\n *\n * @param {string} childName New human-readable name for the segment.\n * @returns {TraceSegment} New nested TraceSegment.\n */\n\n\nTraceSegment.prototype.add = function add(childName, recorder) {\n  if (this.opaque) {\n    logger.trace('Skipping child addition on opaque segment');\n    return this;\n  }\n\n  logger.trace('Adding segment %s to %s in %s', childName, this.name, this.transaction.id);\n  var segment = new TraceSegment(this.transaction, childName, recorder);\n  var config = this.transaction.agent.config;\n\n  if (this.transaction.trace.segmentsSeen++ >= config.max_trace_segments) {\n    segment._collect = false;\n  }\n\n  this.children.push(segment);\n\n  if (config.debug && config.debug.double_linked_transactions) {\n    segment.parent = this;\n  }\n\n  return segment;\n};\n/**\n * Set the duration of the segment explicitly.\n *\n * @param {Number} duration Duration in milliseconds.\n */\n\n\nTraceSegment.prototype.setDurationInMillis = setDurationInMillis;\n\nfunction setDurationInMillis(duration, start) {\n  this.timer.setDurationInMillis(duration, start);\n}\n\nTraceSegment.prototype.getDurationInMillis = function getDurationInMillis() {\n  return this.timer.getDurationInMillis();\n};\n/**\n * Only for testing!\n *\n * @param {number} duration Milliseconds of exclusive duration.\n */\n\n\nTraceSegment.prototype._setExclusiveDurationInMillis = _setExclusiveDurationInMillis;\n\nfunction _setExclusiveDurationInMillis(duration) {\n  this._exclusiveDuration = duration;\n}\n/**\n * The duration of the transaction trace tree that only this level accounts\n * for.\n *\n * @return {integer} The amount of time the trace took, minus any child\n *                   segments, in milliseconds.\n */\n\n\nTraceSegment.prototype.getExclusiveDurationInMillis = getExclusiveDurationInMillis;\n\nfunction getExclusiveDurationInMillis() {\n  if (this._exclusiveDuration == null) {\n    // Calculate the exclusive time for the subtree rooted at `this`\n    const calculator = new ExclusiveCalculator(this);\n    calculator.process();\n  }\n\n  return this._exclusiveDuration;\n}\n\nTraceSegment.prototype.getChildren = function getChildren() {\n  var children = [];\n\n  for (var i = 0, len = this.children.length; i < len; ++i) {\n    if (!this.children[i].ignore) {\n      children.push(this.children[i]);\n    }\n  }\n\n  return children;\n};\n\nTraceSegment.prototype.getCollectedChildren = function getCollectedChildren() {\n  var children = [];\n\n  for (var i = 0, len = this.children.length; i < len; ++i) {\n    if (this.children[i]._collect && !this.children[i].ignore) {\n      children.push(this.children[i]);\n    }\n  }\n\n  return children;\n};\n/**\n * Enumerate the timings of this segment's descendants.\n *\n * @param {Number} end The end of this segment, to keep the calculated\n *                     duration from exceeding the duration of the\n *                     parent. Defaults to Infinity.\n *\n * @returns {Array} Unsorted list of [start, end] pairs, with no pair\n *                  having an end greater than the passed in end time.\n */\n\n\nTraceSegment.prototype._getChildPairs = function _getChildPairs(end) {\n  // quick optimization\n  if (this.children.length < 1) return [];\n  if (!end) end = Infinity;\n  var children = this.getChildren();\n  var childPairs = [];\n\n  while (children.length) {\n    var child = children.pop();\n    var pair = child.timer.toRange();\n    if (pair[0] >= end) continue;\n    children = children.concat(child.getChildren());\n    pair[1] = Math.min(pair[1], end);\n    childPairs.push(pair);\n  }\n\n  return childPairs;\n};\n/**\n * This is perhaps the most poorly-documented element of transaction traces:\n * what do each of the segment representations look like prior to encoding?\n * Spelunking in the code for the other agents has revealed that each child\n * node is an array with the following field in the following order:\n *\n * 0: entry timestamp relative to transaction start time\n * 1: exit timestamp\n * 2: metric name\n * 3: parameters as a name -> value JSON dictionary\n * 4: any child segments\n *\n * Other agents include further fields in this. I haven't gotten to the bottom\n * of all of them (and Ruby, of course, sends marshalled Ruby object), but\n * here's what I know so far:\n *\n * in Java:\n * 5: class name\n * 6: method name\n *\n * in Python:\n * 5: a \"label\"\n *\n * FIXME: I don't know if it makes sense to add custom fields for Node. TBD\n */\n\n\nTraceSegment.prototype.toJSON = function toJSON() {\n  // use depth-first search on the segment tree using stack\n  const resultDest = []; // array of objects relating a segment and the destination for its\n  // serialized data.\n\n  const segmentsToProcess = [{\n    segment: this,\n    destination: resultDest\n  }];\n\n  while (segmentsToProcess.length !== 0) {\n    const _segmentsToProcess$po = segmentsToProcess.pop(),\n          segment = _segmentsToProcess$po.segment,\n          destination = _segmentsToProcess$po.destination;\n\n    const start = segment.timer.startedRelativeTo(segment.transaction.trace.root.timer);\n    const duration = segment.getDurationInMillis();\n    const segmentChildren = segment.getCollectedChildren();\n    const childArray = []; // push serialized data into the specified destination\n\n    destination.push([start, start + duration, segment.name, segment.getAttributes(), childArray]);\n\n    if (segmentChildren.length) {\n      // push the children and the parent's children array into the stack.\n      // to preserve the chronological order of the children, push them\n      // onto the stack backwards (so the first one created is on top).\n      for (var i = segmentChildren.length - 1; i >= 0; --i) {\n        segmentsToProcess.push({\n          segment: segmentChildren[i],\n          destination: childArray\n        });\n      }\n    }\n  } // pull the result out of the array we serialized it into\n\n\n  return resultDest[0];\n};\n\nmodule.exports = TraceSegment;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/transaction/trace/segment.js"],"names":["require","DESTINATIONS","logger","child","component","Timer","urltils","hashes","Attributes","ExclusiveCalculator","NAMES","INSTANCE_UNKNOWN","STATE","EXTERNAL","CALLBACK","ATTRIBUTE_SCOPE","TraceSegment","transaction","name","recorder","numSegments","agent","totalActiveSegments","segmentsCreatedInHarvest","addRecorder","bind","attributes","children","id","makeId","timer","internal","opaque","shim","partialName","_exclusiveDuration","_collect","host","port","state","async","ignore","probe","prototype","addAttribute","key","value","truncateExempt","SEGMENT_SCOPE","getAttributes","get","TRANS_SEGMENT","getSpanId","conf","config","enabled","span_events","distributed_tracing","captureDBInstanceAttributes","database","dsTracerConf","datastore_tracer","database_name_reporting","instance_reporting","isLocalhost","getHostnameSafe","String","moveToCallbackState","isInCallbackState","action","traceStacks","segment","setNameFromTransaction","getFullName","_partialName","markAsWeb","traceAttrs","trace","TRANS_TRACE","Object","keys","forEach","has","touch","_updateRootTimer","overwriteDurationInMillis","duration","start","begin","end","isActive","finalize","softEnd","TRUNCATED","PREFIX","getExclusiveDurationInMillis","root","endsAfter","newDuration","getDurationInMillis","_isEnded","touched","add","childName","segmentsSeen","max_trace_segments","push","debug","double_linked_transactions","parent","setDurationInMillis","_setExclusiveDurationInMillis","calculator","process","getChildren","i","len","length","getCollectedChildren","_getChildPairs","Infinity","childPairs","pop","pair","toRange","concat","Math","min","toJSON","resultDest","segmentsToProcess","destination","startedRelativeTo","segmentChildren","childArray","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {DESTINATIONS} = require('../../config/attribute-filter')\nconst logger = require('../../logger').child({component: 'segment'})\nconst Timer = require('../../timer')\nconst urltils = require('../../util/urltils')\nconst hashes = require('../../util/hashes')\n\nconst Attributes = require('../../attributes')\nconst ExclusiveCalculator = require('./exclusive-time-calculator')\n\nconst NAMES = require('../../metrics/names')\nconst INSTANCE_UNKNOWN = 'unknown'\nconst STATE = {\n  EXTERNAL: 'EXTERNAL',\n  CALLBACK: 'CALLBACK'\n}\nconst ATTRIBUTE_SCOPE = 'segment'\n\n\n/**\n * Initializes the segment and binds the recorder to itself, if provided.\n *\n * @constructor\n * @classdesc\n * TraceSegments are inserted to track instrumented function calls. Each one is\n * bound to a transaction, given a name (used only internally to the framework\n * for now), and has one or more children (that are also part of the same\n * transaction), as well as an associated timer.\n *\n * @param {Transaction} transaction\n *  The transaction to which this segment will be bound.\n *\n * @param {string} name\n *  Human-readable name for this segment (e.g. 'http', 'net', 'express',\n *  'mysql', etc).\n *\n * @param {?function} recorder\n *  Callback that takes a segment and a scope name as attributes (intended to be\n *  used to record metrics related to the segment).\n */\nfunction TraceSegment(transaction, name, recorder) {\n  this.name = name\n  this.transaction = transaction\n\n  ++transaction.numSegments\n  ++transaction.agent.totalActiveSegments\n  ++transaction.agent.segmentsCreatedInHarvest\n\n  if (recorder) {\n    transaction.addRecorder(recorder.bind(null, this))\n  }\n\n  this.attributes = new Attributes(ATTRIBUTE_SCOPE)\n\n  this.children = []\n\n  // Generate a unique id for use in span events.\n  this.id = hashes.makeId()\n  this.timer = new Timer()\n\n  this.internal = false\n  this.opaque = false\n  this.shim = null\n\n  // hidden class optimization\n  this.partialName = null\n  this._exclusiveDuration = null\n  this._collect = true\n  this.host = null\n  this.port = null\n  this.state = STATE.EXTERNAL\n  this.async = true\n  this.ignore = false\n\n  this.probe('new TraceSegment')\n}\n\nTraceSegment.prototype.addAttribute =\nfunction addAttribute(key, value, truncateExempt = false) {\n  this.attributes.addAttribute(\n    DESTINATIONS.SEGMENT_SCOPE,\n    key,\n    value,\n    truncateExempt\n  )\n}\n\nTraceSegment.prototype.getAttributes = function getAttributes() {\n  return this.attributes.get(DESTINATIONS.TRANS_SEGMENT)\n}\n\nTraceSegment.prototype.getSpanId = function getSpanId() {\n  const conf = this.transaction.agent.config\n  const enabled = conf.span_events.enabled && conf.distributed_tracing.enabled\n  if (enabled) {\n    return this.id\n  }\n\n  return null\n}\n\n/**\n * @param {string} host\n *  The name of the host of the database. This will be normalized if the string\n *  represents localhost.\n *\n * @param {string|number} port\n *  The database's port, path to unix socket, or id.\n *\n * @param {string|number|bool} database\n *  The name or ID of the database that was connected to. Or `false` if there is\n *  no database name (i.e. Redis has no databases, only hosts).\n */\nTraceSegment.prototype.captureDBInstanceAttributes = captureDBInstanceAttributes\n\nfunction captureDBInstanceAttributes(host, port, database) {\n  var config = this.transaction.agent.config\n  var dsTracerConf = config.datastore_tracer\n\n  // Add database name if provided and enabled.\n  if (database !== false && dsTracerConf.database_name_reporting.enabled) {\n    this.addAttribute(\n      'database_name',\n      typeof database === 'number' ? database : (database || INSTANCE_UNKNOWN)\n    )\n  }\n\n  // Add instance information if enabled.\n  if (dsTracerConf.instance_reporting.enabled) {\n    // Determine appropriate defaults for host and port.\n    port = port || INSTANCE_UNKNOWN\n    if (host && urltils.isLocalhost(host)) {\n      host = config.getHostnameSafe(host)\n    }\n    if (!host || host === 'UNKNOWN_BOX') { // Config's default name of a host.\n      host = INSTANCE_UNKNOWN\n    }\n\n    this.addAttribute('host', host)\n    this.addAttribute('port_path_or_id', String(port))\n  }\n}\n\nTraceSegment.prototype.moveToCallbackState = function moveToCallbackState() {\n  this.state = STATE.CALLBACK\n}\n\nTraceSegment.prototype.isInCallbackState = function isInCallbackState() {\n  return this.state === STATE.CALLBACK\n}\n\nTraceSegment.prototype.probe = function probe(action) {\n  if (this.transaction.traceStacks) {\n    this.transaction.probe(action, {segment: this.name})\n  }\n}\n\n\n/**\n * For use when a transaction is ending.  The transaction segment should\n * be named after the transaction it belongs to (which is only known by\n * the end).\n */\nTraceSegment.prototype.setNameFromTransaction = function setNameFromTransaction() {\n  var transaction = this.transaction\n\n  // transaction name and transaciton segment name must match\n  this.name = transaction.getFullName()\n\n  // partialName is used to name apdex metrics when recording\n  this.partialName = transaction._partialName\n}\n\n/**\n * Once a transaction is named, the web segment also needs to be updated to\n * match it (which implies this method must be called subsequent to\n * transaction.finalizeNameFromUri). To properly name apdex metrics during metric\n * recording, it's also necessary to copy the transaction's partial name. And\n * finally, marking the trace segment as being a web segment copies the\n * segment's parameters onto the transaction.\n */\nTraceSegment.prototype.markAsWeb = function markAsWeb() {\n  var transaction = this.transaction\n  this.setNameFromTransaction()\n\n  var traceAttrs = transaction.trace.attributes.get(DESTINATIONS.TRANS_TRACE)\n  Object.keys(traceAttrs).forEach((key) => {\n    if (!this.attributes.has(key)) {\n      this.addAttribute(key, traceAttrs[key])\n    }\n  })\n}\n\n/**\n * A segment attached to something evented (such as a database\n * cursor) just finished an action, so set the timer to mark\n * the timer as having a stop time.\n */\nTraceSegment.prototype.touch = function touch() {\n  this.probe('Touched')\n  this.timer.touch()\n  this._updateRootTimer()\n}\n\nTraceSegment.prototype.overwriteDurationInMillis = overwriteDurationInMillis\nfunction overwriteDurationInMillis(duration, start) {\n  this.timer.overwriteDurationInMillis(duration, start)\n}\n\n\nTraceSegment.prototype.start = function start() {\n  this.timer.begin()\n}\n\n/**\n * Stop timing the related action.\n */\nTraceSegment.prototype.end = function end() {\n  if (!this.timer.isActive()) return\n  this.probe('Ended')\n  this.timer.end()\n  this._updateRootTimer()\n}\n\nTraceSegment.prototype.finalize = function finalize() {\n  if (this.timer.softEnd()) {\n    this._updateRootTimer()\n    // timer.softEnd() returns true if the timer was ended prematurely, so\n    // in that case we can name the segment as truncated\n    this.name = NAMES.TRUNCATED.PREFIX + this.name\n  }\n\n  this.addAttribute(\n    'nr_exclusive_duration_millis',\n    this.getExclusiveDurationInMillis()\n  )\n}\n\n/**\n * Helper to set the end of the root timer to this segment's root if it is later\n * in time.\n */\nTraceSegment.prototype._updateRootTimer = function _updateRootTimer() {\n  var root = this.transaction.trace.root\n  if (this.timer.endsAfter(root.timer)) {\n    var newDuration = (\n      this.timer.start +\n      this.getDurationInMillis() -\n      root.timer.start\n    )\n    root.overwriteDurationInMillis(newDuration)\n  }\n}\n\n/**\n * Test to see if underlying timer is still active\n *\n * @returns {boolean} true if no longer active, else false.\n */\nTraceSegment.prototype._isEnded = function _isEnded() {\n  return !this.timer.isActive() || this.timer.touched\n}\n\n/**\n * Add a new segment to a scope implicitly bounded by this segment.\n *\n * @param {string} childName New human-readable name for the segment.\n * @returns {TraceSegment} New nested TraceSegment.\n */\nTraceSegment.prototype.add = function add(childName, recorder) {\n  if (this.opaque) {\n    logger.trace('Skipping child addition on opaque segment')\n    return this\n  }\n  logger.trace('Adding segment %s to %s in %s', childName, this.name, this.transaction.id)\n  var segment = new TraceSegment(this.transaction, childName, recorder)\n  var config = this.transaction.agent.config\n\n  if (this.transaction.trace.segmentsSeen++ >= config.max_trace_segments) {\n    segment._collect = false\n  }\n  this.children.push(segment)\n\n  if (config.debug && config.debug.double_linked_transactions) {\n    segment.parent = this\n  }\n\n  return segment\n}\n\n/**\n * Set the duration of the segment explicitly.\n *\n * @param {Number} duration Duration in milliseconds.\n */\nTraceSegment.prototype.setDurationInMillis = setDurationInMillis\n\nfunction setDurationInMillis(duration, start) {\n  this.timer.setDurationInMillis(duration, start)\n}\n\nTraceSegment.prototype.getDurationInMillis = function getDurationInMillis() {\n  return this.timer.getDurationInMillis()\n}\n\n/**\n * Only for testing!\n *\n * @param {number} duration Milliseconds of exclusive duration.\n */\nTraceSegment.prototype._setExclusiveDurationInMillis = _setExclusiveDurationInMillis\n\nfunction _setExclusiveDurationInMillis(duration) {\n  this._exclusiveDuration = duration\n}\n\n/**\n * The duration of the transaction trace tree that only this level accounts\n * for.\n *\n * @return {integer} The amount of time the trace took, minus any child\n *                   segments, in milliseconds.\n */\nTraceSegment.prototype.getExclusiveDurationInMillis = getExclusiveDurationInMillis\n\nfunction getExclusiveDurationInMillis() {\n  if (this._exclusiveDuration == null) {\n    // Calculate the exclusive time for the subtree rooted at `this`\n    const calculator = new ExclusiveCalculator(this)\n    calculator.process()\n  }\n  return this._exclusiveDuration\n}\n\nTraceSegment.prototype.getChildren = function getChildren() {\n  var children = []\n  for (var i = 0, len = this.children.length; i < len; ++i) {\n    if (!this.children[i].ignore) {\n      children.push(this.children[i])\n    }\n  }\n  return children\n}\n\nTraceSegment.prototype.getCollectedChildren = function getCollectedChildren() {\n  var children = []\n  for (var i = 0, len = this.children.length; i < len; ++i) {\n    if (this.children[i]._collect && !this.children[i].ignore) {\n      children.push(this.children[i])\n    }\n  }\n  return children\n}\n\n/**\n * Enumerate the timings of this segment's descendants.\n *\n * @param {Number} end The end of this segment, to keep the calculated\n *                     duration from exceeding the duration of the\n *                     parent. Defaults to Infinity.\n *\n * @returns {Array} Unsorted list of [start, end] pairs, with no pair\n *                  having an end greater than the passed in end time.\n */\nTraceSegment.prototype._getChildPairs = function _getChildPairs(end) {\n  // quick optimization\n  if (this.children.length < 1) return []\n  if (!end) end = Infinity\n\n  var children = this.getChildren()\n  var childPairs = []\n  while (children.length) {\n    var child = children.pop()\n    var pair = child.timer.toRange()\n\n    if (pair[0] >= end) continue\n\n    children = children.concat(child.getChildren())\n\n    pair[1] = Math.min(pair[1], end)\n    childPairs.push(pair)\n  }\n\n  return childPairs\n}\n\n/**\n * This is perhaps the most poorly-documented element of transaction traces:\n * what do each of the segment representations look like prior to encoding?\n * Spelunking in the code for the other agents has revealed that each child\n * node is an array with the following field in the following order:\n *\n * 0: entry timestamp relative to transaction start time\n * 1: exit timestamp\n * 2: metric name\n * 3: parameters as a name -> value JSON dictionary\n * 4: any child segments\n *\n * Other agents include further fields in this. I haven't gotten to the bottom\n * of all of them (and Ruby, of course, sends marshalled Ruby object), but\n * here's what I know so far:\n *\n * in Java:\n * 5: class name\n * 6: method name\n *\n * in Python:\n * 5: a \"label\"\n *\n * FIXME: I don't know if it makes sense to add custom fields for Node. TBD\n */\nTraceSegment.prototype.toJSON = function toJSON() {\n  // use depth-first search on the segment tree using stack\n  const resultDest = []\n  // array of objects relating a segment and the destination for its\n  // serialized data.\n  const segmentsToProcess = [{\n    segment: this,\n    destination: resultDest\n  }]\n\n  while (segmentsToProcess.length !== 0) {\n    const {segment, destination} = segmentsToProcess.pop()\n\n    const start = segment.timer.startedRelativeTo(segment.transaction.trace.root.timer)\n    const duration = segment.getDurationInMillis()\n\n    const segmentChildren = segment.getCollectedChildren()\n    const childArray = []\n\n    // push serialized data into the specified destination\n    destination.push([\n      start,\n      start + duration,\n      segment.name,\n      segment.getAttributes(),\n      childArray\n    ])\n\n    if (segmentChildren.length) {\n      // push the children and the parent's children array into the stack.\n      // to preserve the chronological order of the children, push them\n      // onto the stack backwards (so the first one created is on top).\n      for (var i = segmentChildren.length - 1; i >= 0; --i) {\n        segmentsToProcess.push({\n          segment: segmentChildren[i],\n          destination: childArray\n        })\n      }\n    }\n  }\n\n  // pull the result out of the array we serialized it into\n  return resultDest[0]\n}\n\nmodule.exports = TraceSegment\n"]},"metadata":{},"sourceType":"script"}