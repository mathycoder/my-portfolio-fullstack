{"ast":null,"code":"'use strict';\n\nvar copy = require('../util/copy');\n\nvar genericRecorder = require('../metrics/recorders/generic');\n\nvar logger = require('../logger').child({\n  component: 'MessageShim'\n});\n\nvar messageTransactionRecorder = require('../metrics/recorders/message-transaction');\n\nvar props = require('../util/properties');\n\nvar TransactionShim = require('./transaction-shim');\n\nvar Shim = require('./shim'); // For Shim.defineProperty\n\n\nvar util = require('util');\n\nvar ATTR_DESTS = require('../config/attribute-filter').DESTINATIONS;\n/**\n * Enumeration of well-known message brokers.\n *\n * @readonly\n * @memberof MessageShim\n * @enum {string}\n */\n\n\nconst LIBRARY_NAMES = {\n  IRONMQ: 'IronMQ',\n  KAFKA: 'Kafka',\n  RABBITMQ: 'RabbitMQ',\n  SNS: 'SNS',\n  SQS: 'SQS'\n};\n/**\n * Mapping of well-known message brokers to their distributed tracing transport\n * type.\n *\n * @private\n * @readonly\n * @enum {string}\n */\n\nconst LIBRARY_TRANSPORT_TYPES = {\n  AMQP: TransactionShim.TRANSPORT_TYPES.AMQP,\n  IronMQ: TransactionShim.TRANSPORT_TYPES.IRONMQ,\n  Kafka: TransactionShim.TRANSPORT_TYPES.KAFKA,\n  RabbitMQ: TransactionShim.TRANSPORT_TYPES.AMQP\n};\n/**\n * Enumeration of possible message broker destination types.\n *\n * @readonly\n * @memberof MessageShim\n * @enum {string}\n */\n\nconst DESTINATION_TYPES = {\n  EXCHANGE: 'Exchange',\n  QUEUE: 'Queue',\n  TOPIC: 'Topic'\n};\n/**\n * Constructs a shim specialized for instrumenting message brokers.\n *\n * @constructor\n * @extends TransactionShim\n * @classdesc\n *  Used for instrumenting message broker client libraries.\n *\n * @param {Agent} agent\n *  The agent this shim will use.\n *\n * @param {string} moduleName\n *  The name of the module being instrumented.\n *\n * @param {string} resolvedName\n *  The full path to the loaded module.\n *\n * @see Shim\n * @see TransactionShim\n */\n\nfunction MessageShim(agent, moduleName, resolvedName) {\n  TransactionShim.call(this, agent, moduleName, resolvedName);\n  this._logger = logger.child({\n    module: moduleName\n  });\n  this._metrics = null;\n  this._transportType = TransactionShim.TRANSPORT_TYPES.UNKNOWN;\n}\n\nmodule.exports = MessageShim;\nutil.inherits(MessageShim, TransactionShim); // Add constants on the shim for message broker libraries.\n\nMessageShim.LIBRARY_NAMES = LIBRARY_NAMES;\nObject.keys(LIBRARY_NAMES).forEach(function defineLibraryEnum(libName) {\n  Shim.defineProperty(MessageShim, libName, LIBRARY_NAMES[libName]);\n  Shim.defineProperty(MessageShim.prototype, libName, LIBRARY_NAMES[libName]);\n}); // Add constants to the shim for message broker destination types.\n\nMessageShim.DESTINATION_TYPES = DESTINATION_TYPES;\nObject.keys(DESTINATION_TYPES).forEach(function defineTypesEnum(type) {\n  Shim.defineProperty(MessageShim, type, DESTINATION_TYPES[type]);\n  Shim.defineProperty(MessageShim.prototype, type, DESTINATION_TYPES[type]);\n});\nMessageShim.prototype.setLibrary = setLibrary;\nMessageShim.prototype.recordProduce = recordProduce;\nMessageShim.prototype.recordConsume = recordConsume;\nMessageShim.prototype.recordPurgeQueue = recordPurgeQueue;\nMessageShim.prototype.recordSubscribedConsume = recordSubscribedConsume; // -------------------------------------------------------------------------- //\n\n/**\n * @callback MessageFunction\n *\n * @summary\n *  Used for determining information about a message either being produced or\n *  consumed.\n *\n * @param {MessageShim} shim\n *  The shim this function was handed to.\n *\n * @param {Function} func\n *  The produce method or message consumer.\n *\n * @param {string} name\n *  The name of the producer or consumer.\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the produce method or consumer.\n *\n * @return {MessageSpec} The specification for the message being produced or\n *  consumed.\n *\n * @see MessageShim#recordProduce\n * @see MessageShim#recordConsume\n */\n\n/**\n * @callback MessageHandlerFunction\n *\n * @summary\n *  A function that is used to extract properties from a consumed message. This\n *  method is handed the results of a consume call. If the consume used a\n *  callback, then this method will receive the arguments to the callback. If\n *  the consume used a promise, then this method will receive the resolved\n *  value.\n *\n * @param {MessageShim} shim\n *  The shim this function was handed to.\n *\n * @param {Function} func\n *  The produce method or message consumer.\n *\n * @param {string} name\n *  The name of the producer or consumer.\n *\n * @param {Array|*} args\n *  Either the arguments for the consumer callback function or the result of\n *  the resolved consume promise, depending on the mode of the instrumented\n *  method.\n *\n * @return {MessageSpec} The extracted properties of the consumed message.\n *\n * @see MessageShim#recordConsume\n */\n\n/**\n * @callback MessageConsumerWrapperFunction\n *\n * @summary\n *  Function that is used to wrap message consumer functions. Used along side\n *  the MessageShim#recordSubscribedConsume API method.\n *\n * @param {MessageShim} shim\n *  The shim this function was handed to.\n *\n * @param {Function} consumer\n *  The message consumer to wrap.\n *\n * @param {string} name\n *  The name of the consumer method.\n *\n * @param {string} queue\n *  The name of the queue this consumer is being subscribed to.\n *\n * @return {Function} The consumer method, possibly wrapped.\n *\n * @see MessageShim#recordSubscribedConsume\n * @see MessageShim#recordConsume\n */\n\n/**\n * @interface MessageSpec\n * @extends RecorderSpec\n *\n * @description\n *  The specification for a message being produced or consumed.\n *\n * @property {string} destinationName\n *  The name of the exchange or queue the message is being produced to or\n *  consumed from.\n *\n * @property {MessageShim.DESTINATION_TYPES} [destinationType=null]\n *  The type of the destination. Defaults to `shim.EXCHANGE`.\n *\n * @property {Object} [headers=null]\n *  A reference to the message headers. On produce, more headers will be added\n *  to this object which should be sent along with the message. On consume,\n *  cross-application headers will be read from this object.\n *\n * @property {string} [routingKey=null]\n *  The routing key for the message. If provided on consume, the routing key\n *  will be added to the transaction attributes as `message.routingKey`.\n *\n * @property {string} [queue=null]\n *  The name of the queue the message was consumed from. If provided on\n *  consume, the queue name will be added to the transaction attributes as\n *  `message.queueName`.\n *\n * @property {string} [parameters.correlation_id]\n *  In AMQP, this should be the correlation Id of the message, if it has one.\n *\n * @property {string} [parameters.reply_to]\n *  In AMQP, this should be the name of the queue to reply to, if the message\n *  has one.\n *\n * @property {MessageHandlerFunction} [messageHandler]\n *  An optional function to extract message properties from a consumed message.\n *  This method is only used in the consume case to pull data from the\n *  retrieved message.\n *\n * @see RecorderSpec\n * @see MessageShim#recordProduce\n * @see MessageShim#recordConsume\n * @see MessageShim.DESTINATION_TYPES\n */\n\n/**\n * @interface MessageSubscribeSpec\n * @extends MessageSpec\n *\n * @description\n *  Specification for message subscriber methods. That is, methods which\n *  register a consumer to start receiving messages.\n *\n * @property {number} consumer\n *  The index of the consumer in the method's arguments. Note that if the\n *  consumer and callback indexes point to the same argument, the argument will\n *  be wrapped as a consumer.\n *\n * @property {MessageHandlerFunction} messageHandler\n *  A function to extract message properties from a consumed message.\n *  This method is only used in the consume case to pull data from the\n *  retrieved message. Its return value is combined with the `MessageSubscribeSpec`\n *  to fully describe the consumed message.\n *\n * @see MessageSpec\n * @see MessageConsumerWrapperFunction\n * @see MessageShim#recordSubscribedConsume\n */\n// -------------------------------------------------------------------------- //\n\n/**\n * Sets the vendor of the message broker being instrumented.\n *\n * This is used to generate the names for metrics and segments. If a string is\n * passed, metric names will be generated using that.\n *\n * @memberof MessageShim.prototype\n *\n * @param {MessageShim.LIBRARY_NAMES|string} library\n *  The name of the message broker library. Use one of the well-known constants\n *  listed in {@link MessageShim.LIBRARY_NAMES} if available for the library.\n *\n * @see MessageShim.LIBRARY_NAMES\n */\n\nfunction setLibrary(library) {\n  this._metrics = {\n    PREFIX: 'MessageBroker/',\n    LIBRARY: library,\n    PRODUCE: 'Produce/',\n    CONSUME: 'Consume/',\n    PURGE: 'Purge/',\n    NAMED: 'Named/',\n    TEMP: 'Temp'\n  };\n\n  if (LIBRARY_TRANSPORT_TYPES[library]) {\n    this._transportType = LIBRARY_TRANSPORT_TYPES[library];\n  }\n\n  this._logger = this._logger.child({\n    library: library\n  });\n  this.logger.trace({\n    metrics: this._metrics\n  }, 'Library metric names set');\n}\n/**\n * Wraps the given properties as message producing methods to be recorded.\n *\n * - `recordProduce(nodule, properties, recordNamer)`\n * - `recordProduce(func, recordNamer)`\n *\n * The resulting wrapped methods will record their executions using the messaging\n * `PRODUCE` metric.\n *\n * @memberof MessageShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {MessageFunction} recordNamer\n *  A function which specifies details of the message.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see MessageSpec\n * @see MessageFunction\n */\n\n\nfunction recordProduce(nodule, properties, recordNamer) {\n  if (this.isFunction(properties)) {\n    // recordProduce(func, recordNamer)\n    recordNamer = properties;\n    properties = null;\n  }\n\n  return this.record(nodule, properties, function recordProd(shim) {\n    var msgDesc = recordNamer.apply(this, arguments);\n\n    if (!msgDesc) {\n      return null;\n    }\n\n    var name = _nameMessageSegment(shim, msgDesc, shim._metrics.PRODUCE);\n\n    if (!shim.agent.config.message_tracer.segment_parameters.enabled) {\n      delete msgDesc.parameters;\n    } else if (msgDesc.routingKey) {\n      msgDesc.parameters = shim.setDefaults(msgDesc.parameters, {\n        routing_key: msgDesc.routingKey\n      });\n    }\n\n    return {\n      name: name,\n      promise: msgDesc.promise || false,\n      callback: msgDesc.callback || null,\n      recorder: genericRecorder,\n      inContext: function generateCATHeaders() {\n        if (msgDesc.headers) {\n          shim.insertCATRequestHeaders(msgDesc.headers, true);\n        }\n      },\n      parameters: msgDesc.parameters || null,\n      opaque: msgDesc.opaque || false\n    };\n  });\n}\n/**\n * Wraps the given properties as message consumers to be recorded.\n *\n * - `recordConsume(nodule, properties, spec)`\n * - `recordConsume(func, spec)`\n *\n * The resulting wrapped methods will record their executions using the messaging\n * `CONSUME` metric, possibly also starting a message transaction. Note that\n * this should wrap the message _consumer_, to record methods which subscribe\n * consumers see {@link MessageShim#recordSubscribedConsume}\n *\n * @memberof MessageShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {MessageSpec|MessageFunction} spec\n *  The spec for the method or a function which returns the details of the\n *  method.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see MessageShim#recordSubscribedConsume\n * @see MessageSpec\n * @see MessageFunction\n */\n\n\nfunction recordConsume(nodule, properties, spec) {\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // recordConsume(func, spec)\n    spec = properties;\n    properties = null;\n  }\n\n  var DEFAULT_SPEC = {\n    destinationName: null,\n    promise: false,\n    callback: null,\n    messageHandler: null\n  };\n\n  if (!this.isFunction(spec)) {\n    spec = this.setDefaults(spec, DEFAULT_SPEC);\n  }\n\n  return this.wrap(nodule, properties, function wrapConsume(shim, fn, fnName) {\n    if (!shim.isFunction(fn)) {\n      shim.logger.debug('Not wrapping %s (%s) as consume', fn, fnName);\n      return fn;\n    }\n\n    return function consumeRecorder() {\n      var parent = shim.getSegment();\n\n      if (!parent || !parent.transaction.isActive()) {\n        shim.logger.trace('Not recording consume, no active transaction.');\n        return fn.apply(this, arguments);\n      } // Process the message args.\n\n\n      var args = shim.argsToArray.apply(shim, arguments);\n      var msgDesc = null;\n\n      if (shim.isFunction(spec)) {\n        msgDesc = spec.call(this, shim, fn, fnName, args);\n        shim.setDefaults(msgDesc, DEFAULT_SPEC);\n      } else {\n        msgDesc = {\n          destinationName: null,\n          callback: spec.callback,\n          promise: spec.promise,\n          messageHandler: spec.messageHandler\n        };\n        var destIdx = shim.normalizeIndex(args.length, spec.destinationName);\n\n        if (destIdx !== null) {\n          msgDesc.destinationName = args[destIdx];\n        }\n      } // Make the segment if we can.\n\n\n      if (!msgDesc) {\n        shim.logger.trace('Not recording consume, no message descriptor.');\n        return fn.apply(this, args);\n      }\n\n      const name = _nameMessageSegment(shim, msgDesc, shim._metrics.CONSUME); // Adds details needed by createSegment when used with a spec\n\n\n      msgDesc.name = name;\n      msgDesc.recorder = genericRecorder;\n      msgDesc.parent = parent;\n      var segment = shim.createSegment(msgDesc);\n      var getParams = shim.agent.config.message_tracer.segment_parameters.enabled;\n      var resHandler = shim.isFunction(msgDesc.messageHandler) ? msgDesc.messageHandler : null;\n      var cbIdx = shim.normalizeIndex(args.length, msgDesc.callback);\n\n      if (cbIdx !== null) {\n        shim.bindCallbackSegment(args, cbIdx, segment); // If we have a callback and a results handler, then wrap the callback so\n        // we can call the results handler and get the message properties.\n\n        if (resHandler) {\n          shim.wrap(args, cbIdx, function wrapCb(shim, cb, cbName) {\n            if (shim.isFunction(cb)) {\n              return function cbWrapper() {\n                var cbArgs = shim.argsToArray.apply(shim, arguments);\n                var msgProps = resHandler.call(this, shim, cb, cbName, cbArgs);\n\n                if (getParams && msgProps && msgProps.parameters) {\n                  shim.copySegmentParameters(segment, msgProps.parameters);\n                }\n\n                return cb.apply(this, arguments);\n              };\n            }\n          });\n        }\n      } // Call the method in the context of our segment.\n\n\n      var ret = shim.applySegment(fn, segment, true, this, args); // Intercept the promise to handle the result.\n\n      if (resHandler && ret && msgDesc.promise && shim.isPromise(ret)) {\n        ret = ret.then(function interceptValue(res) {\n          var msgProps = resHandler.call(this, shim, fn, fnName, res);\n\n          if (getParams && msgProps && msgProps.parameters) {\n            shim.copySegmentParameters(segment, msgProps.parameters);\n          }\n\n          return res;\n        });\n      }\n\n      return ret;\n    };\n  });\n}\n/**\n * Wraps the given properties as queue purging methods.\n *\n * - `recordPurgeQueue(nodule, properties, spec)`\n * - `recordPurgeQueue(func, spec)`\n *\n * @memberof MessageShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {RecorderSpec} spec\n *  The specification for this queue purge method's interface.\n *\n * @param {string} spec.queue\n *  The name of the queue being purged.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see RecorderSpec\n */\n\n\nfunction recordPurgeQueue(nodule, properties, spec) {\n  if (!nodule) {\n    this.logger.debug('Not wrapping non-existent nodule.');\n    return nodule;\n  } // Sort out the parameters.\n\n\n  if (!this.isString(properties) && !this.isArray(properties)) {\n    // recordPurgeQueue(nodule, spec)\n    spec = properties;\n    properties = null;\n  } // Fill the spec with defaults.\n\n\n  var specIsFunction = this.isFunction(spec);\n\n  if (!specIsFunction) {\n    spec = this.setDefaults(spec, {\n      queue: null,\n      callback: null,\n      promise: false,\n      internal: false\n    });\n  }\n\n  return this.record(nodule, properties, function purgeRecorder(shim, fn, name, args) {\n    var descriptor = spec;\n\n    if (specIsFunction) {\n      descriptor = spec.apply(this, arguments);\n    }\n\n    var queue = descriptor.queue;\n\n    if (shim.isNumber(queue)) {\n      var queueIdx = shim.normalizeIndex(args.length, descriptor.queue);\n      queue = args[queueIdx];\n    }\n\n    return {\n      name: _nameMessageSegment(shim, {\n        destinationType: shim.QUEUE,\n        destinationName: queue\n      }, shim._metrics.PURGE),\n      recorder: genericRecorder,\n      callback: descriptor.callback,\n      promise: descriptor.promise,\n      internal: descriptor.internal\n    };\n  });\n}\n/**\n * Wraps the given properties as message subscription methods.\n *\n * - `recordSubscribedConsume(nodule, properties, spec)`\n * - `recordSubscribedConsume(func, spec)`\n *\n * Message subscriber methods are ones used to register a message consumer with\n * the message library. See {@link MessageShim#recordConsume} for recording\n * the consumer itself.\n *\n * Note that unlike most `shim.recordX` methods, this method will call the\n * `spec.wrapper` method even if no transaction is active.\n *\n * @memberof MessageShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {MessageSubscribeSpec} spec\n *  The specification for this subscription method's interface.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see MessageShim#recordConsume\n * @see MessageSubscribeSpec\n */\n\n\nfunction recordSubscribedConsume(nodule, properties, spec) {\n  if (!nodule) {\n    this.logger.debug('Not wrapping non-existent nodule.');\n    return nodule;\n  } // Sort out the parameters.\n\n\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // recordSubscribedConsume(nodule, spec)\n    spec = properties;\n    properties = null;\n  } // Fill the spec with defaults.\n\n\n  spec = this.setDefaults(spec, {\n    name: null,\n    destinationName: null,\n    destinationType: null,\n    consumer: null,\n    callback: null,\n    messageHandler: null,\n    promise: false\n  }); // Make sure our spec has what we need.\n\n  if (!this.isFunction(spec.messageHandler)) {\n    this.logger.debug('spec.messageHandler should be a function');\n    return nodule;\n  } else if (!this.isNumber(spec.consumer)) {\n    this.logger.debug('spec.consumer is required for recordSubscribedConsume');\n    return nodule;\n  }\n\n  var destNameIsArg = this.isNumber(spec.destinationName); // Must wrap the subscribe method independently to ensure that we can wrap\n  // the consumer regardless of transaction state.\n\n  var wrapped = this.wrap(nodule, properties, function wrapSubscribe(shim, fn) {\n    if (!shim.isFunction(fn)) {\n      return fn;\n    }\n\n    return function wrappedSubscribe() {\n      var args = shim.argsToArray.apply(shim, arguments);\n      var queueIdx = shim.normalizeIndex(args.length, spec.queue);\n      var consumerIdx = shim.normalizeIndex(args.length, spec.consumer);\n      var queue = queueIdx === null ? null : args[queueIdx];\n      var destName = null;\n\n      if (destNameIsArg) {\n        var destNameIdx = shim.normalizeIndex(args.length, spec.destinationName);\n\n        if (destNameIdx !== null) {\n          destName = args[destNameIdx];\n        }\n      }\n\n      if (consumerIdx !== null) {\n        args[consumerIdx] = shim.wrap(args[consumerIdx], makeWrapConsumer(queue, destName));\n      }\n\n      return fn.apply(this, args);\n    };\n  }); // Wrap the subscriber with segment creation.\n\n  return this.record(wrapped, properties, function recordSubscribe(shim, fn, name, args) {\n    // Make sure the specified consumer and callback indexes do not overlap.\n    // This could happen for instance if the function signature is\n    // `fn(consumer [, callback])` and specified as `consumer: shim.FIRST`,\n    // `callback: shim.LAST`.\n    var consumerIdx = shim.normalizeIndex(args.length, spec.consumer);\n    var cbIdx = shim.normalizeIndex(args.length, spec.callback);\n\n    if (cbIdx === consumerIdx) {\n      cbIdx = null;\n    }\n\n    return {\n      name: spec.name || name,\n      callback: cbIdx,\n      promise: spec.promise,\n      stream: false,\n      internal: false\n    };\n  });\n\n  function makeWrapConsumer(queue, destinationName) {\n    var msgDescDefaults = copy.shallow(spec);\n\n    if (destNameIsArg && destinationName != null) {\n      msgDescDefaults.destinationName = destinationName;\n    }\n\n    if (queue != null) {\n      msgDescDefaults.queue = queue;\n    }\n\n    return function wrapConsumer(shim, consumer, cName) {\n      if (!shim.isFunction(consumer)) {\n        return consumer;\n      }\n\n      return shim.bindCreateTransaction(function createConsumeTrans() {\n        // If there is no transaction or we're in a pre-existing transaction,\n        // then don't do anything. Note that the latter should never happen.\n        var args = shim.argsToArray.apply(shim, arguments);\n        var tx = shim.tracer.getTransaction();\n\n        if (!tx || tx.baseSegment) {\n          shim.logger.debug({\n            transaction: !!tx\n          }, 'Failed to start message transaction.');\n          return consumer.apply(this, args);\n        }\n\n        var msgDesc = spec.messageHandler.call(this, shim, consumer, cName, args); // If message could not be handled, immediately kill this transaction.\n\n        if (!msgDesc) {\n          shim.logger.debug('No description for message, cancelling transaction.');\n          tx.setForceIgnore(true);\n          tx.end();\n          return consumer.apply(this, args);\n        } // Derive the transaction name.\n\n\n        shim.setDefaults(msgDesc, msgDescDefaults);\n\n        var txName = _nameMessageTransaction(shim, msgDesc);\n\n        tx.setPartialName(txName);\n        tx.baseSegment = shim.createSegment({\n          name: tx.getFullName(),\n          recorder: messageTransactionRecorder\n        }); // Add would-be baseSegment attributes to transaction trace\n\n        for (var key in msgDesc.parameters) {\n          if (props.hasOwn(msgDesc.parameters, key)) {\n            tx.trace.attributes.addAttribute(ATTR_DESTS.NONE, 'message.parameters.' + key, msgDesc.parameters[key]);\n          }\n        } // If we have a routing key, add it to the transaction. Note that it is\n        // camel cased here, but snake cased in the segment parameters.\n\n\n        if (!shim.agent.config.high_security) {\n          if (msgDesc.routingKey) {\n            tx.trace.attributes.addAttribute(ATTR_DESTS.TRANS_COMMON, 'message.routingKey', msgDesc.routingKey);\n          }\n\n          if (shim.isString(msgDesc.queue)) {\n            tx.trace.attributes.addAttribute(ATTR_DESTS.TRANS_COMMON, 'message.queueName', msgDesc.queue);\n          }\n        }\n\n        if (msgDesc.headers) {\n          shim.handleCATHeaders(msgDesc.headers, tx.baseSegment, shim._transportType);\n        }\n\n        shim.logger.trace('Started message transaction %s named %s', tx.id, txName); // Execute the original function and attempt to hook in the transaction\n        // finish.\n\n        var ret = null;\n\n        try {\n          ret = shim.applySegment(consumer, tx.baseSegment, true, this, args);\n        } finally {\n          if (shim.isPromise(ret)) {\n            shim.logger.trace('Got a promise, attaching tx %s ending to promise', tx.id);\n            ret = shim.interceptPromise(ret, endTransaction);\n          } else if (!tx.handledExternally) {\n            // We have no way of knowing when this transaction ended! ABORT!\n            shim.logger.trace('Immediately ending message tx %s', tx.id);\n            setImmediate(endTransaction);\n          }\n        }\n\n        return ret;\n\n        function endTransaction() {\n          tx.finalizeName(null); // Use existing partial name.\n\n          tx.end();\n        }\n      }, {\n        type: shim.MESSAGE,\n        nest: true\n      });\n    };\n  }\n} // -------------------------------------------------------------------------- //\n\n/**\n * Constructs a message segment name from the given message descriptor.\n *\n * @private\n *\n * @param {MessageShim} shim    - The shim the segment will be constructed by.\n * @param {MessageSpec} msgDesc - The message descriptor.\n * @param {string}      action  - Produce or consume?\n *\n * @return {string} The generated name of the message segment.\n */\n\n\nfunction _nameMessageSegment(shim, msgDesc, action) {\n  var name = shim._metrics.PREFIX + shim._metrics.LIBRARY + '/' + (msgDesc.destinationType || shim.EXCHANGE) + '/' + action;\n\n  if (msgDesc.destinationName) {\n    name += shim._metrics.NAMED + msgDesc.destinationName;\n  } else {\n    name += shim._metrics.TEMP;\n  }\n\n  return name;\n}\n\nfunction _nameMessageTransaction(shim, msgDesc) {\n  var name = shim._metrics.LIBRARY + '/' + (msgDesc.destinationType || shim.EXCHANGE) + '/';\n\n  if (msgDesc.destinationName) {\n    name += shim._metrics.NAMED + msgDesc.destinationName;\n  } else {\n    name += shim._metrics.TEMP;\n  }\n\n  return name;\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/shim/message-shim.js"],"names":["copy","require","genericRecorder","logger","child","component","messageTransactionRecorder","props","TransactionShim","Shim","util","ATTR_DESTS","DESTINATIONS","LIBRARY_NAMES","IRONMQ","KAFKA","RABBITMQ","SNS","SQS","LIBRARY_TRANSPORT_TYPES","AMQP","TRANSPORT_TYPES","IronMQ","Kafka","RabbitMQ","DESTINATION_TYPES","EXCHANGE","QUEUE","TOPIC","MessageShim","agent","moduleName","resolvedName","call","_logger","module","_metrics","_transportType","UNKNOWN","exports","inherits","Object","keys","forEach","defineLibraryEnum","libName","defineProperty","prototype","defineTypesEnum","type","setLibrary","recordProduce","recordConsume","recordPurgeQueue","recordSubscribedConsume","library","PREFIX","LIBRARY","PRODUCE","CONSUME","PURGE","NAMED","TEMP","trace","metrics","nodule","properties","recordNamer","isFunction","record","recordProd","shim","msgDesc","apply","arguments","name","_nameMessageSegment","config","message_tracer","segment_parameters","enabled","parameters","routingKey","setDefaults","routing_key","promise","callback","recorder","inContext","generateCATHeaders","headers","insertCATRequestHeaders","opaque","spec","isObject","isArray","DEFAULT_SPEC","destinationName","messageHandler","wrap","wrapConsume","fn","fnName","debug","consumeRecorder","parent","getSegment","transaction","isActive","args","argsToArray","destIdx","normalizeIndex","length","segment","createSegment","getParams","resHandler","cbIdx","bindCallbackSegment","wrapCb","cb","cbName","cbWrapper","cbArgs","msgProps","copySegmentParameters","ret","applySegment","isPromise","then","interceptValue","res","isString","specIsFunction","queue","internal","purgeRecorder","descriptor","isNumber","queueIdx","destinationType","consumer","destNameIsArg","wrapped","wrapSubscribe","wrappedSubscribe","consumerIdx","destName","destNameIdx","makeWrapConsumer","recordSubscribe","stream","msgDescDefaults","shallow","wrapConsumer","cName","bindCreateTransaction","createConsumeTrans","tx","tracer","getTransaction","baseSegment","setForceIgnore","end","txName","_nameMessageTransaction","setPartialName","getFullName","key","hasOwn","attributes","addAttribute","NONE","high_security","TRANS_COMMON","handleCATHeaders","id","interceptPromise","endTransaction","handledExternally","setImmediate","finalizeName","MESSAGE","nest","action"],"mappings":"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","sourcesContent":["'use strict'\n\nvar copy = require('../util/copy')\nvar genericRecorder = require('../metrics/recorders/generic')\nvar logger = require('../logger').child({component: 'MessageShim'})\nvar messageTransactionRecorder = require('../metrics/recorders/message-transaction')\nvar props = require('../util/properties')\nvar TransactionShim = require('./transaction-shim')\nvar Shim = require('./shim') // For Shim.defineProperty\nvar util = require('util')\n\nvar ATTR_DESTS = require('../config/attribute-filter').DESTINATIONS\n\n\n/**\n * Enumeration of well-known message brokers.\n *\n * @readonly\n * @memberof MessageShim\n * @enum {string}\n */\nconst LIBRARY_NAMES = {\n  IRONMQ: 'IronMQ',\n  KAFKA: 'Kafka',\n  RABBITMQ: 'RabbitMQ',\n  SNS: 'SNS',\n  SQS: 'SQS'\n}\n\n/**\n * Mapping of well-known message brokers to their distributed tracing transport\n * type.\n *\n * @private\n * @readonly\n * @enum {string}\n */\nconst LIBRARY_TRANSPORT_TYPES = {\n  AMQP: TransactionShim.TRANSPORT_TYPES.AMQP,\n  IronMQ: TransactionShim.TRANSPORT_TYPES.IRONMQ,\n  Kafka: TransactionShim.TRANSPORT_TYPES.KAFKA,\n  RabbitMQ: TransactionShim.TRANSPORT_TYPES.AMQP\n}\n\n/**\n * Enumeration of possible message broker destination types.\n *\n * @readonly\n * @memberof MessageShim\n * @enum {string}\n */\nconst DESTINATION_TYPES = {\n  EXCHANGE: 'Exchange',\n  QUEUE: 'Queue',\n  TOPIC: 'Topic'\n}\n\n\n/**\n * Constructs a shim specialized for instrumenting message brokers.\n *\n * @constructor\n * @extends TransactionShim\n * @classdesc\n *  Used for instrumenting message broker client libraries.\n *\n * @param {Agent} agent\n *  The agent this shim will use.\n *\n * @param {string} moduleName\n *  The name of the module being instrumented.\n *\n * @param {string} resolvedName\n *  The full path to the loaded module.\n *\n * @see Shim\n * @see TransactionShim\n */\nfunction MessageShim(agent, moduleName, resolvedName) {\n  TransactionShim.call(this, agent, moduleName, resolvedName)\n  this._logger = logger.child({module: moduleName})\n  this._metrics = null\n  this._transportType = TransactionShim.TRANSPORT_TYPES.UNKNOWN\n}\nmodule.exports = MessageShim\nutil.inherits(MessageShim, TransactionShim)\n\n// Add constants on the shim for message broker libraries.\nMessageShim.LIBRARY_NAMES = LIBRARY_NAMES\nObject.keys(LIBRARY_NAMES).forEach(function defineLibraryEnum(libName) {\n  Shim.defineProperty(MessageShim, libName, LIBRARY_NAMES[libName])\n  Shim.defineProperty(MessageShim.prototype, libName, LIBRARY_NAMES[libName])\n})\n\n// Add constants to the shim for message broker destination types.\nMessageShim.DESTINATION_TYPES = DESTINATION_TYPES\nObject.keys(DESTINATION_TYPES).forEach(function defineTypesEnum(type) {\n  Shim.defineProperty(MessageShim, type, DESTINATION_TYPES[type])\n  Shim.defineProperty(MessageShim.prototype, type, DESTINATION_TYPES[type])\n})\n\nMessageShim.prototype.setLibrary = setLibrary\nMessageShim.prototype.recordProduce = recordProduce\nMessageShim.prototype.recordConsume = recordConsume\nMessageShim.prototype.recordPurgeQueue = recordPurgeQueue\nMessageShim.prototype.recordSubscribedConsume = recordSubscribedConsume\n\n// -------------------------------------------------------------------------- //\n\n/**\n * @callback MessageFunction\n *\n * @summary\n *  Used for determining information about a message either being produced or\n *  consumed.\n *\n * @param {MessageShim} shim\n *  The shim this function was handed to.\n *\n * @param {Function} func\n *  The produce method or message consumer.\n *\n * @param {string} name\n *  The name of the producer or consumer.\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the produce method or consumer.\n *\n * @return {MessageSpec} The specification for the message being produced or\n *  consumed.\n *\n * @see MessageShim#recordProduce\n * @see MessageShim#recordConsume\n */\n\n/**\n * @callback MessageHandlerFunction\n *\n * @summary\n *  A function that is used to extract properties from a consumed message. This\n *  method is handed the results of a consume call. If the consume used a\n *  callback, then this method will receive the arguments to the callback. If\n *  the consume used a promise, then this method will receive the resolved\n *  value.\n *\n * @param {MessageShim} shim\n *  The shim this function was handed to.\n *\n * @param {Function} func\n *  The produce method or message consumer.\n *\n * @param {string} name\n *  The name of the producer or consumer.\n *\n * @param {Array|*} args\n *  Either the arguments for the consumer callback function or the result of\n *  the resolved consume promise, depending on the mode of the instrumented\n *  method.\n *\n * @return {MessageSpec} The extracted properties of the consumed message.\n *\n * @see MessageShim#recordConsume\n */\n\n/**\n * @callback MessageConsumerWrapperFunction\n *\n * @summary\n *  Function that is used to wrap message consumer functions. Used along side\n *  the MessageShim#recordSubscribedConsume API method.\n *\n * @param {MessageShim} shim\n *  The shim this function was handed to.\n *\n * @param {Function} consumer\n *  The message consumer to wrap.\n *\n * @param {string} name\n *  The name of the consumer method.\n *\n * @param {string} queue\n *  The name of the queue this consumer is being subscribed to.\n *\n * @return {Function} The consumer method, possibly wrapped.\n *\n * @see MessageShim#recordSubscribedConsume\n * @see MessageShim#recordConsume\n */\n\n/**\n * @interface MessageSpec\n * @extends RecorderSpec\n *\n * @description\n *  The specification for a message being produced or consumed.\n *\n * @property {string} destinationName\n *  The name of the exchange or queue the message is being produced to or\n *  consumed from.\n *\n * @property {MessageShim.DESTINATION_TYPES} [destinationType=null]\n *  The type of the destination. Defaults to `shim.EXCHANGE`.\n *\n * @property {Object} [headers=null]\n *  A reference to the message headers. On produce, more headers will be added\n *  to this object which should be sent along with the message. On consume,\n *  cross-application headers will be read from this object.\n *\n * @property {string} [routingKey=null]\n *  The routing key for the message. If provided on consume, the routing key\n *  will be added to the transaction attributes as `message.routingKey`.\n *\n * @property {string} [queue=null]\n *  The name of the queue the message was consumed from. If provided on\n *  consume, the queue name will be added to the transaction attributes as\n *  `message.queueName`.\n *\n * @property {string} [parameters.correlation_id]\n *  In AMQP, this should be the correlation Id of the message, if it has one.\n *\n * @property {string} [parameters.reply_to]\n *  In AMQP, this should be the name of the queue to reply to, if the message\n *  has one.\n *\n * @property {MessageHandlerFunction} [messageHandler]\n *  An optional function to extract message properties from a consumed message.\n *  This method is only used in the consume case to pull data from the\n *  retrieved message.\n *\n * @see RecorderSpec\n * @see MessageShim#recordProduce\n * @see MessageShim#recordConsume\n * @see MessageShim.DESTINATION_TYPES\n */\n\n/**\n * @interface MessageSubscribeSpec\n * @extends MessageSpec\n *\n * @description\n *  Specification for message subscriber methods. That is, methods which\n *  register a consumer to start receiving messages.\n *\n * @property {number} consumer\n *  The index of the consumer in the method's arguments. Note that if the\n *  consumer and callback indexes point to the same argument, the argument will\n *  be wrapped as a consumer.\n *\n * @property {MessageHandlerFunction} messageHandler\n *  A function to extract message properties from a consumed message.\n *  This method is only used in the consume case to pull data from the\n *  retrieved message. Its return value is combined with the `MessageSubscribeSpec`\n *  to fully describe the consumed message.\n *\n * @see MessageSpec\n * @see MessageConsumerWrapperFunction\n * @see MessageShim#recordSubscribedConsume\n */\n\n// -------------------------------------------------------------------------- //\n\n/**\n * Sets the vendor of the message broker being instrumented.\n *\n * This is used to generate the names for metrics and segments. If a string is\n * passed, metric names will be generated using that.\n *\n * @memberof MessageShim.prototype\n *\n * @param {MessageShim.LIBRARY_NAMES|string} library\n *  The name of the message broker library. Use one of the well-known constants\n *  listed in {@link MessageShim.LIBRARY_NAMES} if available for the library.\n *\n * @see MessageShim.LIBRARY_NAMES\n */\nfunction setLibrary(library) {\n  this._metrics = {\n    PREFIX: 'MessageBroker/',\n    LIBRARY: library,\n    PRODUCE: 'Produce/',\n    CONSUME: 'Consume/',\n    PURGE: 'Purge/',\n    NAMED: 'Named/',\n    TEMP: 'Temp'\n  }\n\n  if (LIBRARY_TRANSPORT_TYPES[library]) {\n    this._transportType = LIBRARY_TRANSPORT_TYPES[library]\n  }\n\n  this._logger = this._logger.child({library: library})\n  this.logger.trace({metrics: this._metrics}, 'Library metric names set')\n}\n\n/**\n * Wraps the given properties as message producing methods to be recorded.\n *\n * - `recordProduce(nodule, properties, recordNamer)`\n * - `recordProduce(func, recordNamer)`\n *\n * The resulting wrapped methods will record their executions using the messaging\n * `PRODUCE` metric.\n *\n * @memberof MessageShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {MessageFunction} recordNamer\n *  A function which specifies details of the message.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see MessageSpec\n * @see MessageFunction\n */\nfunction recordProduce(nodule, properties, recordNamer) {\n  if (this.isFunction(properties)) {\n    // recordProduce(func, recordNamer)\n    recordNamer = properties\n    properties = null\n  }\n\n  return this.record(nodule, properties, function recordProd(shim) {\n    var msgDesc = recordNamer.apply(this, arguments)\n    if (!msgDesc) {\n      return null\n    }\n\n    var name = _nameMessageSegment(shim, msgDesc, shim._metrics.PRODUCE)\n    if (!shim.agent.config.message_tracer.segment_parameters.enabled) {\n      delete msgDesc.parameters\n    } else if (msgDesc.routingKey) {\n      msgDesc.parameters = shim.setDefaults(msgDesc.parameters, {\n        routing_key: msgDesc.routingKey\n      })\n    }\n\n    return {\n      name: name,\n      promise: msgDesc.promise || false,\n      callback: msgDesc.callback || null,\n      recorder: genericRecorder,\n      inContext: function generateCATHeaders() {\n        if (msgDesc.headers) {\n          shim.insertCATRequestHeaders(msgDesc.headers, true)\n        }\n      },\n      parameters: msgDesc.parameters || null,\n      opaque: msgDesc.opaque || false\n    }\n  })\n}\n\n/**\n * Wraps the given properties as message consumers to be recorded.\n *\n * - `recordConsume(nodule, properties, spec)`\n * - `recordConsume(func, spec)`\n *\n * The resulting wrapped methods will record their executions using the messaging\n * `CONSUME` metric, possibly also starting a message transaction. Note that\n * this should wrap the message _consumer_, to record methods which subscribe\n * consumers see {@link MessageShim#recordSubscribedConsume}\n *\n * @memberof MessageShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {MessageSpec|MessageFunction} spec\n *  The spec for the method or a function which returns the details of the\n *  method.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see MessageShim#recordSubscribedConsume\n * @see MessageSpec\n * @see MessageFunction\n */\nfunction recordConsume(nodule, properties, spec) {\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // recordConsume(func, spec)\n    spec = properties\n    properties = null\n  }\n  var DEFAULT_SPEC = {\n    destinationName: null,\n    promise: false,\n    callback: null,\n    messageHandler: null\n  }\n  if (!this.isFunction(spec)) {\n    spec = this.setDefaults(spec, DEFAULT_SPEC)\n  }\n\n  return this.wrap(nodule, properties, function wrapConsume(shim, fn, fnName) {\n    if (!shim.isFunction(fn)) {\n      shim.logger.debug('Not wrapping %s (%s) as consume', fn, fnName)\n      return fn\n    }\n\n    return function consumeRecorder() {\n      var parent = shim.getSegment()\n      if (!parent || !parent.transaction.isActive()) {\n        shim.logger.trace('Not recording consume, no active transaction.')\n        return fn.apply(this, arguments)\n      }\n\n      // Process the message args.\n      var args = shim.argsToArray.apply(shim, arguments)\n      var msgDesc = null\n      if (shim.isFunction(spec)) {\n        msgDesc = spec.call(this, shim, fn, fnName, args)\n        shim.setDefaults(msgDesc, DEFAULT_SPEC)\n      } else {\n        msgDesc = {\n          destinationName: null,\n          callback: spec.callback,\n          promise: spec.promise,\n          messageHandler: spec.messageHandler\n        }\n\n        var destIdx = shim.normalizeIndex(args.length, spec.destinationName)\n        if (destIdx !== null) {\n          msgDesc.destinationName = args[destIdx]\n        }\n      }\n\n      // Make the segment if we can.\n      if (!msgDesc) {\n        shim.logger.trace('Not recording consume, no message descriptor.')\n        return fn.apply(this, args)\n      }\n\n      const name = _nameMessageSegment(shim, msgDesc, shim._metrics.CONSUME)\n\n      // Adds details needed by createSegment when used with a spec\n      msgDesc.name = name\n      msgDesc.recorder = genericRecorder\n      msgDesc.parent = parent\n\n      var segment = shim.createSegment(msgDesc)\n      var getParams = shim.agent.config.message_tracer.segment_parameters.enabled\n      var resHandler = shim.isFunction(msgDesc.messageHandler)\n        ? msgDesc.messageHandler : null\n\n      var cbIdx = shim.normalizeIndex(args.length, msgDesc.callback)\n      if (cbIdx !== null) {\n        shim.bindCallbackSegment(args, cbIdx, segment)\n\n        // If we have a callback and a results handler, then wrap the callback so\n        // we can call the results handler and get the message properties.\n        if (resHandler) {\n          shim.wrap(args, cbIdx, function wrapCb(shim, cb, cbName) {\n            if (shim.isFunction(cb)) {\n              return function cbWrapper() {\n                var cbArgs = shim.argsToArray.apply(shim, arguments)\n                var msgProps = resHandler.call(this, shim, cb, cbName, cbArgs)\n                if (getParams && msgProps && msgProps.parameters) {\n                  shim.copySegmentParameters(segment, msgProps.parameters)\n                }\n\n                return cb.apply(this, arguments)\n              }\n            }\n          })\n        }\n      }\n\n      // Call the method in the context of our segment.\n      var ret = shim.applySegment(fn, segment, true, this, args)\n\n      // Intercept the promise to handle the result.\n      if (resHandler && ret && msgDesc.promise && shim.isPromise(ret)) {\n        ret = ret.then(function interceptValue(res) {\n          var msgProps = resHandler.call(this, shim, fn, fnName, res)\n          if (getParams && msgProps && msgProps.parameters) {\n            shim.copySegmentParameters(segment, msgProps.parameters)\n          }\n          return res\n        })\n      }\n\n      return ret\n    }\n  })\n}\n\n/**\n * Wraps the given properties as queue purging methods.\n *\n * - `recordPurgeQueue(nodule, properties, spec)`\n * - `recordPurgeQueue(func, spec)`\n *\n * @memberof MessageShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {RecorderSpec} spec\n *  The specification for this queue purge method's interface.\n *\n * @param {string} spec.queue\n *  The name of the queue being purged.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see RecorderSpec\n */\nfunction recordPurgeQueue(nodule, properties, spec) {\n  if (!nodule) {\n    this.logger.debug('Not wrapping non-existent nodule.')\n    return nodule\n  }\n\n  // Sort out the parameters.\n  if (!this.isString(properties) && !this.isArray(properties)) {\n    // recordPurgeQueue(nodule, spec)\n    spec = properties\n    properties = null\n  }\n\n  // Fill the spec with defaults.\n  var specIsFunction = this.isFunction(spec)\n  if (!specIsFunction) {\n    spec = this.setDefaults(spec, {\n      queue: null,\n      callback: null,\n      promise: false,\n      internal: false\n    })\n  }\n\n  return this.record(nodule, properties, function purgeRecorder(shim, fn, name, args) {\n    var descriptor = spec\n    if (specIsFunction) {\n      descriptor = spec.apply(this, arguments)\n    }\n\n    var queue = descriptor.queue\n    if (shim.isNumber(queue)) {\n      var queueIdx = shim.normalizeIndex(args.length, descriptor.queue)\n      queue = args[queueIdx]\n    }\n\n    return {\n      name: _nameMessageSegment(shim, {\n        destinationType: shim.QUEUE,\n        destinationName: queue\n      }, shim._metrics.PURGE),\n      recorder: genericRecorder,\n      callback: descriptor.callback,\n      promise: descriptor.promise,\n      internal: descriptor.internal\n    }\n  })\n}\n\n/**\n * Wraps the given properties as message subscription methods.\n *\n * - `recordSubscribedConsume(nodule, properties, spec)`\n * - `recordSubscribedConsume(func, spec)`\n *\n * Message subscriber methods are ones used to register a message consumer with\n * the message library. See {@link MessageShim#recordConsume} for recording\n * the consumer itself.\n *\n * Note that unlike most `shim.recordX` methods, this method will call the\n * `spec.wrapper` method even if no transaction is active.\n *\n * @memberof MessageShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {MessageSubscribeSpec} spec\n *  The specification for this subscription method's interface.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see Shim#record\n * @see MessageShim#recordConsume\n * @see MessageSubscribeSpec\n */\nfunction recordSubscribedConsume(nodule, properties, spec) {\n  if (!nodule) {\n    this.logger.debug('Not wrapping non-existent nodule.')\n    return nodule\n  }\n\n  // Sort out the parameters.\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // recordSubscribedConsume(nodule, spec)\n    spec = properties\n    properties = null\n  }\n\n  // Fill the spec with defaults.\n  spec = this.setDefaults(spec, {\n    name: null,\n    destinationName: null,\n    destinationType: null,\n    consumer: null,\n    callback: null,\n    messageHandler: null,\n    promise: false\n  })\n\n  // Make sure our spec has what we need.\n  if (!this.isFunction(spec.messageHandler)) {\n    this.logger.debug('spec.messageHandler should be a function')\n    return nodule\n  } else if (!this.isNumber(spec.consumer)) {\n    this.logger.debug('spec.consumer is required for recordSubscribedConsume')\n    return nodule\n  }\n\n  var destNameIsArg = this.isNumber(spec.destinationName)\n\n  // Must wrap the subscribe method independently to ensure that we can wrap\n  // the consumer regardless of transaction state.\n  var wrapped = this.wrap(nodule, properties, function wrapSubscribe(shim, fn) {\n    if (!shim.isFunction(fn)) {\n      return fn\n    }\n    return function wrappedSubscribe() {\n      var args = shim.argsToArray.apply(shim, arguments)\n      var queueIdx = shim.normalizeIndex(args.length, spec.queue)\n      var consumerIdx = shim.normalizeIndex(args.length, spec.consumer)\n      var queue = queueIdx === null ? null : args[queueIdx]\n      var destName = null\n\n      if (destNameIsArg) {\n        var destNameIdx = shim.normalizeIndex(args.length, spec.destinationName)\n        if (destNameIdx !== null) {\n          destName = args[destNameIdx]\n        }\n      }\n\n      if (consumerIdx !== null) {\n        args[consumerIdx] = shim.wrap(\n          args[consumerIdx],\n          makeWrapConsumer(queue, destName)\n        )\n      }\n\n      return fn.apply(this, args)\n    }\n  })\n\n  // Wrap the subscriber with segment creation.\n  return this.record(wrapped, properties, function recordSubscribe(shim, fn, name, args) {\n    // Make sure the specified consumer and callback indexes do not overlap.\n    // This could happen for instance if the function signature is\n    // `fn(consumer [, callback])` and specified as `consumer: shim.FIRST`,\n    // `callback: shim.LAST`.\n    var consumerIdx = shim.normalizeIndex(args.length, spec.consumer)\n    var cbIdx = shim.normalizeIndex(args.length, spec.callback)\n    if (cbIdx === consumerIdx) {\n      cbIdx = null\n    }\n\n    return {\n      name: spec.name || name,\n      callback: cbIdx,\n      promise: spec.promise,\n\n      stream: false,\n      internal: false\n    }\n  })\n\n  function makeWrapConsumer(queue, destinationName) {\n    var msgDescDefaults = copy.shallow(spec)\n    if (destNameIsArg && destinationName != null) {\n      msgDescDefaults.destinationName = destinationName\n    }\n    if (queue != null) {\n      msgDescDefaults.queue = queue\n    }\n\n    return function wrapConsumer(shim, consumer, cName) {\n      if (!shim.isFunction(consumer)) {\n        return consumer\n      }\n\n      return shim.bindCreateTransaction(function createConsumeTrans() {\n        // If there is no transaction or we're in a pre-existing transaction,\n        // then don't do anything. Note that the latter should never happen.\n        var args = shim.argsToArray.apply(shim, arguments)\n        var tx = shim.tracer.getTransaction()\n\n        if (!tx || tx.baseSegment) {\n          shim.logger.debug({transaction: !!tx}, 'Failed to start message transaction.')\n          return consumer.apply(this, args)\n        }\n\n        var msgDesc = spec.messageHandler.call(this, shim, consumer, cName, args)\n\n        // If message could not be handled, immediately kill this transaction.\n        if (!msgDesc) {\n          shim.logger.debug('No description for message, cancelling transaction.')\n          tx.setForceIgnore(true)\n          tx.end()\n          return consumer.apply(this, args)\n        }\n\n        // Derive the transaction name.\n        shim.setDefaults(msgDesc, msgDescDefaults)\n        var txName = _nameMessageTransaction(shim, msgDesc)\n        tx.setPartialName(txName)\n        tx.baseSegment = shim.createSegment({\n          name: tx.getFullName(),\n          recorder: messageTransactionRecorder\n        })\n\n        // Add would-be baseSegment attributes to transaction trace\n        for (var key in msgDesc.parameters) {\n          if (props.hasOwn(msgDesc.parameters, key)) {\n            tx.trace.attributes.addAttribute(\n              ATTR_DESTS.NONE,\n              'message.parameters.' + key,\n              msgDesc.parameters[key])\n          }\n        }\n\n        // If we have a routing key, add it to the transaction. Note that it is\n        // camel cased here, but snake cased in the segment parameters.\n        if (!shim.agent.config.high_security) {\n          if (msgDesc.routingKey) {\n            tx.trace.attributes.addAttribute(\n              ATTR_DESTS.TRANS_COMMON,\n              'message.routingKey',\n              msgDesc.routingKey\n            )\n          }\n          if (shim.isString(msgDesc.queue)) {\n            tx.trace.attributes.addAttribute(\n              ATTR_DESTS.TRANS_COMMON,\n              'message.queueName',\n              msgDesc.queue\n            )\n          }\n        }\n        if (msgDesc.headers) {\n          shim.handleCATHeaders(msgDesc.headers, tx.baseSegment, shim._transportType)\n        }\n\n        shim.logger.trace('Started message transaction %s named %s', tx.id, txName)\n\n        // Execute the original function and attempt to hook in the transaction\n        // finish.\n        var ret = null\n        try {\n          ret = shim.applySegment(consumer, tx.baseSegment, true, this, args)\n        } finally {\n          if (shim.isPromise(ret)) {\n            shim.logger.trace('Got a promise, attaching tx %s ending to promise', tx.id)\n            ret = shim.interceptPromise(ret, endTransaction)\n          } else if (!tx.handledExternally) {\n            // We have no way of knowing when this transaction ended! ABORT!\n            shim.logger.trace('Immediately ending message tx %s', tx.id)\n            setImmediate(endTransaction)\n          }\n        }\n\n        return ret\n\n        function endTransaction() {\n          tx.finalizeName(null) // Use existing partial name.\n          tx.end()\n        }\n      }, {\n        type: shim.MESSAGE,\n        nest: true\n      })\n    }\n  }\n}\n\n// -------------------------------------------------------------------------- //\n\n/**\n * Constructs a message segment name from the given message descriptor.\n *\n * @private\n *\n * @param {MessageShim} shim    - The shim the segment will be constructed by.\n * @param {MessageSpec} msgDesc - The message descriptor.\n * @param {string}      action  - Produce or consume?\n *\n * @return {string} The generated name of the message segment.\n */\nfunction _nameMessageSegment(shim, msgDesc, action) {\n  var name =\n    shim._metrics.PREFIX + shim._metrics.LIBRARY + '/' +\n    (msgDesc.destinationType || shim.EXCHANGE) + '/' + action\n\n  if (msgDesc.destinationName) {\n    name += shim._metrics.NAMED + msgDesc.destinationName\n  } else {\n    name += shim._metrics.TEMP\n  }\n\n  return name\n}\n\nfunction _nameMessageTransaction(shim, msgDesc) {\n  var name =\n    shim._metrics.LIBRARY + '/' +\n    (msgDesc.destinationType || shim.EXCHANGE) + '/'\n\n  if (msgDesc.destinationName) {\n    name += shim._metrics.NAMED + msgDesc.destinationName\n  } else {\n    name += shim._metrics.TEMP\n  }\n\n  return name\n}\n"]},"metadata":{},"sourceType":"script"}