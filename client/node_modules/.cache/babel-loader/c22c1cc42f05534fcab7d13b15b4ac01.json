{"ast":null,"code":"'use strict';\n\nconst errorHelper = require('../errors/helper');\n\nvar hashes = require('../util/hashes');\n\nvar logger = require('../logger').child({\n  component: 'transaction'\n});\n\nvar Metrics = require('../metrics');\n\nvar NAMES = require('../metrics/names');\n\nvar NameState = require('./name-state');\n\nvar props = require('../util/properties');\n\nvar Timer = require('../timer');\n\nvar Trace = require('./trace');\n\nvar url = require('url');\n\nvar urltils = require('../util/urltils');\n/*\n *\n * CONSTANTS\n *\n */\n\n\nconst DESTS = require('../config/attribute-filter').DESTINATIONS;\n\nconst FROM_MILLIS = 1e-3;\nconst TYPES = {\n  WEB: 'web',\n  BG: 'bg',\n  MESSAGE: 'message'\n};\n\nconst TYPES_SET = _makeValueSet(TYPES);\n\nconst TYPE_METRICS = {\n  web: NAMES.WEB.RESPONSE_TIME,\n  bg: NAMES.OTHER_TRANSACTION.RESPONSE_TIME,\n  message: NAMES.OTHER_TRANSACTION.MESSAGE\n};\nconst TRANSPORT_TYPES = {\n  AMQP: 'AMQP',\n  HTTP: 'HTTP',\n  HTTPS: 'HTTPS',\n  IRONMQ: 'IronMQ',\n  JMS: 'JMS',\n  KAFKA: 'Kafka',\n  OTHER: 'Other',\n  QUEUE: 'Queue',\n  UNKNOWN: 'Unknown'\n};\n\nconst TRANSPORT_TYPES_SET = _makeValueSet(TRANSPORT_TYPES);\n\nconst REQUIRED_DT_KEYS = ['ty', 'ac', 'ap', 'tr', 'ti'];\n\nconst DTPayload = require('./dt-payload');\n\nconst DTPayloadStub = DTPayload.Stub;\n/**\n * Bundle together the metrics and the trace segment for a single agent\n * transaction.\n *\n * @param {Object} agent The agent.\n */\n\nfunction Transaction(agent) {\n  if (!agent) throw new Error('every transaction must be bound to the agent');\n  this.traceFlag = false;\n\n  if (agent.config.logging.diagnostics) {\n    this.traceStacks = [];\n  } else {\n    this.traceStacks = null;\n  }\n\n  this.agent = agent;\n  this.metrics = new Metrics(agent.config.apdex_t, agent.mapper, agent.metricNameNormalizer);\n  ++agent.activeTransactions;\n  this.numSegments = 0;\n  this.id = hashes.makeId();\n  this.trace = new Trace(this);\n  this.exceptions = [];\n  this.userErrors = [];\n  this.timer = new Timer();\n  this.timer.begin();\n  this._recorders = [];\n  this._intrinsicAttributes = Object.create(null);\n  this._partialName = null; // If handledExternally is set to true the transaction will not ended\n  // automatically, instead it should be ended by user code.\n\n  this.handledExternally = false; // hidden class optimization\n\n  this.catResponseTime = 0;\n  this.error = null;\n  this.forceIgnore = null;\n  this.forceName = null;\n  this.ignore = false;\n  this.incomingCatId = null;\n  this.name = null;\n  this.nameState = new NameState(null, null, null, null);\n  this.pathHashes = [];\n  this.queueTime = 0;\n  this.referringPathHash = null;\n  this.referringTransactionGuid = null;\n  this.invalidIncomingExternalTransaction = false;\n  this.statusCode = null;\n  this.syntheticsHeader = null;\n  this.syntheticsData = null;\n  this.url = null;\n  this.parsedUrl = null;\n  this.verb = null;\n  this.baseSegment = null;\n  this.type = TYPES.WEB; // DT fields\n\n  this.parentId = null;\n  this.parentType = null;\n  this.parentApp = null;\n  this.parentAcct = null;\n  this.parentTransportType = null;\n  this.parentTransportDuration = null;\n  this.traceId = null;\n  this.parentSpanId = null;\n  this.isDistributedTrace = null;\n  this.acceptedDistributedTrace = null; // Lazy evaluate the priority and sampling in case we end up accepting a payload.\n\n  this.priority = null;\n  this.sampled = null;\n  agent.emit('transactionStarted', this);\n  this.probe('Transaction created', {\n    id: this.id\n  });\n}\n\nTransaction.TYPES = TYPES;\nTransaction.TYPES_SET = TYPES_SET;\nTransaction.TRANSPORT_TYPES = TRANSPORT_TYPES;\nTransaction.TRANSPORT_TYPES_SET = TRANSPORT_TYPES_SET;\n\nTransaction.prototype.probe = function probe(action, extra) {\n  if (this.traceStacks) {\n    this.traceStacks.push({\n      stack: new Error(action).stack.split('\\n'),\n      extra: extra\n    });\n  }\n};\n/**\n * Add a clear API method for determining whether a transaction is web or\n * background.\n *\n * @returns {boolean} Whether this transaction has a URL.\n */\n\n\nTransaction.prototype.isWeb = function isWeb() {\n  return this.type === TYPES.WEB;\n};\n/**\n * @return {bool} Is this transaction still alive?\n */\n\n\nTransaction.prototype.isActive = function isActive() {\n  return this.timer.isActive();\n};\n/**\n * Close out the current transaction and its associated trace. Remove any\n * instances of this transaction annotated onto the call stack.\n */\n\n\nTransaction.prototype.end = function end() {\n  if (!this.timer.isActive()) return;\n\n  if (this.traceFlag) {\n    logger.warn({\n      segment: {\n        name: this.name,\n        stacks: this.traceStacks\n      }\n    }, 'Flagged transaction ended.');\n  }\n\n  if (!this.name) {\n    this.finalizeName(null); // Use existing partial name.\n  }\n\n  if (this.baseSegment) {\n    this.baseSegment.touch();\n  }\n\n  this.agent.recordSupportability('Nodejs/Transactions/Segments', this.numSegments);\n\n  this._calculatePriority();\n\n  this.trace.end();\n  this.timer.end(); // recorders must be run before the trace is collected\n\n  if (!this.ignore) {\n    this.record(); // This method currently must be called after all recorders have been fired due\n    // to some of the recorders (namely the db recorders) adding parameters to the\n    // segments.\n\n    this.trace.generateSpanEvents();\n  }\n\n  this.agent.emit('transactionFinished', this);\n  return this;\n};\n/**\n * For web transactions, this represents the time from when the request was received\n * to when response was sent.  For background transactions, it is equal to duration\n * of the transaction trace (until last segment ended).\n */\n\n\nTransaction.prototype.getResponseTimeInMillis = function getResponseTimeInMillis() {\n  if (this.isWeb()) {\n    return this.timer.getDurationInMillis();\n  }\n\n  return this.trace.getDurationInMillis();\n};\n/**\n * Executes the user and server provided naming rules to clean up the given url.\n *\n * @private\n *\n * @param {string} requestUrl - The URL to normalize.\n *\n * @return {object} The normalization results after running user and server rules.\n */\n\n\nTransaction.prototype._runUserNamingRules = function _runUserNamingRules(requestUrl) {\n  // 1. user normalization rules (set in configuration)\n  var normalized = this.agent.userNormalizer.normalize(requestUrl);\n\n  if (normalized.matched) {\n    // After applying user naming rule, apply server-side sent rules to\n    // further squash possible MGIs\n    var serverNormalized = this.agent.urlNormalizer.normalize(normalized.value);\n\n    if (serverNormalized.ignore) {\n      normalized.ignore = true;\n    }\n\n    if (serverNormalized.matched) {\n      // NAMES.NORMALIZED is prepended by the sever rule normalizer\n      normalized.value = serverNormalized.value;\n    } else {\n      normalized.value = NAMES.NORMALIZED + normalized.value;\n    }\n  }\n\n  return normalized;\n};\n/**\n * Executes the user naming rules and applies the results to the transaction.\n *\n * @param {string} requestUrl - The URL to normalize and apply to this transaction.\n */\n\n\nTransaction.prototype.applyUserNamingRules = function applyUserNamingRules(requestUrl) {\n  var normalized = this._runUserNamingRules(requestUrl);\n\n  if (normalized.ignore) {\n    this.ignore = normalized.ignore;\n  }\n\n  if (normalized.matched) {\n    this._partialName = normalized.value;\n  }\n};\n/**\n * Set's the transaction partial name.\n *\n * The partial name is everything after the `WebTransaction/` part.\n *\n * @param {string} name - The new transaction partial name to use.\n */\n\n\nTransaction.prototype.setPartialName = function setPartialName(name) {\n  this._partialName = name;\n};\n/**\n * Derive the transaction partial name from the given url and status code.\n *\n * @private\n *\n * @param {string} requestUrl - The URL to derive the name from.\n * @param {number} status     - The status code of the response.\n *\n * @return {object} An object with the derived partial name in `value` and a\n *  boolean flag in `ignore`.\n */\n\n\nTransaction.prototype._partialNameFromUri = _partialNameFromUri;\n\nfunction _partialNameFromUri(requestUrl, status) {\n  var scrubbedUrl = urltils.scrub(requestUrl); // 0. If there is a name in the name-state stack, use it.\n\n  var partialName = this._partialName;\n  var ignore = false;\n\n  if (!this.nameState.isEmpty()) {\n    partialName = this.nameState.getFullName();\n  } // 1. name set by the api\n\n\n  if (this.forceName !== null) {\n    partialName = this.forceName;\n  } // 2. user normalization rules (set in configuration) can override transaction\n  // naming from API\n\n\n  var userNormalized = this._runUserNamingRules(scrubbedUrl);\n\n  ignore = ignore || userNormalized.ignore;\n\n  if (userNormalized.matched) {\n    partialName = userNormalized.value;\n  } // 3. URL normalization rules (sent by server).\n  // Nothing has already set a name for this transaction, so normalize and\n  // potentially apply the URL backstop now. Only do so if no user rules matched.\n\n\n  if (!partialName) {\n    // avoid polluting root path when 404\n    const statusName = this.nameState.getStatusName(status);\n\n    if (statusName) {\n      partialName = statusName;\n    } else {\n      var normalized = this.agent.urlNormalizer.normalize(scrubbedUrl);\n      ignore = ignore || normalized.ignore;\n      partialName = normalized.value;\n    }\n  }\n\n  return {\n    ignore: ignore,\n    value: partialName\n  };\n}\n/**\n * Set the forceIgnore value on the transaction. This will cause the\n * transaction to clean up after itself without collecting any data.\n *\n * @param {Boolean} ignore The value to assign to  transaction.ignore\n */\n\n\nTransaction.prototype.setForceIgnore = function setForceIgnore(ignore) {\n  if (ignore != null) {\n    this.forceIgnore = ignore;\n  } else {\n    logger.debug(\"Transaction#setForceIgnore called with null value\");\n  }\n};\n/**\n *\n * Gets the current ignore state for the transaction.\n *\n */\n\n\nTransaction.prototype.isIgnored = function getIgnore() {\n  return this.ignore || this.forceIgnore;\n};\n/**\n * Derives the transaction's name from the given URL and status code.\n *\n * The transaction's name will be set after this as well as its ignored status\n * based on the derived name.\n *\n * @param {string} requestURL - The URL to derive the request's name and status from.\n * @param {number} statusCode - The response status code.\n */\n\n\nTransaction.prototype.finalizeNameFromUri = finalizeNameFromUri;\n\nfunction finalizeNameFromUri(requestURL, statusCode) {\n  logger.trace({\n    requestURL: requestURL,\n    statusCode: statusCode,\n    transactionId: this.id,\n    transactionName: this.name\n  }, 'Setting transaction name');\n  this.url = urltils.scrub(requestURL);\n  this.statusCode = statusCode; // Derive the name from the request URL.\n\n  var partialName = this._partialNameFromUri(requestURL, statusCode);\n\n  this._partialName = partialName.value;\n\n  if (partialName.ignore) {\n    this.ignore = true;\n  } // If a namestate stack exists, copy route parameters over to the trace.\n\n\n  if (!this.nameState.isEmpty() && this.baseSegment) {\n    this.nameState.forEachParams(function forEachRouteParams(params) {\n      for (var key in params) {\n        if (props.hasOwn(params, key)) {\n          this.trace.attributes.addAttribute(DESTS.NONE, 'request.parameters.' + key, params[key]);\n        }\n      }\n    }, this);\n  } // Apply transaction name normalization rules (sent by server) to full name.\n\n\n  var fullName = TYPE_METRICS[this.type] + '/' + this._partialName;\n  var normalized = this.agent.transactionNameNormalizer.normalize(fullName);\n\n  if (normalized.ignore) {\n    this.ignore = true;\n  }\n\n  this.name = normalized.value; // 5. transaction segment term normalizer\n\n  this.name = this.agent.txSegmentNormalizer.normalize(this.name).value; // Allow the API to explicitly set the ignored status.\n\n  if (this.forceIgnore !== null) {\n    this.ignore = this.forceIgnore;\n  }\n\n  this.baseSegment && this._markAsWeb(requestURL);\n  logger.trace({\n    transactionId: this.id,\n    transactionName: this.name,\n    ignore: this.ignore\n  }, 'Finished setting transaction name from Uri');\n}\n/**\n * Copies final base segment parameters to trace attributes before reapplying\n * them to the segment.\n *\n * @param {string} rawURL The URL, as it came in, for parameter extraction.\n */\n\n\nTransaction.prototype._markAsWeb = function _markAsWeb(rawURL) {\n  // Because we are assured we have the URL here, lets grab query params.\n  var params = urltils.parseParameters(rawURL);\n\n  for (var key in params) {\n    if (props.hasOwn(params, key)) {\n      this.trace.attributes.addAttribute(DESTS.NONE, 'request.parameters.' + key, params[key]);\n    }\n  }\n\n  this.baseSegment.markAsWeb();\n};\n/**\n * Sets the transaction's name and determines if it will be ignored.\n *\n * @param {string} [name]\n *  Optional. The partial name to use for the finalized transaction. If ommitted\n *  the current partial name is used.\n */\n\n\nTransaction.prototype.finalizeName = function finalizeName(name) {\n  // If no name is given, and this is a web transaction with a url, then\n  // finalize the name using the stored url.\n  if (name == null && this.type === 'web' && this.url) {\n    return this.finalizeNameFromUri(this.url, this.statusCode);\n  }\n\n  this._partialName = this.forceName || name || this._partialName;\n\n  if (!this._partialName) {\n    logger.debug('No name for transaction %s, not finalizing.', this.id);\n    return;\n  }\n\n  var fullName = TYPE_METRICS[this.type] + '/' + this._partialName; // Transaction normalizers run on the full metric name, not the user facing\n  // transaction name.\n\n  var normalized = this.agent.transactionNameNormalizer.normalize(fullName);\n\n  if (normalized.ignore) {\n    this.ignore = true;\n  }\n\n  this.name = normalized.value;\n\n  if (this.forceIgnore !== null) {\n    this.ignore = this.forceIgnore;\n  }\n\n  this.baseSegment && this.baseSegment.setNameFromTransaction();\n  logger.trace({\n    transactionId: this.id,\n    transactionName: this.name,\n    ignore: this.ignore\n  }, 'Finished setting transaction name from string');\n};\n/**\n * Gets the transaction name safely.\n *\n * Gathering the transaction name for WebTransactions is risky complicated\n * business. OtherTransactions (aka background) are much simpler as they are\n * always fully specified by the user at creation time.\n *\n * This has the potential of causing the normalizers run extra times, which can\n * cause extra performance overhead. Once this is refactored we can make the\n * caching better and eliminate this extra overhead. Be mindful of if/when this\n * is called.\n */\n\n\nTransaction.prototype.getName = function getName() {\n  if (this.isWeb() && this.url) {\n    return this._partialNameFromUri(this.url, this.statusCode).value;\n  }\n\n  return this._partialName;\n};\n\nTransaction.prototype.getFullName = function getFullName() {\n  var name = null;\n\n  if (this.forceName) {\n    name = this.forceName;\n  } else if (this.name) {\n    return this.name;\n  } else {\n    name = this.getName();\n  }\n\n  if (!name) {\n    return null;\n  }\n\n  var fullName = TYPE_METRICS[this.type] + '/' + name;\n  return this.agent.transactionNameNormalizer.normalize(fullName).value;\n};\n/**\n * Returns the full URL of the transaction with query, search, or hash portions\n * removed. This is only applicable for web transactions.\n *\n * Caches to ._scrubbedUrl, pulls in from .parsedUrl if it is available,\n * otherwise it will parse .url, store it on .parsedUrl, then scrub the URL and\n * store it in the cache.\n *\n * Returns a string or undefined.\n */\n\n\nTransaction.prototype.getScrubbedUrl = function getScrubbedUrl() {\n  if (!this.isWeb()) return;\n  if (this._scrubbedUrl) return this._scrubbedUrl; // If we don't have a parsedUrl, lets populate it from .url\n\n  if (!this.parsedUrl) {\n    // At time of writing .url should always be set by the time we get here\n    // because that is what .isWeb() checks against. In the future it may be\n    // instead checking a enum or other property so guard ourselves just in\n    // case.\n    if (!this.url) return;\n    this.parsedUrl = url.parse(this.url);\n  }\n\n  var scrubbedParsedUrl = Object.assign(Object.create(null), this.parsedUrl);\n  scrubbedParsedUrl.search = null;\n  scrubbedParsedUrl.query = null;\n  scrubbedParsedUrl.href = null;\n  scrubbedParsedUrl.path = null;\n  scrubbedParsedUrl.hash = null;\n  this._scrubbedUrl = url.format(scrubbedParsedUrl);\n  return this._scrubbedUrl;\n};\n/**\n * The instrumentation associates metrics with the different kinds of trace\n * segments. The metrics recorders are dependent on the transaction name to\n * collect their scoped metrics, and so must wait for the transaction's\n * name to be finalized before the recording process. Segments are only\n * responsible for their own life cycle, so responsibility for understanding\n * when the transaction name has been finalized is handed off to the trace,\n * which for now defers running these recorders until the trace is ended.\n *\n * @param {Function} recorder The callback which records metrics. Takes a\n *                            single parameter, which is the transaction's\n *                            name.\n */\n\n\nTransaction.prototype.addRecorder = function addRecorder(recorder) {\n  this._recorders.push(recorder);\n};\n/**\n * Run the metrics recorders for this trace. If the transaction's name /\n * scope hasn't been set yet, the recorder will be passed an undefined name,\n * and should be written to handle this.\n */\n\n\nTransaction.prototype.record = function record() {\n  var name = this.name;\n\n  for (var i = 0, l = this._recorders.length; i < l; ++i) {\n    this._recorders[i](name);\n  }\n};\n/**\n * Measure the duration of an operation named by a metric, optionally\n * belonging to a scope.\n *\n * @param {string} name The name of the metric to gather.\n * @param {string} scope (optional) Scope to which the metric is bound.\n * @param {number} duration The time taken by the operation, in milliseconds.\n * @param {number} exclusive The time exclusively taken by an operation, and\n *                           not its children.\n */\n\n\nTransaction.prototype.measure = function measure(name, scope, duration, exclusive) {\n  this.metrics.measureMilliseconds(name, scope, duration, exclusive);\n};\n/**\n * Based on the status code and the duration of a web transaction, either\n * mark the transaction as frustrating, or record its time for apdex purposes.\n *\n * @param {string} name     Metric name.\n * @param {number} duration Duration of the transaction, in milliseconds.\n * @param {number} keyApdex A key transaction apdexT, in milliseconds\n *                          (optional).\n */\n\n\nTransaction.prototype._setApdex = function _setApdex(name, duration, keyApdexInMillis) {\n  var apdexStats = this.metrics.getOrCreateApdexMetric(name, null, keyApdexInMillis); // if we have an error-like status code, and all the errors are\n  // expected, we know the status code was caused by an expected\n  // error, so we will not report \"frustrating\".  Otherwise, we\n  // don't know which error triggered the error-like status code,\n  // and will still incrementing frustrating.  If this is an issue,\n  // users can either set a status code as expected, or ignore the\n  // specific error to avoid incrementing to frustrating\n\n  if (urltils.isError(this.agent.config, this.statusCode) && !urltils.isExpectedError(this.agent.config, this.statusCode) && !this.hasOnlyExpectedErrors()) {\n    apdexStats.incrementFrustrating();\n  } else {\n    apdexStats.recordValueInMillis(duration, keyApdexInMillis);\n  }\n};\n/**\n * Store first 10 unique path hashes calculated for a transaction.\n *\n * @param {string} pathHash Path hash\n */\n\n\nTransaction.prototype.pushPathHash = function pushPathHash(pathHash) {\n  if (this.pathHashes.length >= 10 || this.pathHashes.indexOf(pathHash) !== -1) return;\n  this.pathHashes.unshift(pathHash);\n};\n/**\n * Return whether transaction spawned any outbound requests.\n */\n\n\nTransaction.prototype.includesOutboundRequests = function includesOutboundRequests() {\n  return this.pathHashes.length > 0;\n};\n/**\n * Get unique previous path hashes for a transaction. Does not include\n * current path hash.\n */\n\n\nTransaction.prototype.alternatePathHashes = function alternatePathHashes() {\n  var curHash = hashes.calculatePathHash(this.agent.config.applications()[0], this.getFullName(), this.referringPathHash);\n  var altHashes = this.pathHashes.slice();\n  var curIndex = altHashes.indexOf(curHash);\n  if (curIndex !== -1) altHashes.splice(curIndex, 1);\n  return altHashes.length === 0 ? null : altHashes.sort().join(',');\n};\n/**\n * Associate an exception with the transaction.  When the transaction ends,\n * the exception will be collected along with the transaction details.\n *\n * @param {Error}   exception         The exception to be collected.\n * @param {object}  customAttributes  Any custom attributes associated with\n *                                    the request (optional).\n * @param {number}  timestamp         The timestamp for when the exception occurred.\n */\n\n\nTransaction.prototype.addException = _addException;\n\nfunction _addException(exception, customAttributes, timestamp) {\n  this.exceptions.push([exception, customAttributes, timestamp]);\n}\n/**\n * Associate a user error (reported using the noticeError() API) with the transaction.\n * When the transaction ends, the exception will be collected along with the transaction\n * details.\n *\n * @param {Error}   exception         The exception to be collected.\n * @param {object}  customAttributes  Any custom attributes associated with\n *                                    the request (optional).\n * @param {number}  timestamp         The timestamp for when the exception occurred.\n */\n\n\nTransaction.prototype.addUserError = _addUserError;\n\nfunction _addUserError(exception, customAttributes, timestamp) {\n  this.userErrors.push([exception, customAttributes, timestamp]);\n}\n/**\n * Returns true if an error happened during the transaction or if the transaction itself\n * is considered to be an error.\n */\n\n\nTransaction.prototype.hasErrors = function _hasErrors() {\n  var isErroredTransaction = urltils.isError(this.agent.config, this.statusCode);\n  var transactionHasExceptions = this.exceptions.length > 0;\n  var transactionHasuserErrors = this.userErrors.length > 0;\n  return transactionHasExceptions || transactionHasuserErrors || isErroredTransaction;\n};\n/**\n * Returns true if all the errors/exceptions collected so far\n * are expected errors.\n */\n\n\nTransaction.prototype.hasOnlyExpectedErrors = function hasOnlyExpectedErrors() {\n  if (0 === this.exceptions.length) {\n    return false;\n  }\n\n  for (let i = 0; i < this.exceptions.length; i++) {\n    const exception = this.exceptions[i]; // this expection is neither expected nor ignored\n\n    const isUnexpected = !(errorHelper.isExpectedException(this, exception[0], this.agent.config, urltils) || errorHelper.shouldIgnoreError(this, exception[0], this.agent.config));\n\n    if (isUnexpected) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Returns agent intrinsic attribute for this transaction.\n */\n\n\nTransaction.prototype.getIntrinsicAttributes = function getIntrinsicAttributes() {\n  if (!this._intrinsicAttributes.totalTime) {\n    var config = this.agent.config;\n    this._intrinsicAttributes.totalTime = this.trace.getTotalTimeDurationInMillis() * FROM_MILLIS;\n\n    if (config.distributed_tracing.enabled) {\n      this.addDistributedTraceIntrinsics(this._intrinsicAttributes);\n    } else if (config.cross_application_tracer.enabled) {\n      this._intrinsicAttributes.path_hash = hashes.calculatePathHash(config.applications()[0], this.name || this._partialName, this.referringPathHash);\n      this._intrinsicAttributes.trip_id = this.tripId || this.id;\n\n      if (this.referringTransactionGuid) {\n        this._intrinsicAttributes.referring_transaction_guid = this.referringTransactionGuid;\n      }\n\n      if (this.incomingCatId) {\n        this._intrinsicAttributes.client_cross_process_id = this.incomingCatId;\n      }\n    }\n\n    if (this.syntheticsData) {\n      this._intrinsicAttributes.synthetics_resource_id = this.syntheticsData.resourceId;\n      this._intrinsicAttributes.synthetics_job_id = this.syntheticsData.jobId;\n      this._intrinsicAttributes.synthetics_monitor_id = this.syntheticsData.monitorId;\n    }\n  }\n\n  return Object.assign(Object.create(null), this._intrinsicAttributes);\n};\n/**\n * Parses incoming distributed trace header payload.\n *\n * @param {object} payload                - The distributed trace payload to accept.\n * @param {string} [transport='Unknown']  - The transport type that delivered the payload.\n */\n\n\nTransaction.prototype.acceptDistributedTracePayload = acceptDistributedTracePayload;\n\nfunction acceptDistributedTracePayload(payload, transport) {\n  if (!payload) {\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/Ignored/Null');\n    return;\n  }\n\n  if (this.isDistributedTrace) {\n    logger.warn('Already accepted distributed trace payload for transaction %s, ignoring call', this.id);\n\n    if (this.parentId) {\n      this.agent.recordSupportability('DistributedTrace/AcceptPayload/Ignored/Multiple');\n    } else {\n      this.agent.recordSupportability('DistributedTrace/AcceptPayload/Ignored/CreateBeforeAccept');\n    }\n\n    return;\n  }\n\n  const config = this.agent.config;\n  const distTraceEnabled = config.distributed_tracing.enabled;\n  const trustedAccount = config.trusted_account_key || config.account_id;\n\n  if (!distTraceEnabled || !trustedAccount) {\n    logger.debug('Invalid configuration for distributed trace payload, not accepting ' + '(distributed_tracing.enabled: %s, trustKey: %s', distTraceEnabled, trustedAccount);\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/Exception');\n    return;\n  }\n\n  const parsed = this._getParsedPayload(payload);\n\n  if (!parsed) {\n    return;\n  }\n\n  if (!parsed.v || !parsed.d) {\n    if (!parsed.v) {\n      logger.warn('Received a distributed trace payload with no version field', this.id);\n    }\n\n    if (!parsed.d) {\n      logger.warn('Received a distributed trace payload with no data field', this.id);\n    }\n\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/ParseException');\n    return;\n  }\n\n  const majorVersion = parsed.v && typeof parsed.v[0] === 'number' && parsed.v[0];\n\n  if (majorVersion == null) {\n    logger.warn('Invalid distributed trace payload, not accepting');\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/Exception');\n  }\n\n  if (majorVersion > 0) {\n    // TODO: Add DistributedTracePayload class?\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/Ignored/MajorVersion');\n    return;\n  }\n\n  const data = parsed.d;\n\n  if (!data) {\n    logger.warn('No distributed trace data received, not accepting payload');\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/Exception');\n    return;\n  }\n\n  const requiredKeysExist = REQUIRED_DT_KEYS.every(function checkExists(key) {\n    return data[key] != null;\n  }); // Either parentSpanId or parentId are required.\n\n  if (!requiredKeysExist || data.tx == null && data.id == null) {\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/ParseException');\n    return;\n  }\n\n  const trustedAccountKey = data.tk || data.ac;\n\n  if (trustedAccountKey !== trustedAccount) {\n    this.agent.recordSupportability(`DistributedTrace/AcceptPayload/Ignored/UntrustedAccount`);\n    return;\n  }\n\n  transport = TRANSPORT_TYPES_SET[transport] ? transport : 'Unknown';\n  this.parentType = data.ty;\n  this.parentApp = data.ap;\n  this.parentAcct = data.ac;\n  this.parentTransportType = transport;\n  this.parentTransportDuration = Math.max(0, (Date.now() - data.ti) / 1000);\n  this.traceId = data.tr;\n\n  if (data.pr) {\n    this.priority = data.pr;\n    this.sampled = data.sa != null ? data.sa : this.sampled;\n  }\n\n  if (data.tx) {\n    this.parentId = data.tx;\n  }\n\n  if (data.id) {\n    this.parentSpanId = data.id;\n  }\n\n  this.isDistributedTrace = true; // Track if the distributed trace was created through accepting, since\n  // there is potentially no data difference between creation from\n  // Mobile or Browser trace payloads and creation.\n\n  this.acceptedDistributedTrace = true;\n  this.agent.recordSupportability('DistributedTrace/AcceptPayload/Success');\n}\n/**\n * Returns parsed payload object after attempting to decode it from base64,\n * and parsing the JSON string.\n */\n\n\nTransaction.prototype._getParsedPayload = function _getParsedPayload(payload) {\n  let parsed = payload;\n\n  if (typeof payload === 'string') {\n    if (payload.charAt(0) !== '{' && payload.charAt(0) !== '[') {\n      try {\n        payload = Buffer.from(payload, 'base64').toString('utf-8');\n      } catch (err) {\n        logger.warn(err, 'Got unparseable distributed trace payload in transaction %s', this.id);\n        this.agent.recordSupportability('DistributedTrace/AcceptPayload/ParseException');\n        return null;\n      }\n    }\n\n    try {\n      parsed = JSON.parse(payload);\n    } catch (err) {\n      logger.warn(err, 'Failed to parse distributed trace payload in transaction %s', this.id);\n      this.agent.recordSupportability('DistributedTrace/AcceptPayload/ParseException');\n      return null;\n    }\n  }\n\n  return parsed;\n};\n/**\n * Creates a distributed trace payload.\n */\n\n\nTransaction.prototype.createDistributedTracePayload = createDistributedTracePayload;\n\nfunction createDistributedTracePayload() {\n  const config = this.agent.config;\n  const accountId = config.account_id;\n  const appId = config.primary_application_id;\n  const distTraceEnabled = config.distributed_tracing.enabled;\n\n  if (!accountId || !appId || !distTraceEnabled) {\n    logger.debug('Invalid configuration for distributed trace payload ' + '(distributed_tracing.enabled: %s, account_id: %s, application_id: %s) ' + 'in transaction %s', distTraceEnabled, accountId, appId, this.id);\n    return new DTPayloadStub();\n  }\n\n  this._calculatePriority();\n\n  const currSegment = this.agent.tracer.getSegment();\n  const data = {\n    ty: 'App',\n    ac: accountId,\n    ap: appId,\n    tx: this.id,\n    tr: this.getTraceId(),\n    pr: this.priority,\n    sa: this.sampled,\n    ti: Date.now()\n  };\n\n  if (config.span_events.enabled && this.sampled && currSegment) {\n    data.id = currSegment.id;\n  }\n\n  if (config.trusted_account_key && config.trusted_account_key !== accountId) {\n    data.tk = config.trusted_account_key;\n  }\n\n  this.isDistributedTrace = true;\n  this.agent.recordSupportability('DistributedTrace/CreatePayload/Success');\n  return new DTPayload(data);\n}\n/**\n * Adds distributed trace attributes to instrinsics object.\n */\n\n\nTransaction.prototype.addDistributedTraceIntrinsics = addDistributedTraceIntrinsics;\n\nfunction addDistributedTraceIntrinsics(attrs) {\n  this._calculatePriority(); // *always* add these if DT flag is enabled.\n\n\n  attrs.traceId = this.getTraceId();\n  attrs.guid = this.id;\n  attrs.priority = this.priority;\n  attrs.sampled = !!this.sampled; // add the rest only if payload was received\n\n  if (this.parentType) {\n    attrs['parent.type'] = this.parentType;\n  }\n\n  if (this.parentApp) {\n    attrs['parent.app'] = this.parentApp;\n  }\n\n  if (this.parentAcct) {\n    attrs['parent.account'] = this.parentAcct;\n  }\n\n  if (this.parentTransportType) {\n    attrs['parent.transportType'] = this.parentTransportType;\n  }\n\n  if (this.parentTransportDuration != null) {\n    attrs['parent.transportDuration'] = this.parentTransportDuration;\n  }\n}\n\nTransaction.prototype.isSampled = function isSampled() {\n  this._calculatePriority();\n\n  return this.sampled;\n};\n/**\n * Generates a priority for the transaction if it does not have one already.\n */\n\n\nTransaction.prototype._calculatePriority = function _calculatePriority() {\n  if (this.priority === null) {\n    this.priority = Math.random(); // We want to separate the priority roll from the decision roll to\n    // avoid biasing the priority range\n\n    this.sampled = this.agent.transactionSampler.shouldSample(Math.random());\n\n    if (this.sampled) {\n      this.priority += 1;\n    } // Truncate the priority after potentially modifying it to avoid floating\n    // point errors.\n\n\n    this.priority = (this.priority * 1e6 | 0) / 1e6;\n  }\n};\n\nfunction _makeValueSet(obj) {\n  return Object.keys(obj).map(t => obj[t]).reduce(function reduceToMap(o, t) {\n    o[t] = true;\n    return o;\n  }, Object.create(null));\n}\n\nTransaction.prototype.addRequestParameters = addRequestParameters;\n/**\n * Adds request/query parameters to create attributes in the form\n * 'request.parameters.{key}'. These attributes will only be created\n * when 'request.parameters.*' is included in the attribute config.\n * @param {Object.<string, string>} requestParameters\n */\n\nfunction addRequestParameters(requestParameters) {\n  for (var key in requestParameters) {\n    if (props.hasOwn(requestParameters, key)) {\n      this.trace.attributes.addAttribute(DESTS.NONE, 'request.parameters.' + key, requestParameters[key]);\n    }\n  }\n}\n/**\n * Gets the current distributed trace traceId\n */\n\n\nTransaction.prototype.getTraceId = function getTraceId() {\n  return this.traceId || this.id;\n};\n\nmodule.exports = Transaction;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/transaction/index.js"],"names":["errorHelper","require","hashes","logger","child","component","Metrics","NAMES","NameState","props","Timer","Trace","url","urltils","DESTS","DESTINATIONS","FROM_MILLIS","TYPES","WEB","BG","MESSAGE","TYPES_SET","_makeValueSet","TYPE_METRICS","web","RESPONSE_TIME","bg","OTHER_TRANSACTION","message","TRANSPORT_TYPES","AMQP","HTTP","HTTPS","IRONMQ","JMS","KAFKA","OTHER","QUEUE","UNKNOWN","TRANSPORT_TYPES_SET","REQUIRED_DT_KEYS","DTPayload","DTPayloadStub","Stub","Transaction","agent","Error","traceFlag","config","logging","diagnostics","traceStacks","metrics","apdex_t","mapper","metricNameNormalizer","activeTransactions","numSegments","id","makeId","trace","exceptions","userErrors","timer","begin","_recorders","_intrinsicAttributes","Object","create","_partialName","handledExternally","catResponseTime","error","forceIgnore","forceName","ignore","incomingCatId","name","nameState","pathHashes","queueTime","referringPathHash","referringTransactionGuid","invalidIncomingExternalTransaction","statusCode","syntheticsHeader","syntheticsData","parsedUrl","verb","baseSegment","type","parentId","parentType","parentApp","parentAcct","parentTransportType","parentTransportDuration","traceId","parentSpanId","isDistributedTrace","acceptedDistributedTrace","priority","sampled","emit","probe","prototype","action","extra","push","stack","split","isWeb","isActive","end","warn","segment","stacks","finalizeName","touch","recordSupportability","_calculatePriority","record","generateSpanEvents","getResponseTimeInMillis","getDurationInMillis","_runUserNamingRules","requestUrl","normalized","userNormalizer","normalize","matched","serverNormalized","urlNormalizer","value","NORMALIZED","applyUserNamingRules","setPartialName","_partialNameFromUri","status","scrubbedUrl","scrub","partialName","isEmpty","getFullName","userNormalized","statusName","getStatusName","setForceIgnore","debug","isIgnored","getIgnore","finalizeNameFromUri","requestURL","transactionId","transactionName","forEachParams","forEachRouteParams","params","key","hasOwn","attributes","addAttribute","NONE","fullName","transactionNameNormalizer","txSegmentNormalizer","_markAsWeb","rawURL","parseParameters","markAsWeb","setNameFromTransaction","getName","getScrubbedUrl","_scrubbedUrl","parse","scrubbedParsedUrl","assign","search","query","href","path","hash","format","addRecorder","recorder","i","l","length","measure","scope","duration","exclusive","measureMilliseconds","_setApdex","keyApdexInMillis","apdexStats","getOrCreateApdexMetric","isError","isExpectedError","hasOnlyExpectedErrors","incrementFrustrating","recordValueInMillis","pushPathHash","pathHash","indexOf","unshift","includesOutboundRequests","alternatePathHashes","curHash","calculatePathHash","applications","altHashes","slice","curIndex","splice","sort","join","addException","_addException","exception","customAttributes","timestamp","addUserError","_addUserError","hasErrors","_hasErrors","isErroredTransaction","transactionHasExceptions","transactionHasuserErrors","isUnexpected","isExpectedException","shouldIgnoreError","getIntrinsicAttributes","totalTime","getTotalTimeDurationInMillis","distributed_tracing","enabled","addDistributedTraceIntrinsics","cross_application_tracer","path_hash","trip_id","tripId","referring_transaction_guid","client_cross_process_id","synthetics_resource_id","resourceId","synthetics_job_id","jobId","synthetics_monitor_id","monitorId","acceptDistributedTracePayload","payload","transport","distTraceEnabled","trustedAccount","trusted_account_key","account_id","parsed","_getParsedPayload","v","d","majorVersion","data","requiredKeysExist","every","checkExists","tx","trustedAccountKey","tk","ac","ty","ap","Math","max","Date","now","ti","tr","pr","sa","charAt","Buffer","from","toString","err","JSON","createDistributedTracePayload","accountId","appId","primary_application_id","currSegment","tracer","getSegment","getTraceId","span_events","attrs","guid","isSampled","random","transactionSampler","shouldSample","obj","keys","map","t","reduce","reduceToMap","o","addRequestParameters","requestParameters","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errorHelper = require('../errors/helper')\nvar hashes = require('../util/hashes')\nvar logger = require('../logger').child({component: 'transaction'})\nvar Metrics = require('../metrics')\nvar NAMES = require('../metrics/names')\nvar NameState = require('./name-state')\nvar props = require('../util/properties')\nvar Timer = require('../timer')\nvar Trace = require('./trace')\nvar url = require('url')\nvar urltils = require('../util/urltils')\n\n\n/*\n *\n * CONSTANTS\n *\n */\nconst DESTS = require('../config/attribute-filter').DESTINATIONS\nconst FROM_MILLIS = 1e-3\nconst TYPES = {\n  WEB: 'web',\n  BG: 'bg',\n  MESSAGE: 'message'\n}\nconst TYPES_SET = _makeValueSet(TYPES)\nconst TYPE_METRICS = {\n  web: NAMES.WEB.RESPONSE_TIME,\n  bg: NAMES.OTHER_TRANSACTION.RESPONSE_TIME,\n  message: NAMES.OTHER_TRANSACTION.MESSAGE\n}\nconst TRANSPORT_TYPES = {\n  AMQP: 'AMQP',\n  HTTP: 'HTTP',\n  HTTPS: 'HTTPS',\n  IRONMQ: 'IronMQ',\n  JMS: 'JMS',\n  KAFKA: 'Kafka',\n  OTHER: 'Other',\n  QUEUE: 'Queue',\n  UNKNOWN: 'Unknown'\n}\nconst TRANSPORT_TYPES_SET = _makeValueSet(TRANSPORT_TYPES)\nconst REQUIRED_DT_KEYS = ['ty', 'ac', 'ap', 'tr', 'ti']\nconst DTPayload = require('./dt-payload')\nconst DTPayloadStub = DTPayload.Stub\n\n\n/**\n * Bundle together the metrics and the trace segment for a single agent\n * transaction.\n *\n * @param {Object} agent The agent.\n */\nfunction Transaction(agent) {\n  if (!agent) throw new Error('every transaction must be bound to the agent')\n\n  this.traceFlag = false\n  if (agent.config.logging.diagnostics) {\n    this.traceStacks = []\n  } else {\n    this.traceStacks = null\n  }\n\n  this.agent = agent\n  this.metrics = new Metrics(\n    agent.config.apdex_t,\n    agent.mapper,\n    agent.metricNameNormalizer\n  )\n\n  ++agent.activeTransactions\n\n  this.numSegments = 0\n  this.id = hashes.makeId()\n\n  this.trace = new Trace(this)\n  this.exceptions = []\n  this.userErrors = []\n  this.timer = new Timer()\n  this.timer.begin()\n\n  this._recorders = []\n  this._intrinsicAttributes = Object.create(null)\n  this._partialName = null\n\n  // If handledExternally is set to true the transaction will not ended\n  // automatically, instead it should be ended by user code.\n  this.handledExternally = false\n\n  // hidden class optimization\n  this.catResponseTime = 0\n  this.error = null\n  this.forceIgnore = null\n  this.forceName = null\n  this.ignore = false\n  this.incomingCatId = null\n  this.name = null\n  this.nameState = new NameState(null, null, null, null)\n  this.pathHashes = []\n  this.queueTime = 0\n  this.referringPathHash = null\n  this.referringTransactionGuid = null\n  this.invalidIncomingExternalTransaction = false\n  this.statusCode = null\n  this.syntheticsHeader = null\n  this.syntheticsData = null\n  this.url = null\n  this.parsedUrl = null\n  this.verb = null\n  this.baseSegment = null\n  this.type = TYPES.WEB\n  // DT fields\n  this.parentId = null\n  this.parentType = null\n  this.parentApp = null\n  this.parentAcct = null\n  this.parentTransportType = null\n  this.parentTransportDuration = null\n  this.traceId = null\n  this.parentSpanId = null\n  this.isDistributedTrace = null\n  this.acceptedDistributedTrace = null\n\n  // Lazy evaluate the priority and sampling in case we end up accepting a payload.\n  this.priority = null\n  this.sampled = null\n\n  agent.emit('transactionStarted', this)\n  this.probe('Transaction created', {id: this.id})\n}\n\nTransaction.TYPES = TYPES\nTransaction.TYPES_SET = TYPES_SET\nTransaction.TRANSPORT_TYPES = TRANSPORT_TYPES\nTransaction.TRANSPORT_TYPES_SET = TRANSPORT_TYPES_SET\n\nTransaction.prototype.probe = function probe(action, extra) {\n  if (this.traceStacks) {\n    this.traceStacks.push({\n      stack: (new Error(action)).stack.split('\\n'),\n      extra: extra\n    })\n  }\n}\n\n/**\n * Add a clear API method for determining whether a transaction is web or\n * background.\n *\n * @returns {boolean} Whether this transaction has a URL.\n */\nTransaction.prototype.isWeb = function isWeb() {\n  return this.type === TYPES.WEB\n}\n\n/**\n * @return {bool} Is this transaction still alive?\n */\nTransaction.prototype.isActive = function isActive() {\n  return this.timer.isActive()\n}\n\n/**\n * Close out the current transaction and its associated trace. Remove any\n * instances of this transaction annotated onto the call stack.\n */\nTransaction.prototype.end = function end() {\n  if (!this.timer.isActive()) return\n  if (this.traceFlag) {\n    logger.warn(\n      {segment: {name: this.name, stacks: this.traceStacks}},\n      'Flagged transaction ended.'\n    )\n  }\n\n  if (!this.name) {\n    this.finalizeName(null) // Use existing partial name.\n  }\n  if (this.baseSegment) {\n    this.baseSegment.touch()\n  }\n\n  this.agent.recordSupportability('Nodejs/Transactions/Segments', this.numSegments)\n  this._calculatePriority()\n\n  this.trace.end()\n\n  this.timer.end()\n  // recorders must be run before the trace is collected\n  if (!this.ignore) {\n    this.record()\n\n    // This method currently must be called after all recorders have been fired due\n    // to some of the recorders (namely the db recorders) adding parameters to the\n    // segments.\n    this.trace.generateSpanEvents()\n  }\n\n  this.agent.emit('transactionFinished', this)\n  return this\n}\n\n/**\n * For web transactions, this represents the time from when the request was received\n * to when response was sent.  For background transactions, it is equal to duration\n * of the transaction trace (until last segment ended).\n */\nTransaction.prototype.getResponseTimeInMillis = function getResponseTimeInMillis() {\n  if (this.isWeb()) {\n    return this.timer.getDurationInMillis()\n  }\n  return this.trace.getDurationInMillis()\n}\n\n/**\n * Executes the user and server provided naming rules to clean up the given url.\n *\n * @private\n *\n * @param {string} requestUrl - The URL to normalize.\n *\n * @return {object} The normalization results after running user and server rules.\n */\nTransaction.prototype._runUserNamingRules = function _runUserNamingRules(requestUrl) {\n  // 1. user normalization rules (set in configuration)\n  var normalized = this.agent.userNormalizer.normalize(requestUrl)\n  if (normalized.matched) {\n    // After applying user naming rule, apply server-side sent rules to\n    // further squash possible MGIs\n    var serverNormalized = this.agent.urlNormalizer.normalize(normalized.value)\n    if (serverNormalized.ignore) {\n      normalized.ignore = true\n    }\n    if (serverNormalized.matched) {\n      // NAMES.NORMALIZED is prepended by the sever rule normalizer\n      normalized.value = serverNormalized.value\n    } else {\n      normalized.value = NAMES.NORMALIZED + normalized.value\n    }\n  }\n  return normalized\n}\n\n/**\n * Executes the user naming rules and applies the results to the transaction.\n *\n * @param {string} requestUrl - The URL to normalize and apply to this transaction.\n */\nTransaction.prototype.applyUserNamingRules = function applyUserNamingRules(requestUrl) {\n  var normalized = this._runUserNamingRules(requestUrl)\n  if (normalized.ignore) {\n    this.ignore = normalized.ignore\n  }\n  if (normalized.matched) {\n    this._partialName = normalized.value\n  }\n}\n\n/**\n * Set's the transaction partial name.\n *\n * The partial name is everything after the `WebTransaction/` part.\n *\n * @param {string} name - The new transaction partial name to use.\n */\nTransaction.prototype.setPartialName = function setPartialName(name) {\n  this._partialName = name\n}\n\n/**\n * Derive the transaction partial name from the given url and status code.\n *\n * @private\n *\n * @param {string} requestUrl - The URL to derive the name from.\n * @param {number} status     - The status code of the response.\n *\n * @return {object} An object with the derived partial name in `value` and a\n *  boolean flag in `ignore`.\n */\nTransaction.prototype._partialNameFromUri = _partialNameFromUri\nfunction _partialNameFromUri(requestUrl, status) {\n  var scrubbedUrl = urltils.scrub(requestUrl)\n\n  // 0. If there is a name in the name-state stack, use it.\n  var partialName = this._partialName\n  var ignore = false\n  if (!this.nameState.isEmpty()) {\n    partialName = this.nameState.getFullName()\n  }\n\n  // 1. name set by the api\n  if (this.forceName !== null) {\n    partialName = this.forceName\n  }\n\n  // 2. user normalization rules (set in configuration) can override transaction\n  // naming from API\n  var userNormalized = this._runUserNamingRules(scrubbedUrl)\n  ignore = ignore || userNormalized.ignore\n  if (userNormalized.matched) {\n    partialName = userNormalized.value\n  }\n\n  // 3. URL normalization rules (sent by server).\n  // Nothing has already set a name for this transaction, so normalize and\n  // potentially apply the URL backstop now. Only do so if no user rules matched.\n  if (!partialName) {\n    // avoid polluting root path when 404\n    const statusName = this.nameState.getStatusName(status)\n    if (statusName) {\n      partialName = statusName\n    } else {\n      var normalized = this.agent.urlNormalizer.normalize(scrubbedUrl)\n      ignore = ignore || normalized.ignore\n      partialName = normalized.value\n    }\n  }\n\n  return {\n    ignore: ignore,\n    value: partialName\n  }\n}\n\n/**\n * Set the forceIgnore value on the transaction. This will cause the\n * transaction to clean up after itself without collecting any data.\n *\n * @param {Boolean} ignore The value to assign to  transaction.ignore\n */\nTransaction.prototype.setForceIgnore = function setForceIgnore(ignore) {\n  if (ignore != null) {\n    this.forceIgnore = ignore\n  } else {\n    logger.debug(\"Transaction#setForceIgnore called with null value\")\n  }\n}\n\n/**\n *\n * Gets the current ignore state for the transaction.\n *\n */\n\nTransaction.prototype.isIgnored = function getIgnore() {\n  return this.ignore || this.forceIgnore\n}\n\n/**\n * Derives the transaction's name from the given URL and status code.\n *\n * The transaction's name will be set after this as well as its ignored status\n * based on the derived name.\n *\n * @param {string} requestURL - The URL to derive the request's name and status from.\n * @param {number} statusCode - The response status code.\n */\nTransaction.prototype.finalizeNameFromUri = finalizeNameFromUri\nfunction finalizeNameFromUri(requestURL, statusCode) {\n  logger.trace({requestURL: requestURL, statusCode: statusCode, transactionId: this.id,\n    transactionName: this.name}, 'Setting transaction name')\n\n  this.url = urltils.scrub(requestURL)\n  this.statusCode = statusCode\n\n  // Derive the name from the request URL.\n  var partialName = this._partialNameFromUri(requestURL, statusCode)\n  this._partialName = partialName.value\n  if (partialName.ignore) {\n    this.ignore = true\n  }\n\n  // If a namestate stack exists, copy route parameters over to the trace.\n  if (!this.nameState.isEmpty() && this.baseSegment) {\n    this.nameState.forEachParams(function forEachRouteParams(params) {\n      for (var key in params) {\n        if (props.hasOwn(params, key)) {\n          this.trace.attributes.addAttribute(\n            DESTS.NONE,\n            'request.parameters.' + key,\n            params[key]\n          )\n        }\n      }\n    }, this)\n  }\n\n  // Apply transaction name normalization rules (sent by server) to full name.\n  var fullName = TYPE_METRICS[this.type] + '/' + this._partialName\n  var normalized = this.agent.transactionNameNormalizer.normalize(fullName)\n  if (normalized.ignore) {\n    this.ignore = true\n  }\n  this.name = normalized.value\n\n  // 5. transaction segment term normalizer\n  this.name = this.agent.txSegmentNormalizer.normalize(this.name).value\n\n  // Allow the API to explicitly set the ignored status.\n  if (this.forceIgnore !== null) {\n    this.ignore = this.forceIgnore\n  }\n\n  this.baseSegment && this._markAsWeb(requestURL)\n  logger.trace({\n    transactionId: this.id,\n    transactionName: this.name,\n    ignore: this.ignore\n  }, 'Finished setting transaction name from Uri')\n}\n\n/**\n * Copies final base segment parameters to trace attributes before reapplying\n * them to the segment.\n *\n * @param {string} rawURL The URL, as it came in, for parameter extraction.\n */\nTransaction.prototype._markAsWeb = function _markAsWeb(rawURL) {\n  // Because we are assured we have the URL here, lets grab query params.\n  var params = urltils.parseParameters(rawURL)\n  for (var key in params) {\n    if (props.hasOwn(params, key)) {\n      this.trace.attributes.addAttribute(\n        DESTS.NONE,\n        'request.parameters.' + key,\n        params[key]\n      )\n    }\n  }\n  this.baseSegment.markAsWeb()\n}\n\n/**\n * Sets the transaction's name and determines if it will be ignored.\n *\n * @param {string} [name]\n *  Optional. The partial name to use for the finalized transaction. If ommitted\n *  the current partial name is used.\n */\nTransaction.prototype.finalizeName = function finalizeName(name) {\n  // If no name is given, and this is a web transaction with a url, then\n  // finalize the name using the stored url.\n  if (name == null && this.type === 'web' && this.url) {\n    return this.finalizeNameFromUri(this.url, this.statusCode)\n  }\n\n  this._partialName = this.forceName || name || this._partialName\n  if (!this._partialName) {\n    logger.debug('No name for transaction %s, not finalizing.', this.id)\n    return\n  }\n\n  var fullName = TYPE_METRICS[this.type] + '/' + this._partialName\n\n  // Transaction normalizers run on the full metric name, not the user facing\n  // transaction name.\n  var normalized = this.agent.transactionNameNormalizer.normalize(fullName)\n  if (normalized.ignore) {\n    this.ignore = true\n  }\n  this.name = normalized.value\n\n  if (this.forceIgnore !== null) {\n    this.ignore = this.forceIgnore\n  }\n\n  this.baseSegment && this.baseSegment.setNameFromTransaction()\n\n  logger.trace({\n    transactionId: this.id,\n    transactionName: this.name,\n    ignore: this.ignore\n  }, 'Finished setting transaction name from string')\n}\n\n/**\n * Gets the transaction name safely.\n *\n * Gathering the transaction name for WebTransactions is risky complicated\n * business. OtherTransactions (aka background) are much simpler as they are\n * always fully specified by the user at creation time.\n *\n * This has the potential of causing the normalizers run extra times, which can\n * cause extra performance overhead. Once this is refactored we can make the\n * caching better and eliminate this extra overhead. Be mindful of if/when this\n * is called.\n */\nTransaction.prototype.getName = function getName() {\n  if (this.isWeb() && this.url) {\n    return this._partialNameFromUri(this.url, this.statusCode).value\n  }\n  return this._partialName\n}\n\nTransaction.prototype.getFullName = function getFullName() {\n  var name = null\n  if (this.forceName) {\n    name = this.forceName\n  } else if (this.name) {\n    return this.name\n  } else {\n    name = this.getName()\n  }\n\n  if (!name) {\n    return null\n  }\n  var fullName = TYPE_METRICS[this.type] + '/' + name\n  return this.agent.transactionNameNormalizer.normalize(fullName).value\n}\n\n/**\n * Returns the full URL of the transaction with query, search, or hash portions\n * removed. This is only applicable for web transactions.\n *\n * Caches to ._scrubbedUrl, pulls in from .parsedUrl if it is available,\n * otherwise it will parse .url, store it on .parsedUrl, then scrub the URL and\n * store it in the cache.\n *\n * Returns a string or undefined.\n */\nTransaction.prototype.getScrubbedUrl = function getScrubbedUrl() {\n  if (!this.isWeb()) return\n  if (this._scrubbedUrl) return this._scrubbedUrl\n\n  // If we don't have a parsedUrl, lets populate it from .url\n  if (!this.parsedUrl) {\n    // At time of writing .url should always be set by the time we get here\n    // because that is what .isWeb() checks against. In the future it may be\n    // instead checking a enum or other property so guard ourselves just in\n    // case.\n    if (!this.url) return\n    this.parsedUrl = url.parse(this.url)\n  }\n\n  var scrubbedParsedUrl = Object.assign(Object.create(null), this.parsedUrl)\n  scrubbedParsedUrl.search = null\n  scrubbedParsedUrl.query = null\n  scrubbedParsedUrl.href = null\n  scrubbedParsedUrl.path = null\n  scrubbedParsedUrl.hash = null\n\n  this._scrubbedUrl = url.format(scrubbedParsedUrl)\n\n  return this._scrubbedUrl\n}\n\n/**\n * The instrumentation associates metrics with the different kinds of trace\n * segments. The metrics recorders are dependent on the transaction name to\n * collect their scoped metrics, and so must wait for the transaction's\n * name to be finalized before the recording process. Segments are only\n * responsible for their own life cycle, so responsibility for understanding\n * when the transaction name has been finalized is handed off to the trace,\n * which for now defers running these recorders until the trace is ended.\n *\n * @param {Function} recorder The callback which records metrics. Takes a\n *                            single parameter, which is the transaction's\n *                            name.\n */\nTransaction.prototype.addRecorder = function addRecorder(recorder) {\n  this._recorders.push(recorder)\n}\n\n/**\n * Run the metrics recorders for this trace. If the transaction's name /\n * scope hasn't been set yet, the recorder will be passed an undefined name,\n * and should be written to handle this.\n */\nTransaction.prototype.record = function record() {\n  var name = this.name\n  for (var i = 0, l = this._recorders.length; i < l; ++i) {\n    this._recorders[i](name)\n  }\n}\n\n/**\n * Measure the duration of an operation named by a metric, optionally\n * belonging to a scope.\n *\n * @param {string} name The name of the metric to gather.\n * @param {string} scope (optional) Scope to which the metric is bound.\n * @param {number} duration The time taken by the operation, in milliseconds.\n * @param {number} exclusive The time exclusively taken by an operation, and\n *                           not its children.\n */\nTransaction.prototype.measure = function measure(name, scope, duration, exclusive) {\n  this.metrics.measureMilliseconds(name, scope, duration, exclusive)\n}\n\n/**\n * Based on the status code and the duration of a web transaction, either\n * mark the transaction as frustrating, or record its time for apdex purposes.\n *\n * @param {string} name     Metric name.\n * @param {number} duration Duration of the transaction, in milliseconds.\n * @param {number} keyApdex A key transaction apdexT, in milliseconds\n *                          (optional).\n */\nTransaction.prototype._setApdex = function _setApdex(name, duration, keyApdexInMillis) {\n  var apdexStats = this.metrics.getOrCreateApdexMetric(name, null, keyApdexInMillis)\n\n\n  // if we have an error-like status code, and all the errors are\n  // expected, we know the status code was caused by an expected\n  // error, so we will not report \"frustrating\".  Otherwise, we\n  // don't know which error triggered the error-like status code,\n  // and will still incrementing frustrating.  If this is an issue,\n  // users can either set a status code as expected, or ignore the\n  // specific error to avoid incrementing to frustrating\n  if (\n    urltils.isError(this.agent.config, this.statusCode) &&\n    !urltils.isExpectedError(this.agent.config, this.statusCode) &&\n    !this.hasOnlyExpectedErrors()\n  ) {\n    apdexStats.incrementFrustrating()\n  } else {\n    apdexStats.recordValueInMillis(duration, keyApdexInMillis)\n  }\n}\n\n/**\n * Store first 10 unique path hashes calculated for a transaction.\n *\n * @param {string} pathHash Path hash\n */\nTransaction.prototype.pushPathHash = function pushPathHash(pathHash) {\n  if (this.pathHashes.length >= 10 || this.pathHashes.indexOf(pathHash) !== -1) return\n  this.pathHashes.unshift(pathHash)\n}\n\n/**\n * Return whether transaction spawned any outbound requests.\n */\nTransaction.prototype.includesOutboundRequests = function includesOutboundRequests() {\n  return this.pathHashes.length > 0\n}\n\n/**\n * Get unique previous path hashes for a transaction. Does not include\n * current path hash.\n */\nTransaction.prototype.alternatePathHashes = function alternatePathHashes() {\n  var curHash = hashes.calculatePathHash(\n    this.agent.config.applications()[0],\n    this.getFullName(),\n    this.referringPathHash\n  )\n  var altHashes = this.pathHashes.slice()\n  var curIndex = altHashes.indexOf(curHash)\n\n  if (curIndex !== -1) altHashes.splice(curIndex, 1)\n\n  return altHashes.length === 0 ? null : altHashes.sort().join(',')\n}\n\n/**\n * Associate an exception with the transaction.  When the transaction ends,\n * the exception will be collected along with the transaction details.\n *\n * @param {Error}   exception         The exception to be collected.\n * @param {object}  customAttributes  Any custom attributes associated with\n *                                    the request (optional).\n * @param {number}  timestamp         The timestamp for when the exception occurred.\n */\nTransaction.prototype.addException = _addException\n\nfunction _addException(exception, customAttributes, timestamp) {\n  this.exceptions.push([exception, customAttributes, timestamp])\n}\n\n/**\n * Associate a user error (reported using the noticeError() API) with the transaction.\n * When the transaction ends, the exception will be collected along with the transaction\n * details.\n *\n * @param {Error}   exception         The exception to be collected.\n * @param {object}  customAttributes  Any custom attributes associated with\n *                                    the request (optional).\n * @param {number}  timestamp         The timestamp for when the exception occurred.\n */\nTransaction.prototype.addUserError = _addUserError\n\nfunction _addUserError(exception, customAttributes, timestamp) {\n  this.userErrors.push([exception, customAttributes, timestamp])\n}\n\n/**\n * Returns true if an error happened during the transaction or if the transaction itself\n * is considered to be an error.\n */\nTransaction.prototype.hasErrors = function _hasErrors() {\n  var isErroredTransaction = urltils.isError(this.agent.config, this.statusCode)\n  var transactionHasExceptions = this.exceptions.length > 0\n  var transactionHasuserErrors = this.userErrors.length > 0\n  return (transactionHasExceptions || transactionHasuserErrors || isErroredTransaction)\n}\n\n/**\n * Returns true if all the errors/exceptions collected so far\n * are expected errors.\n */\nTransaction.prototype.hasOnlyExpectedErrors = function hasOnlyExpectedErrors() {\n  if (0 === this.exceptions.length) {\n    return false\n  }\n\n  for (let i = 0;i < this.exceptions.length;i++) {\n    const exception = this.exceptions[i]\n    // this expection is neither expected nor ignored\n    const isUnexpected = !(\n      errorHelper.isExpectedException(\n        this,\n        exception[0],\n        this.agent.config,\n        urltils\n      ) ||\n      errorHelper.shouldIgnoreError(\n        this,\n        exception[0],\n        this.agent.config\n      )\n    )\n    if (isUnexpected) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Returns agent intrinsic attribute for this transaction.\n */\nTransaction.prototype.getIntrinsicAttributes = function getIntrinsicAttributes() {\n  if (!this._intrinsicAttributes.totalTime) {\n    var config = this.agent.config\n    this._intrinsicAttributes.totalTime =\n      this.trace.getTotalTimeDurationInMillis() * FROM_MILLIS\n\n    if (config.distributed_tracing.enabled) {\n      this.addDistributedTraceIntrinsics(this._intrinsicAttributes)\n    } else if (config.cross_application_tracer.enabled) {\n      this._intrinsicAttributes.path_hash = hashes.calculatePathHash(\n        config.applications()[0],\n        this.name || this._partialName,\n        this.referringPathHash\n      )\n      this._intrinsicAttributes.trip_id = this.tripId || this.id\n      if (this.referringTransactionGuid) {\n        this._intrinsicAttributes.referring_transaction_guid =\n          this.referringTransactionGuid\n      }\n      if (this.incomingCatId) {\n        this._intrinsicAttributes.client_cross_process_id = this.incomingCatId\n      }\n    }\n\n    if (this.syntheticsData) {\n      this._intrinsicAttributes.synthetics_resource_id = this.syntheticsData.resourceId\n      this._intrinsicAttributes.synthetics_job_id = this.syntheticsData.jobId\n      this._intrinsicAttributes.synthetics_monitor_id = this.syntheticsData.monitorId\n    }\n  }\n  return Object.assign(Object.create(null), this._intrinsicAttributes)\n}\n\n/**\n * Parses incoming distributed trace header payload.\n *\n * @param {object} payload                - The distributed trace payload to accept.\n * @param {string} [transport='Unknown']  - The transport type that delivered the payload.\n */\nTransaction.prototype.acceptDistributedTracePayload = acceptDistributedTracePayload\nfunction acceptDistributedTracePayload(payload, transport) {\n  if (!payload) {\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/Ignored/Null')\n    return\n  }\n\n  if (this.isDistributedTrace) {\n    logger.warn(\n      'Already accepted distributed trace payload for transaction %s, ignoring call',\n      this.id\n    )\n    if (this.parentId) {\n      this.agent.recordSupportability('DistributedTrace/AcceptPayload/Ignored/Multiple')\n    } else {\n      this.agent.recordSupportability(\n        'DistributedTrace/AcceptPayload/Ignored/CreateBeforeAccept'\n      )\n    }\n    return\n  }\n\n  const config = this.agent.config\n  const distTraceEnabled = config.distributed_tracing.enabled\n  const trustedAccount = config.trusted_account_key || config.account_id\n\n  if (!distTraceEnabled || !trustedAccount) {\n    logger.debug(\n      'Invalid configuration for distributed trace payload, not accepting ' +\n      '(distributed_tracing.enabled: %s, trustKey: %s',\n      distTraceEnabled,\n      trustedAccount\n    )\n\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/Exception')\n    return\n  }\n\n  const parsed = this._getParsedPayload(payload)\n\n  if (!parsed) {\n    return\n  }\n\n  if (!parsed.v || !parsed.d) {\n    if (!parsed.v) {\n      logger.warn(\n        'Received a distributed trace payload with no version field',\n        this.id\n      )\n    }\n    if (!parsed.d) {\n      logger.warn(\n        'Received a distributed trace payload with no data field',\n        this.id\n      )\n    }\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/ParseException')\n    return\n  }\n\n  const majorVersion = parsed.v && typeof parsed.v[0] === 'number' && parsed.v[0]\n  if (majorVersion == null) {\n    logger.warn('Invalid distributed trace payload, not accepting')\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/Exception')\n  }\n  if (majorVersion > 0) { // TODO: Add DistributedTracePayload class?\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/Ignored/MajorVersion')\n    return\n  }\n\n  const data = parsed.d\n\n  if (!data) {\n    logger.warn('No distributed trace data received, not accepting payload')\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/Exception')\n    return\n  }\n\n  const requiredKeysExist = REQUIRED_DT_KEYS.every(function checkExists(key) {\n    return data[key] != null\n  })\n  // Either parentSpanId or parentId are required.\n  if (!requiredKeysExist || data.tx == null && data.id == null) {\n    this.agent.recordSupportability('DistributedTrace/AcceptPayload/ParseException')\n    return\n  }\n\n  const trustedAccountKey = data.tk || data.ac\n  if (trustedAccountKey !== trustedAccount) {\n    this.agent.recordSupportability(\n      `DistributedTrace/AcceptPayload/Ignored/UntrustedAccount`\n    )\n    return\n  }\n\n  transport = TRANSPORT_TYPES_SET[transport] ? transport : 'Unknown'\n\n  this.parentType = data.ty\n  this.parentApp = data.ap\n  this.parentAcct = data.ac\n  this.parentTransportType = transport\n  this.parentTransportDuration = Math.max(0, (Date.now() - data.ti) / 1000)\n  this.traceId = data.tr\n\n  if (data.pr) {\n    this.priority = data.pr\n    this.sampled = data.sa != null ? data.sa : this.sampled\n  }\n\n  if (data.tx) {\n    this.parentId = data.tx\n  }\n\n  if (data.id) {\n    this.parentSpanId = data.id\n  }\n\n  this.isDistributedTrace = true\n  // Track if the distributed trace was created through accepting, since\n  // there is potentially no data difference between creation from\n  // Mobile or Browser trace payloads and creation.\n  this.acceptedDistributedTrace = true\n\n  this.agent.recordSupportability('DistributedTrace/AcceptPayload/Success')\n}\n\n/**\n * Returns parsed payload object after attempting to decode it from base64,\n * and parsing the JSON string.\n */\nTransaction.prototype._getParsedPayload = function _getParsedPayload(payload) {\n  let parsed = payload\n\n  if (typeof payload === 'string') {\n    if (payload.charAt(0) !== '{' && payload.charAt(0) !== '[') {\n      try {\n        payload = Buffer.from(payload, 'base64').toString('utf-8')\n      } catch (err) {\n        logger.warn(\n          err,\n          'Got unparseable distributed trace payload in transaction %s',\n          this.id\n        )\n        this.agent.recordSupportability('DistributedTrace/AcceptPayload/ParseException')\n        return null\n      }\n    }\n    try {\n      parsed = JSON.parse(payload)\n    } catch (err) {\n      logger.warn(\n        err,\n        'Failed to parse distributed trace payload in transaction %s',\n        this.id\n      )\n      this.agent.recordSupportability('DistributedTrace/AcceptPayload/ParseException')\n      return null\n    }\n  }\n\n  return parsed\n}\n\n/**\n * Creates a distributed trace payload.\n */\nTransaction.prototype.createDistributedTracePayload = createDistributedTracePayload\n\nfunction createDistributedTracePayload() {\n  const config = this.agent.config\n  const accountId = config.account_id\n  const appId = config.primary_application_id\n  const distTraceEnabled = config.distributed_tracing.enabled\n\n  if (!accountId || !appId || !distTraceEnabled) {\n    logger.debug(\n      'Invalid configuration for distributed trace payload ' +\n      '(distributed_tracing.enabled: %s, account_id: %s, application_id: %s) ' +\n      'in transaction %s',\n      distTraceEnabled,\n      accountId,\n      appId,\n      this.id\n    )\n\n    return new DTPayloadStub()\n  }\n\n  this._calculatePriority()\n\n  const currSegment = this.agent.tracer.getSegment()\n  const data = {\n    ty: 'App',\n    ac: accountId,\n    ap: appId,\n    tx: this.id,\n    tr: this.getTraceId(),\n    pr: this.priority,\n    sa: this.sampled,\n    ti: Date.now()\n  }\n\n  if (config.span_events.enabled && this.sampled && currSegment) {\n    data.id = currSegment.id\n  }\n\n  if (config.trusted_account_key && config.trusted_account_key !== accountId) {\n    data.tk = config.trusted_account_key\n  }\n\n  this.isDistributedTrace = true\n  this.agent.recordSupportability('DistributedTrace/CreatePayload/Success')\n\n  return new DTPayload(data)\n}\n\n/**\n * Adds distributed trace attributes to instrinsics object.\n */\nTransaction.prototype.addDistributedTraceIntrinsics = addDistributedTraceIntrinsics\nfunction addDistributedTraceIntrinsics(attrs) {\n  this._calculatePriority()\n\n  // *always* add these if DT flag is enabled.\n  attrs.traceId = this.getTraceId()\n  attrs.guid = this.id\n  attrs.priority = this.priority\n\n  attrs.sampled = !!this.sampled\n\n  // add the rest only if payload was received\n  if (this.parentType) {\n    attrs['parent.type'] = this.parentType\n  }\n\n  if (this.parentApp) {\n    attrs['parent.app'] = this.parentApp\n  }\n\n  if (this.parentAcct) {\n    attrs['parent.account'] = this.parentAcct\n  }\n\n  if (this.parentTransportType) {\n    attrs['parent.transportType'] = this.parentTransportType\n  }\n\n  if (this.parentTransportDuration != null) {\n    attrs['parent.transportDuration'] = this.parentTransportDuration\n  }\n}\n\nTransaction.prototype.isSampled = function isSampled() {\n  this._calculatePriority()\n  return this.sampled\n}\n\n/**\n * Generates a priority for the transaction if it does not have one already.\n */\nTransaction.prototype._calculatePriority = function _calculatePriority() {\n  if (this.priority === null) {\n    this.priority = Math.random()\n    // We want to separate the priority roll from the decision roll to\n    // avoid biasing the priority range\n    this.sampled = this.agent.transactionSampler.shouldSample(Math.random())\n    if (this.sampled) {\n      this.priority += 1\n    }\n\n    // Truncate the priority after potentially modifying it to avoid floating\n    // point errors.\n    this.priority = (this.priority * 1e6 | 0) / 1e6\n  }\n}\n\nfunction _makeValueSet(obj) {\n  return Object.keys(obj).map((t) => obj[t]).reduce(function reduceToMap(o, t) {\n    o[t] = true\n    return o\n  }, Object.create(null))\n}\n\nTransaction.prototype.addRequestParameters = addRequestParameters\n\n/**\n * Adds request/query parameters to create attributes in the form\n * 'request.parameters.{key}'. These attributes will only be created\n * when 'request.parameters.*' is included in the attribute config.\n * @param {Object.<string, string>} requestParameters\n */\nfunction addRequestParameters(requestParameters) {\n  for (var key in requestParameters) {\n    if (props.hasOwn(requestParameters, key)) {\n      this.trace.attributes.addAttribute(\n        DESTS.NONE,\n        'request.parameters.' + key,\n        requestParameters[key]\n      )\n    }\n  }\n}\n\n/**\n * Gets the current distributed trace traceId\n */\nTransaction.prototype.getTraceId = function getTraceId() {\n  return this.traceId || this.id\n}\n\nmodule.exports = Transaction\n"]},"metadata":{},"sourceType":"script"}