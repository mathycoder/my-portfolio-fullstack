{"ast":null,"code":"'use strict';\n\nexports = module.exports = flatten;\nexports.keys = flatKeys;\n/**\n * Flatten nested maps of JSONifiable data.\n *\n * Ex: {a: 5, b: {c: true, d: 7}} -> {a: 5, 'b.c': true, 'b.d': 7}\n *\n * @private\n *\n * @param {object} result Object to place key-value pairs into, normally called with `{}`.\n * @param {string} prefix Prefix for keys, normally called with `''`.\n * @param {object} obj    Object to be flattened.\n *\n * @return {object} Object with flattened key-value pairs\n */\n\nfunction flatten(result, prefix, obj, seen) {\n  seen = seen || [];\n  seen.push(obj);\n\n  for (var key in obj) {\n    if (seen.indexOf(obj[key]) > -1) {\n      continue;\n    }\n\n    if (obj[key] instanceof Object) flatten(result, prefix + key + '.', obj[key], seen);else result[prefix + key] = obj[key];\n  }\n\n  return result;\n}\n/**\n * Retrieves all the keys that would exist in the flattened version of the object.\n *\n * @private\n *\n * @param {object}  obj       - The object to get the flat keys of.\n * @param {string}  prefix    - A prefix for the keys, usually `''`.\n * @param {bool}    arrayIdx  - Flag indicating if array indexes should be iterated.\n *\n * @return {array.<string>} An array of keys names.\n */\n\n\nfunction flatKeys(obj, prefix, arrayIdxs) {\n  var keys = [];\n  var seen = [];\n  recurse(prefix || '', obj);\n  return keys;\n\n  function recurse(p, o) {\n    seen.push(o);\n\n    for (var key in o) {\n      if (seen.indexOf(o[key]) !== -1) {\n        continue;\n      }\n\n      if (o[key] instanceof Object && (arrayIdxs || !Array.isArray(o[key]))) {\n        recurse(p + key + '.', o[key]);\n      } else {\n        keys.push(p + key);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/util/flatten.js"],"names":["exports","module","flatten","keys","flatKeys","result","prefix","obj","seen","push","key","indexOf","Object","arrayIdxs","recurse","p","o","Array","isArray"],"mappings":"AAAA;;AAEAA,OAAO,GAAGC,MAAM,CAACD,OAAP,GAAiBE,OAA3B;AACAF,OAAO,CAACG,IAAR,GAAeC,QAAf;AAEA;;;;;;;;;;;;;;AAaA,SAASF,OAAT,CAAiBG,MAAjB,EAAyBC,MAAzB,EAAiCC,GAAjC,EAAsCC,IAAtC,EAA4C;AAC1CA,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACAA,EAAAA,IAAI,CAACC,IAAL,CAAUF,GAAV;;AAEA,OAAK,IAAIG,GAAT,IAAgBH,GAAhB,EAAqB;AACnB,QAAIC,IAAI,CAACG,OAAL,CAAaJ,GAAG,CAACG,GAAD,CAAhB,IAAyB,CAAC,CAA9B,EAAiC;AAC/B;AACD;;AAED,QAAIH,GAAG,CAACG,GAAD,CAAH,YAAoBE,MAAxB,EAAgCV,OAAO,CAACG,MAAD,EAASC,MAAM,GAAGI,GAAT,GAAe,GAAxB,EAA6BH,GAAG,CAACG,GAAD,CAAhC,EAAuCF,IAAvC,CAAP,CAAhC,KACKH,MAAM,CAACC,MAAM,GAAGI,GAAV,CAAN,GAAuBH,GAAG,CAACG,GAAD,CAA1B;AACN;;AAED,SAAOL,MAAP;AACD;AAED;;;;;;;;;;;;;AAWA,SAASD,QAAT,CAAkBG,GAAlB,EAAuBD,MAAvB,EAA+BO,SAA/B,EAA0C;AACxC,MAAIV,IAAI,GAAG,EAAX;AACA,MAAIK,IAAI,GAAG,EAAX;AACAM,EAAAA,OAAO,CAACR,MAAM,IAAI,EAAX,EAAeC,GAAf,CAAP;AACA,SAAOJ,IAAP;;AAEA,WAASW,OAAT,CAAiBC,CAAjB,EAAoBC,CAApB,EAAuB;AACrBR,IAAAA,IAAI,CAACC,IAAL,CAAUO,CAAV;;AAEA,SAAK,IAAIN,GAAT,IAAgBM,CAAhB,EAAmB;AACjB,UAAIR,IAAI,CAACG,OAAL,CAAaK,CAAC,CAACN,GAAD,CAAd,MAAyB,CAAC,CAA9B,EAAiC;AAC/B;AACD;;AAED,UAAIM,CAAC,CAACN,GAAD,CAAD,YAAkBE,MAAlB,KAA6BC,SAAS,IAAI,CAACI,KAAK,CAACC,OAAN,CAAcF,CAAC,CAACN,GAAD,CAAf,CAA3C,CAAJ,EAAuE;AACrEI,QAAAA,OAAO,CAACC,CAAC,GAAGL,GAAJ,GAAU,GAAX,EAAgBM,CAAC,CAACN,GAAD,CAAjB,CAAP;AACD,OAFD,MAEO;AACLP,QAAAA,IAAI,CAACM,IAAL,CAAUM,CAAC,GAAGL,GAAd;AACD;AACF;AACF;AACF","sourcesContent":["'use strict'\n\nexports = module.exports = flatten\nexports.keys = flatKeys\n\n/**\n * Flatten nested maps of JSONifiable data.\n *\n * Ex: {a: 5, b: {c: true, d: 7}} -> {a: 5, 'b.c': true, 'b.d': 7}\n *\n * @private\n *\n * @param {object} result Object to place key-value pairs into, normally called with `{}`.\n * @param {string} prefix Prefix for keys, normally called with `''`.\n * @param {object} obj    Object to be flattened.\n *\n * @return {object} Object with flattened key-value pairs\n */\nfunction flatten(result, prefix, obj, seen) {\n  seen = seen || []\n  seen.push(obj)\n\n  for (var key in obj) {\n    if (seen.indexOf(obj[key]) > -1) {\n      continue\n    }\n\n    if (obj[key] instanceof Object) flatten(result, prefix + key + '.', obj[key], seen)\n    else result[prefix + key] = obj[key]\n  }\n\n  return result\n}\n\n/**\n * Retrieves all the keys that would exist in the flattened version of the object.\n *\n * @private\n *\n * @param {object}  obj       - The object to get the flat keys of.\n * @param {string}  prefix    - A prefix for the keys, usually `''`.\n * @param {bool}    arrayIdx  - Flag indicating if array indexes should be iterated.\n *\n * @return {array.<string>} An array of keys names.\n */\nfunction flatKeys(obj, prefix, arrayIdxs) {\n  var keys = []\n  var seen = []\n  recurse(prefix || '', obj)\n  return keys\n\n  function recurse(p, o) {\n    seen.push(o)\n\n    for (var key in o) {\n      if (seen.indexOf(o[key]) !== -1) {\n        continue\n      }\n\n      if (o[key] instanceof Object && (arrayIdxs || !Array.isArray(o[key]))) {\n        recurse(p + key + '.', o[key])\n      } else {\n        keys.push(p + key)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}