{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Daniel Imms <http://www.growingwiththeweb.com>\n * Released under MIT license. See LICENSE in the project root for details.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar node_1 = require(\"./node\");\n\nvar nodeListIterator_1 = require(\"./nodeListIterator\");\n\nvar FibonacciHeap =\n/** @class */\nfunction () {\n  function FibonacciHeap(compare) {\n    this._minNode = null;\n    this._nodeCount = 0;\n    this._compare = compare ? compare : this._defaultCompare;\n  }\n  /**\n   * Clears the heap's data, making it an empty heap.\n   */\n\n\n  FibonacciHeap.prototype.clear = function () {\n    this._minNode = null;\n    this._nodeCount = 0;\n  };\n  /**\n   * Decreases a key of a node.\n   * @param node The node to decrease the key of.\n   * @param newKey The new key to assign to the node.\n   */\n\n\n  FibonacciHeap.prototype.decreaseKey = function (node, newKey) {\n    if (!node) {\n      throw new Error('Cannot decrease key of non-existent node');\n    }\n\n    if (this._compare({\n      key: newKey\n    }, {\n      key: node.key\n    }) > 0) {\n      throw new Error('New key is larger than old key');\n    }\n\n    node.key = newKey;\n    var parent = node.parent;\n\n    if (parent && this._compare(node, parent) < 0) {\n      this._cut(node, parent, this._minNode);\n\n      this._cascadingCut(parent, this._minNode);\n    }\n\n    if (this._compare(node, this._minNode) < 0) {\n      this._minNode = node;\n    }\n  };\n  /**\n   * Deletes a node.\n   * @param node The node to delete.\n   */\n\n\n  FibonacciHeap.prototype.delete = function (node) {\n    // This is a special implementation of decreaseKey that sets the argument to\n    // the minimum value. This is necessary to make generic keys work, since there\n    // is no MIN_VALUE constant for generic types.\n    var parent = node.parent;\n\n    if (parent) {\n      this._cut(node, parent, this._minNode);\n\n      this._cascadingCut(parent, this._minNode);\n    }\n\n    this._minNode = node;\n    this.extractMinimum();\n  };\n  /**\n   * Extracts and returns the minimum node from the heap.\n   * @return The heap's minimum node or null if the heap is empty.\n   */\n\n\n  FibonacciHeap.prototype.extractMinimum = function () {\n    var extractedMin = this._minNode;\n\n    if (extractedMin) {\n      // Set parent to null for the minimum's children\n      if (extractedMin.child) {\n        var child = extractedMin.child;\n\n        do {\n          child.parent = null;\n          child = child.next;\n        } while (child !== extractedMin.child);\n      }\n\n      var nextInRootList = null;\n\n      if (extractedMin.next !== extractedMin) {\n        nextInRootList = extractedMin.next;\n      } // Remove min from root list\n\n\n      this._removeNodeFromList(extractedMin);\n\n      this._nodeCount--; // Merge the children of the minimum node with the root list\n\n      this._minNode = this._mergeLists(nextInRootList, extractedMin.child);\n\n      if (this._minNode) {\n        this._minNode = this._consolidate(this._minNode);\n      }\n    }\n\n    return extractedMin;\n  };\n  /**\n   * Returns the minimum node from the heap.\n   * @return The heap's minimum node or null if the heap is empty.\n   */\n\n\n  FibonacciHeap.prototype.findMinimum = function () {\n    return this._minNode;\n  };\n  /**\n   * Inserts a new key-value pair into the heap.\n   * @param key The key to insert.\n   * @param value The value to insert.\n   * @return node The inserted node.\n   */\n\n\n  FibonacciHeap.prototype.insert = function (key, value) {\n    var node = new node_1.Node(key, value);\n    this._minNode = this._mergeLists(this._minNode, node);\n    this._nodeCount++;\n    return node;\n  };\n  /**\n   * @return Whether the heap is empty.\n   */\n\n\n  FibonacciHeap.prototype.isEmpty = function () {\n    return this._minNode === null;\n  };\n  /**\n   * @return The size of the heap.\n   */\n\n\n  FibonacciHeap.prototype.size = function () {\n    if (this._minNode === null) {\n      return 0;\n    }\n\n    return this._getNodeListSize(this._minNode);\n  };\n  /**\n   * Joins another heap to this heap.\n   * @param other The other heap.\n   */\n\n\n  FibonacciHeap.prototype.union = function (other) {\n    this._minNode = this._mergeLists(this._minNode, other._minNode);\n    this._nodeCount += other._nodeCount;\n  };\n  /**\n   * Compares two nodes with each other.\n   * @param a The first key to compare.\n   * @param b The second key to compare.\n   * @return -1, 0 or 1 if a < b, a == b or a > b respectively.\n   */\n\n\n  FibonacciHeap.prototype._defaultCompare = function (a, b) {\n    if (a.key > b.key) {\n      return 1;\n    }\n\n    if (a.key < b.key) {\n      return -1;\n    }\n\n    return 0;\n  };\n  /**\n   * Cut the link between a node and its parent, moving the node to the root list.\n   * @param node The node being cut.\n   * @param parent The parent of the node being cut.\n   * @param minNode The minimum node in the root list.\n   * @return The heap's new minimum node.\n   */\n\n\n  FibonacciHeap.prototype._cut = function (node, parent, minNode) {\n    node.parent = null;\n    parent.degree--;\n\n    if (node.next === node) {\n      parent.child = null;\n    } else {\n      parent.child = node.next;\n    }\n\n    this._removeNodeFromList(node);\n\n    var newMinNode = this._mergeLists(minNode, node);\n\n    node.isMarked = false;\n    return newMinNode;\n  };\n  /**\n   * Perform a cascading cut on a node; mark the node if it is not marked,\n   * otherwise cut the node and perform a cascading cut on its parent.\n   * @param node The node being considered to be cut.\n   * @param minNode The minimum node in the root list.\n   * @return The heap's new minimum node.\n   */\n\n\n  FibonacciHeap.prototype._cascadingCut = function (node, minNode) {\n    var parent = node.parent;\n\n    if (parent) {\n      if (node.isMarked) {\n        minNode = this._cut(node, parent, minNode);\n        minNode = this._cascadingCut(parent, minNode);\n      } else {\n        node.isMarked = true;\n      }\n    }\n\n    return minNode;\n  };\n  /**\n   * Merge all trees of the same order together until there are no two trees of\n   * the same order.\n   * @param minNode The current minimum node.\n   * @return The new minimum node.\n   */\n\n\n  FibonacciHeap.prototype._consolidate = function (minNode) {\n    var aux = [];\n    var it = new nodeListIterator_1.NodeListIterator(minNode);\n\n    while (it.hasNext()) {\n      var current = it.next(); // If there exists another node with the same degree, merge them\n\n      var auxCurrent = aux[current.degree];\n\n      while (auxCurrent) {\n        if (this._compare(current, auxCurrent) > 0) {\n          var temp = current;\n          current = auxCurrent;\n          auxCurrent = temp;\n        }\n\n        this._linkHeaps(auxCurrent, current);\n\n        aux[current.degree] = null;\n        current.degree++;\n        auxCurrent = aux[current.degree];\n      }\n\n      aux[current.degree] = current;\n    }\n\n    var newMinNode = null;\n\n    for (var i = 0; i < aux.length; i++) {\n      var node = aux[i];\n\n      if (node) {\n        // Remove siblings before merging\n        node.next = node;\n        node.prev = node;\n        newMinNode = this._mergeLists(newMinNode, node);\n      }\n    }\n\n    return newMinNode;\n  };\n  /**\n   * Removes a node from a node list.\n   * @param node The node to remove.\n   */\n\n\n  FibonacciHeap.prototype._removeNodeFromList = function (node) {\n    var prev = node.prev;\n    var next = node.next;\n    prev.next = next;\n    next.prev = prev;\n    node.next = node;\n    node.prev = node;\n  };\n  /**\n   * Links two heaps of the same order together.\n   *\n   * @private\n   * @param max The heap with the larger root.\n   * @param min The heap with the smaller root.\n   */\n\n\n  FibonacciHeap.prototype._linkHeaps = function (max, min) {\n    this._removeNodeFromList(max);\n\n    min.child = this._mergeLists(max, min.child);\n    max.parent = min;\n    max.isMarked = false;\n  };\n  /**\n   * Merge two lists of nodes together.\n   *\n   * @private\n   * @param a The first list to merge.\n   * @param b The second list to merge.\n   * @return The new minimum node from the two lists.\n   */\n\n\n  FibonacciHeap.prototype._mergeLists = function (a, b) {\n    if (!a) {\n      if (!b) {\n        return null;\n      }\n\n      return b;\n    }\n\n    if (!b) {\n      return a;\n    }\n\n    var temp = a.next;\n    a.next = b.next;\n    a.next.prev = a;\n    b.next = temp;\n    b.next.prev = b;\n    return this._compare(a, b) < 0 ? a : b;\n  };\n  /**\n   * Gets the size of a node list.\n   * @param node A node within the node list.\n   * @return The size of the node list.\n   */\n\n\n  FibonacciHeap.prototype._getNodeListSize = function (node) {\n    var count = 0;\n    var current = node;\n\n    do {\n      count++;\n\n      if (current.child) {\n        count += this._getNodeListSize(current.child);\n      }\n\n      current = current.next;\n    } while (current !== node);\n\n    return count;\n  };\n\n  return FibonacciHeap;\n}();\n\nexports.FibonacciHeap = FibonacciHeap;","map":{"version":3,"sources":["../src/fibonacciHeap.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Daniel Imms <http://www.growingwiththeweb.com>\n * Released under MIT license. See LICENSE in the project root for details.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar node_1 = require(\"./node\");\nvar nodeListIterator_1 = require(\"./nodeListIterator\");\nvar FibonacciHeap = /** @class */ (function () {\n    function FibonacciHeap(compare) {\n        this._minNode = null;\n        this._nodeCount = 0;\n        this._compare = compare ? compare : this._defaultCompare;\n    }\n    /**\n     * Clears the heap's data, making it an empty heap.\n     */\n    FibonacciHeap.prototype.clear = function () {\n        this._minNode = null;\n        this._nodeCount = 0;\n    };\n    /**\n     * Decreases a key of a node.\n     * @param node The node to decrease the key of.\n     * @param newKey The new key to assign to the node.\n     */\n    FibonacciHeap.prototype.decreaseKey = function (node, newKey) {\n        if (!node) {\n            throw new Error('Cannot decrease key of non-existent node');\n        }\n        if (this._compare({ key: newKey }, { key: node.key }) > 0) {\n            throw new Error('New key is larger than old key');\n        }\n        node.key = newKey;\n        var parent = node.parent;\n        if (parent && this._compare(node, parent) < 0) {\n            this._cut(node, parent, this._minNode);\n            this._cascadingCut(parent, this._minNode);\n        }\n        if (this._compare(node, this._minNode) < 0) {\n            this._minNode = node;\n        }\n    };\n    /**\n     * Deletes a node.\n     * @param node The node to delete.\n     */\n    FibonacciHeap.prototype.delete = function (node) {\n        // This is a special implementation of decreaseKey that sets the argument to\n        // the minimum value. This is necessary to make generic keys work, since there\n        // is no MIN_VALUE constant for generic types.\n        var parent = node.parent;\n        if (parent) {\n            this._cut(node, parent, this._minNode);\n            this._cascadingCut(parent, this._minNode);\n        }\n        this._minNode = node;\n        this.extractMinimum();\n    };\n    /**\n     * Extracts and returns the minimum node from the heap.\n     * @return The heap's minimum node or null if the heap is empty.\n     */\n    FibonacciHeap.prototype.extractMinimum = function () {\n        var extractedMin = this._minNode;\n        if (extractedMin) {\n            // Set parent to null for the minimum's children\n            if (extractedMin.child) {\n                var child = extractedMin.child;\n                do {\n                    child.parent = null;\n                    child = child.next;\n                } while (child !== extractedMin.child);\n            }\n            var nextInRootList = null;\n            if (extractedMin.next !== extractedMin) {\n                nextInRootList = extractedMin.next;\n            }\n            // Remove min from root list\n            this._removeNodeFromList(extractedMin);\n            this._nodeCount--;\n            // Merge the children of the minimum node with the root list\n            this._minNode = this._mergeLists(nextInRootList, extractedMin.child);\n            if (this._minNode) {\n                this._minNode = this._consolidate(this._minNode);\n            }\n        }\n        return extractedMin;\n    };\n    /**\n     * Returns the minimum node from the heap.\n     * @return The heap's minimum node or null if the heap is empty.\n     */\n    FibonacciHeap.prototype.findMinimum = function () {\n        return this._minNode;\n    };\n    /**\n     * Inserts a new key-value pair into the heap.\n     * @param key The key to insert.\n     * @param value The value to insert.\n     * @return node The inserted node.\n     */\n    FibonacciHeap.prototype.insert = function (key, value) {\n        var node = new node_1.Node(key, value);\n        this._minNode = this._mergeLists(this._minNode, node);\n        this._nodeCount++;\n        return node;\n    };\n    /**\n     * @return Whether the heap is empty.\n     */\n    FibonacciHeap.prototype.isEmpty = function () {\n        return this._minNode === null;\n    };\n    /**\n     * @return The size of the heap.\n     */\n    FibonacciHeap.prototype.size = function () {\n        if (this._minNode === null) {\n            return 0;\n        }\n        return this._getNodeListSize(this._minNode);\n    };\n    /**\n     * Joins another heap to this heap.\n     * @param other The other heap.\n     */\n    FibonacciHeap.prototype.union = function (other) {\n        this._minNode = this._mergeLists(this._minNode, other._minNode);\n        this._nodeCount += other._nodeCount;\n    };\n    /**\n     * Compares two nodes with each other.\n     * @param a The first key to compare.\n     * @param b The second key to compare.\n     * @return -1, 0 or 1 if a < b, a == b or a > b respectively.\n     */\n    FibonacciHeap.prototype._defaultCompare = function (a, b) {\n        if (a.key > b.key) {\n            return 1;\n        }\n        if (a.key < b.key) {\n            return -1;\n        }\n        return 0;\n    };\n    /**\n     * Cut the link between a node and its parent, moving the node to the root list.\n     * @param node The node being cut.\n     * @param parent The parent of the node being cut.\n     * @param minNode The minimum node in the root list.\n     * @return The heap's new minimum node.\n     */\n    FibonacciHeap.prototype._cut = function (node, parent, minNode) {\n        node.parent = null;\n        parent.degree--;\n        if (node.next === node) {\n            parent.child = null;\n        }\n        else {\n            parent.child = node.next;\n        }\n        this._removeNodeFromList(node);\n        var newMinNode = this._mergeLists(minNode, node);\n        node.isMarked = false;\n        return newMinNode;\n    };\n    /**\n     * Perform a cascading cut on a node; mark the node if it is not marked,\n     * otherwise cut the node and perform a cascading cut on its parent.\n     * @param node The node being considered to be cut.\n     * @param minNode The minimum node in the root list.\n     * @return The heap's new minimum node.\n     */\n    FibonacciHeap.prototype._cascadingCut = function (node, minNode) {\n        var parent = node.parent;\n        if (parent) {\n            if (node.isMarked) {\n                minNode = this._cut(node, parent, minNode);\n                minNode = this._cascadingCut(parent, minNode);\n            }\n            else {\n                node.isMarked = true;\n            }\n        }\n        return minNode;\n    };\n    /**\n     * Merge all trees of the same order together until there are no two trees of\n     * the same order.\n     * @param minNode The current minimum node.\n     * @return The new minimum node.\n     */\n    FibonacciHeap.prototype._consolidate = function (minNode) {\n        var aux = [];\n        var it = new nodeListIterator_1.NodeListIterator(minNode);\n        while (it.hasNext()) {\n            var current = it.next();\n            // If there exists another node with the same degree, merge them\n            var auxCurrent = aux[current.degree];\n            while (auxCurrent) {\n                if (this._compare(current, auxCurrent) > 0) {\n                    var temp = current;\n                    current = auxCurrent;\n                    auxCurrent = temp;\n                }\n                this._linkHeaps(auxCurrent, current);\n                aux[current.degree] = null;\n                current.degree++;\n                auxCurrent = aux[current.degree];\n            }\n            aux[current.degree] = current;\n        }\n        var newMinNode = null;\n        for (var i = 0; i < aux.length; i++) {\n            var node = aux[i];\n            if (node) {\n                // Remove siblings before merging\n                node.next = node;\n                node.prev = node;\n                newMinNode = this._mergeLists(newMinNode, node);\n            }\n        }\n        return newMinNode;\n    };\n    /**\n     * Removes a node from a node list.\n     * @param node The node to remove.\n     */\n    FibonacciHeap.prototype._removeNodeFromList = function (node) {\n        var prev = node.prev;\n        var next = node.next;\n        prev.next = next;\n        next.prev = prev;\n        node.next = node;\n        node.prev = node;\n    };\n    /**\n     * Links two heaps of the same order together.\n     *\n     * @private\n     * @param max The heap with the larger root.\n     * @param min The heap with the smaller root.\n     */\n    FibonacciHeap.prototype._linkHeaps = function (max, min) {\n        this._removeNodeFromList(max);\n        min.child = this._mergeLists(max, min.child);\n        max.parent = min;\n        max.isMarked = false;\n    };\n    /**\n     * Merge two lists of nodes together.\n     *\n     * @private\n     * @param a The first list to merge.\n     * @param b The second list to merge.\n     * @return The new minimum node from the two lists.\n     */\n    FibonacciHeap.prototype._mergeLists = function (a, b) {\n        if (!a) {\n            if (!b) {\n                return null;\n            }\n            return b;\n        }\n        if (!b) {\n            return a;\n        }\n        var temp = a.next;\n        a.next = b.next;\n        a.next.prev = a;\n        b.next = temp;\n        b.next.prev = b;\n        return this._compare(a, b) < 0 ? a : b;\n    };\n    /**\n     * Gets the size of a node list.\n     * @param node A node within the node list.\n     * @return The size of the node list.\n     */\n    FibonacciHeap.prototype._getNodeListSize = function (node) {\n        var count = 0;\n        var current = node;\n        do {\n            count++;\n            if (current.child) {\n                count += this._getNodeListSize(current.child);\n            }\n            current = current.next;\n        } while (current !== node);\n        return count;\n    };\n    return FibonacciHeap;\n}());\nexports.FibonacciHeap = FibonacciHeap;\n//# sourceMappingURL=fibonacciHeap.js.map"]},"metadata":{},"sourceType":"script"}