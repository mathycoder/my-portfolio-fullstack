{"ast":null,"code":"'use strict';\n\nconst Config = require('../config');\n\nconst _require = require('../util/byte-limit'),\n      truncate = _require.truncate;\n\nconst _require2 = require('../config/attribute-filter'),\n      DESTINATIONS = _require2.DESTINATIONS;\n\nconst NAMES = require('../metrics/names');\n\nconst HTTP_LIBRARY = 'http';\nconst CLIENT_KIND = 'client';\nconst CATEGORIES = {\n  HTTP: 'http',\n  DATASTORE: 'datastore',\n  GENERIC: 'generic'\n};\nconst EMPTY_USER_ATTRS = Object.freeze(Object.create(null));\n/**\n * All the intrinsic attributes for span events, regardless of kind.\n */\n\nclass SpanIntrinsics {\n  constructor() {\n    this.type = 'Span';\n    this.traceId = null;\n    this.guid = null;\n    this.parentId = null;\n    this.transactionId = null;\n    this.sampled = null;\n    this.priority = null;\n    this.name = null;\n    this.category = CATEGORIES.GENERIC;\n    this.component = null;\n    this.timestamp = null;\n    this.duration = null;\n    this['nr.entryPoint'] = null;\n    this['span.kind'] = null;\n  }\n\n}\n/**\n * General span event class.\n *\n * Do not construct directly, instead use one of the static `from*` methods such\n * as `SpanEvent.fromSegment`.\n *\n * @private\n * @class\n */\n\n\nclass SpanEvent {\n  constructor(attributes) {\n    this.attributes = attributes;\n    this.intrinsics = new SpanIntrinsics();\n  }\n\n  static get CATEGORIES() {\n    return CATEGORIES;\n  }\n\n  static get DatastoreSpanEvent() {\n    return DatastoreSpanEvent;\n  }\n\n  static get HttpSpanEvent() {\n    return HttpSpanEvent;\n  }\n  /**\n   * Constructs a `SpanEvent` from the given segment.\n   *\n   * The constructed span event will contain extra data depending on the\n   * category of the segment.\n   *\n   * @param {TraceSegment}  segment         - The segment to turn into a span event.\n   * @param {?string}       [parentId=null] - The ID of the segment's parent.\n   *\n   * @return {SpanEvent} The constructed event.\n   */\n\n\n  static fromSegment(segment, parentId = null) {\n    const attributes = segment.attributes.get(DESTINATIONS.SPAN_EVENT);\n    let span = null;\n\n    if (HttpSpanEvent.testSegment(segment)) {\n      span = new HttpSpanEvent(attributes);\n    } else if (DatastoreSpanEvent.testSegment(segment)) {\n      span = new DatastoreSpanEvent(attributes);\n    } else {\n      span = new SpanEvent(attributes);\n    }\n\n    const tx = segment.transaction;\n    span.intrinsics.traceId = tx.getTraceId();\n    span.intrinsics.guid = segment.id;\n    span.intrinsics.parentId = parentId;\n    span.intrinsics.transactionId = tx.id;\n    span.intrinsics.sampled = tx.sampled;\n    span.intrinsics.priority = tx.priority;\n    span.intrinsics.name = segment.name; // Only set this if it will be `true`. Must be `null` otherwise.\n\n    if (tx.baseSegment === segment) {\n      span.intrinsics['nr.entryPoint'] = true;\n    } // Timestamp in milliseconds, duration in seconds. Yay consistency!\n\n\n    span.intrinsics.timestamp = segment.timer.start;\n    span.intrinsics.duration = segment.timer.getDurationInMillis() / 1000;\n    return span;\n  }\n\n  toJSON() {\n    return [_filterNulls(this.intrinsics), EMPTY_USER_ATTRS, _filterNulls(this.attributes)];\n  }\n\n  addAttribute(key, value, truncateExempt = false) {\n    const _Config$getInstance = Config.getInstance(),\n          attributeFilter = _Config$getInstance.attributeFilter;\n\n    const dest = attributeFilter.filterSegment(DESTINATIONS.SPAN_EVENT, key);\n\n    if (dest & DESTINATIONS.SPAN_EVENT) {\n      this.attributes[key] = truncateExempt ? value : _truncate(value);\n    }\n  }\n\n}\n/**\n * Span event class for external requests.\n *\n * @private\n * @class\n */\n\n\nclass HttpSpanEvent extends SpanEvent {\n  constructor(attributes) {\n    super(attributes);\n    this.intrinsics.category = CATEGORIES.HTTP;\n    this.intrinsics.component = attributes.library || HTTP_LIBRARY;\n    this.intrinsics['span.kind'] = CLIENT_KIND;\n\n    if (attributes.library) {\n      attributes.library = null;\n    }\n\n    if (attributes.url) {\n      this.addAttribute('http.url', attributes.url);\n      attributes.url = null;\n    }\n\n    if (attributes.procedure) {\n      this.addAttribute('http.method', attributes.procedure);\n      attributes.procedure = null;\n    }\n  }\n\n  static testSegment(segment) {\n    return segment.name.startsWith(NAMES.EXTERNAL.PREFIX);\n  }\n\n}\n/**\n * Span event class for datastore operations and queries.\n *\n * @private\n * @class.\n */\n\n\nclass DatastoreSpanEvent extends SpanEvent {\n  constructor(attributes) {\n    super(attributes);\n    this.intrinsics.category = CATEGORIES.DATASTORE;\n    this.intrinsics['span.kind'] = CLIENT_KIND;\n\n    if (attributes.product) {\n      this.intrinsics.component = attributes.product;\n      attributes.product = null;\n    }\n\n    if (attributes.collection) {\n      this.addAttribute('db.collection', attributes.collection);\n      attributes.collection = null;\n    }\n\n    if (attributes.sql || attributes.sql_obfuscated) {\n      let sql = null;\n\n      if (attributes.sql_obfuscated) {\n        sql = _truncate(attributes.sql_obfuscated);\n        attributes.sql_obfuscated = null;\n      } else if (attributes.sql) {\n        sql = _truncate(attributes.sql);\n        attributes.sql = null;\n      } // Flag as exempt from normal attribute truncation\n\n\n      this.addAttribute('db.statement', sql, true);\n    }\n\n    if (attributes.database_name) {\n      this.addAttribute('db.instance', attributes.database_name);\n      attributes.database_name = null;\n    }\n\n    if (attributes.host) {\n      this.addAttribute('peer.hostname', attributes.host);\n\n      if (attributes.port_path_or_id) {\n        const address = `${attributes.host}:${attributes.port_path_or_id}`;\n        this.addAttribute('peer.address', address);\n        attributes.port_path_or_id = null;\n      }\n\n      attributes.host = null;\n    }\n  }\n\n  static testSegment(segment) {\n    return segment.name.startsWith(NAMES.DB.PREFIX);\n  }\n\n}\n\nfunction _truncate(val) {\n  let truncated = truncate(val, 1997);\n\n  if (truncated !== val) {\n    truncated += '...';\n  }\n\n  return truncated;\n}\n\nfunction _filterNulls(obj) {\n  const out = Object.create(null);\n\n  for (let key in obj) {\n    if (obj[key] != null) {\n      out[key] = obj[key];\n    }\n  }\n\n  return out;\n}\n\nmodule.exports = SpanEvent;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/spans/span-event.js"],"names":["Config","require","truncate","DESTINATIONS","NAMES","HTTP_LIBRARY","CLIENT_KIND","CATEGORIES","HTTP","DATASTORE","GENERIC","EMPTY_USER_ATTRS","Object","freeze","create","SpanIntrinsics","constructor","type","traceId","guid","parentId","transactionId","sampled","priority","name","category","component","timestamp","duration","SpanEvent","attributes","intrinsics","DatastoreSpanEvent","HttpSpanEvent","fromSegment","segment","get","SPAN_EVENT","span","testSegment","tx","transaction","getTraceId","id","baseSegment","timer","start","getDurationInMillis","toJSON","_filterNulls","addAttribute","key","value","truncateExempt","getInstance","attributeFilter","dest","filterSegment","_truncate","library","url","procedure","startsWith","EXTERNAL","PREFIX","product","collection","sql","sql_obfuscated","database_name","host","port_path_or_id","address","DB","val","truncated","obj","out","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Config = require('../config')\nconst {truncate} = require('../util/byte-limit')\n\nconst {DESTINATIONS} = require('../config/attribute-filter')\nconst NAMES = require('../metrics/names')\nconst HTTP_LIBRARY = 'http'\nconst CLIENT_KIND = 'client'\nconst CATEGORIES = {\n  HTTP: 'http',\n  DATASTORE: 'datastore',\n  GENERIC: 'generic'\n}\nconst EMPTY_USER_ATTRS = Object.freeze(Object.create(null))\n\n/**\n * All the intrinsic attributes for span events, regardless of kind.\n */\nclass SpanIntrinsics {\n  constructor() {\n    this.type = 'Span'\n    this.traceId = null\n    this.guid = null\n    this.parentId = null\n    this.transactionId = null\n    this.sampled = null\n    this.priority = null\n    this.name = null\n    this.category = CATEGORIES.GENERIC\n    this.component = null\n    this.timestamp = null\n    this.duration = null\n    this['nr.entryPoint'] = null\n    this['span.kind'] = null\n  }\n}\n\n/**\n * General span event class.\n *\n * Do not construct directly, instead use one of the static `from*` methods such\n * as `SpanEvent.fromSegment`.\n *\n * @private\n * @class\n */\nclass SpanEvent {\n  constructor(attributes) {\n    this.attributes = attributes\n    this.intrinsics = new SpanIntrinsics()\n  }\n\n  static get CATEGORIES() {\n    return CATEGORIES\n  }\n\n  static get DatastoreSpanEvent() {\n    return DatastoreSpanEvent\n  }\n\n  static get HttpSpanEvent() {\n    return HttpSpanEvent\n  }\n\n  /**\n   * Constructs a `SpanEvent` from the given segment.\n   *\n   * The constructed span event will contain extra data depending on the\n   * category of the segment.\n   *\n   * @param {TraceSegment}  segment         - The segment to turn into a span event.\n   * @param {?string}       [parentId=null] - The ID of the segment's parent.\n   *\n   * @return {SpanEvent} The constructed event.\n   */\n  static fromSegment(segment, parentId = null) {\n    const attributes = segment.attributes.get(DESTINATIONS.SPAN_EVENT)\n\n    let span = null\n    if (HttpSpanEvent.testSegment(segment)) {\n      span = new HttpSpanEvent(attributes)\n    } else if (DatastoreSpanEvent.testSegment(segment)) {\n      span = new DatastoreSpanEvent(attributes)\n    } else {\n      span = new SpanEvent(attributes)\n    }\n\n    const tx = segment.transaction\n\n    span.intrinsics.traceId = tx.getTraceId()\n    span.intrinsics.guid = segment.id\n    span.intrinsics.parentId = parentId\n    span.intrinsics.transactionId = tx.id\n    span.intrinsics.sampled = tx.sampled\n    span.intrinsics.priority = tx.priority\n    span.intrinsics.name = segment.name\n\n    // Only set this if it will be `true`. Must be `null` otherwise.\n    if (tx.baseSegment === segment) {\n      span.intrinsics['nr.entryPoint'] = true\n    }\n\n    // Timestamp in milliseconds, duration in seconds. Yay consistency!\n    span.intrinsics.timestamp = segment.timer.start\n    span.intrinsics.duration = segment.timer.getDurationInMillis() / 1000\n\n    return span\n  }\n\n  toJSON() {\n    return [\n      _filterNulls(this.intrinsics),\n      EMPTY_USER_ATTRS,\n      _filterNulls(this.attributes)\n    ]\n  }\n\n  addAttribute(key, value, truncateExempt = false) {\n    const {attributeFilter} = Config.getInstance()\n    const dest = attributeFilter.filterSegment(DESTINATIONS.SPAN_EVENT, key)\n    if (dest & DESTINATIONS.SPAN_EVENT) {\n      this.attributes[key] = truncateExempt ? value : _truncate(value)\n    }\n  }\n}\n\n/**\n * Span event class for external requests.\n *\n * @private\n * @class\n */\nclass HttpSpanEvent extends SpanEvent {\n  constructor(attributes) {\n    super(attributes)\n\n    this.intrinsics.category = CATEGORIES.HTTP\n    this.intrinsics.component = attributes.library || HTTP_LIBRARY\n    this.intrinsics['span.kind'] = CLIENT_KIND\n\n    if (attributes.library) {\n      attributes.library = null\n    }\n\n    if (attributes.url) {\n      this.addAttribute('http.url', attributes.url)\n      attributes.url = null\n    }\n\n    if (attributes.procedure) {\n      this.addAttribute('http.method', attributes.procedure)\n      attributes.procedure = null\n    }\n  }\n\n  static testSegment(segment) {\n    return segment.name.startsWith(NAMES.EXTERNAL.PREFIX)\n  }\n}\n\n/**\n * Span event class for datastore operations and queries.\n *\n * @private\n * @class.\n */\nclass DatastoreSpanEvent extends SpanEvent {\n  constructor(attributes) {\n    super(attributes)\n\n    this.intrinsics.category = CATEGORIES.DATASTORE\n    this.intrinsics['span.kind'] = CLIENT_KIND\n\n    if (attributes.product) {\n      this.intrinsics.component = attributes.product\n      attributes.product = null\n    }\n\n    if (attributes.collection) {\n      this.addAttribute('db.collection', attributes.collection)\n      attributes.collection = null\n    }\n\n    if (attributes.sql || attributes.sql_obfuscated) {\n      let sql = null\n      if (attributes.sql_obfuscated) {\n        sql = _truncate(attributes.sql_obfuscated)\n        attributes.sql_obfuscated = null\n      } else if (attributes.sql) {\n        sql = _truncate(attributes.sql)\n        attributes.sql = null\n      }\n\n      // Flag as exempt from normal attribute truncation\n      this.addAttribute('db.statement', sql, true)\n    }\n\n    if (attributes.database_name) {\n      this.addAttribute('db.instance', attributes.database_name)\n      attributes.database_name = null\n    }\n\n    if (attributes.host) {\n      this.addAttribute('peer.hostname', attributes.host)\n\n      if (attributes.port_path_or_id) {\n        const address = `${attributes.host}:${attributes.port_path_or_id}`\n        this.addAttribute('peer.address', address)\n        attributes.port_path_or_id = null\n      }\n      attributes.host = null\n    }\n  }\n\n  static testSegment(segment) {\n    return segment.name.startsWith(NAMES.DB.PREFIX)\n  }\n}\n\nfunction _truncate(val) {\n  let truncated = truncate(val, 1997)\n  if (truncated !== val) {\n    truncated += '...'\n  }\n  return truncated\n}\n\nfunction _filterNulls(obj) {\n  const out = Object.create(null)\n  for (let key in obj) {\n    if (obj[key] != null) {\n      out[key] = obj[key]\n    }\n  }\n  return out\n}\n\nmodule.exports = SpanEvent\n"]},"metadata":{},"sourceType":"script"}