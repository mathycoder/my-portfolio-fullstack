{"ast":null,"code":"'use strict';\n\nvar NO_MATCH = -Infinity;\nvar EXACT_MATCH = Infinity;\nvar DESTINATIONS = {\n  NONE: 0x00,\n  TRANS_EVENT: 0x01,\n  TRANS_TRACE: 0x02,\n  ERROR_EVENT: 0x04,\n  BROWSER_EVENT: 0x08,\n  SPAN_EVENT: 0x10,\n  TRANS_SEGMENT: 0x20\n};\nDESTINATIONS.TRANS_SCOPE = DESTINATIONS.TRANS_EVENT | DESTINATIONS.TRANS_TRACE | DESTINATIONS.ERROR_EVENT | DESTINATIONS.BROWSER_EVENT;\nDESTINATIONS.SEGMENT_SCOPE = DESTINATIONS.SPAN_EVENT | DESTINATIONS.TRANS_SEGMENT;\nDESTINATIONS.TRANS_COMMON = DESTINATIONS.TRANS_EVENT | DESTINATIONS.TRANS_TRACE | DESTINATIONS.ERROR_EVENT;\nDESTINATIONS.LIMITED = DESTINATIONS.TRANS_TRACE | DESTINATIONS.ERROR_EVENT;\nconst TRANS_SCOPE_DETAILS = [{\n  id: DESTINATIONS.TRANS_EVENT,\n  key: 'TRANS_EVENT',\n  name: 'transaction_events'\n}, {\n  id: DESTINATIONS.TRANS_TRACE,\n  key: 'TRANS_TRACE',\n  name: 'transaction_tracer'\n}, {\n  id: DESTINATIONS.ERROR_EVENT,\n  key: 'ERROR_EVENT',\n  name: 'error_collector'\n}, {\n  id: DESTINATIONS.BROWSER_EVENT,\n  key: 'BROWSER_EVENT',\n  name: 'browser_monitoring'\n}];\nconst SEGMENT_SCOPE_DETAILS = [{\n  id: DESTINATIONS.SPAN_EVENT,\n  key: 'SPAN_EVENT',\n  name: 'span_events'\n}, {\n  id: DESTINATIONS.TRANS_SEGMENT,\n  key: 'TRANS_SEGMENT',\n  name: 'transaction_segments'\n}];\nconst DESTINATION_DETAILS = [...TRANS_SCOPE_DETAILS, ...SEGMENT_SCOPE_DETAILS];\nmodule.exports = exports = AttributeFilter;\nexports.DESTINATIONS = DESTINATIONS;\n/**\n * Parses configuration for filtering attributes and provides way to test keys\n * against the configuration.\n *\n * @class\n * @private\n *\n * @param {Config} config - The configuration object for the agent.\n */\n\nfunction AttributeFilter(config) {\n  this.config = config;\n  this._rules = Object.create(null);\n  this._cache = Object.create(null);\n  this._cachedCount = 0;\n  this._enabledDestinations = DESTINATIONS.NONE;\n  var updater = this.update.bind(this); // Add the global rules.\n\n  config.on('attributes.enabled', updater);\n  config.on('attributes.include', updater);\n  config.on('attributes.exclude', updater);\n  this._rules.global = Object.create(null); // And all the destination rules.\n\n  DESTINATION_DETAILS.forEach(function forEachDestination(dest) {\n    config.on(dest.name + '.attributes.enabled', updater);\n    config.on(dest.name + '.attributes.include', updater);\n    config.on(dest.name + '.attributes.exclude', updater);\n    this._rules[dest.name] = Object.create(null);\n  }, this); // Now pull in all the rules.\n\n  this.update();\n}\n/**\n * Tests a given key against the global and destination transaction filters.\n *\n * @param {DESTINATIONS}  destinations  - The locations the attribute wants to be put.\n * @param {string}        key           - The name of the attribute to test.\n *\n * @return {DESTINATIONS} The destinations the attribute should be put.\n */\n\n\nAttributeFilter.prototype.filterTransaction = filterTransaction;\n\nfunction filterTransaction(destinations, key) {\n  return this._filter(TRANS_SCOPE_DETAILS, destinations, key);\n}\n/**\n * Tests a given key against the global and destination segment filters.\n *\n * @param {DESTINATIONS}  destinations  - The locations the attribute wants to be put.\n * @param {string}        key           - The name of the attribute to test.\n *\n * @return {DESTINATIONS} The destinations the attribute should be put.\n */\n\n\nAttributeFilter.prototype.filterSegment = function filterSegment(destinations, key) {\n  return this._filter(SEGMENT_SCOPE_DETAILS, destinations, key);\n};\n/**\n * Tests a given key against all global and destination filters.\n *\n * @param {DESTINATIONS}  destinations  - The locations the attribute wants to be put.\n * @param {string}        key           - The name of the attribute to test.\n *\n * @return {DESTINATIONS} The destinations the attribute should be put.\n */\n\n\nAttributeFilter.prototype.filterAll = function filterSegment(destinations, key) {\n  return this._filter(DESTINATION_DETAILS, destinations, key);\n};\n/**\n * Tests a given key against the global and destination filters.\n *\n * @param {array}         scope         - The destination details for filtering.\n * @param {DESTINATIONS}  destinations  - The locations the attribute wants to be put.\n * @param {string}        key           - The name of the attribute to test.\n *\n * @return {DESTINATIONS} The destinations the attribute should be put.\n */\n\n\nAttributeFilter.prototype._filter = function _filter(scope, destinations, key) {\n  // This method could be easily memoized since for a given destination and key\n  // the result will always be the same until a configuration update happens. A\n  // given application will also have a controllable set of destinations and\n  // keys to check.\n  // First, see if attributes are even enabled for this destination.\n  if (!this.config.attributes.enabled) {\n    return DESTINATIONS.NONE;\n  } // These are lazy computed to avoid calculating them for cached results.\n\n\n  var globalInclude = null;\n  var globalExclude = null; // Iterate over each desination and see if the rules apply.\n\n  for (var i = 0; i < scope.length; ++i) {\n    var dest = scope[i];\n    var destId = dest.id;\n    var destName = dest.name;\n\n    if (!(this._enabledDestinations & destId)) {\n      destinations &= ~destId; // Remove this destination.\n\n      continue;\n    } // Check for a cached result for this key.\n\n\n    var result = this._cache[destName][key];\n\n    if (result === undefined) {\n      if (globalInclude === null) {\n        globalInclude = _matchRules(this._rules.global.include, key);\n        globalExclude = _matchRules(this._rules.global.exclude, key);\n      } // Freshly calculate this attribute.\n\n\n      var result = _doTest(globalInclude, globalExclude, this._rules[destName], key);\n\n      if (this._cachedCount < this.config.attributes.filter_cache_limit) {\n        this._cache[destName][key] = result;\n        ++this._cachedCount;\n      }\n    }\n\n    if (result === NO_MATCH) {// No match, no-op.\n    } else if (result) {\n      destinations |= destId; // Positive match, add it in.\n    } else {\n      destinations &= ~destId; // Negative match, remove it.\n    }\n  }\n\n  return destinations;\n};\n/**\n * Updates all the rules the given filter has access to.\n */\n\n\nAttributeFilter.prototype.update = function update() {\n  // Update the global rules.\n  this._rules.global.include = _importRules(this.config.attributes.include_enabled ? this.config.attributes.include : []);\n  this._rules.global.exclude = _importRules(this.config.attributes.exclude);\n  this._cache = Object.create(null);\n  this._cachedCount = 0; // And all the destination rules.\n\n  DESTINATION_DETAILS.forEach(function forEachDestination(dest) {\n    var name = dest.name;\n\n    if (!this.config[name].attributes.enabled) {\n      return;\n    }\n\n    this._enabledDestinations |= dest.id;\n    this._rules[name].include = _importRules(this.config.attributes.include_enabled ? this.config[name].attributes.include : []);\n    this._rules[name].exclude = _importRules(this.config[name].attributes.exclude);\n    this._cache[name] = Object.create(null);\n  }, this);\n};\n/**\n * Applies the global and destination rules to this key.\n *\n * @private\n *\n * @return {bool|number} True if this key is explicitly included, false if it is\n *  explicitly excluded, or `NO_MATCH` if no rule applies.\n */\n\n\nfunction _doTest(globalInclude, globalExclude, destConfig, key) {\n  // Check for exclusion of the attribute.\n  if (globalExclude === EXACT_MATCH) {\n    return false;\n  }\n\n  var destExclude = _matchRules(destConfig.exclude, key);\n\n  if (destExclude === EXACT_MATCH) {\n    return false;\n  } // Then check for inclusion of the attribute.\n\n\n  if (globalInclude === EXACT_MATCH) {\n    return true;\n  }\n\n  var destInclude = _matchRules(destConfig.include, key);\n\n  if (destInclude === EXACT_MATCH) {\n    return true;\n  } // Did any rule match this key? If not, this is a no-match.\n\n\n  if (globalExclude === NO_MATCH && globalInclude === NO_MATCH && destExclude === NO_MATCH && destInclude === NO_MATCH) {\n    return NO_MATCH;\n  } // Something has matched this key, so compare the strength of any wildcard\n  // matches that have happened.\n\n\n  return (// If destination include is a better match than either exclude, it's in!\n    destInclude > destExclude && destInclude >= globalExclude || // If global include is a better match than either exclude, it's in!\n    globalInclude > destExclude && globalInclude > globalExclude\n  );\n}\n/**\n * Tests the given key against the given rule set.\n *\n * @private\n *\n * This method assumes that the rule set is sorted from best possible match to\n * least possible match. Unsorted lists may result in a lesser score being given\n * to the value.\n *\n * @param {array.<string>}  rules - The set of rules to match against.\n * @param {string}          key   - The name of the attribute to look for.\n *\n * @return {number} The strength of the match, from `0` for no-match to `Infinity`\n *  for exact matches.\n */\n\n\nfunction _matchRules(rules, key) {\n  if (rules.exact && rules.exact.test(key)) {\n    return EXACT_MATCH;\n  }\n\n  var wildcard = rules.wildcard;\n\n  if (!wildcard) {\n    return NO_MATCH;\n  }\n\n  wildcard.lastIndex = 0;\n  return wildcard.test(key) ? wildcard.lastIndex + 1 : NO_MATCH;\n}\n/**\n * Converts the raw rules into a set of regular expressions to test against.\n *\n * @private\n *\n * @param {array.<string>} rules - The set of rules to compose.\n *\n * @return {object} An object with `exact` and `wildcard` properties which are\n * `RegExp` instances for testing keys.\n */\n\n\nfunction _importRules(rules) {\n  var out = {\n    exact: null,\n    wildcard: null\n  };\n  var exactRules = [];\n  var wildcardRules = [];\n  rules.forEach(function separateRules(rule) {\n    if (rule[rule.length - 1] === '*') {\n      wildcardRules.push(rule);\n    } else {\n      exactRules.push(rule);\n    }\n  });\n\n  if (exactRules.length) {\n    out.exact = new RegExp('^' + _convertRulesToRegex(exactRules) + '$');\n  }\n\n  if (wildcardRules.length) {\n    // The 'g' option is what makes the RegExp set `lastIndex` which we use to\n    // test the strength of the match.\n    out.wildcard = new RegExp('^' + _convertRulesToRegex(wildcardRules), 'g');\n  }\n\n  return out;\n}\n/**\n * Converts an array of attribute rules into a regular expression string.\n *\n * @private\n *\n * `[\"foo.bar\", \"foo.bang\"]` becomes \"(?:foo\\.(?:bar|bang))\"\n *\n * @param {array.<string>} rules - The set of rules compose into a regex.\n *\n * @return {string} The rules composed into a single regular expression string.\n */\n\n\nfunction _convertRulesToRegex(rules) {\n  return '(?:' + rules.sort(function ruleSorter(a, b) {\n    // Step 1) Sort the rules according to match-ability. This way the regex\n    // will test the rules with the highest possible strength before weaker rules.\n    if (a[a.length - 1] !== '*') {\n      // If `a` is an exact rule, it should be moved up.\n      return -1;\n    } else if (b[b.length - 1] !== '*') {\n      // If `b` is an exact rule and `a` is not, `b` should be moved up.\n      return 1;\n    } // Both `a` and `b` are wildcard rules, so the rule with greater length\n    // should be moved up.\n\n\n    return b.length - a.length;\n  }).map(function ruleSplitter(rule) {\n    // Step 2) Escape regex special characters and split the rules into arrays.\n    // 'foo.bar' => ['foo', 'bar']\n    // 'foo.bang*' => ['foo', 'bang\\\\*']\n    // 'fizz.bang' => ['fizz', 'bang']\n    // '*' => ['\\\\*']\n    return rule.replace(/([.*+?|\\\\^$()\\[\\]])/g, function cleaner(m) {\n      return '\\\\' + m;\n    }).split('.');\n  }).reduce(function ruleTransformer(collection, ruleParts) {\n    // Step 3) Merge the split rules into a single nested array, deduplicating\n    // rule sections as we go.\n    // ['foo', 'bar'] => [['foo\\\\.', ['bar']]]\n    // ['foo', 'bang\\\\*'] => [['foo\\\\.', ['bar'], ['bang']]]\n    // ['fizz', 'bang'] => [['foo\\\\.', ['bar'], ['bang']], ['fizz\\\\.', ['bang']]]\n    // ['\\\\*'] => [['foo\\\\.', ['bar'], ['bang']], ['fizz\\\\.', ['bang']], ['']]\n    add(collection, ruleParts, 0);\n    return collection;\n\n    function add(c, r, i) {\n      var v = r[i];\n\n      if (i !== r.length - 1) {\n        v += '.';\n      } else if (/\\\\\\*$/.test(v)) {\n        v = v.substr(0, v.length - 2);\n      }\n\n      var idx = c.findIndex(function findV(a) {\n        return a[0] === v;\n      });\n      var part = c[idx];\n\n      if (idx === -1) {\n        part = [v];\n        c.push(part);\n      }\n\n      if (i !== r.length - 1) {\n        add(part, r, i + 1);\n      }\n    }\n  }, []).map(function rulesToRegex(part) {\n    // Step 4) Merge each of the transformed rules into a regex.\n    // ['foo\\\\.', ['bar', 'bang']] => 'foo\\\\.(?:bar|bang)'\n    // ['fizz\\\\.', ['bang']] => 'fizz\\\\.(?:bang)'\n    // [''] => ''\n    return mapper(part);\n\n    function mapper(p) {\n      if (typeof p === 'string') {\n        return p;\n      } else if (p.length === 1) {\n        return mapper(p[0]);\n      }\n\n      var first = mapper(p.shift()); // shift === pop_front\n\n      return first + '(?:' + p.map(mapper).join('|') + ')';\n    }\n  }).join('|') + ')'; // Step 5) Merge all the regex strings into one.\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/config/attribute-filter.js"],"names":["NO_MATCH","Infinity","EXACT_MATCH","DESTINATIONS","NONE","TRANS_EVENT","TRANS_TRACE","ERROR_EVENT","BROWSER_EVENT","SPAN_EVENT","TRANS_SEGMENT","TRANS_SCOPE","SEGMENT_SCOPE","TRANS_COMMON","LIMITED","TRANS_SCOPE_DETAILS","id","key","name","SEGMENT_SCOPE_DETAILS","DESTINATION_DETAILS","module","exports","AttributeFilter","config","_rules","Object","create","_cache","_cachedCount","_enabledDestinations","updater","update","bind","on","global","forEach","forEachDestination","dest","prototype","filterTransaction","destinations","_filter","filterSegment","filterAll","scope","attributes","enabled","globalInclude","globalExclude","i","length","destId","destName","result","undefined","_matchRules","include","exclude","_doTest","filter_cache_limit","_importRules","include_enabled","destConfig","destExclude","destInclude","rules","exact","test","wildcard","lastIndex","out","exactRules","wildcardRules","separateRules","rule","push","RegExp","_convertRulesToRegex","sort","ruleSorter","a","b","map","ruleSplitter","replace","cleaner","m","split","reduce","ruleTransformer","collection","ruleParts","add","c","r","v","substr","idx","findIndex","findV","part","rulesToRegex","mapper","p","first","shift","join"],"mappings":"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","sourcesContent":["'use strict'\n\nvar NO_MATCH = -Infinity\nvar EXACT_MATCH = Infinity\nvar DESTINATIONS = {\n  NONE: 0x00,\n  TRANS_EVENT: 0x01,\n  TRANS_TRACE: 0x02,\n  ERROR_EVENT: 0x04,\n  BROWSER_EVENT: 0x08,\n  SPAN_EVENT: 0x10,\n  TRANS_SEGMENT: 0x20\n}\nDESTINATIONS.TRANS_SCOPE =\n  DESTINATIONS.TRANS_EVENT |\n  DESTINATIONS.TRANS_TRACE |\n  DESTINATIONS.ERROR_EVENT |\n  DESTINATIONS.BROWSER_EVENT\n\nDESTINATIONS.SEGMENT_SCOPE = DESTINATIONS.SPAN_EVENT | DESTINATIONS.TRANS_SEGMENT\n\nDESTINATIONS.TRANS_COMMON =\n  DESTINATIONS.TRANS_EVENT |\n  DESTINATIONS.TRANS_TRACE |\n  DESTINATIONS.ERROR_EVENT\n\nDESTINATIONS.LIMITED = DESTINATIONS.TRANS_TRACE | DESTINATIONS.ERROR_EVENT\n\nconst TRANS_SCOPE_DETAILS = [\n  {id: DESTINATIONS.TRANS_EVENT, key: 'TRANS_EVENT', name: 'transaction_events'},\n  {id: DESTINATIONS.TRANS_TRACE, key: 'TRANS_TRACE', name: 'transaction_tracer'},\n  {id: DESTINATIONS.ERROR_EVENT, key: 'ERROR_EVENT', name: 'error_collector'},\n  {id: DESTINATIONS.BROWSER_EVENT, key: 'BROWSER_EVENT', name: 'browser_monitoring'}\n]\n\nconst SEGMENT_SCOPE_DETAILS = [\n  {id: DESTINATIONS.SPAN_EVENT, key: 'SPAN_EVENT', name: 'span_events'},\n  {id: DESTINATIONS.TRANS_SEGMENT, key: 'TRANS_SEGMENT', name: 'transaction_segments'}\n]\n\nconst DESTINATION_DETAILS = [...TRANS_SCOPE_DETAILS, ...SEGMENT_SCOPE_DETAILS]\n\nmodule.exports = exports = AttributeFilter\nexports.DESTINATIONS = DESTINATIONS\n\n/**\n * Parses configuration for filtering attributes and provides way to test keys\n * against the configuration.\n *\n * @class\n * @private\n *\n * @param {Config} config - The configuration object for the agent.\n */\nfunction AttributeFilter(config) {\n  this.config = config\n  this._rules = Object.create(null)\n  this._cache = Object.create(null)\n  this._cachedCount = 0\n  this._enabledDestinations = DESTINATIONS.NONE\n\n  var updater = this.update.bind(this)\n\n  // Add the global rules.\n  config.on('attributes.enabled', updater)\n  config.on('attributes.include', updater)\n  config.on('attributes.exclude', updater)\n  this._rules.global = Object.create(null)\n\n  // And all the destination rules.\n  DESTINATION_DETAILS.forEach(function forEachDestination(dest) {\n    config.on(dest.name + '.attributes.enabled', updater)\n    config.on(dest.name + '.attributes.include', updater)\n    config.on(dest.name + '.attributes.exclude', updater)\n    this._rules[dest.name] = Object.create(null)\n  }, this)\n\n  // Now pull in all the rules.\n  this.update()\n}\n\n/**\n * Tests a given key against the global and destination transaction filters.\n *\n * @param {DESTINATIONS}  destinations  - The locations the attribute wants to be put.\n * @param {string}        key           - The name of the attribute to test.\n *\n * @return {DESTINATIONS} The destinations the attribute should be put.\n */\nAttributeFilter.prototype.filterTransaction = filterTransaction\nfunction filterTransaction(destinations, key) {\n  return this._filter(TRANS_SCOPE_DETAILS, destinations, key)\n}\n\n/**\n * Tests a given key against the global and destination segment filters.\n *\n * @param {DESTINATIONS}  destinations  - The locations the attribute wants to be put.\n * @param {string}        key           - The name of the attribute to test.\n *\n * @return {DESTINATIONS} The destinations the attribute should be put.\n */\nAttributeFilter.prototype.filterSegment = function filterSegment(destinations, key) {\n  return this._filter(SEGMENT_SCOPE_DETAILS, destinations, key)\n}\n\n/**\n * Tests a given key against all global and destination filters.\n *\n * @param {DESTINATIONS}  destinations  - The locations the attribute wants to be put.\n * @param {string}        key           - The name of the attribute to test.\n *\n * @return {DESTINATIONS} The destinations the attribute should be put.\n */\nAttributeFilter.prototype.filterAll = function filterSegment(destinations, key) {\n  return this._filter(DESTINATION_DETAILS, destinations, key)\n}\n\n/**\n * Tests a given key against the global and destination filters.\n *\n * @param {array}         scope         - The destination details for filtering.\n * @param {DESTINATIONS}  destinations  - The locations the attribute wants to be put.\n * @param {string}        key           - The name of the attribute to test.\n *\n * @return {DESTINATIONS} The destinations the attribute should be put.\n */\nAttributeFilter.prototype._filter = function _filter(scope, destinations, key) {\n  // This method could be easily memoized since for a given destination and key\n  // the result will always be the same until a configuration update happens. A\n  // given application will also have a controllable set of destinations and\n  // keys to check.\n\n  // First, see if attributes are even enabled for this destination.\n  if (!this.config.attributes.enabled) {\n    return DESTINATIONS.NONE\n  }\n\n  // These are lazy computed to avoid calculating them for cached results.\n  var globalInclude = null\n  var globalExclude = null\n\n  // Iterate over each desination and see if the rules apply.\n  for (var i = 0; i < scope.length; ++i) {\n    var dest = scope[i]\n    var destId = dest.id\n    var destName = dest.name\n    if (!(this._enabledDestinations & destId)) {\n      destinations &= ~destId // Remove this destination.\n      continue\n    }\n\n    // Check for a cached result for this key.\n    var result = this._cache[destName][key]\n    if (result === undefined) {\n      if (globalInclude === null) {\n        globalInclude = _matchRules(this._rules.global.include, key)\n        globalExclude = _matchRules(this._rules.global.exclude, key)\n      }\n\n      // Freshly calculate this attribute.\n      var result = _doTest(globalInclude, globalExclude, this._rules[destName], key)\n      if (this._cachedCount < this.config.attributes.filter_cache_limit) {\n        this._cache[destName][key] = result\n        ++this._cachedCount\n      }\n    }\n\n    if (result === NO_MATCH) {\n      // No match, no-op.\n    } else if (result) {\n      destinations |= destId // Positive match, add it in.\n    } else {\n      destinations &= ~destId // Negative match, remove it.\n    }\n  }\n\n  return destinations\n}\n\n/**\n * Updates all the rules the given filter has access to.\n */\nAttributeFilter.prototype.update = function update() {\n  // Update the global rules.\n  this._rules.global.include = _importRules(\n    this.config.attributes.include_enabled ? this.config.attributes.include : []\n  )\n  this._rules.global.exclude = _importRules(this.config.attributes.exclude)\n  this._cache = Object.create(null)\n  this._cachedCount = 0\n\n  // And all the destination rules.\n  DESTINATION_DETAILS.forEach(function forEachDestination(dest) {\n    var name = dest.name\n    if (!this.config[name].attributes.enabled) {\n      return\n    }\n\n    this._enabledDestinations |= dest.id\n    this._rules[name].include = _importRules(\n      this.config.attributes.include_enabled ? this.config[name].attributes.include : []\n    )\n    this._rules[name].exclude = _importRules(this.config[name].attributes.exclude)\n    this._cache[name] = Object.create(null)\n  }, this)\n}\n\n/**\n * Applies the global and destination rules to this key.\n *\n * @private\n *\n * @return {bool|number} True if this key is explicitly included, false if it is\n *  explicitly excluded, or `NO_MATCH` if no rule applies.\n */\nfunction _doTest(globalInclude, globalExclude, destConfig, key) {\n  // Check for exclusion of the attribute.\n  if (globalExclude === EXACT_MATCH) {\n    return false\n  }\n  var destExclude = _matchRules(destConfig.exclude, key)\n  if (destExclude === EXACT_MATCH) {\n    return false\n  }\n\n  // Then check for inclusion of the attribute.\n  if (globalInclude === EXACT_MATCH) {\n    return true\n  }\n  var destInclude = _matchRules(destConfig.include, key)\n  if (destInclude === EXACT_MATCH) {\n    return true\n  }\n\n  // Did any rule match this key? If not, this is a no-match.\n  if (\n    globalExclude === NO_MATCH &&\n    globalInclude === NO_MATCH &&\n    destExclude === NO_MATCH &&\n    destInclude === NO_MATCH\n  ) {\n    return NO_MATCH\n  }\n\n  // Something has matched this key, so compare the strength of any wildcard\n  // matches that have happened.\n  return (\n    // If destination include is a better match than either exclude, it's in!\n    (destInclude > destExclude && destInclude >= globalExclude) ||\n\n    // If global include is a better match than either exclude, it's in!\n    (globalInclude > destExclude && globalInclude > globalExclude)\n  )\n}\n\n/**\n * Tests the given key against the given rule set.\n *\n * @private\n *\n * This method assumes that the rule set is sorted from best possible match to\n * least possible match. Unsorted lists may result in a lesser score being given\n * to the value.\n *\n * @param {array.<string>}  rules - The set of rules to match against.\n * @param {string}          key   - The name of the attribute to look for.\n *\n * @return {number} The strength of the match, from `0` for no-match to `Infinity`\n *  for exact matches.\n */\nfunction _matchRules(rules, key) {\n  if (rules.exact && rules.exact.test(key)) {\n    return EXACT_MATCH\n  }\n\n  var wildcard = rules.wildcard\n  if (!wildcard) {\n    return NO_MATCH\n  }\n\n  wildcard.lastIndex = 0\n  return wildcard.test(key) ? wildcard.lastIndex + 1 : NO_MATCH\n}\n\n/**\n * Converts the raw rules into a set of regular expressions to test against.\n *\n * @private\n *\n * @param {array.<string>} rules - The set of rules to compose.\n *\n * @return {object} An object with `exact` and `wildcard` properties which are\n * `RegExp` instances for testing keys.\n */\nfunction _importRules(rules) {\n  var out = {\n    exact: null,\n    wildcard: null\n  }\n  var exactRules = []\n  var wildcardRules = []\n  rules.forEach(function separateRules(rule) {\n    if (rule[rule.length - 1] === '*') {\n      wildcardRules.push(rule)\n    } else {\n      exactRules.push(rule)\n    }\n  })\n\n  if (exactRules.length) {\n    out.exact = new RegExp('^' + _convertRulesToRegex(exactRules) + '$')\n  }\n  if (wildcardRules.length) {\n    // The 'g' option is what makes the RegExp set `lastIndex` which we use to\n    // test the strength of the match.\n    out.wildcard = new RegExp('^' + _convertRulesToRegex(wildcardRules), 'g')\n  }\n  return out\n}\n\n/**\n * Converts an array of attribute rules into a regular expression string.\n *\n * @private\n *\n * `[\"foo.bar\", \"foo.bang\"]` becomes \"(?:foo\\.(?:bar|bang))\"\n *\n * @param {array.<string>} rules - The set of rules compose into a regex.\n *\n * @return {string} The rules composed into a single regular expression string.\n */\nfunction _convertRulesToRegex(rules) {\n  return '(?:' + rules.sort(function ruleSorter(a, b) {\n    // Step 1) Sort the rules according to match-ability. This way the regex\n    // will test the rules with the highest possible strength before weaker rules.\n\n    if (a[a.length - 1] !== '*') {\n      // If `a` is an exact rule, it should be moved up.\n      return -1\n    } else if (b[b.length - 1] !== '*') {\n      // If `b` is an exact rule and `a` is not, `b` should be moved up.\n      return 1\n    }\n\n    // Both `a` and `b` are wildcard rules, so the rule with greater length\n    // should be moved up.\n    return b.length - a.length\n  }).map(function ruleSplitter(rule) {\n    // Step 2) Escape regex special characters and split the rules into arrays.\n\n    // 'foo.bar' => ['foo', 'bar']\n    // 'foo.bang*' => ['foo', 'bang\\\\*']\n    // 'fizz.bang' => ['fizz', 'bang']\n    // '*' => ['\\\\*']\n    return rule.replace(/([.*+?|\\\\^$()\\[\\]])/g, function cleaner(m) {\n      return '\\\\' + m\n    }).split('.')\n  }).reduce(function ruleTransformer(collection, ruleParts) {\n    // Step 3) Merge the split rules into a single nested array, deduplicating\n    // rule sections as we go.\n\n    // ['foo', 'bar'] => [['foo\\\\.', ['bar']]]\n    // ['foo', 'bang\\\\*'] => [['foo\\\\.', ['bar'], ['bang']]]\n    // ['fizz', 'bang'] => [['foo\\\\.', ['bar'], ['bang']], ['fizz\\\\.', ['bang']]]\n    // ['\\\\*'] => [['foo\\\\.', ['bar'], ['bang']], ['fizz\\\\.', ['bang']], ['']]\n    add(collection, ruleParts, 0)\n    return collection\n    function add(c, r, i) {\n      var v = r[i]\n      if (i !== r.length - 1) {\n        v += '.'\n      } else if (/\\\\\\*$/.test(v)) {\n        v = v.substr(0, v.length - 2)\n      }\n\n      var idx = c.findIndex(function findV(a) {\n        return a[0] === v\n      })\n      var part = c[idx]\n\n      if (idx === -1) {\n        part = [v]\n        c.push(part)\n      }\n      if (i !== r.length - 1) {\n        add(part, r, i + 1)\n      }\n    }\n  }, []).map(function rulesToRegex(part) {\n    // Step 4) Merge each of the transformed rules into a regex.\n\n    // ['foo\\\\.', ['bar', 'bang']] => 'foo\\\\.(?:bar|bang)'\n    // ['fizz\\\\.', ['bang']] => 'fizz\\\\.(?:bang)'\n    // [''] => ''\n    return mapper(part)\n    function mapper(p) {\n      if (typeof p === 'string') {\n        return p\n      } else if (p.length === 1) {\n        return mapper(p[0])\n      }\n      var first = mapper(p.shift()) // shift === pop_front\n      return first + '(?:' + p.map(mapper).join('|') + ')'\n    }\n  }).join('|') + ')' // Step 5) Merge all the regex strings into one.\n}\n"]},"metadata":{},"sourceType":"script"}