{"ast":null,"code":"'use strict'; //               (       `  database` .     `    table ` )\n\nvar CLEANER = /^\\(?(?:([`'\"]?)(.*?)\\1\\.)?([`'\"]?)(.*?)\\3\\)?$/;\n\nfunction StatementMatcher(operation, operationPattern) {\n  this.operation = operation;\n  this.matcher = new RegExp('^\\\\s*' + operation, 'ig');\n  this.operationPattern = operationPattern;\n}\n\nStatementMatcher.prototype.getParsedStatement = function getParsedStatement(sql) {\n  this.operationPattern.lastIndex = 0;\n  this.matcher.lastIndex = 0;\n  CLEANER.lastIndex = 0;\n\n  if (this.matcher.test(sql)) {\n    var queryMatch = this.operationPattern.exec(sql);\n    var collection = queryMatch ? queryMatch[1] : 'unknown';\n    var database = null; // If the cleaner can match this collection, pull out the cleaned up names\n    // from there. The spec doesn't want the database names in the collection\n    // name, but for legacy reasons we keep it.\n    // TODO: Either update the spec (and CATs) to accept database name in the\n    // collection name or remove it here.\n\n    var cleanerMatch = CLEANER.exec(collection);\n\n    if (cleanerMatch && cleanerMatch[4]) {\n      collection = cleanerMatch[4];\n\n      if (cleanerMatch[2]) {\n        database = cleanerMatch[2];\n        collection = database + '.' + collection;\n      }\n    } // TODO: Pass through the database here to the parsed statement. It could\n    // be used for datastore attributes.\n\n\n    return {\n      operation: this.operation,\n      database: database,\n      collection: collection,\n      query: sql\n    };\n  }\n\n  return null;\n};\n\nmodule.exports = StatementMatcher;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/db/statement-matcher.js"],"names":["CLEANER","StatementMatcher","operation","operationPattern","matcher","RegExp","prototype","getParsedStatement","sql","lastIndex","test","queryMatch","exec","collection","database","cleanerMatch","query","module","exports"],"mappings":"AAAA,a,CAEA;;AACA,IAAIA,OAAO,GAAG,+CAAd;;AAEA,SAASC,gBAAT,CAA0BC,SAA1B,EAAqCC,gBAArC,EAAuD;AACrD,OAAKD,SAAL,GAAiBA,SAAjB;AACA,OAAKE,OAAL,GAAe,IAAIC,MAAJ,CAAW,UAAUH,SAArB,EAAgC,IAAhC,CAAf;AACA,OAAKC,gBAAL,GAAwBA,gBAAxB;AACD;;AAEDF,gBAAgB,CAACK,SAAjB,CAA2BC,kBAA3B,GAAgD,SAASA,kBAAT,CAA4BC,GAA5B,EAAiC;AAC/E,OAAKL,gBAAL,CAAsBM,SAAtB,GAAkC,CAAlC;AACA,OAAKL,OAAL,CAAaK,SAAb,GAAyB,CAAzB;AACAT,EAAAA,OAAO,CAACS,SAAR,GAAoB,CAApB;;AAEA,MAAI,KAAKL,OAAL,CAAaM,IAAb,CAAkBF,GAAlB,CAAJ,EAA4B;AAC1B,QAAIG,UAAU,GAAG,KAAKR,gBAAL,CAAsBS,IAAtB,CAA2BJ,GAA3B,CAAjB;AACA,QAAIK,UAAU,GAAGF,UAAU,GAAGA,UAAU,CAAC,CAAD,CAAb,GAAmB,SAA9C;AACA,QAAIG,QAAQ,GAAG,IAAf,CAH0B,CAK1B;AACA;AACA;AACA;AACA;;AACA,QAAIC,YAAY,GAAGf,OAAO,CAACY,IAAR,CAAaC,UAAb,CAAnB;;AACA,QAAIE,YAAY,IAAIA,YAAY,CAAC,CAAD,CAAhC,EAAqC;AACnCF,MAAAA,UAAU,GAAGE,YAAY,CAAC,CAAD,CAAzB;;AACA,UAAIA,YAAY,CAAC,CAAD,CAAhB,EAAqB;AACnBD,QAAAA,QAAQ,GAAGC,YAAY,CAAC,CAAD,CAAvB;AACAF,QAAAA,UAAU,GAAGC,QAAQ,GAAG,GAAX,GAAiBD,UAA9B;AACD;AACF,KAjByB,CAmB1B;AACA;;;AACA,WAAO;AACLX,MAAAA,SAAS,EAAE,KAAKA,SADX;AAELY,MAAAA,QAAQ,EAAEA,QAFL;AAGLD,MAAAA,UAAU,EAAEA,UAHP;AAILG,MAAAA,KAAK,EAAER;AAJF,KAAP;AAMD;;AAED,SAAO,IAAP;AACD,CAnCD;;AAqCAS,MAAM,CAACC,OAAP,GAAiBjB,gBAAjB","sourcesContent":["'use strict'\n\n//               (       `  database` .     `    table ` )\nvar CLEANER = /^\\(?(?:([`'\"]?)(.*?)\\1\\.)?([`'\"]?)(.*?)\\3\\)?$/\n\nfunction StatementMatcher(operation, operationPattern) {\n  this.operation = operation\n  this.matcher = new RegExp('^\\\\s*' + operation, 'ig')\n  this.operationPattern = operationPattern\n}\n\nStatementMatcher.prototype.getParsedStatement = function getParsedStatement(sql) {\n  this.operationPattern.lastIndex = 0\n  this.matcher.lastIndex = 0\n  CLEANER.lastIndex = 0\n\n  if (this.matcher.test(sql)) {\n    var queryMatch = this.operationPattern.exec(sql)\n    var collection = queryMatch ? queryMatch[1] : 'unknown'\n    var database = null\n\n    // If the cleaner can match this collection, pull out the cleaned up names\n    // from there. The spec doesn't want the database names in the collection\n    // name, but for legacy reasons we keep it.\n    // TODO: Either update the spec (and CATs) to accept database name in the\n    // collection name or remove it here.\n    var cleanerMatch = CLEANER.exec(collection)\n    if (cleanerMatch && cleanerMatch[4]) {\n      collection = cleanerMatch[4]\n      if (cleanerMatch[2]) {\n        database = cleanerMatch[2]\n        collection = database + '.' + collection\n      }\n    }\n\n    // TODO: Pass through the database here to the parsed statement. It could\n    // be used for datastore attributes.\n    return {\n      operation: this.operation,\n      database: database,\n      collection: collection,\n      query: sql\n    }\n  }\n\n  return null\n}\n\nmodule.exports = StatementMatcher\n"]},"metadata":{},"sourceType":"script"}