{"ast":null,"code":"'use strict';\n\nvar genericRecorder = require('../metrics/recorders/generic');\n\nvar logger = require('../logger.js').child({\n  component: 'WebFrameworkShim'\n});\n\nvar metrics = require('../metrics/names');\n\nvar TransactionShim = require('./transaction-shim');\n\nvar Shim = require('./shim');\n\nvar specs = require('./specs');\n\nvar urltils = require('../util/urltils');\n\nvar util = require('util');\n/**\n * An enumeration of well-known web frameworks so that new instrumentations can\n * use the same names we already use for first-party instrumentation.\n *\n * Each of these values is also exposed directly on the WebFrameworkShim class\n * as static members.\n *\n * @readonly\n * @memberof WebFrameworkShim\n * @enum {string}\n */\n\n\nvar FRAMEWORK_NAMES = {\n  CONNECT: 'Connect',\n  DIRECTOR: 'Director',\n  EXPRESS: 'Expressjs',\n  HAPI: 'Hapi',\n  KOA: 'Koa',\n  RESTIFY: 'Restify'\n};\nvar MIDDLEWARE_TYPE_DETAILS = {\n  APPLICATION: {\n    name: 'Mounted App: ',\n    path: true,\n    record: false\n  },\n  ERRORWARE: {\n    name: '',\n    path: false,\n    record: true\n  },\n  MIDDLEWARE: {\n    name: '',\n    path: false,\n    record: true\n  },\n  PARAMWARE: {\n    name: '',\n    path: false,\n    record: true\n  },\n  ROUTE: {\n    name: 'Route Path: ',\n    path: true,\n    record: false\n  },\n  ROUTER: {\n    name: 'Router: ',\n    path: true,\n    record: false\n  }\n};\nvar MIDDLEWARE_TYPE_NAMES = {\n  APPLICATION: 'APPLICATION',\n  ERRORWARE: 'ERRORWARE',\n  MIDDLEWARE: 'MIDDLEWARE',\n  PARAMWARE: 'PARAMWARE',\n  ROUTE: 'ROUTE',\n  ROUTER: 'ROUTER'\n};\n/**\n * Name of the key used to store transaction information on `req` and `res`.\n *\n * @private\n */\n\nvar TRANSACTION_INFO_KEY = '__NR_transactionInfo';\n/**\n * Constructs a shim associated with the given agent instance, specialized for\n * instrumenting web frameworks.\n *\n * @constructor\n * @extends TransactionShim\n * @classdesc\n *  A helper class for wrapping web framework modules.\n *\n * @param {Agent} agent\n *  The agent this shim will use.\n *\n * @param {string} moduleName\n *  The name of the module being instrumented.\n *\n * @param {string} resolvedName\n *  The full path to the loaded module.\n *\n * @param {string} [frameworkId]\n *  The name of the web framework being instrumented. If available, use one of\n *  the values from {@link WebFrameworkShim.FRAMEWORK_NAMES}.\n *\n * @see TransactionShim\n * @see WebFrameworkShim.FRAMEWORK_NAMES\n */\n\nfunction WebFrameworkShim(agent, moduleName, resolvedName, frameworkId) {\n  TransactionShim.call(this, agent, moduleName, resolvedName);\n  this._logger = logger.child({\n    module: moduleName\n  });\n\n  if (frameworkId) {\n    this.setFramework(frameworkId);\n  }\n\n  this._routeParser = _defaultRouteParser;\n  this._errorPredicate = _defaultErrorPredicate;\n  this._responsePredicate = _defaultResponsePredicate;\n}\n\nmodule.exports = WebFrameworkShim;\nutil.inherits(WebFrameworkShim, TransactionShim); // Add constants on the shim for the well-known frameworks.\n\nWebFrameworkShim.FRAMEWORK_NAMES = FRAMEWORK_NAMES;\nObject.keys(FRAMEWORK_NAMES).forEach(function defineWebFrameworkMetricEnum(fwName) {\n  Shim.defineProperty(WebFrameworkShim, fwName, FRAMEWORK_NAMES[fwName]);\n  Shim.defineProperty(WebFrameworkShim.prototype, fwName, FRAMEWORK_NAMES[fwName]);\n});\nWebFrameworkShim.MIDDLEWARE_TYPE_NAMES = MIDDLEWARE_TYPE_NAMES;\nObject.keys(MIDDLEWARE_TYPE_NAMES).forEach(function defineMiddlewareTypeEnum(mtName) {\n  Shim.defineProperty(WebFrameworkShim, mtName, MIDDLEWARE_TYPE_NAMES[mtName]);\n  Shim.defineProperty(WebFrameworkShim.prototype, mtName, MIDDLEWARE_TYPE_NAMES[mtName]);\n});\nWebFrameworkShim.prototype.setRouteParser = setRouteParser;\nWebFrameworkShim.prototype.setFramework = setFramework;\nWebFrameworkShim.prototype.setTransactionUri = setTransactionUri;\nWebFrameworkShim.prototype.wrapMiddlewareMounter = wrapMiddlewareMounter;\nWebFrameworkShim.prototype.recordParamware = recordParamware;\nWebFrameworkShim.prototype.recordMiddleware = recordMiddleware;\nWebFrameworkShim.prototype.recordRender = recordRender;\nWebFrameworkShim.prototype.noticeError = noticeError;\nWebFrameworkShim.prototype.errorHandled = errorHandled;\nWebFrameworkShim.prototype.setErrorPredicate = setErrorPredicate;\nWebFrameworkShim.prototype.setResponsePredicate = setResponsePredicate;\nWebFrameworkShim.prototype.savePossibleTransactionName = savePossibleTransactionName;\nWebFrameworkShim.prototype.captureUrlParams = captureUrlParams; // -------------------------------------------------------------------------- //\n\n/**\n * @callback RouteParserFunction\n *\n * @summary\n *  Called whenever new middleware are mounted using the instrumented framework,\n *  this method should pull out a representation of the mounted path.\n *\n * @param {WebFrameworkShim} shim\n *  The shim in use for this instrumentation.\n *\n * @param {function} fn\n *  The function which received this route string/RegExp.\n *\n * @param {string} fnName\n *  The name of the function to which this route was given.\n *\n * @param {string|RegExp} route\n *  The route that was given to the function.\n *\n * @return {string|RegExp} The mount point from the given route.\n */\n\n/**\n * @callback RouteRequestFunction\n *\n * @summary\n *  Extracts the request object from the arguments to the middleware function.\n *\n * @param {WebFrameworkShim}  shim    - The shim used for instrumentation.\n * @param {function}          fn      - The middleware function.\n * @param {string}            fnName  - The name of the middleware function.\n * @param {Array}             args    - The arguments to the middleware function.\n *\n * @return {Object} The request object.\n */\n\n/**\n * @callback RouteNextFunction\n *\n * @summary\n *  Used to wrap functions that users can call to continue to the next middleware.\n *\n * @param {WebFrameworkShim}    shim    - The shim used for instrumentation.\n * @param {function}            fn      - The middleware function.\n * @param {string}              fnName  - The name of the middleware function.\n * @param {Array}               args    - The arguments to the middleware function.\n * @param {NextWrapperFunction} wrap    - A function to wrap an individual next function.\n *\n * @return {Object} The request object.\n */\n\n/**\n * @callback RouteParameterFunction\n *\n * @summary\n *  Extracts the route parameters from the arguments to the middleware function.\n *\n * @param {WebFrameworkShim}  shim    - The shim used for instrumentation.\n * @param {function}          fn      - The middleware function.\n * @param {string}            fnName  - The name of the middleware function.\n * @param {Array}             args    - The arguments to the middleware function.\n *\n * @return {Object} A map of route parameter names to values.\n */\n\n/**\n * @callback MiddlewareWrapperFunction\n *\n * @summary\n *  Called for each middleware passed to a mounting method. Should perform the\n *  wrapping of the middleware.\n *\n * @param {WebFrameworkShim} shim\n *  The shim used for instrumentation.\n *\n * @param {function} middleware\n *  The middleware function to wrap.\n *\n * @param {string} fnName\n *  The name of the middleware function.\n *\n * @param {string} [route=null]\n *  The route the middleware is mounted on if one was found.\n *\n * @see WebFrameworkShim#recordMiddleware\n * @see WebFrameworkShim#recordParamware\n */\n\n/**\n * @interface MiddlewareSpec\n *\n * @description\n *  Describes the interface for middleware functions with this instrumentation.\n *\n * @property {number|RouteRequestFunction} [req=shim.FIRST]\n *  Indicates which argument to the middleware is the request object. It can also be\n *  a function to extract the request object from the middleware arguments.\n *\n * @property {number} [res=shim.SECOND]\n *  Indicates which argument to the middleware is the response object.\n *\n * @property {number|RouteNextFunction} [next=shim.THIRD]\n *  Indicates which argument to the middleware function is the callback.  When it is\n *  a function, it will be called with the arguments of the middleware and a function\n *  for wrapping calls that represent continuation from the current middleware.\n *\n * @property {string} [name]\n *  The name to use for this middleware. Defaults to `middleware.name`.\n *\n * @property {RouteParameterFunction} [params]\n *  A function to extract the route parameters from the middleware arguments.\n *  Defaults to using `req.params`.\n *\n * @property {string} [type='MIDDLEWARE']\n *\n * @property {string|function} [route=null]\n *  Route/path used for naming segments and transaction name candidates. If a function,\n *  will be invoked just before segment creation with middleware invocation.\n *\n * @property {boolean} [appendPath=true]\n *  Indicates that the path associated with the middleware should be appended\n *  and popped from the stack of name candidates.\n */\n\n/**\n * @interface MiddlewareMounterSpec\n *\n * @description\n *  Describes the arguments provided to mounting methods (e.g. `app.post()`).\n *\n * @property {number|string} [route=null]\n *  Tells which argument may be the mounting path for the other arguments. If\n *  the indicated argument is a function it is assumed the route was not provided\n *  and the indicated argument is a middleware function. If a string is provided\n *  it will be used as the mounting path.\n *\n * @property {MiddlewareWrapperFunction} [wrapper]\n *  A function to call for each middleware function passed to the mounter.\n */\n\n/**\n * @interface RenderSpec\n * @extends RecorderSpec\n *\n * @description\n *  Describes the interface for render methods.\n *\n * @property {number} [view=shim.FIRST]\n *  Identifies which argument is the name of the view being rendered. Defaults\n *  to {@link Shim#ARG_INDEXES shim.FIRST}.\n *\n * @see SegmentSpec\n * @see RecorderSpec\n */\n// -------------------------------------------------------------------------- //\n\n/**\n * Sets the function used to convert the route handed to middleware-adding\n * methods into a string.\n *\n * - `setRouteParser(parser)`\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {RouteParserFunction} parser - The parser function to use.\n */\n\nfunction setRouteParser(parser) {\n  if (!this.isFunction(parser)) {\n    return this.logger.debug('Given route parser is not a function.');\n  }\n\n  this._routeParser = parser;\n}\n/**\n * Sets the name of the web framework in use by the server to the one given.\n *\n * - `setFramework(framework)`\n *\n * This should be the first thing the instrumentation does.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {WebFrameworkShim.FRAMEWORK_NAMES|string} framework\n *  The name of the framework.\n *\n * @see WebFrameworkShim.FRAMEWORK_NAMES\n */\n\n\nfunction setFramework(framework) {\n  this._metrics = {\n    PREFIX: framework + '/',\n    FRAMEWORK: framework,\n    MIDDLEWARE: metrics.MIDDLEWARE.PREFIX\n  };\n  this.agent.environment.setFramework(framework);\n  this._logger = this._logger.child({\n    framework: framework\n  });\n  this.logger.trace({\n    metrics: this._metrics\n  }, 'Framework metric names set');\n}\n/**\n * Sets the URI path to be used for naming the transaction currenty in scope.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {string} uri - The URI path to use for the transaction.\n */\n\n\nfunction setTransactionUri(uri) {\n  var tx = this.tracer.getTransaction();\n\n  if (!tx) {\n    return;\n  }\n\n  tx.nameState.setName(this._metrics.FRAMEWORK, tx.verb, metrics.ACTION_DELIMITER, uri);\n}\n/**\n * Records calls to methods used for rendering views.\n *\n * - `recordRender(nodule, properties [, spec])`\n * - `recordRender(func [, spec])`\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {RenderSpec} [spec]\n *  The spec for wrapping the render method.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n */\n\n\nfunction recordRender(nodule, properties, spec) {\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // recordRender(func, spec)\n    spec = properties;\n    properties = null;\n  }\n\n  spec = this.setDefaults(spec, {\n    view: this.FIRST,\n    callback: null,\n    promise: null\n  });\n  return this.record(nodule, properties, function renderRecorder(shim, fn, name, args) {\n    var viewIdx = shim.normalizeIndex(args.length, spec.view);\n\n    if (viewIdx === null) {\n      shim.logger.debug('Invalid spec.view (%d vs %d), not recording.', spec.view, args.length);\n      return null;\n    }\n\n    return {\n      name: metrics.VIEW.PREFIX + args[viewIdx] + metrics.VIEW.RENDER,\n      callback: spec.callback,\n      promise: spec.promise,\n      recorder: genericRecorder,\n      // Hidden class stuff\n      rowCallback: null,\n      stream: null,\n      internal: false\n    };\n  });\n}\n/**\n * Wraps a method that is used to add middleware to a server. The middleware\n * can then be recorded as metrics.\n *\n * - `wrapMiddlewareMounter(nodule, properties [, spec])`\n * - `wrapMiddlewareMounter(func [, spec])`\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {MiddlewareMounterSpec} [spec]\n *  Spec describing the parameters for this middleware mount point.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see WebFrameworkShim#recordMiddleware\n */\n\n\nfunction wrapMiddlewareMounter(nodule, properties, spec) {\n  if (properties && !this.isString(properties) && !this.isArray(properties)) {\n    // wrapMiddlewareMounter(func, spec)\n    spec = properties;\n    properties = null;\n  }\n\n  if (this.isFunction(spec)) {\n    // wrapMiddlewareMounter(nodule [, properties], wrapper)\n    spec = {\n      wrapper: spec\n    };\n  }\n\n  spec = this.setDefaults(spec, {\n    route: null,\n    endpoint: null\n  });\n  var wrapSpec = {\n    wrapper: function wrapMounter(shim, fn, fnName) {\n      if (!shim.isFunction(fn)) {\n        return fn;\n      }\n\n      return function wrappedMounter() {\n        var args = shim.argsToArray.apply(shim, arguments); // Normalize the route index and pull out the route argument if provided.\n\n        var routeIdx = null;\n        var route = null;\n\n        if (shim.isNumber(spec.route)) {\n          routeIdx = shim.normalizeIndex(args.length, spec.route);\n          route = routeIdx === null ? null : args[routeIdx];\n          const isArrayOfFunctions = shim.isArray(route) && shim.isFunction(route[0]);\n\n          if (shim.isFunction(route) || isArrayOfFunctions) {\n            routeIdx = null;\n            route = null;\n          } else if (shim.isArray(route)) {\n            route = route.map(routeArg => {\n              return shim._routeParser.call(this, shim, fn, fnName, routeArg);\n            });\n          } else {\n            route = shim._routeParser.call(this, shim, fn, fnName, route);\n          }\n        } else if (spec.route !== null) {\n          route = shim._routeParser.call(this, shim, fn, fnName, spec.route);\n        }\n\n        _wrapMiddlewares.call(this, routeIdx, args);\n\n        function _wrapMiddlewares(_routeIdx, middlewares) {\n          for (let i = 0; i < middlewares.length; ++i) {\n            // If this argument is the route argument skip it.\n            if (i === _routeIdx) {\n              continue;\n            } // Some platforms accept an arbitrarily nested array of middlewares,\n            // so if this argument is an array we must recurse into it.\n\n\n            var middleware = middlewares[i];\n\n            if (middleware instanceof Array) {\n              _wrapMiddlewares(null, middleware);\n\n              continue;\n            }\n\n            middlewares[i] = spec.wrapper.call(this, shim, middleware, shim.getName(middleware), route);\n          }\n        }\n\n        return fn.apply(this, args);\n      };\n    }\n  };\n\n  _copyExpectedSpecParameters(wrapSpec, spec);\n\n  return this.wrap(nodule, properties, wrapSpec);\n}\n/**\n * Records the provided function as a middleware.\n *\n * - `recordMiddleware(nodule, properties [, spec])`\n * - `recordMiddleware(func [, spec])`\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {MiddlewareSpec} [spec]\n *  The spec for wrapping the middleware.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see WebFrameworkShim#wrapMiddlewareMounter\n */\n\n\nfunction recordMiddleware(nodule, properties, spec) {\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // recordMiddleware(func, spec)\n    spec = properties;\n    properties = null;\n  }\n\n  spec = spec || Object.create(null);\n  var mwSpec = new specs.MiddlewareSpec(spec);\n  var wrapSpec = new specs.WrapSpec(function wrapMiddleware(shim, middleware) {\n    return _recordMiddleware(shim, middleware, mwSpec);\n  });\n\n  _copyExpectedSpecParameters(wrapSpec, spec);\n\n  return this.wrap(nodule, properties, wrapSpec);\n}\n/**\n * Records the provided function as a paramware.\n *\n * - `recordParamware(nodule, properties [, spec])`\n * - `recordParamware(func [, spec])`\n *\n * Paramware are specialized middleware that execute when certain route\n * parameters are encountered. For example, the route `/users/:userId` could\n * trigger a paramware hooked to `userId`.\n *\n * For every new request that comes in, this should be called as early in the\n * processing as possible.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {MiddlewareSpec} [spec]\n *  The spec for wrapping the middleware.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n */\n\n\nfunction recordParamware(nodule, properties, spec) {\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // recordParamware(func, spec)\n    spec = properties;\n    properties = null;\n  }\n\n  spec = spec || Object.create(null);\n  var mwSpec = new specs.MiddlewareSpec(spec);\n\n  if (spec && this.isString(spec.name)) {\n    mwSpec.route = '[param handler :' + spec.name + ']';\n  } else {\n    mwSpec.route = '[param handler]';\n  }\n\n  mwSpec.type = MIDDLEWARE_TYPE_NAMES.PARAMWARE;\n  var wrapSpec = new specs.WrapSpec(function wrapParamware(shim, middleware, name) {\n    mwSpec.name = name;\n    return _recordMiddleware(shim, middleware, mwSpec);\n  });\n\n  _copyExpectedSpecParameters(wrapSpec, spec);\n\n  return this.wrap(nodule, properties, wrapSpec);\n}\n/**\n * Tells the shim that the given request has caused an error.\n *\n * The given error will be checked for truthiness and if it passes the error\n * predicate check before being held onto.\n *\n * Use {@link WebFrameworkShim#errorHandled} to unnotice an error if it is later\n * caught by the user.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Request} req - The request which caused the error.\n * @param {*?}      err - The error which has occurred.\n *\n * @see WebFrameworkShim#errorHandled\n * @see WebFrameworkShim#setErrorPredicate\n */\n\n\nfunction noticeError(req, err) {\n  var txInfo = _getTransactionInfo(this, req);\n\n  if (txInfo && _isError(this, err)) {\n    _noticeError(this, txInfo, err);\n  }\n}\n/**\n * Indicates that the given error has been handled for this request.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Request} req - The request which caused the error.\n * @param {*}       err - The error which has been handled.\n *\n * @see WebFrameworkShim#noticeError\n * @see WebFrameworkShim#setErrorPredicate\n */\n\n\nfunction errorHandled(req, err) {\n  var txInfo = _getTransactionInfo(this, req);\n\n  if (txInfo && txInfo.error === err) {\n    txInfo.errorHandled = true;\n  }\n}\n/**\n * Sets a function to call when an error is noticed to determine if it is really\n * an error.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {function(object): bool} pred\n *  Function which should return true if the object passed to it is considered\n *  an error.\n *\n * @see WebFrameworkShim#noticeError\n * @see WebFrameworkShim#errorHandled\n */\n\n\nfunction setErrorPredicate(pred) {\n  this._errorPredicate = pred;\n}\n/**\n * Marks the current path as a potential responder.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Request} req - The request which caused the error.\n */\n\n\nfunction savePossibleTransactionName(req) {\n  var txInfo = _getTransactionInfo(this, req);\n\n  if (txInfo && txInfo.transaction) {\n    txInfo.transaction.nameState.markPath();\n  }\n}\n/**\n * Sets a function to call with the result of a middleware to determine if it has\n * responded.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {function(args, object): bool} pred\n *  Function which should return true if the object passed to it is considered\n *  a response.\n */\n\n\nfunction setResponsePredicate(pred) {\n  this._responsePredicate = pred;\n}\n/**\n * Capture URL parameters from a request object as attributes of the current segment.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Object} params\n *  An object with key-value pairs.\n */\n\n\nfunction captureUrlParams(params) {\n  var segment = this.getSegment();\n\n  if (segment && !this.agent.config.high_security) {\n    urltils.copyParameters(params, segment.parameters);\n  }\n} // -------------------------------------------------------------------------- //\n\n/**\n * Default route parser function if one is not provided.\n *\n * @private\n *\n * @param {WebFrameworkShim} shim\n *  The shim in use for this instrumentation.\n *\n * @param {function} fn\n *  The function which received this route string/RegExp.\n *\n * @param {string} fnName\n *  The name of the function to which this route was given.\n *\n * @param {string|RegExp} route\n *  The route that was given to the function.\n *\n * @see RouteParserFunction\n */\n\n\nfunction _defaultRouteParser(shim, fn, fnName, route) {\n  if (route instanceof RegExp) {\n    return '/' + route.source + '/';\n  } else if (typeof route === 'string') {\n    return route;\n  }\n\n  return '<unknown>';\n}\n/**\n * Default error predicate just returns true.\n *\n * @private\n *\n * @return {bool} True. Always.\n */\n\n\nfunction _defaultErrorPredicate() {\n  return true;\n}\n/**\n * Default response predicate just returns false.\n *\n * @private\n *\n * @return {bool} False. Always.\n */\n\n\nfunction _defaultResponsePredicate() {\n  return false;\n}\n/**\n * Wraps the given function in a middleware recorder function.\n *\n * @private\n *\n * @param {WebFrameworkShim} shim\n *  The shim used for this instrumentation.\n *\n * @param {function} middleware\n *  The middleware function to record.\n *\n * @param {MiddlewareSpec} spec\n *  The spec describing the middleware.\n *\n * @return {function} The middleware function wrapped in a recorder.\n */\n\n\nfunction _recordMiddleware(shim, middleware, spec) {\n  function getRoute() {\n    let route = spec.route || '/';\n\n    if (shim.isFunction(route)) {\n      route = route();\n    }\n\n    if (route instanceof RegExp) {\n      route = '/' + route.source + '/';\n    } else if (shim.isArray(route)) {\n      route = route.join(',');\n    } else if (route[0] !== '/') {\n      route = '/' + route;\n    }\n\n    return route;\n  }\n\n  const typeDetails = MIDDLEWARE_TYPE_DETAILS[spec.type];\n  const name = spec.name || shim.getName(shim.getOriginal(middleware));\n  let metricName = shim._metrics.PREFIX + typeDetails.name;\n\n  if (typeDetails.record) {\n    metricName = shim._metrics.MIDDLEWARE + metricName + name;\n  }\n\n  function getSegmentName(route) {\n    let segmentName = metricName;\n\n    if (typeDetails.path) {\n      segmentName += route;\n    } else if (route.length > 1) {\n      segmentName += '/' + route;\n    }\n\n    return segmentName;\n  }\n\n  var isErrorWare = spec.type === MIDDLEWARE_TYPE_NAMES.ERRORWARE;\n  var getReq = shim.isFunction(spec.req) ? spec.req : _makeGetReq(shim, spec.req);\n  return shim.record(middleware, spec.promise ? middlewareWithPromiseRecorder : middlewareWithCallbackRecorder); // TODO: let's please break these out\n\n  function middlewareWithCallbackRecorder(shim, fn, fnName, args) {\n    const route = getRoute(); // Pull out the request object.\n\n    var req = getReq.call(this, shim, fn, fnName, args); // Fetch the transaction information from that request.\n\n    var txInfo = _getTransactionInfo(shim, req);\n\n    if (!txInfo || !txInfo.transaction) {\n      shim.logger.debug({\n        txInfo: txInfo\n      }, 'Could not get transaction info in %s (%s)', route, fnName);\n      return null;\n    }\n\n    txInfo.transaction.nameState.setPrefix(shim._metrics.FRAMEWORK);\n    txInfo.errorHandled |= isErrorWare; // Copy over route parameters onto the transaction root.\n\n    var params = shim.agent.config.high_security ? null : spec.params.call(this, shim, fn, fnName, args, req); // Wrap up `next` and push on our name state if we find it. We only want to\n    // push the name state if there is a next so that we can safely remove it\n    // if context leaves this middleware.\n\n    var nextWrapper = null;\n\n    if (shim.isFunction(spec.next)) {\n      const nextDetails = {\n        route,\n        wrapNext: spec.next,\n        isErrorWare,\n        isPromise: false,\n        appendPath: spec.appendPath\n      };\n      nextWrapper = _makeNextBinder(nextDetails, txInfo);\n    } else {\n      var nextIdx = shim.normalizeIndex(args.length, spec.next);\n\n      if (nextIdx !== null && args[nextIdx] instanceof Function) {\n        const nextDetails = {\n          route,\n          wrapNext: function wrapNext(s, f, n, _args, wrap) {\n            wrap(_args, nextIdx);\n          },\n          isErrorWare,\n          isPromise: false,\n          appendPath: spec.appendPath\n        };\n        nextWrapper = _makeNextBinder(nextDetails, txInfo);\n      }\n    } // Append this middleware's mount point if it's not an errorware...\n    // (to avoid doubling up, a la 'WebTransaction/Expressjs/GET//test/test')\n\n\n    if (!isErrorWare && spec.appendPath) {\n      txInfo.transaction.nameState.appendPath(route, params);\n    } // ...and possibly construct a recorder\n\n\n    var recorder = null;\n\n    if (typeDetails.record) {\n      var stackPath = txInfo.transaction.nameState.getPath() || '';\n      recorder = _makeMiddlewareRecorder(shim, metricName + '/' + stackPath);\n    }\n\n    const segmentName = getSegmentName(route); // Finally, return the segment descriptor.\n\n    return {\n      name: segmentName,\n      callback: nextWrapper,\n      parent: txInfo.segmentStack[txInfo.segmentStack.length - 1],\n      recorder: recorder,\n      parameters: params,\n      after: function afterExec(shim, _fn, _name, err) {\n        var errIsError = _isError(shim, err);\n\n        if (errIsError) {\n          _noticeError(shim, txInfo, err);\n        } else if (!nextWrapper && !isErrorWare && spec.appendPath) {\n          txInfo.transaction.nameState.popPath(route);\n        }\n\n        if (errIsError || !nextWrapper) {\n          txInfo.segmentStack.pop();\n        }\n      }\n    };\n  }\n\n  function middlewareWithPromiseRecorder(shim, fn, fnName, args) {\n    const route = getRoute(); // Pull out the request object.\n\n    var req = getReq.call(this, shim, fn, fnName, args); // Fetch the transaction information from that request.\n\n    var txInfo = _getTransactionInfo(shim, req);\n\n    if (!txInfo || !txInfo.transaction) {\n      shim.logger.debug({\n        txInfo: txInfo\n      }, 'Could not get transaction info in %s (%s)', route, fnName);\n      return null;\n    }\n\n    txInfo.transaction.nameState.setPrefix(shim._metrics.FRAMEWORK);\n    txInfo.errorHandled |= isErrorWare; // Copy over route parameters onto the transaction root.\n\n    var params = shim.agent.config.high_security ? null : spec.params.call(this, shim, fn, fnName, args, req); // Append this middleware's mount point and possibly construct a recorder.\n\n    if (spec.appendPath) {\n      txInfo.transaction.nameState.appendPath(route, params);\n    }\n\n    var recorder = null;\n\n    if (typeDetails.record) {\n      var stackPath = txInfo.transaction.nameState.getPath() || '';\n      recorder = _makeMiddlewareRecorder(shim, metricName + '/' + stackPath);\n    } // The next callback style can still apply to promise based\n    // middleware (e.g. koa).  In this case we would like to remove the\n    // path for the current executing middleware, then readd it once the\n    // next callback is done (either asynchronously or after the\n    // returned promise is resolved).\n\n\n    var nextWrapper = function pushSegment(shim, _fn, _name, segment) {\n      txInfo.segmentStack.push(segment);\n    };\n\n    if (shim.isFunction(spec.next)) {\n      const nextDetails = {\n        route,\n        wrapNext: spec.next,\n        isErrorWare,\n        isPromise: true,\n        appendPath: spec.appendPath\n      };\n      nextWrapper = _makeNextBinder(nextDetails, txInfo);\n    } else {\n      var nextIdx = shim.normalizeIndex(args.length, spec.next);\n\n      if (nextIdx !== null && args[nextIdx] instanceof Function) {\n        const nextDetails = {\n          route,\n          wrapNext: function wrapNext(s, f, n, _args, wrap) {\n            wrap(_args, nextIdx);\n          },\n          isErrorWare,\n          isPromise: true,\n          appendPath: spec.appendPath\n        };\n        nextWrapper = _makeNextBinder(nextDetails, txInfo);\n      }\n    }\n\n    const segmentName = getSegmentName(route); // Finally, return the segment descriptor.\n\n    return {\n      name: segmentName,\n      parent: txInfo.segmentStack[txInfo.segmentStack.length - 1],\n      promise: spec.promise,\n      callback: nextWrapper,\n      recorder: recorder,\n      parameters: params,\n      after: function afterExec(shim, _fn, _name, err, result) {\n        if (shim._responsePredicate(args, result)) {\n          txInfo.transaction.nameState.freeze();\n        }\n\n        if (_isError(shim, err)) {\n          _noticeError(shim, txInfo, err);\n        } else {\n          txInfo.errorHandled = true;\n\n          if (spec.appendPath) {\n            txInfo.transaction.nameState.popPath(route);\n          }\n        }\n\n        txInfo.segmentStack.pop();\n      }\n    };\n  }\n}\n\nfunction _makeGetReq(shim, req) {\n  return function getReqFromArgs(shim, fn, name, args) {\n    var reqIdx = shim.normalizeIndex(args.length, req);\n\n    if (reqIdx === null || !args[reqIdx]) {\n      shim.logger.debug('Can not find request parameter, not recording.');\n      return null;\n    }\n\n    return args[reqIdx];\n  };\n}\n\nfunction _makeNextBinder(nextDetails, txInfo) {\n  return function bindNext(shim, fn, _name, segment, args) {\n    if (!segment) {\n      return;\n    }\n\n    txInfo.segmentStack.push(segment);\n    nextDetails.wrapNext(shim, fn, _name, args, nextWrapper); // Called from outside to wrap functions that could be called to continue\n    // to the next middleware\n\n    function nextWrapper(nodule, property, isFinal) {\n      shim.wrap(nodule, property, function wrapper(shim, original) {\n        const parentSegment = segment || shim.getSegment();\n        return shim.bindSegment(function boundNext(err) {\n          // Only pop the stack if we didn't error. This way the transaction\n          // name is derived from the failing middleware.\n          if (_isError(shim, err)) {\n            _noticeError(shim, txInfo, err);\n          } else if (!isFinal && !nextDetails.isErrorWare && nextDetails.appendPath) {\n            segment.transaction.nameState.popPath(nextDetails.route);\n          } // The next call does not signify the end of the segment\n          // calling next in the promise case.  Keep the segment on the\n          // stack and wait for its promise to be resolved to end it.\n\n\n          if (!nextDetails.isPromise) {\n            txInfo.segmentStack.pop();\n            segment.end();\n          }\n\n          var ret = original.apply(this, arguments);\n\n          if (nextDetails.isPromise && shim.isPromise(ret)) {\n            // After the next call has resolved, we should reinstate the\n            // segment responsible for calling next in case there is\n            // more work to do in that scope.\n            return ret.then(function onNextFinish(v) {\n              if (nextDetails.appendPath) {\n                segment.transaction.nameState.appendPath(nextDetails.route);\n              }\n\n              txInfo.segmentStack.push(segment);\n              return v;\n            });\n          }\n\n          return ret;\n        }, parentSegment); // Bind to parent.\n      });\n    }\n  };\n}\n/**\n * Retrieves the cached transaction information from the given object if it is\n * available.\n *\n * @private\n *\n * @param {WebFrameworkShim}      shim  - The shim used for this instrumentation.\n * @param {http.IncomingMessage}  req   - The incoming request object.\n *\n * @return {object?} The transaction information if available, otherwise null.\n */\n\n\nfunction _getTransactionInfo(shim, req) {\n  try {\n    return req[TRANSACTION_INFO_KEY] || null;\n  } catch (e) {\n    shim.logger.debug(e, 'Failed to fetch transaction info from req');\n    return null;\n  }\n}\n/**\n * Creates a recorder for middleware metrics.\n *\n * @private\n *\n *\n * @param {string}  path    - The mounting path of the middleware.\n * @param {Segment} segment - The segment generated for this middleware.\n * @param {string}  scope   - The scope of the metric to record.\n */\n\n\nfunction _makeMiddlewareRecorder(shim, metricName) {\n  return function middlewareMetricRecorder(segment, scope) {\n    var duration = segment.getDurationInMillis();\n    var exclusive = segment.getExclusiveDurationInMillis();\n    var transaction = segment.transaction;\n\n    if (scope) {\n      transaction.measure(metricName, scope, duration, exclusive);\n    }\n\n    transaction.measure(metricName, null, duration, exclusive);\n  };\n}\n/**\n * Adds the given error to the transaction information if it is actually an error.\n *\n * @private\n *\n * @param {WebFrameworkShim} shim\n *  The shim used for this web framework.\n *\n * @param {TransactionInfo} txInfo\n *  The transaction context information for the request.\n *\n * @param {*} err\n *  The error to notice.\n */\n\n\nfunction _noticeError(shim, txInfo, err) {\n  txInfo.error = err;\n  txInfo.errorHandled = false;\n}\n/**\n * Determines if the given object is an error according to the shim.\n *\n * @private\n *\n * @param {WebFrameworkShim} shim\n *  The shim used for this web framework.\n *\n * @param {?*} err\n *  The object to check for error-ness.\n *\n * @return {bool} True if the given object is an error according to the shim.\n */\n\n\nfunction _isError(shim, err) {\n  return err && shim._errorPredicate(err);\n}\n/**\n * Copy the keys expected from source to destination.\n *\n * @private\n *\n * @param {Object} destination\n *   The spec object receiving the expected values\n *\n * @param {Object} source\n *   The spec object the values are coming from\n */\n\n\nfunction _copyExpectedSpecParameters(destination, source) {\n  var keys = ['matchArity'];\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n\n    if (source[key] != null) {\n      destination[key] = source[key];\n    }\n  }\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/shim/webframework-shim.js"],"names":["genericRecorder","require","logger","child","component","metrics","TransactionShim","Shim","specs","urltils","util","FRAMEWORK_NAMES","CONNECT","DIRECTOR","EXPRESS","HAPI","KOA","RESTIFY","MIDDLEWARE_TYPE_DETAILS","APPLICATION","name","path","record","ERRORWARE","MIDDLEWARE","PARAMWARE","ROUTE","ROUTER","MIDDLEWARE_TYPE_NAMES","TRANSACTION_INFO_KEY","WebFrameworkShim","agent","moduleName","resolvedName","frameworkId","call","_logger","module","setFramework","_routeParser","_defaultRouteParser","_errorPredicate","_defaultErrorPredicate","_responsePredicate","_defaultResponsePredicate","exports","inherits","Object","keys","forEach","defineWebFrameworkMetricEnum","fwName","defineProperty","prototype","defineMiddlewareTypeEnum","mtName","setRouteParser","setTransactionUri","wrapMiddlewareMounter","recordParamware","recordMiddleware","recordRender","noticeError","errorHandled","setErrorPredicate","setResponsePredicate","savePossibleTransactionName","captureUrlParams","parser","isFunction","debug","framework","_metrics","PREFIX","FRAMEWORK","environment","trace","uri","tx","tracer","getTransaction","nameState","setName","verb","ACTION_DELIMITER","nodule","properties","spec","isObject","isArray","setDefaults","view","FIRST","callback","promise","renderRecorder","shim","fn","args","viewIdx","normalizeIndex","length","VIEW","RENDER","recorder","rowCallback","stream","internal","isString","wrapper","route","endpoint","wrapSpec","wrapMounter","fnName","wrappedMounter","argsToArray","apply","arguments","routeIdx","isNumber","isArrayOfFunctions","map","routeArg","_wrapMiddlewares","_routeIdx","middlewares","i","middleware","Array","getName","_copyExpectedSpecParameters","wrap","create","mwSpec","MiddlewareSpec","WrapSpec","wrapMiddleware","_recordMiddleware","type","wrapParamware","req","err","txInfo","_getTransactionInfo","_isError","_noticeError","error","pred","transaction","markPath","params","segment","getSegment","config","high_security","copyParameters","parameters","RegExp","source","getRoute","join","typeDetails","getOriginal","metricName","getSegmentName","segmentName","isErrorWare","getReq","_makeGetReq","middlewareWithPromiseRecorder","middlewareWithCallbackRecorder","setPrefix","nextWrapper","next","nextDetails","wrapNext","isPromise","appendPath","_makeNextBinder","nextIdx","Function","s","f","n","_args","stackPath","getPath","_makeMiddlewareRecorder","parent","segmentStack","after","afterExec","_fn","_name","errIsError","popPath","pop","pushSegment","push","result","freeze","getReqFromArgs","reqIdx","bindNext","property","isFinal","original","parentSegment","bindSegment","boundNext","end","ret","then","onNextFinish","v","e","middlewareMetricRecorder","scope","duration","getDurationInMillis","exclusive","getExclusiveDurationInMillis","measure","destination","key"],"mappings":"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","sourcesContent":["'use strict'\n\nvar genericRecorder = require('../metrics/recorders/generic')\nvar logger = require('../logger.js').child({component: 'WebFrameworkShim'})\nvar metrics = require('../metrics/names')\nvar TransactionShim = require('./transaction-shim')\nvar Shim = require('./shim')\nvar specs = require('./specs')\nvar urltils = require('../util/urltils')\nvar util = require('util')\n\n\n/**\n * An enumeration of well-known web frameworks so that new instrumentations can\n * use the same names we already use for first-party instrumentation.\n *\n * Each of these values is also exposed directly on the WebFrameworkShim class\n * as static members.\n *\n * @readonly\n * @memberof WebFrameworkShim\n * @enum {string}\n */\nvar FRAMEWORK_NAMES = {\n  CONNECT: 'Connect',\n  DIRECTOR: 'Director',\n  EXPRESS: 'Expressjs',\n  HAPI: 'Hapi',\n  KOA: 'Koa',\n  RESTIFY: 'Restify'\n}\n\nvar MIDDLEWARE_TYPE_DETAILS = {\n  APPLICATION:  {name: 'Mounted App: ', path: true,   record: false},\n  ERRORWARE:    {name: '',              path: false,  record: true},\n  MIDDLEWARE:   {name: '',              path: false,  record: true},\n  PARAMWARE:    {name: '',              path: false,  record: true},\n  ROUTE:        {name: 'Route Path: ',  path: true,   record: false},\n  ROUTER:       {name: 'Router: ',      path: true,   record: false}\n}\n\nvar MIDDLEWARE_TYPE_NAMES = {\n  APPLICATION: 'APPLICATION',\n  ERRORWARE: 'ERRORWARE',\n  MIDDLEWARE: 'MIDDLEWARE',\n  PARAMWARE: 'PARAMWARE',\n  ROUTE: 'ROUTE',\n  ROUTER: 'ROUTER'\n}\n\n/**\n * Name of the key used to store transaction information on `req` and `res`.\n *\n * @private\n */\nvar TRANSACTION_INFO_KEY = '__NR_transactionInfo'\n\n\n/**\n * Constructs a shim associated with the given agent instance, specialized for\n * instrumenting web frameworks.\n *\n * @constructor\n * @extends TransactionShim\n * @classdesc\n *  A helper class for wrapping web framework modules.\n *\n * @param {Agent} agent\n *  The agent this shim will use.\n *\n * @param {string} moduleName\n *  The name of the module being instrumented.\n *\n * @param {string} resolvedName\n *  The full path to the loaded module.\n *\n * @param {string} [frameworkId]\n *  The name of the web framework being instrumented. If available, use one of\n *  the values from {@link WebFrameworkShim.FRAMEWORK_NAMES}.\n *\n * @see TransactionShim\n * @see WebFrameworkShim.FRAMEWORK_NAMES\n */\nfunction WebFrameworkShim(agent, moduleName, resolvedName, frameworkId) {\n  TransactionShim.call(this, agent, moduleName, resolvedName)\n  this._logger = logger.child({module: moduleName})\n  if (frameworkId) {\n    this.setFramework(frameworkId)\n  }\n\n  this._routeParser = _defaultRouteParser\n  this._errorPredicate = _defaultErrorPredicate\n  this._responsePredicate = _defaultResponsePredicate\n}\nmodule.exports = WebFrameworkShim\nutil.inherits(WebFrameworkShim, TransactionShim)\n\n// Add constants on the shim for the well-known frameworks.\nWebFrameworkShim.FRAMEWORK_NAMES = FRAMEWORK_NAMES\nObject.keys(FRAMEWORK_NAMES).forEach(function defineWebFrameworkMetricEnum(fwName) {\n  Shim.defineProperty(WebFrameworkShim, fwName, FRAMEWORK_NAMES[fwName])\n  Shim.defineProperty(WebFrameworkShim.prototype, fwName, FRAMEWORK_NAMES[fwName])\n})\n\nWebFrameworkShim.MIDDLEWARE_TYPE_NAMES = MIDDLEWARE_TYPE_NAMES\nObject.keys(MIDDLEWARE_TYPE_NAMES).forEach(function defineMiddlewareTypeEnum(mtName) {\n  Shim.defineProperty(WebFrameworkShim, mtName, MIDDLEWARE_TYPE_NAMES[mtName])\n  Shim.defineProperty(WebFrameworkShim.prototype, mtName, MIDDLEWARE_TYPE_NAMES[mtName])\n})\n\nWebFrameworkShim.prototype.setRouteParser = setRouteParser\nWebFrameworkShim.prototype.setFramework = setFramework\nWebFrameworkShim.prototype.setTransactionUri = setTransactionUri\nWebFrameworkShim.prototype.wrapMiddlewareMounter = wrapMiddlewareMounter\nWebFrameworkShim.prototype.recordParamware = recordParamware\nWebFrameworkShim.prototype.recordMiddleware = recordMiddleware\nWebFrameworkShim.prototype.recordRender = recordRender\nWebFrameworkShim.prototype.noticeError = noticeError\nWebFrameworkShim.prototype.errorHandled = errorHandled\nWebFrameworkShim.prototype.setErrorPredicate = setErrorPredicate\nWebFrameworkShim.prototype.setResponsePredicate = setResponsePredicate\nWebFrameworkShim.prototype.savePossibleTransactionName = savePossibleTransactionName\nWebFrameworkShim.prototype.captureUrlParams = captureUrlParams\n\n// -------------------------------------------------------------------------- //\n\n/**\n * @callback RouteParserFunction\n *\n * @summary\n *  Called whenever new middleware are mounted using the instrumented framework,\n *  this method should pull out a representation of the mounted path.\n *\n * @param {WebFrameworkShim} shim\n *  The shim in use for this instrumentation.\n *\n * @param {function} fn\n *  The function which received this route string/RegExp.\n *\n * @param {string} fnName\n *  The name of the function to which this route was given.\n *\n * @param {string|RegExp} route\n *  The route that was given to the function.\n *\n * @return {string|RegExp} The mount point from the given route.\n */\n\n/**\n * @callback RouteRequestFunction\n *\n * @summary\n *  Extracts the request object from the arguments to the middleware function.\n *\n * @param {WebFrameworkShim}  shim    - The shim used for instrumentation.\n * @param {function}          fn      - The middleware function.\n * @param {string}            fnName  - The name of the middleware function.\n * @param {Array}             args    - The arguments to the middleware function.\n *\n * @return {Object} The request object.\n */\n\n/**\n * @callback RouteNextFunction\n *\n * @summary\n *  Used to wrap functions that users can call to continue to the next middleware.\n *\n * @param {WebFrameworkShim}    shim    - The shim used for instrumentation.\n * @param {function}            fn      - The middleware function.\n * @param {string}              fnName  - The name of the middleware function.\n * @param {Array}               args    - The arguments to the middleware function.\n * @param {NextWrapperFunction} wrap    - A function to wrap an individual next function.\n *\n * @return {Object} The request object.\n */\n\n/**\n * @callback RouteParameterFunction\n *\n * @summary\n *  Extracts the route parameters from the arguments to the middleware function.\n *\n * @param {WebFrameworkShim}  shim    - The shim used for instrumentation.\n * @param {function}          fn      - The middleware function.\n * @param {string}            fnName  - The name of the middleware function.\n * @param {Array}             args    - The arguments to the middleware function.\n *\n * @return {Object} A map of route parameter names to values.\n */\n\n/**\n * @callback MiddlewareWrapperFunction\n *\n * @summary\n *  Called for each middleware passed to a mounting method. Should perform the\n *  wrapping of the middleware.\n *\n * @param {WebFrameworkShim} shim\n *  The shim used for instrumentation.\n *\n * @param {function} middleware\n *  The middleware function to wrap.\n *\n * @param {string} fnName\n *  The name of the middleware function.\n *\n * @param {string} [route=null]\n *  The route the middleware is mounted on if one was found.\n *\n * @see WebFrameworkShim#recordMiddleware\n * @see WebFrameworkShim#recordParamware\n */\n\n/**\n * @interface MiddlewareSpec\n *\n * @description\n *  Describes the interface for middleware functions with this instrumentation.\n *\n * @property {number|RouteRequestFunction} [req=shim.FIRST]\n *  Indicates which argument to the middleware is the request object. It can also be\n *  a function to extract the request object from the middleware arguments.\n *\n * @property {number} [res=shim.SECOND]\n *  Indicates which argument to the middleware is the response object.\n *\n * @property {number|RouteNextFunction} [next=shim.THIRD]\n *  Indicates which argument to the middleware function is the callback.  When it is\n *  a function, it will be called with the arguments of the middleware and a function\n *  for wrapping calls that represent continuation from the current middleware.\n *\n * @property {string} [name]\n *  The name to use for this middleware. Defaults to `middleware.name`.\n *\n * @property {RouteParameterFunction} [params]\n *  A function to extract the route parameters from the middleware arguments.\n *  Defaults to using `req.params`.\n *\n * @property {string} [type='MIDDLEWARE']\n *\n * @property {string|function} [route=null]\n *  Route/path used for naming segments and transaction name candidates. If a function,\n *  will be invoked just before segment creation with middleware invocation.\n *\n * @property {boolean} [appendPath=true]\n *  Indicates that the path associated with the middleware should be appended\n *  and popped from the stack of name candidates.\n */\n\n/**\n * @interface MiddlewareMounterSpec\n *\n * @description\n *  Describes the arguments provided to mounting methods (e.g. `app.post()`).\n *\n * @property {number|string} [route=null]\n *  Tells which argument may be the mounting path for the other arguments. If\n *  the indicated argument is a function it is assumed the route was not provided\n *  and the indicated argument is a middleware function. If a string is provided\n *  it will be used as the mounting path.\n *\n * @property {MiddlewareWrapperFunction} [wrapper]\n *  A function to call for each middleware function passed to the mounter.\n */\n\n/**\n * @interface RenderSpec\n * @extends RecorderSpec\n *\n * @description\n *  Describes the interface for render methods.\n *\n * @property {number} [view=shim.FIRST]\n *  Identifies which argument is the name of the view being rendered. Defaults\n *  to {@link Shim#ARG_INDEXES shim.FIRST}.\n *\n * @see SegmentSpec\n * @see RecorderSpec\n */\n\n// -------------------------------------------------------------------------- //\n\n/**\n * Sets the function used to convert the route handed to middleware-adding\n * methods into a string.\n *\n * - `setRouteParser(parser)`\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {RouteParserFunction} parser - The parser function to use.\n */\nfunction setRouteParser(parser) {\n  if (!this.isFunction(parser)) {\n    return this.logger.debug('Given route parser is not a function.')\n  }\n  this._routeParser = parser\n}\n\n/**\n * Sets the name of the web framework in use by the server to the one given.\n *\n * - `setFramework(framework)`\n *\n * This should be the first thing the instrumentation does.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {WebFrameworkShim.FRAMEWORK_NAMES|string} framework\n *  The name of the framework.\n *\n * @see WebFrameworkShim.FRAMEWORK_NAMES\n */\nfunction setFramework(framework) {\n  this._metrics = {\n    PREFIX: framework + '/',\n    FRAMEWORK: framework,\n    MIDDLEWARE: metrics.MIDDLEWARE.PREFIX\n  }\n  this.agent.environment.setFramework(framework)\n\n  this._logger = this._logger.child({framework: framework})\n  this.logger.trace({metrics: this._metrics}, 'Framework metric names set')\n}\n\n/**\n * Sets the URI path to be used for naming the transaction currenty in scope.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {string} uri - The URI path to use for the transaction.\n */\nfunction setTransactionUri(uri) {\n  var tx = this.tracer.getTransaction()\n  if (!tx) {\n    return\n  }\n\n  tx.nameState.setName(\n    this._metrics.FRAMEWORK,\n    tx.verb,\n    metrics.ACTION_DELIMITER,\n    uri\n  )\n}\n\n/**\n * Records calls to methods used for rendering views.\n *\n * - `recordRender(nodule, properties [, spec])`\n * - `recordRender(func [, spec])`\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {RenderSpec} [spec]\n *  The spec for wrapping the render method.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n */\nfunction recordRender(nodule, properties, spec) {\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // recordRender(func, spec)\n    spec = properties\n    properties = null\n  }\n\n  spec = this.setDefaults(spec, {\n    view: this.FIRST,\n    callback: null,\n    promise: null\n  })\n\n  return this.record(nodule, properties, function renderRecorder(shim, fn, name, args) {\n    var viewIdx = shim.normalizeIndex(args.length, spec.view)\n    if (viewIdx === null) {\n      shim.logger.debug(\n        'Invalid spec.view (%d vs %d), not recording.',\n        spec.view, args.length\n      )\n      return null\n    }\n\n    return {\n      name: metrics.VIEW.PREFIX + args[viewIdx] + metrics.VIEW.RENDER,\n      callback: spec.callback,\n      promise: spec.promise,\n      recorder: genericRecorder,\n\n      // Hidden class stuff\n      rowCallback: null,\n      stream: null,\n      internal: false\n    }\n  })\n}\n\n/**\n * Wraps a method that is used to add middleware to a server. The middleware\n * can then be recorded as metrics.\n *\n * - `wrapMiddlewareMounter(nodule, properties [, spec])`\n * - `wrapMiddlewareMounter(func [, spec])`\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {MiddlewareMounterSpec} [spec]\n *  Spec describing the parameters for this middleware mount point.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see WebFrameworkShim#recordMiddleware\n */\nfunction wrapMiddlewareMounter(nodule, properties, spec) {\n  if (properties && !this.isString(properties) && !this.isArray(properties)) {\n    // wrapMiddlewareMounter(func, spec)\n    spec = properties\n    properties = null\n  }\n  if (this.isFunction(spec)) {\n    // wrapMiddlewareMounter(nodule [, properties], wrapper)\n    spec = {wrapper: spec}\n  }\n\n  spec = this.setDefaults(spec, {\n    route: null,\n    endpoint: null\n  })\n\n  var wrapSpec = {\n    wrapper: function wrapMounter(shim, fn, fnName) {\n      if (!shim.isFunction(fn)) {\n        return fn\n      }\n\n      return function wrappedMounter() {\n        var args = shim.argsToArray.apply(shim, arguments)\n\n        // Normalize the route index and pull out the route argument if provided.\n        var routeIdx = null\n        var route = null\n        if (shim.isNumber(spec.route)) {\n          routeIdx = shim.normalizeIndex(args.length, spec.route)\n          route = routeIdx === null ? null : args[routeIdx]\n          const isArrayOfFunctions = shim.isArray(route) && shim.isFunction(route[0])\n          if (shim.isFunction(route) || isArrayOfFunctions) {\n            routeIdx = null\n            route = null\n          } else if (shim.isArray(route)) {\n            route = route.map((routeArg) => {\n              return shim._routeParser.call(this, shim, fn, fnName, routeArg)\n            })\n          } else {\n            route = shim._routeParser.call(this, shim, fn, fnName, route)\n          }\n        } else if (spec.route !== null) {\n          route = shim._routeParser.call(this, shim, fn, fnName, spec.route)\n        }\n\n        _wrapMiddlewares.call(this, routeIdx, args)\n        function _wrapMiddlewares(_routeIdx, middlewares) {\n          for (let i = 0; i < middlewares.length; ++i) {\n            // If this argument is the route argument skip it.\n            if (i === _routeIdx) {\n              continue\n            }\n\n            // Some platforms accept an arbitrarily nested array of middlewares,\n            // so if this argument is an array we must recurse into it.\n            var middleware = middlewares[i]\n            if (middleware instanceof Array) {\n              _wrapMiddlewares(null, middleware)\n              continue\n            }\n\n            middlewares[i] = spec.wrapper.call(\n              this,\n              shim,\n              middleware,\n              shim.getName(middleware),\n              route\n            )\n          }\n        }\n\n        return fn.apply(this, args)\n      }\n    }\n  }\n\n  _copyExpectedSpecParameters(wrapSpec, spec)\n\n  return this.wrap(nodule, properties, wrapSpec)\n}\n\n/**\n * Records the provided function as a middleware.\n *\n * - `recordMiddleware(nodule, properties [, spec])`\n * - `recordMiddleware(func [, spec])`\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {MiddlewareSpec} [spec]\n *  The spec for wrapping the middleware.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see WebFrameworkShim#wrapMiddlewareMounter\n */\nfunction recordMiddleware(nodule, properties, spec) {\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // recordMiddleware(func, spec)\n    spec = properties\n    properties = null\n  }\n  spec = spec || Object.create(null)\n\n  var mwSpec = new specs.MiddlewareSpec(spec)\n  var wrapSpec = new specs.WrapSpec(function wrapMiddleware(shim, middleware) {\n    return _recordMiddleware(shim, middleware, mwSpec)\n  })\n\n  _copyExpectedSpecParameters(wrapSpec, spec)\n\n  return this.wrap(nodule, properties, wrapSpec)\n}\n\n/**\n * Records the provided function as a paramware.\n *\n * - `recordParamware(nodule, properties [, spec])`\n * - `recordParamware(func [, spec])`\n *\n * Paramware are specialized middleware that execute when certain route\n * parameters are encountered. For example, the route `/users/:userId` could\n * trigger a paramware hooked to `userId`.\n *\n * For every new request that comes in, this should be called as early in the\n * processing as possible.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {MiddlewareSpec} [spec]\n *  The spec for wrapping the middleware.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n */\nfunction recordParamware(nodule, properties, spec) {\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // recordParamware(func, spec)\n    spec = properties\n    properties = null\n  }\n  spec = spec || Object.create(null)\n\n  var mwSpec = new specs.MiddlewareSpec(spec)\n  if (spec && this.isString(spec.name)) {\n    mwSpec.route = '[param handler :' + spec.name + ']'\n  } else {\n    mwSpec.route = '[param handler]'\n  }\n  mwSpec.type = MIDDLEWARE_TYPE_NAMES.PARAMWARE\n\n  var wrapSpec = new specs.WrapSpec(function wrapParamware(shim, middleware, name) {\n    mwSpec.name = name\n    return _recordMiddleware(shim, middleware, mwSpec)\n  })\n\n  _copyExpectedSpecParameters(wrapSpec, spec)\n\n  return this.wrap(nodule, properties, wrapSpec)\n}\n\n/**\n * Tells the shim that the given request has caused an error.\n *\n * The given error will be checked for truthiness and if it passes the error\n * predicate check before being held onto.\n *\n * Use {@link WebFrameworkShim#errorHandled} to unnotice an error if it is later\n * caught by the user.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Request} req - The request which caused the error.\n * @param {*?}      err - The error which has occurred.\n *\n * @see WebFrameworkShim#errorHandled\n * @see WebFrameworkShim#setErrorPredicate\n */\nfunction noticeError(req, err) {\n  var txInfo = _getTransactionInfo(this, req)\n  if (txInfo && _isError(this, err)) {\n    _noticeError(this, txInfo, err)\n  }\n}\n\n/**\n * Indicates that the given error has been handled for this request.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Request} req - The request which caused the error.\n * @param {*}       err - The error which has been handled.\n *\n * @see WebFrameworkShim#noticeError\n * @see WebFrameworkShim#setErrorPredicate\n */\nfunction errorHandled(req, err) {\n  var txInfo = _getTransactionInfo(this, req)\n  if (txInfo && txInfo.error === err) {\n    txInfo.errorHandled = true\n  }\n}\n\n/**\n * Sets a function to call when an error is noticed to determine if it is really\n * an error.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {function(object): bool} pred\n *  Function which should return true if the object passed to it is considered\n *  an error.\n *\n * @see WebFrameworkShim#noticeError\n * @see WebFrameworkShim#errorHandled\n */\nfunction setErrorPredicate(pred) {\n  this._errorPredicate = pred\n}\n\n/**\n * Marks the current path as a potential responder.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Request} req - The request which caused the error.\n */\nfunction savePossibleTransactionName(req) {\n  var txInfo = _getTransactionInfo(this, req)\n  if (txInfo && txInfo.transaction) {\n    txInfo.transaction.nameState.markPath()\n  }\n}\n\n/**\n * Sets a function to call with the result of a middleware to determine if it has\n * responded.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {function(args, object): bool} pred\n *  Function which should return true if the object passed to it is considered\n *  a response.\n */\nfunction setResponsePredicate(pred) {\n  this._responsePredicate = pred\n}\n\n/**\n * Capture URL parameters from a request object as attributes of the current segment.\n *\n * @memberof WebFrameworkShim.prototype\n *\n * @param {Object} params\n *  An object with key-value pairs.\n */\nfunction captureUrlParams(params) {\n  var segment = this.getSegment()\n  if (segment && !this.agent.config.high_security) {\n    urltils.copyParameters(params, segment.parameters)\n  }\n}\n\n// -------------------------------------------------------------------------- //\n\n/**\n * Default route parser function if one is not provided.\n *\n * @private\n *\n * @param {WebFrameworkShim} shim\n *  The shim in use for this instrumentation.\n *\n * @param {function} fn\n *  The function which received this route string/RegExp.\n *\n * @param {string} fnName\n *  The name of the function to which this route was given.\n *\n * @param {string|RegExp} route\n *  The route that was given to the function.\n *\n * @see RouteParserFunction\n */\nfunction _defaultRouteParser(shim, fn, fnName, route) {\n  if (route instanceof RegExp) {\n    return '/' + route.source + '/'\n  } else if (typeof route === 'string') {\n    return route\n  }\n\n  return '<unknown>'\n}\n\n/**\n * Default error predicate just returns true.\n *\n * @private\n *\n * @return {bool} True. Always.\n */\nfunction _defaultErrorPredicate() {\n  return true\n}\n\n/**\n * Default response predicate just returns false.\n *\n * @private\n *\n * @return {bool} False. Always.\n */\nfunction _defaultResponsePredicate() {\n  return false\n}\n\n/**\n * Wraps the given function in a middleware recorder function.\n *\n * @private\n *\n * @param {WebFrameworkShim} shim\n *  The shim used for this instrumentation.\n *\n * @param {function} middleware\n *  The middleware function to record.\n *\n * @param {MiddlewareSpec} spec\n *  The spec describing the middleware.\n *\n * @return {function} The middleware function wrapped in a recorder.\n */\nfunction _recordMiddleware(shim, middleware, spec) {\n  function getRoute() {\n    let route = spec.route || '/'\n\n    if (shim.isFunction(route)) {\n      route = route()\n    }\n\n    if (route instanceof RegExp) {\n      route = '/' + route.source + '/'\n    } else if (shim.isArray(route)) {\n      route = route.join(',')\n    } else if (route[0] !== '/') {\n      route = '/' + route\n    }\n\n    return route\n  }\n\n  const typeDetails = MIDDLEWARE_TYPE_DETAILS[spec.type]\n  const name = spec.name || shim.getName(shim.getOriginal(middleware))\n  let metricName = shim._metrics.PREFIX + typeDetails.name\n  if (typeDetails.record) {\n    metricName = shim._metrics.MIDDLEWARE + metricName + name\n  }\n\n  function getSegmentName(route) {\n    let segmentName = metricName\n    if (typeDetails.path) {\n      segmentName += route\n    } else if (route.length > 1) {\n      segmentName += '/' + route\n    }\n\n    return segmentName\n  }\n\n  var isErrorWare = spec.type === MIDDLEWARE_TYPE_NAMES.ERRORWARE\n  var getReq = shim.isFunction(spec.req) ? spec.req : _makeGetReq(shim, spec.req)\n\n  return shim.record(\n    middleware,\n    spec.promise\n      ? middlewareWithPromiseRecorder\n      : middlewareWithCallbackRecorder\n  )\n\n  // TODO: let's please break these out\n  function middlewareWithCallbackRecorder(shim, fn, fnName, args) {\n    const route = getRoute()\n\n    // Pull out the request object.\n    var req = getReq.call(this, shim, fn, fnName, args)\n\n    // Fetch the transaction information from that request.\n    var txInfo = _getTransactionInfo(shim, req)\n    if (!txInfo || !txInfo.transaction) {\n      shim.logger.debug(\n        {txInfo: txInfo},\n        'Could not get transaction info in %s (%s)',\n        route, fnName\n      )\n      return null\n    }\n    txInfo.transaction.nameState.setPrefix(shim._metrics.FRAMEWORK)\n    txInfo.errorHandled |= isErrorWare\n\n    // Copy over route parameters onto the transaction root.\n    var params = shim.agent.config.high_security\n      ? null : spec.params.call(this, shim, fn, fnName, args, req)\n\n    // Wrap up `next` and push on our name state if we find it. We only want to\n    // push the name state if there is a next so that we can safely remove it\n    // if context leaves this middleware.\n    var nextWrapper = null\n    if (shim.isFunction(spec.next)) {\n      const nextDetails = {\n        route,\n        wrapNext: spec.next,\n        isErrorWare,\n        isPromise: false,\n        appendPath: spec.appendPath\n      }\n\n      nextWrapper = _makeNextBinder(nextDetails, txInfo)\n    } else {\n      var nextIdx = shim.normalizeIndex(args.length, spec.next)\n      if (nextIdx !== null && args[nextIdx] instanceof Function) {\n        const nextDetails = {\n          route,\n          wrapNext: function wrapNext(s, f, n, _args, wrap) {\n            wrap(_args, nextIdx)\n          },\n          isErrorWare,\n          isPromise: false,\n          appendPath: spec.appendPath\n        }\n\n        nextWrapper = _makeNextBinder(nextDetails, txInfo)\n      }\n    }\n\n    // Append this middleware's mount point if it's not an errorware...\n    // (to avoid doubling up, a la 'WebTransaction/Expressjs/GET//test/test')\n    if (!isErrorWare && spec.appendPath) {\n      txInfo.transaction.nameState.appendPath(route, params)\n    }\n\n    // ...and possibly construct a recorder\n    var recorder = null\n    if (typeDetails.record) {\n      var stackPath = txInfo.transaction.nameState.getPath() || ''\n      recorder = _makeMiddlewareRecorder(shim, metricName + '/' + stackPath)\n    }\n\n    const segmentName = getSegmentName(route)\n\n    // Finally, return the segment descriptor.\n    return {\n      name: segmentName,\n      callback: nextWrapper,\n      parent: txInfo.segmentStack[txInfo.segmentStack.length - 1],\n      recorder: recorder,\n      parameters: params,\n      after: function afterExec(shim, _fn, _name, err) {\n        var errIsError = _isError(shim, err)\n        if (errIsError) {\n          _noticeError(shim, txInfo, err)\n        } else if (!nextWrapper && !isErrorWare && spec.appendPath) {\n          txInfo.transaction.nameState.popPath(route)\n        }\n        if (errIsError || !nextWrapper) {\n          txInfo.segmentStack.pop()\n        }\n      }\n    }\n  }\n\n  function middlewareWithPromiseRecorder(shim, fn, fnName, args) {\n    const route = getRoute()\n\n    // Pull out the request object.\n    var req = getReq.call(this, shim, fn, fnName, args)\n\n    // Fetch the transaction information from that request.\n    var txInfo = _getTransactionInfo(shim, req)\n    if (!txInfo || !txInfo.transaction) {\n      shim.logger.debug(\n        {txInfo: txInfo},\n        'Could not get transaction info in %s (%s)',\n        route, fnName\n      )\n      return null\n    }\n    txInfo.transaction.nameState.setPrefix(shim._metrics.FRAMEWORK)\n    txInfo.errorHandled |= isErrorWare\n\n    // Copy over route parameters onto the transaction root.\n    var params = shim.agent.config.high_security\n      ? null : spec.params.call(this, shim, fn, fnName, args, req)\n\n    // Append this middleware's mount point and possibly construct a recorder.\n    if (spec.appendPath) {\n      txInfo.transaction.nameState.appendPath(route, params)\n    }\n    var recorder = null\n    if (typeDetails.record) {\n      var stackPath = txInfo.transaction.nameState.getPath() || ''\n      recorder = _makeMiddlewareRecorder(shim, metricName + '/' + stackPath)\n    }\n\n    // The next callback style can still apply to promise based\n    // middleware (e.g. koa).  In this case we would like to remove the\n    // path for the current executing middleware, then readd it once the\n    // next callback is done (either asynchronously or after the\n    // returned promise is resolved).\n    var nextWrapper = function pushSegment(shim, _fn, _name, segment) {\n      txInfo.segmentStack.push(segment)\n    }\n    if (shim.isFunction(spec.next)) {\n      const nextDetails = {\n        route,\n        wrapNext: spec.next,\n        isErrorWare,\n        isPromise: true,\n        appendPath: spec.appendPath\n      }\n      nextWrapper = _makeNextBinder(nextDetails, txInfo)\n    } else {\n      var nextIdx = shim.normalizeIndex(args.length, spec.next)\n      if (nextIdx !== null && args[nextIdx] instanceof Function) {\n        const nextDetails = {\n          route,\n          wrapNext: function wrapNext(s, f, n, _args, wrap) {\n            wrap(_args, nextIdx)\n          },\n          isErrorWare,\n          isPromise: true,\n          appendPath: spec.appendPath\n        }\n\n        nextWrapper = _makeNextBinder(nextDetails, txInfo)\n      }\n    }\n\n    const segmentName = getSegmentName(route)\n\n    // Finally, return the segment descriptor.\n    return {\n      name: segmentName,\n      parent: txInfo.segmentStack[txInfo.segmentStack.length - 1],\n      promise: spec.promise,\n      callback: nextWrapper,\n      recorder: recorder,\n      parameters: params,\n      after: function afterExec(shim, _fn, _name, err, result) {\n        if (shim._responsePredicate(args, result)) {\n          txInfo.transaction.nameState.freeze()\n        }\n        if (_isError(shim, err)) {\n          _noticeError(shim, txInfo, err)\n        } else {\n          txInfo.errorHandled = true\n\n          if (spec.appendPath) {\n            txInfo.transaction.nameState.popPath(route)\n          }\n        }\n        txInfo.segmentStack.pop()\n      }\n    }\n  }\n}\n\nfunction _makeGetReq(shim, req) {\n  return function getReqFromArgs(shim, fn, name, args) {\n    var reqIdx = shim.normalizeIndex(args.length, req)\n    if (reqIdx === null || !args[reqIdx]) {\n      shim.logger.debug('Can not find request parameter, not recording.')\n      return null\n    }\n    return args[reqIdx]\n  }\n}\n\nfunction _makeNextBinder(nextDetails, txInfo) {\n  return function bindNext(shim, fn, _name, segment, args) {\n    if (!segment) {\n      return\n    }\n    txInfo.segmentStack.push(segment)\n\n    nextDetails.wrapNext(shim, fn, _name, args, nextWrapper)\n\n    // Called from outside to wrap functions that could be called to continue\n    // to the next middleware\n    function nextWrapper(nodule, property, isFinal) {\n      shim.wrap(nodule, property, function wrapper(shim, original) {\n        const parentSegment = segment || shim.getSegment()\n        return shim.bindSegment(function boundNext(err) {\n          // Only pop the stack if we didn't error. This way the transaction\n          // name is derived from the failing middleware.\n          if (_isError(shim, err)) {\n            _noticeError(shim, txInfo, err)\n          } else if (!isFinal && !nextDetails.isErrorWare && nextDetails.appendPath) {\n            segment.transaction.nameState.popPath(nextDetails.route)\n          }\n\n          // The next call does not signify the end of the segment\n          // calling next in the promise case.  Keep the segment on the\n          // stack and wait for its promise to be resolved to end it.\n          if (!nextDetails.isPromise) {\n            txInfo.segmentStack.pop()\n            segment.end()\n          }\n          var ret = original.apply(this, arguments)\n\n          if (nextDetails.isPromise && shim.isPromise(ret)) {\n            // After the next call has resolved, we should reinstate the\n            // segment responsible for calling next in case there is\n            // more work to do in that scope.\n            return ret.then(function onNextFinish(v) {\n              if (nextDetails.appendPath) {\n                segment.transaction.nameState.appendPath(nextDetails.route)\n              }\n\n              txInfo.segmentStack.push(segment)\n\n              return v\n            })\n          }\n\n          return ret\n        }, parentSegment) // Bind to parent.\n      })\n    }\n  }\n}\n\n/**\n * Retrieves the cached transaction information from the given object if it is\n * available.\n *\n * @private\n *\n * @param {WebFrameworkShim}      shim  - The shim used for this instrumentation.\n * @param {http.IncomingMessage}  req   - The incoming request object.\n *\n * @return {object?} The transaction information if available, otherwise null.\n */\nfunction _getTransactionInfo(shim, req) {\n  try {\n    return req[TRANSACTION_INFO_KEY] || null\n  } catch (e) {\n    shim.logger.debug(e, 'Failed to fetch transaction info from req')\n    return null\n  }\n}\n\n/**\n * Creates a recorder for middleware metrics.\n *\n * @private\n *\n *\n * @param {string}  path    - The mounting path of the middleware.\n * @param {Segment} segment - The segment generated for this middleware.\n * @param {string}  scope   - The scope of the metric to record.\n */\nfunction _makeMiddlewareRecorder(shim, metricName) {\n  return function middlewareMetricRecorder(segment, scope) {\n    var duration = segment.getDurationInMillis()\n    var exclusive = segment.getExclusiveDurationInMillis()\n    var transaction = segment.transaction\n\n    if (scope) {\n      transaction.measure(metricName, scope, duration, exclusive)\n    }\n    transaction.measure(metricName, null, duration, exclusive)\n  }\n}\n\n/**\n * Adds the given error to the transaction information if it is actually an error.\n *\n * @private\n *\n * @param {WebFrameworkShim} shim\n *  The shim used for this web framework.\n *\n * @param {TransactionInfo} txInfo\n *  The transaction context information for the request.\n *\n * @param {*} err\n *  The error to notice.\n */\nfunction _noticeError(shim, txInfo, err) {\n  txInfo.error = err\n  txInfo.errorHandled = false\n}\n\n/**\n * Determines if the given object is an error according to the shim.\n *\n * @private\n *\n * @param {WebFrameworkShim} shim\n *  The shim used for this web framework.\n *\n * @param {?*} err\n *  The object to check for error-ness.\n *\n * @return {bool} True if the given object is an error according to the shim.\n */\nfunction _isError(shim, err) {\n  return err && shim._errorPredicate(err)\n}\n\n/**\n * Copy the keys expected from source to destination.\n *\n * @private\n *\n * @param {Object} destination\n *   The spec object receiving the expected values\n *\n * @param {Object} source\n *   The spec object the values are coming from\n */\nfunction _copyExpectedSpecParameters(destination, source) {\n  var keys = [\n    'matchArity'\n  ]\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i]\n    if (source[key] != null) {\n      destination[key] = source[key]\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}