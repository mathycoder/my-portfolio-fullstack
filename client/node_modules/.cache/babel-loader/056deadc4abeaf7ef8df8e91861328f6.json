{"ast":null,"code":"'use strict';\n\nvar logger = require('../../logger').child({\n  component: 'sql_query_parser'\n});\n\nvar StatementMatcher = require('../statement-matcher');\n\nvar stringify = require('json-stringify-safe');\n\nvar OPERATIONS = [new StatementMatcher('select', /^[^\\S]*?select\\b[\\s\\S]+?\\bfrom[\\s\\n\\r\\[\\(]+([^\\]\\s\\n\\r,)(;]*)/gim), new StatementMatcher('update', /^[^\\S]*?update[^\\S]+?([^\\s\\n\\r,;]+)/gim), new StatementMatcher('insert', /^[^\\S]*?insert(?:[^\\S]+ignore)?[^\\S]+into[^\\S]+([^\\s\\n\\r(,;]+)/gim), new StatementMatcher('delete', /^[^\\S]*?delete[^\\S]+?from[^\\S]+([^\\s\\n\\r,(;]+)/gim)];\nvar COMMENT_PATTERN = /\\/\\\\*.*?\\\\*\\//g; // This must be called syncronously after the initial db call for backtraces to\n// work correctly\n\nmodule.exports = function parseSql(sql) {\n  // Sometimes we get an object here from MySQL. We have been unable to\n  // reproduce it, so we'll just log what that object is and return a statement\n  // type of `other`.\n  if (typeof sql === 'object' && sql.sql !== undefined) sql = sql.sql;\n\n  if (typeof sql !== 'string') {\n    if (logger.traceEnabled()) {\n      try {\n        logger.trace('parseSQL got an a non-string sql that looks like: %s', stringify(sql));\n      } catch (err) {\n        logger.debug(err, 'Unabler to stringify SQL');\n      }\n    }\n\n    return {\n      operation: 'other',\n      collection: null,\n      query: ''\n    };\n  }\n\n  sql = sql.replace(COMMENT_PATTERN, '').trim();\n  var parsedStatement;\n\n  for (var i = 0, l = OPERATIONS.length; i < l; i++) {\n    parsedStatement = OPERATIONS[i].getParsedStatement(sql);\n\n    if (parsedStatement) {\n      break;\n    }\n  }\n\n  if (parsedStatement) {\n    return parsedStatement;\n  }\n\n  return {\n    operation: 'other',\n    collection: null,\n    query: sql\n  };\n};","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/db/query-parsers/sql.js"],"names":["logger","require","child","component","StatementMatcher","stringify","OPERATIONS","COMMENT_PATTERN","module","exports","parseSql","sql","undefined","traceEnabled","trace","err","debug","operation","collection","query","replace","trim","parsedStatement","i","l","length","getParsedStatement"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,cAAD,CAAP,CAAwBC,KAAxB,CAA8B;AAACC,EAAAA,SAAS,EAAE;AAAZ,CAA9B,CAAb;;AACA,IAAIC,gBAAgB,GAAGH,OAAO,CAAC,sBAAD,CAA9B;;AACA,IAAII,SAAS,GAAGJ,OAAO,CAAC,qBAAD,CAAvB;;AAGA,IAAIK,UAAU,GAAG,CACf,IAAIF,gBAAJ,CACE,QADF,EAEE,kEAFF,CADe,EAKf,IAAIA,gBAAJ,CAAqB,QAArB,EAA+B,wCAA/B,CALe,EAMf,IAAIA,gBAAJ,CACE,QADF,EAEE,mEAFF,CANe,EAUf,IAAIA,gBAAJ,CAAqB,QAArB,EAA+B,mDAA/B,CAVe,CAAjB;AAYA,IAAIG,eAAe,GAAG,gBAAtB,C,CAEA;AACA;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,QAAT,CAAkBC,GAAlB,EAAuB;AACtC;AACA;AACA;AACA,MAAI,OAAOA,GAAP,KAAe,QAAf,IAA2BA,GAAG,CAACA,GAAJ,KAAYC,SAA3C,EAAsDD,GAAG,GAAGA,GAAG,CAACA,GAAV;;AACtD,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,QAAIX,MAAM,CAACa,YAAP,EAAJ,EAA2B;AACzB,UAAI;AACFb,QAAAA,MAAM,CAACc,KAAP,CACE,sDADF,EAEET,SAAS,CAACM,GAAD,CAFX;AAID,OALD,CAKE,OAAOI,GAAP,EAAY;AACZf,QAAAA,MAAM,CAACgB,KAAP,CAAaD,GAAb,EAAkB,0BAAlB;AACD;AACF;;AACD,WAAO;AACLE,MAAAA,SAAS,EAAE,OADN;AAELC,MAAAA,UAAU,EAAE,IAFP;AAGLC,MAAAA,KAAK,EAAE;AAHF,KAAP;AAKD;;AAEDR,EAAAA,GAAG,GAAGA,GAAG,CAACS,OAAJ,CAAYb,eAAZ,EAA6B,EAA7B,EAAiCc,IAAjC,EAAN;AAGA,MAAIC,eAAJ;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGlB,UAAU,CAACmB,MAA/B,EAAuCF,CAAC,GAAGC,CAA3C,EAA8CD,CAAC,EAA/C,EAAmD;AACjDD,IAAAA,eAAe,GAAGhB,UAAU,CAACiB,CAAD,CAAV,CAAcG,kBAAd,CAAiCf,GAAjC,CAAlB;;AACA,QAAIW,eAAJ,EAAqB;AACnB;AACD;AACF;;AAED,MAAIA,eAAJ,EAAqB;AACnB,WAAOA,eAAP;AACD;;AAED,SAAO;AACLL,IAAAA,SAAS,EAAE,OADN;AAELC,IAAAA,UAAU,EAAE,IAFP;AAGLC,IAAAA,KAAK,EAAER;AAHF,GAAP;AAKD,CA5CD","sourcesContent":["'use strict'\n\nvar logger = require('../../logger').child({component: 'sql_query_parser'})\nvar StatementMatcher = require('../statement-matcher')\nvar stringify = require('json-stringify-safe')\n\n\nvar OPERATIONS = [\n  new StatementMatcher(\n    'select',\n    /^[^\\S]*?select\\b[\\s\\S]+?\\bfrom[\\s\\n\\r\\[\\(]+([^\\]\\s\\n\\r,)(;]*)/gim\n  ),\n  new StatementMatcher('update', /^[^\\S]*?update[^\\S]+?([^\\s\\n\\r,;]+)/gim),\n  new StatementMatcher(\n    'insert',\n    /^[^\\S]*?insert(?:[^\\S]+ignore)?[^\\S]+into[^\\S]+([^\\s\\n\\r(,;]+)/gim\n  ),\n  new StatementMatcher('delete', /^[^\\S]*?delete[^\\S]+?from[^\\S]+([^\\s\\n\\r,(;]+)/gim)\n]\nvar COMMENT_PATTERN = /\\/\\\\*.*?\\\\*\\//g\n\n// This must be called syncronously after the initial db call for backtraces to\n// work correctly\n\nmodule.exports = function parseSql(sql) {\n  // Sometimes we get an object here from MySQL. We have been unable to\n  // reproduce it, so we'll just log what that object is and return a statement\n  // type of `other`.\n  if (typeof sql === 'object' && sql.sql !== undefined) sql = sql.sql\n  if (typeof sql !== 'string') {\n    if (logger.traceEnabled()) {  \n      try {\n        logger.trace(\n          'parseSQL got an a non-string sql that looks like: %s',\n          stringify(sql)\n        )\n      } catch (err) {\n        logger.debug(err, 'Unabler to stringify SQL')\n      }\n    }\n    return {\n      operation: 'other',\n      collection: null,\n      query: ''\n    }\n  }\n\n  sql = sql.replace(COMMENT_PATTERN, '').trim()\n\n\n  var parsedStatement\n\n  for (var i = 0, l = OPERATIONS.length; i < l; i++) {\n    parsedStatement = OPERATIONS[i].getParsedStatement(sql)\n    if (parsedStatement) {\n      break\n    }\n  }\n\n  if (parsedStatement) {\n    return parsedStatement\n  }\n\n  return {\n    operation: 'other',\n    collection: null,\n    query: sql\n  }\n}\n"]},"metadata":{},"sourceType":"script"}