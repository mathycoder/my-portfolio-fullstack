{"ast":null,"code":"'use strict';\n\nvar path = require('path');\n\nvar logger = require('./logger');\n\nvar NAMES = require('./metrics/names');\n\nvar properties = require('./util/properties');\n\nconst shimmer = require('./shimmer'); // Static variable holding map of un-instrumented modules for use in the future\n\n\nvar uninstrumented = Object.create(null); // Log a helpful message about un-instrumented modules\n\nfunction logUninstrumented() {\n  const modules = Object.keys(uninstrumented);\n\n  if (modules.length > 0) {\n    var message = 'The newrelic module must be the first module required.\\n' + 'The following modules were required before newrelic and are not being ' + 'instrumented:';\n    modules.forEach(function buildMessage(module) {\n      message += '\\n\\t' + uninstrumented[module].name + ': ' + uninstrumented[module].filename;\n    });\n    logger.warn(message);\n  }\n} // Create Supportability/Uninstrumented/<module> metrics\n//\n// @param metrics Agent metrics aggregator\n\n\nfunction createMetrics(metrics) {\n  const modules = Object.keys(uninstrumented);\n\n  if (modules.length > 0) {\n    metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.UNINSTRUMENTED).incrementCallCount();\n  }\n\n  modules.forEach(function addMetrics(module) {\n    metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.UNINSTRUMENTED + '/' + uninstrumented[module].name).incrementCallCount();\n  });\n} // Check for any instrument-able modules that have already been loaded. This does\n// not check core modules as we don't have access to the core module loader\n// cache. But, users probably are missing instrumentation for other modules if\n// they are missing instrumentation for core modules.\n\n\nfunction check() {\n  const instrumentations = Object.keys(shimmer.registeredInstrumentations); // Special case since we do some hackish stuff in lib/shimmer.js to make pg.js,\n  // and mysql2 work.\n\n  instrumentations.push('pg.js', 'mysql2');\n\n  for (var filename in require.cache) {\n    if (!properties.hasOwn(require.cache, filename)) {\n      continue;\n    } // only interested in whatever follows the last occurrence of node_modules\n\n\n    const paths = filename.split('node_modules' + path.sep);\n    const modulePath = paths[paths.length - 1];\n\n    for (let i = 0; i < instrumentations.length; i++) {\n      const name = instrumentations[i];\n\n      if (modulePath.startsWith(name) && !uninstrumented[name]) {\n        uninstrumented[name] = {\n          name,\n          filename\n        };\n      }\n    }\n  }\n\n  logUninstrumented();\n}\n\nmodule.exports = {\n  check,\n  createMetrics\n};","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/uninstrumented.js"],"names":["path","require","logger","NAMES","properties","shimmer","uninstrumented","Object","create","logUninstrumented","modules","keys","length","message","forEach","buildMessage","module","name","filename","warn","createMetrics","metrics","getOrCreateMetric","SUPPORTABILITY","UNINSTRUMENTED","incrementCallCount","addMetrics","check","instrumentations","registeredInstrumentations","push","cache","hasOwn","paths","split","sep","modulePath","i","startsWith","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar path = require('path')\nvar logger = require('./logger')\nvar NAMES = require('./metrics/names')\nvar properties = require('./util/properties')\nconst shimmer = require('./shimmer')\n\n// Static variable holding map of un-instrumented modules for use in the future\nvar uninstrumented = Object.create(null)\n\n// Log a helpful message about un-instrumented modules\nfunction logUninstrumented() {\n  const modules = Object.keys(uninstrumented)\n  if (modules.length > 0) {\n    var message =\n      'The newrelic module must be the first module required.\\n' +\n      'The following modules were required before newrelic and are not being ' +\n      'instrumented:'\n\n    modules.forEach(function buildMessage(module) {\n      message += '\\n\\t' + uninstrumented[module].name\n        + ': ' + uninstrumented[module].filename\n    })\n\n    logger.warn(message)\n  }\n}\n\n// Create Supportability/Uninstrumented/<module> metrics\n//\n// @param metrics Agent metrics aggregator\nfunction createMetrics(metrics) {\n  const modules = Object.keys(uninstrumented)\n  if (modules.length > 0) {\n    metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.UNINSTRUMENTED).incrementCallCount()\n  }\n\n  modules.forEach(function addMetrics(module) {\n    metrics.getOrCreateMetric(\n      NAMES.SUPPORTABILITY.UNINSTRUMENTED + '/' + uninstrumented[module].name\n    ).incrementCallCount()\n  })\n}\n\n// Check for any instrument-able modules that have already been loaded. This does\n// not check core modules as we don't have access to the core module loader\n// cache. But, users probably are missing instrumentation for other modules if\n// they are missing instrumentation for core modules.\nfunction check() {\n  const instrumentations = Object.keys(shimmer.registeredInstrumentations)\n  // Special case since we do some hackish stuff in lib/shimmer.js to make pg.js,\n  // and mysql2 work.\n  instrumentations.push('pg.js', 'mysql2')\n\n  for (var filename in require.cache) {\n    if (!properties.hasOwn(require.cache, filename)) {\n      continue\n    }\n\n    // only interested in whatever follows the last occurrence of node_modules\n    const paths = filename.split('node_modules' + path.sep)\n    const modulePath = paths[paths.length - 1]\n\n    for (let i = 0; i < instrumentations.length; i++) {\n      const name = instrumentations[i]\n      if (modulePath.startsWith(name) && !uninstrumented[name]) {\n        uninstrumented[name] = { name, filename }\n      }\n    }\n  }\n\n  logUninstrumented()\n}\n\nmodule.exports = { check, createMetrics }\n"]},"metadata":{},"sourceType":"script"}