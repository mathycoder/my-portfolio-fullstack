{"ast":null,"code":"'use strict';\n\nvar logger = require('../logger.js').child({\n  component: 'gcp-info'\n});\n\nvar common = require('./common');\n\nvar NAMES = require('../metrics/names.js');\n\nmodule.exports = fetchGCPInfo;\n\nmodule.exports.clearCache = function clearGCPCache() {\n  resultDict = null;\n};\n\nvar resultDict;\n\nfunction fetchGCPInfo(agent, callback) {\n  if (!agent.config.utilization || !agent.config.utilization.detect_gcp) {\n    return setImmediate(callback, null);\n  }\n\n  if (resultDict) {\n    return setImmediate(callback, null, resultDict);\n  }\n\n  common.request({\n    host: 'metadata.google.internal',\n    path: '/computeMetadata/v1/instance/?recursive=true',\n    headers: {\n      'Metadata-Flavor': 'Google'\n    }\n  }, agent, function getMetadata(err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    try {\n      data = JSON.parse(data);\n    } catch (e) {\n      logger.debug(e, 'Failed to parse GCP metadata.');\n      data = null;\n    }\n\n    var results = common.getKeys(data, ['id', 'machineType', 'name', 'zone']);\n\n    if (results == null) {\n      logger.debug('GCP metadata was invalid.');\n      agent.metrics.getOrCreateMetric(NAMES.UTILIZATION.GCP_ERROR).incrementCallCount();\n    } else {\n      // normalize\n      results.machineType = results.machineType.substr(results.machineType.lastIndexOf('/') + 1);\n      results.zone = results.zone.substr(results.zone.lastIndexOf('/') + 1);\n      resultDict = results;\n    }\n\n    callback(null, results);\n  });\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/utilization/gcp-info.js"],"names":["logger","require","child","component","common","NAMES","module","exports","fetchGCPInfo","clearCache","clearGCPCache","resultDict","agent","callback","config","utilization","detect_gcp","setImmediate","request","host","path","headers","getMetadata","err","data","JSON","parse","e","debug","results","getKeys","metrics","getOrCreateMetric","UTILIZATION","GCP_ERROR","incrementCallCount","machineType","substr","lastIndexOf","zone"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,cAAD,CAAP,CAAwBC,KAAxB,CAA8B;AAACC,EAAAA,SAAS,EAAE;AAAZ,CAA9B,CAAb;;AACA,IAAIC,MAAM,GAAGH,OAAO,CAAC,UAAD,CAApB;;AACA,IAAII,KAAK,GAAGJ,OAAO,CAAC,qBAAD,CAAnB;;AAEAK,MAAM,CAACC,OAAP,GAAiBC,YAAjB;;AACAF,MAAM,CAACC,OAAP,CAAeE,UAAf,GAA4B,SAASC,aAAT,GAAyB;AACnDC,EAAAA,UAAU,GAAG,IAAb;AACD,CAFD;;AAIA,IAAIA,UAAJ;;AAEA,SAASH,YAAT,CAAsBI,KAAtB,EAA6BC,QAA7B,EAAuC;AACrC,MAAI,CAACD,KAAK,CAACE,MAAN,CAAaC,WAAd,IAA6B,CAACH,KAAK,CAACE,MAAN,CAAaC,WAAb,CAAyBC,UAA3D,EAAuE;AACrE,WAAOC,YAAY,CAACJ,QAAD,EAAW,IAAX,CAAnB;AACD;;AAED,MAAIF,UAAJ,EAAgB;AACd,WAAOM,YAAY,CAACJ,QAAD,EAAW,IAAX,EAAiBF,UAAjB,CAAnB;AACD;;AAEDP,EAAAA,MAAM,CAACc,OAAP,CAAe;AACbC,IAAAA,IAAI,EAAE,0BADO;AAEbC,IAAAA,IAAI,EAAE,8CAFO;AAGbC,IAAAA,OAAO,EAAE;AACP,yBAAmB;AADZ;AAHI,GAAf,EAMGT,KANH,EAMU,SAASU,WAAT,CAAqBC,GAArB,EAA0BC,IAA1B,EAAgC;AACxC,QAAID,GAAJ,EAAS;AACP,aAAOV,QAAQ,CAACU,GAAD,CAAf;AACD;;AAED,QAAI;AACFC,MAAAA,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWF,IAAX,CAAP;AACD,KAFD,CAEE,OAAOG,CAAP,EAAU;AACV3B,MAAAA,MAAM,CAAC4B,KAAP,CAAaD,CAAb,EAAgB,+BAAhB;AACAH,MAAAA,IAAI,GAAG,IAAP;AACD;;AAED,QAAIK,OAAO,GAAGzB,MAAM,CAAC0B,OAAP,CAAeN,IAAf,EAAqB,CAAC,IAAD,EAAO,aAAP,EAAsB,MAAtB,EAA8B,MAA9B,CAArB,CAAd;;AACA,QAAIK,OAAO,IAAI,IAAf,EAAqB;AACnB7B,MAAAA,MAAM,CAAC4B,KAAP,CAAa,2BAAb;AACAhB,MAAAA,KAAK,CAACmB,OAAN,CAAcC,iBAAd,CAAgC3B,KAAK,CAAC4B,WAAN,CAAkBC,SAAlD,EAA6DC,kBAA7D;AACD,KAHD,MAGO;AACL;AACAN,MAAAA,OAAO,CAACO,WAAR,GACEP,OAAO,CAACO,WAAR,CAAoBC,MAApB,CAA2BR,OAAO,CAACO,WAAR,CAAoBE,WAApB,CAAgC,GAAhC,IAAuC,CAAlE,CADF;AAEAT,MAAAA,OAAO,CAACU,IAAR,GACEV,OAAO,CAACU,IAAR,CAAaF,MAAb,CAAoBR,OAAO,CAACU,IAAR,CAAaD,WAAb,CAAyB,GAAzB,IAAgC,CAApD,CADF;AAGA3B,MAAAA,UAAU,GAAGkB,OAAb;AACD;;AACDhB,IAAAA,QAAQ,CAAC,IAAD,EAAOgB,OAAP,CAAR;AACD,GAhCD;AAiCD","sourcesContent":["'use strict'\n\nvar logger = require('../logger.js').child({component: 'gcp-info'})\nvar common = require('./common')\nvar NAMES = require('../metrics/names.js')\n\nmodule.exports = fetchGCPInfo\nmodule.exports.clearCache = function clearGCPCache() {\n  resultDict = null\n}\n\nvar resultDict\n\nfunction fetchGCPInfo(agent, callback) {\n  if (!agent.config.utilization || !agent.config.utilization.detect_gcp) {\n    return setImmediate(callback, null)\n  }\n\n  if (resultDict) {\n    return setImmediate(callback, null, resultDict)\n  }\n\n  common.request({\n    host: 'metadata.google.internal',\n    path: '/computeMetadata/v1/instance/?recursive=true',\n    headers: {\n      'Metadata-Flavor': 'Google'\n    }\n  }, agent, function getMetadata(err, data) {\n    if (err) {\n      return callback(err)\n    }\n\n    try {\n      data = JSON.parse(data)\n    } catch (e) {\n      logger.debug(e, 'Failed to parse GCP metadata.')\n      data = null\n    }\n\n    var results = common.getKeys(data, ['id', 'machineType', 'name', 'zone'])\n    if (results == null) {\n      logger.debug('GCP metadata was invalid.')\n      agent.metrics.getOrCreateMetric(NAMES.UTILIZATION.GCP_ERROR).incrementCallCount()\n    } else {\n      // normalize\n      results.machineType =\n        results.machineType.substr(results.machineType.lastIndexOf('/') + 1)\n      results.zone =\n        results.zone.substr(results.zone.lastIndexOf('/') + 1)\n\n      resultDict = results\n    }\n    callback(null, results)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}