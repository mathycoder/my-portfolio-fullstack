{"ast":null,"code":"'use strict';\n\nconst logger = require('../logger').child({\n  component: 'error_tracer'\n});\n\nconst TraceAggregator = require('../aggregators/trace-aggregator'); // TODO: do traces ever have differing algorithms or\n// always first-come? If same, can standardize in TraceAggregator\n// Otherwise, TraceAggregator may not be a thing\n\n\nclass ErrorTraceAggregator extends TraceAggregator {\n  constructor(opts, collector) {\n    opts = opts || {};\n    opts.method = opts.method || 'error_data';\n    super(opts, collector);\n    this.errors = [];\n  }\n\n  add(error) {\n    if (this.errors.length < this.limit) {\n      logger.debug(error, 'Error to be sent to collector.');\n      this.errors.push(error);\n    } else {\n      logger.debug('Already have %d errors to send to collector, not keeping.', this.limit);\n    }\n  }\n\n  _toPayloadSync() {\n    if (this.errors.length > 0) {\n      return [this.runId, this.errors];\n    }\n\n    logger.debug('No error traces to send.');\n  }\n\n  _getMergeData() {\n    return this.errors;\n  }\n\n  _merge(errors) {\n    if (!errors) {\n      return;\n    }\n\n    const len = Math.min(errors.length, this.limit - this.errors.length);\n    logger.warn('Merging %s (of %s) errors for next delivery.', len, errors.length);\n\n    for (var i = 0; i < len; i++) {\n      this.errors.push(errors[i]);\n    }\n  }\n\n  clear() {\n    this.errors = [];\n  }\n\n}\n\nmodule.exports = ErrorTraceAggregator;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/errors/error-trace-aggregator.js"],"names":["logger","require","child","component","TraceAggregator","ErrorTraceAggregator","constructor","opts","collector","method","errors","add","error","length","limit","debug","push","_toPayloadSync","runId","_getMergeData","_merge","len","Math","min","warn","i","clear","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,WAAD,CAAP,CAAqBC,KAArB,CAA2B;AAACC,EAAAA,SAAS,EAAE;AAAZ,CAA3B,CAAf;;AACA,MAAMC,eAAe,GAAGH,OAAO,CAAC,iCAAD,CAA/B,C,CAEA;AACA;AACA;;;AACA,MAAMI,oBAAN,SAAmCD,eAAnC,CAAmD;AACjDE,EAAAA,WAAW,CAACC,IAAD,EAAOC,SAAP,EAAkB;AAC3BD,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACAA,IAAAA,IAAI,CAACE,MAAL,GAAcF,IAAI,CAACE,MAAL,IAAe,YAA7B;AAEA,UAAMF,IAAN,EAAYC,SAAZ;AAEA,SAAKE,MAAL,GAAc,EAAd;AACD;;AAEDC,EAAAA,GAAG,CAACC,KAAD,EAAQ;AACT,QAAI,KAAKF,MAAL,CAAYG,MAAZ,GAAqB,KAAKC,KAA9B,EAAqC;AACnCd,MAAAA,MAAM,CAACe,KAAP,CAAaH,KAAb,EAAoB,gCAApB;AACA,WAAKF,MAAL,CAAYM,IAAZ,CAAiBJ,KAAjB;AACD,KAHD,MAGO;AACLZ,MAAAA,MAAM,CAACe,KAAP,CACE,2DADF,EAC+D,KAAKD,KADpE;AAED;AACF;;AAEDG,EAAAA,cAAc,GAAG;AACf,QAAI,KAAKP,MAAL,CAAYG,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B,aAAO,CAAC,KAAKK,KAAN,EAAa,KAAKR,MAAlB,CAAP;AACD;;AAEDV,IAAAA,MAAM,CAACe,KAAP,CAAa,0BAAb;AACD;;AAEDI,EAAAA,aAAa,GAAG;AACd,WAAO,KAAKT,MAAZ;AACD;;AAEDU,EAAAA,MAAM,CAACV,MAAD,EAAS;AACb,QAAI,CAACA,MAAL,EAAa;AACX;AACD;;AAED,UAAMW,GAAG,GAAGC,IAAI,CAACC,GAAL,CAASb,MAAM,CAACG,MAAhB,EAAwB,KAAKC,KAAL,GAAa,KAAKJ,MAAL,CAAYG,MAAjD,CAAZ;AACAb,IAAAA,MAAM,CAACwB,IAAP,CAAY,8CAAZ,EAA4DH,GAA5D,EAAiEX,MAAM,CAACG,MAAxE;;AAEA,SAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,GAApB,EAAyBI,CAAC,EAA1B,EAA8B;AAC5B,WAAKf,MAAL,CAAYM,IAAZ,CAAiBN,MAAM,CAACe,CAAD,CAAvB;AACD;AACF;;AAEDC,EAAAA,KAAK,GAAG;AACN,SAAKhB,MAAL,GAAc,EAAd;AACD;;AA/CgD;;AAkDnDiB,MAAM,CAACC,OAAP,GAAiBvB,oBAAjB","sourcesContent":["'use strict'\n\nconst logger = require('../logger').child({component: 'error_tracer'})\nconst TraceAggregator = require('../aggregators/trace-aggregator')\n\n// TODO: do traces ever have differing algorithms or\n// always first-come? If same, can standardize in TraceAggregator\n// Otherwise, TraceAggregator may not be a thing\nclass ErrorTraceAggregator extends TraceAggregator {\n  constructor(opts, collector) {\n    opts = opts || {}\n    opts.method = opts.method || 'error_data'\n\n    super(opts, collector)\n\n    this.errors = []\n  }\n\n  add(error) {\n    if (this.errors.length < this.limit) {\n      logger.debug(error, 'Error to be sent to collector.')\n      this.errors.push(error)\n    } else {\n      logger.debug(\n        'Already have %d errors to send to collector, not keeping.', this.limit)\n    }\n  }\n\n  _toPayloadSync() {\n    if (this.errors.length > 0) {\n      return [this.runId, this.errors]\n    }\n\n    logger.debug('No error traces to send.')\n  }\n\n  _getMergeData() {\n    return this.errors\n  }\n\n  _merge(errors) {\n    if (!errors) {\n      return\n    }\n\n    const len = Math.min(errors.length, this.limit - this.errors.length)\n    logger.warn('Merging %s (of %s) errors for next delivery.', len, errors.length)\n\n    for (var i = 0; i < len; i++) {\n      this.errors.push(errors[i])\n    }\n  }\n\n  clear() {\n    this.errors = []\n  }\n}\n\nmodule.exports = ErrorTraceAggregator\n"]},"metadata":{},"sourceType":"script"}