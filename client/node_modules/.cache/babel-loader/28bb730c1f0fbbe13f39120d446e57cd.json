{"ast":null,"code":"'use strict';\n\nconst _require = require('../metrics/names'),\n      DB = _require.DB,\n      ALL = _require.ALL;\n\nconst _require2 = require('../config/attribute-filter'),\n      DESTINATIONS = _require2.DESTINATIONS;\n\nfunction ParsedStatement(type, operation, collection, raw) {\n  this.type = type;\n  this.operation = operation;\n  this.collection = collection;\n  this.trace = null;\n  this.raw = '';\n\n  if (typeof raw === 'string') {\n    this.trace = new Error().stack;\n    this.raw = raw;\n  }\n}\n\nParsedStatement.prototype.recordMetrics = function recordMetrics(segment, scope) {\n  var duration = segment.getDurationInMillis();\n  var exclusive = segment.getExclusiveDurationInMillis();\n  var transaction = segment.transaction;\n  var type = transaction.isWeb() ? DB.WEB : DB.OTHER;\n  var thisTypeSlash = this.type + '/';\n  var operation = DB.OPERATION + '/' + thisTypeSlash + this.operation; // Note, an operation metric should _always_ be created even if the action was\n  // a statement. This is part of the spec.\n  // Rollups\n\n  transaction.measure(operation, null, duration, exclusive);\n  transaction.measure(DB.PREFIX + type, null, duration, exclusive);\n  transaction.measure(DB.PREFIX + thisTypeSlash + type, null, duration, exclusive);\n  transaction.measure(DB.PREFIX + thisTypeSlash + ALL, null, duration, exclusive);\n  transaction.measure(DB.ALL, null, duration, exclusive); // If we can parse the SQL statement, create a 'statement' metric, and use it\n  // as the scoped metric for transaction breakdowns. Otherwise, skip the\n  // 'statement' metric and use the 'operation' metric as the scoped metric for\n  // transaction breakdowns.\n\n  if (this.collection) {\n    var collection = DB.STATEMENT + '/' + thisTypeSlash + this.collection + '/' + this.operation;\n    transaction.measure(collection, null, duration, exclusive);\n\n    if (scope) {\n      transaction.measure(collection, scope, duration, exclusive);\n    }\n  } else if (scope) {\n    transaction.measure(operation, scope, duration, exclusive);\n  } // This recorder is side-effectful Because we are depending on the recorder\n  // setting the transaction name, recorders must always be run before generating\n  // the final transaction trace\n\n\n  segment.name = collection || operation; // Datastore instance metrics.\n\n  const attributes = segment.attributes.get(DESTINATIONS.TRANS_SEGMENT);\n\n  if (attributes.host && attributes.port_path_or_id) {\n    var instanceName = DB.INSTANCE + '/' + thisTypeSlash + attributes.host + '/' + attributes.port_path_or_id;\n    transaction.measure(instanceName, null, duration, exclusive);\n  }\n\n  if (this.raw) {\n    transaction.agent.queries.add(segment, this.type.toLowerCase(), this.raw, this.trace);\n  }\n};\n\nmodule.exports = ParsedStatement;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/db/parsed-statement.js"],"names":["require","DB","ALL","DESTINATIONS","ParsedStatement","type","operation","collection","raw","trace","Error","stack","prototype","recordMetrics","segment","scope","duration","getDurationInMillis","exclusive","getExclusiveDurationInMillis","transaction","isWeb","WEB","OTHER","thisTypeSlash","OPERATION","measure","PREFIX","STATEMENT","name","attributes","get","TRANS_SEGMENT","host","port_path_or_id","instanceName","INSTANCE","agent","queries","add","toLowerCase","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {DB, ALL} = require('../metrics/names')\nconst {DESTINATIONS} = require('../config/attribute-filter')\n\n\nfunction ParsedStatement(type, operation, collection, raw) {\n  this.type = type\n  this.operation = operation\n  this.collection = collection\n  this.trace = null\n  this.raw = ''\n\n  if (typeof raw === 'string') {\n    this.trace = new Error().stack\n    this.raw = raw\n  }\n}\n\nParsedStatement.prototype.recordMetrics = function recordMetrics(segment, scope) {\n  var duration = segment.getDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var transaction = segment.transaction\n  var type = transaction.isWeb() ? DB.WEB : DB.OTHER\n  var thisTypeSlash = this.type + '/'\n  var operation = DB.OPERATION + '/' + thisTypeSlash + this.operation\n\n  // Note, an operation metric should _always_ be created even if the action was\n  // a statement. This is part of the spec.\n\n  // Rollups\n  transaction.measure(operation, null, duration, exclusive)\n  transaction.measure(DB.PREFIX + type, null, duration, exclusive)\n  transaction.measure(DB.PREFIX + thisTypeSlash + type, null, duration, exclusive)\n  transaction.measure(DB.PREFIX + thisTypeSlash + ALL, null, duration, exclusive)\n  transaction.measure(DB.ALL, null, duration, exclusive)\n\n  // If we can parse the SQL statement, create a 'statement' metric, and use it\n  // as the scoped metric for transaction breakdowns. Otherwise, skip the\n  // 'statement' metric and use the 'operation' metric as the scoped metric for\n  // transaction breakdowns.\n  if (this.collection) {\n    var collection =\n      DB.STATEMENT + '/' + thisTypeSlash + this.collection + '/' + this.operation\n    transaction.measure(collection, null, duration, exclusive)\n    if (scope) {\n      transaction.measure(collection, scope, duration, exclusive)\n    }\n  } else if (scope) {\n    transaction.measure(operation, scope, duration, exclusive)\n  }\n\n  // This recorder is side-effectful Because we are depending on the recorder\n  // setting the transaction name, recorders must always be run before generating\n  // the final transaction trace\n  segment.name = collection || operation\n\n  // Datastore instance metrics.\n  const attributes = segment.attributes.get(DESTINATIONS.TRANS_SEGMENT)\n  if (attributes.host && attributes.port_path_or_id) {\n    var instanceName = DB.INSTANCE + '/' + thisTypeSlash + attributes.host +\n      '/' + attributes.port_path_or_id\n    transaction.measure(instanceName, null, duration, exclusive)\n  }\n\n  if (this.raw) {\n    transaction.agent.queries.add(\n      segment,\n      this.type.toLowerCase(),\n      this.raw,\n      this.trace\n    )\n  }\n}\n\nmodule.exports = ParsedStatement\n"]},"metadata":{},"sourceType":"script"}