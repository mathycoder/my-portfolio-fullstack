{"ast":null,"code":"'use strict';\n\nclass AdaptiveSampler {\n  constructor(opts) {\n    this._serverless = opts.serverless;\n    this._seen = 0;\n    this._sampled = 0;\n    this._samplingPeriod = 0;\n    this._samplingTarget = opts.target;\n    this._maxSamples = 2 * opts.target;\n    this._samplingThreshold = 0;\n    this._resetCount = 0;\n    this._resetInterval = null;\n    this.samplingPeriod = opts.period;\n\n    if (this._serverless) {\n      this._windowStart = null;\n      opts.agent.on('transactionStarted', this.maybeUpdateWindow.bind(this));\n    }\n  }\n\n  get sampled() {\n    return this._sampled;\n  }\n\n  get samplingThreshold() {\n    return this._samplingThreshold;\n  }\n\n  get samplingTarget() {\n    return this._samplingTarget;\n  }\n\n  set samplingTarget(target) {\n    this._samplingTarget = target;\n    this._maxSamples = 2 * target;\n\n    this._adjustStats(this._samplingTarget);\n  }\n\n  get samplingPeriod() {\n    return this._samplingPeriod;\n  }\n\n  set samplingPeriod(period) {\n    this._samplingPeriod = period;\n\n    if (!this._serverless) {\n      clearInterval(this._resetInterval);\n\n      if (period) {\n        this._resetInterval = setInterval(() => this._reset(), period);\n\n        this._resetInterval.unref();\n      }\n    }\n  }\n  /**\n   *  Used to determine if the sampling window should be reset based on the start time\n   *  of the provided transaction.\n   *\n   *  @param {object} transaction - The transaction to compare against the current\n   *                                window.\n   */\n\n\n  maybeUpdateWindow(transaction) {\n    const timestamp = transaction.timer.start;\n\n    if (!this._windowStart || timestamp - this._windowStart >= this._samplingPeriod) {\n      this._windowStart = timestamp;\n\n      this._reset();\n    }\n  }\n  /**\n   * Determines if an object should be sampled based on the object's priority and\n   * the number of objects sampled in this window.\n   *\n   * @param {number} roll - The number to compare against the threshold\n   *\n   * @return {bool} True if the object should be sampled.\n   */\n\n\n  shouldSample(roll) {\n    ++this._seen;\n\n    if (roll >= this._samplingThreshold) {\n      this._incrementSampled();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Starts a new sample period after adjusting the sampling statistics.\n   */\n\n\n  _reset() {\n    ++this._resetCount;\n\n    this._adjustStats(this._samplingTarget);\n\n    this._seen = 0;\n    this._sampled = 0;\n  }\n  /**\n   * Increments the sampled counter and adjusted the sampling threshold to maintain\n   * a steady sample rate.\n   */\n\n\n  _incrementSampled() {\n    if (++this._sampled >= this._samplingTarget) {\n      // For the first sample window we take the first 10 transactions and only\n      // the first 10.\n      let adjustedTarget = 0;\n\n      if (this._resetCount > 0) {\n        const target = this._samplingTarget;\n        const ratio = target / this._sampled;\n        const max = target / this._maxSamples;\n        adjustedTarget = Math.pow(target, ratio) - Math.pow(target, max);\n      }\n\n      this._adjustStats(adjustedTarget);\n    }\n  }\n  /**\n   * Adjusts the statistics used to determine if an object should be sampled.\n   *\n   * @param {number} target - The target number of objects to sample.\n   */\n\n\n  _adjustStats(target) {\n    if (this._seen) {\n      const ratio = Math.min(target / this._seen, 1);\n      this._samplingThreshold = 1 - ratio;\n    }\n  }\n\n}\n\nmodule.exports = AdaptiveSampler;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/adaptive-sampler.js"],"names":["AdaptiveSampler","constructor","opts","_serverless","serverless","_seen","_sampled","_samplingPeriod","_samplingTarget","target","_maxSamples","_samplingThreshold","_resetCount","_resetInterval","samplingPeriod","period","_windowStart","agent","on","maybeUpdateWindow","bind","sampled","samplingThreshold","samplingTarget","_adjustStats","clearInterval","setInterval","_reset","unref","transaction","timestamp","timer","start","shouldSample","roll","_incrementSampled","adjustedTarget","ratio","max","Math","pow","min","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nclass AdaptiveSampler {\n  constructor(opts) {\n    this._serverless = opts.serverless\n    this._seen = 0\n    this._sampled = 0\n    this._samplingPeriod = 0\n    this._samplingTarget = opts.target\n    this._maxSamples = 2 * opts.target\n    this._samplingThreshold = 0\n    this._resetCount = 0\n    this._resetInterval = null\n\n    this.samplingPeriod = opts.period\n\n    if (this._serverless) {\n      this._windowStart = null\n      opts.agent.on('transactionStarted', this.maybeUpdateWindow.bind(this))\n    }\n  }\n\n  get sampled() {\n    return this._sampled\n  }\n\n  get samplingThreshold() {\n    return this._samplingThreshold\n  }\n\n  get samplingTarget() {\n    return this._samplingTarget\n  }\n\n  set samplingTarget(target) {\n    this._samplingTarget = target\n    this._maxSamples = 2 * target\n    this._adjustStats(this._samplingTarget)\n  }\n\n  get samplingPeriod() {\n    return this._samplingPeriod\n  }\n\n  set samplingPeriod(period) {\n    this._samplingPeriod = period\n    if (!this._serverless) {\n      clearInterval(this._resetInterval)\n\n      if (period) {\n        this._resetInterval = setInterval(() => this._reset(), period)\n        this._resetInterval.unref()\n      }\n    }\n  }\n\n  /**\n   *  Used to determine if the sampling window should be reset based on the start time\n   *  of the provided transaction.\n   *\n   *  @param {object} transaction - The transaction to compare against the current\n   *                                window.\n   */\n  maybeUpdateWindow(transaction) {\n    const timestamp = transaction.timer.start\n    if (!this._windowStart || timestamp - this._windowStart >= this._samplingPeriod) {\n      this._windowStart = timestamp\n      this._reset()\n    }\n  }\n\n  /**\n   * Determines if an object should be sampled based on the object's priority and\n   * the number of objects sampled in this window.\n   *\n   * @param {number} roll - The number to compare against the threshold\n   *\n   * @return {bool} True if the object should be sampled.\n   */\n  shouldSample(roll) {\n    ++this._seen\n    if (roll >= this._samplingThreshold) {\n      this._incrementSampled()\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Starts a new sample period after adjusting the sampling statistics.\n   */\n  _reset() {\n    ++this._resetCount\n    this._adjustStats(this._samplingTarget)\n\n    this._seen = 0\n    this._sampled = 0\n  }\n\n  /**\n   * Increments the sampled counter and adjusted the sampling threshold to maintain\n   * a steady sample rate.\n   */\n  _incrementSampled() {\n    if (++this._sampled >= this._samplingTarget) {\n      // For the first sample window we take the first 10 transactions and only\n      // the first 10.\n      let adjustedTarget = 0\n      if (this._resetCount > 0) {\n        const target = this._samplingTarget\n        const ratio = target / this._sampled\n        const max = target / this._maxSamples\n        adjustedTarget = Math.pow(target, ratio) - Math.pow(target, max)\n      }\n      this._adjustStats(adjustedTarget)\n    }\n  }\n\n  /**\n   * Adjusts the statistics used to determine if an object should be sampled.\n   *\n   * @param {number} target - The target number of objects to sample.\n   */\n  _adjustStats(target) {\n    if (this._seen) {\n      const ratio = Math.min(target / this._seen, 1)\n      this._samplingThreshold = 1 - ratio\n    }\n  }\n}\n\nmodule.exports = AdaptiveSampler\n"]},"metadata":{},"sourceType":"script"}