{"ast":null,"code":"'use strict';\n\nconst AdaptiveSampler = require('./adaptive-sampler');\n\nconst CollectorAPI = require('./collector/api');\n\nconst ServerlessCollector = require('./collector/serverless');\n\nconst DESTINATIONS = require('./config/attribute-filter').DESTINATIONS;\n\nconst CustomEventAggregator = require('./custom-events/custom-event-aggregator');\n\nconst ErrorCollector = require('./errors/error-collector');\n\nconst ErrorTraceAggregator = require('./errors/error-trace-aggregator');\n\nconst ErrorEventAggregator = require('./errors/error-event-aggregator');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst hashes = require('./util/hashes');\n\nconst logger = require('./logger');\n\nconst MetricMapper = require('./metrics/mapper');\n\nconst MetricNormalizer = require('./metrics/normalizer');\n\nconst MetricAggregator = require('./metrics/metric-aggregator');\n\nconst NAMES = require('./metrics/names');\n\nconst QueryTraceAggregator = require('./db/query-trace-aggregator');\n\nconst sampler = require('./sampler');\n\nconst TransactionTraceAggregator = require('./transaction/trace/aggregator');\n\nconst SpanEventAggregator = require('./spans/span-event-aggregator');\n\nconst TransactionEventAggregator = require('./transaction/transaction-event-aggregator');\n\nconst Tracer = require('./transaction/tracer');\n\nconst TxSegmentNormalizer = require('./metrics/normalizer/tx_segment');\n\nconst uninstrumented = require('./uninstrumented');\n\nconst util = require('util'); // Map of valid states to whether or not data collection is valid\n\n\nconst STATES = {\n  stopped: false,\n  starting: true,\n  connecting: true,\n  connected: true,\n  started: true,\n  disconnected: false,\n  stopping: false,\n  errored: false\n};\nconst MAX_ERROR_TRACES_DEFAULT = 20;\nconst INITIAL_HARVEST_DELAY_MS = 1000;\nconst DEFAULT_HARVEST_INTERVAL_MS = 60000;\n/**\n * There's a lot of stuff in this constructor, due to Agent acting as the\n * orchestrator for New Relic within instrumented applications.\n *\n * This constructor can throw if, for some reason, the configuration isn't\n * available. Don't try to recover here, because without configuration the\n * agent can't be brought up to a useful state.\n */\n\nfunction Agent(config) {\n  EventEmitter.call(this);\n  if (!config) throw new Error('Agent must be created with a configuration!'); // The agent base attributes which last throughout its lifetime.\n\n  this._state = 'stopped';\n  this.config = config;\n  this.environment = require('./environment');\n  this.version = this.config.version;\n\n  if (config.serverless_mode.enabled) {\n    this.collector = new ServerlessCollector(this);\n  } else {\n    this.collector = new CollectorAPI(this);\n  }\n\n  this.mapper = new MetricMapper();\n  this.metricNameNormalizer = new MetricNormalizer(this.config, 'metric name');\n  this.metrics = new MetricAggregator({\n    periodMs: DEFAULT_HARVEST_INTERVAL_MS,\n    apdexT: this.config.apdex_t,\n    mapper: this.mapper,\n    normalizer: this.metricNameNormalizer\n  }, this.collector);\n  this.metrics.on('starting metric_data data send.', this._beforeMetricDataSend.bind(this)); // Open tracing.\n\n  this.spanEventAggregator = new SpanEventAggregator({\n    periodMs: config.event_harvest_config.report_period_ms,\n    limit: config.event_harvest_config.harvest_limits.span_event_data\n  }, this.collector, this.metrics);\n  this.transactionNameNormalizer = new MetricNormalizer(this.config, 'transaction name'); // Segment term based tx renaming for MGI mitigation.\n\n  this.txSegmentNormalizer = new TxSegmentNormalizer(); // User naming and ignoring rules.\n\n  this.urlNormalizer = new MetricNormalizer(this.config, 'URL');\n  this.userNormalizer = new MetricNormalizer(this.config, 'user');\n  this.userNormalizer.loadFromConfig();\n  this.transactionEventAggregator = new TransactionEventAggregator({\n    periodMs: config.event_harvest_config.report_period_ms,\n    limit: config.event_harvest_config.harvest_limits.analytic_event_data\n  }, this.collector, this.metrics);\n  this.customEventAggregator = new CustomEventAggregator({\n    periodMs: config.event_harvest_config.report_period_ms,\n    limit: config.event_harvest_config.harvest_limits.custom_event_data\n  }, this.collector, this.metrics);\n  const errorTraceAggregator = new ErrorTraceAggregator({\n    periodMs: DEFAULT_HARVEST_INTERVAL_MS,\n    limit: MAX_ERROR_TRACES_DEFAULT\n  }, this.collector);\n  const errorEventAggregator = new ErrorEventAggregator({\n    periodMs: config.event_harvest_config.report_period_ms,\n    limit: config.event_harvest_config.harvest_limits.error_event_data\n  }, this.collector, this.metrics);\n  this.errors = new ErrorCollector(config, errorTraceAggregator, errorEventAggregator, this.metrics); // Transaction tracing.\n\n  this.tracer = new Tracer(this);\n  this.traces = new TransactionTraceAggregator({\n    periodMs: DEFAULT_HARVEST_INTERVAL_MS,\n    config: this.config,\n    isAsync: !config.serverless_mode.enabled,\n    method: 'transaction_sample_data'\n  }, this.collector);\n  this.transactionSampler = new AdaptiveSampler({\n    agent: this,\n    serverless: config.serverless_mode.enabled,\n    period: config.sampling_target_period_in_seconds * 1000,\n    target: config.sampling_target\n  });\n  this.queries = new QueryTraceAggregator({\n    config: this.config,\n    periodMs: DEFAULT_HARVEST_INTERVAL_MS,\n    method: 'sql_trace_data',\n    isAsync: !config.serverless_mode.enabled\n  }, this.collector); // Set up all the configuration events the agent needs to listen for.\n\n  this._listenForConfigChanges(); // Entity tracking metrics.\n\n\n  this.totalActiveSegments = 0;\n  this.segmentsCreatedInHarvest = 0;\n  this.segmentsClearedInHarvest = 0; // Used by shutdown code as well as entity tracking stats\n\n  this.activeTransactions = 0; // Finally, add listeners for the agent's own events.\n\n  this.on('transactionFinished', this._transactionFinished.bind(this));\n}\n\nutil.inherits(Agent, EventEmitter);\n/**\n * The agent is meant to only exist once per application, but the singleton is\n * managed by index.js. An agent will be created even if the agent's disabled by\n * the configuration.\n *\n * @config {boolean} agent_enabled Whether to start up the agent.\n *\n * @param {Function} callback Continuation and error handler.\n */\n\nAgent.prototype.start = function start(callback) {\n  if (!callback) throw new TypeError('callback required!');\n  const agent = this;\n  this.setState('starting');\n\n  if (this.config.agent_enabled !== true) {\n    logger.warn('The New Relic Node.js agent is disabled by its configuration. ' + 'Not starting!');\n    this.setState('stopped');\n    return process.nextTick(callback);\n  }\n\n  sampler.start(agent);\n\n  if (this.config.serverless_mode.enabled) {\n    return this._serverlessModeStart(callback);\n  }\n\n  if (!this.config.license_key) {\n    logger.error('A valid account license key cannot be found. ' + 'Has a license key been specified in the agent configuration ' + 'file or via the NEW_RELIC_LICENSE_KEY environment variable?');\n    this.setState('errored');\n    sampler.stop();\n    return process.nextTick(function onNextTick() {\n      callback(new Error('Not starting without license key!'));\n    });\n  }\n\n  logger.info('Starting New Relic for Node.js connection process.');\n  this.collector.connect(function onStartConnect(error, response) {\n    if (error || response.shouldShutdownRun()) {\n      agent.setState('errored');\n      sampler.stop();\n      callback(error || new Error('Failed to connect to collector'), response && response.payload);\n      return;\n    }\n\n    if (agent.collector.isConnected()) {\n      agent.onConnect();\n      agent.setState('started');\n      const config = response.payload;\n\n      if (agent.config.no_immediate_harvest) {\n        agent.startAggregators();\n        callback(null, config);\n      } else {\n        // Harvest immediately for quicker data display, but after at least 1\n        // second or the collector will throw away the data.\n        //\n        // NOTE: this setTimeout is deliberately NOT unref'd due to it being\n        // the last step in the Agent startup process\n        setTimeout(function afterTimeout() {\n          logger.info(`Starting initial ${INITIAL_HARVEST_DELAY_MS}ms harvest.`);\n          agent.forceHarvestAll(function afterAllAggregatorsSend() {\n            agent.startAggregators();\n            callback(null, config);\n          });\n        }, INITIAL_HARVEST_DELAY_MS);\n      }\n    } else {\n      callback(new Error('Collector did not connect and did not error'));\n    }\n  });\n};\n/**\n * Forces all aggregators to send the data collected.\n * @param {Function} callback The callback to invoke when all data types have been sent.\n */\n\n\nAgent.prototype.forceHarvestAll = function forceHarvestAll(callback) {\n  const agent = this;\n  const promises = [];\n  const metricPromise = new Promise(resolve => {\n    agent.metrics.once('finished metric_data data send.', function onMetricsFinished() {\n      resolve();\n    });\n    agent.metrics.send();\n  });\n  promises.push(metricPromise); // TODO: plumb config through to aggregators so they can do their own checking.\n\n  if (agent.config.distributed_tracing.enabled && agent.config.span_events.enabled) {\n    const spanPromise = new Promise(resolve => {\n      agent.spanEventAggregator.once('finished span_event_data data send.', function onSpansFinished() {\n        resolve();\n      });\n      agent.spanEventAggregator.send();\n    });\n    promises.push(spanPromise);\n  }\n\n  if (agent.config.custom_insights_events.enabled) {\n    const customEventPromise = new Promise(resolve => {\n      agent.customEventAggregator.once('finished custom_event_data data send.', function onCustomEventsFinished() {\n        resolve();\n      });\n      agent.customEventAggregator.send();\n    });\n    promises.push(customEventPromise);\n  }\n\n  if (agent.config.transaction_events.enabled) {\n    const transactionEventPromise = new Promise(resolve => {\n      agent.transactionEventAggregator.once('finished analytic_event_data data send.', function onTransactionEventsFinished() {\n        resolve();\n      });\n      agent.transactionEventAggregator.send();\n    });\n    promises.push(transactionEventPromise);\n  }\n\n  if (agent.config.transaction_tracer.enabled && agent.config.collect_traces) {\n    const transactionTracePromise = new Promise(resolve => {\n      agent.traces.once('finished transaction_sample_data data send.', function onTracesFinished() {\n        resolve();\n      });\n      agent.traces.send();\n    });\n    promises.push(transactionTracePromise);\n  }\n\n  if (agent.config.slow_sql.enabled) {\n    const sqlTracePromise = new Promise(resolve => {\n      agent.queries.once('finished sql_trace_data data send.', function onSqlTracesFinished() {\n        resolve();\n      });\n      agent.queries.send();\n    });\n    promises.push(sqlTracePromise);\n  }\n\n  const errorCollectorEnabled = agent.config.error_collector && agent.config.error_collector.enabled;\n\n  if (errorCollectorEnabled && agent.config.collect_errors) {\n    const errorTracePromise = new Promise(resolve => {\n      agent.errors.traceAggregator.once('finished error_data data send.', function onErrorTracesFinished() {\n        resolve();\n      });\n      agent.errors.traceAggregator.send();\n    });\n    promises.push(errorTracePromise);\n  }\n\n  if (errorCollectorEnabled && agent.config.error_collector.capture_events) {\n    const errorEventPromise = new Promise(resolve => {\n      agent.errors.eventAggregator.once('finished error_event_data data send.', function onErrorEventsFinished() {\n        resolve();\n      });\n      agent.errors.eventAggregator.send();\n    });\n    promises.push(errorEventPromise);\n  }\n\n  Promise.all(promises).then(() => {\n    // Get out of the promise so callback errors aren't treated as\n    // promise rejections.\n    setImmediate(callback);\n  });\n};\n\nAgent.prototype.stopAggregators = function stopAggregators() {\n  this.metrics.stop();\n  this.errors.stop();\n  this.traces.stop();\n  this.queries.stop();\n  this.spanEventAggregator.stop();\n  this.transactionEventAggregator.stop();\n  this.customEventAggregator.stop();\n};\n\nAgent.prototype.startAggregators = function startAggregators() {\n  this.metrics.start();\n  this.errors.start();\n\n  if (this.config.transaction_tracer.enabled && this.config.collect_traces) {\n    this.traces.start();\n  }\n\n  if (this.config.slow_sql.enabled) {\n    this.queries.start();\n  }\n\n  if (this.config.distributed_tracing.enabled && this.config.span_events.enabled) {\n    this.spanEventAggregator.start();\n  }\n\n  if (this.config.transaction_events.enabled) {\n    this.transactionEventAggregator.start();\n  }\n\n  if (this.config.custom_insights_events.enabled) {\n    this.customEventAggregator.start();\n  }\n};\n\nAgent.prototype.onConnect = function onConnect() {\n  this.metrics.reconfigure(this.config);\n  this.errors.reconfigure(this.config);\n  this.traces.reconfigure(this.config);\n  this.queries.reconfigure(this.config);\n  this.spanEventAggregator.reconfigure(this.config);\n  this.transactionEventAggregator.reconfigure(this.config);\n  this.customEventAggregator.reconfigure(this.config);\n};\n/**\n *  Bypasses standard collector connection by immediately invoking the startup\n *  callback, after gathering local environment details.\n *\n * @param {Function} callback\n */\n\n\nAgent.prototype._serverlessModeStart = function _serverlessModeStart(callback) {\n  logger.info('New Relic for Node.js starting in serverless mode -- skipping connection process.');\n  setImmediate(() => callback(null, this.config));\n};\n/**\n * Any memory claimed by the agent will be retained after stopping.\n *\n * FIXME: make it possible to dispose of the agent, as well as do a\n * \"hard\" restart. This requires working with shimmer to strip the\n * current instrumentation and patch to the module loader.\n */\n\n\nAgent.prototype.stop = function stop(callback) {\n  if (!callback) throw new TypeError('callback required!');\n  const agent = this;\n  this.setState('stopping');\n  this.stopAggregators();\n  sampler.stop();\n\n  if (this.collector.isConnected()) {\n    this.collector.shutdown(function onShutdown(error) {\n      if (error) {\n        agent.setState('errored');\n        logger.warn(error, 'Got error shutting down connection to New Relic:');\n      } else {\n        agent.setState('stopped');\n        logger.info('Stopped New Relic for Node.js.');\n      }\n\n      callback(error);\n    });\n  } else {\n    logger.trace('Collector was not connected, invoking callback.');\n    process.nextTick(callback);\n  }\n};\n/**\n * Resets queries.\n */\n\n\nAgent.prototype._resetQueries = function resetQueries() {\n  this.queries.clear();\n};\n\nAgent.prototype._resetErrors = function resetErrors() {\n  this.errors.clearAll(); // TODO: is this still necessary?\n  // Likely do more direct with new config\n\n  this.errors.reconfigure(this.config);\n};\n/**\n * Resets events.\n */\n\n\nAgent.prototype._resetEvents = function resetEvents() {\n  this.transactionEventAggregator.clear();\n};\n/**\n * Resets custom events.\n *\n * @param {boolean} forceReset\n *   Flag signalling unconditional reset, sent during LASP application.\n */\n\n\nAgent.prototype._resetCustomEvents = function resetCustomEvents() {\n  this.customEventAggregator.clear();\n};\n/**\n * This method invokes a harvest synchronously.\n *\n * NOTE: this doesn't currently work outside of serverless mode.\n */\n\n\nAgent.prototype.harvestSync = function harvestSync() {\n  logger.trace('Peparing to harvest.');\n\n  if (!this.collector.isConnected()) {\n    throw new Error('Sync harvest not connected/enabled!');\n  } // We have a connection, create a new harvest.\n\n\n  this.emit('harvestStarted');\n  logger.info('Harvest started.');\n  const collector = this.collector;\n  const agent = this; // \"Sends\" data to the serverless collector collection\n\n  this.metrics.send();\n  this.errors.traceAggregator.send();\n  this.errors.eventAggregator.send();\n  this.traces.send();\n  this.queries.send();\n  this.spanEventAggregator.send();\n  this.transactionEventAggregator.send();\n  this.customEventAggregator.send(); // Write serverless output\n\n  collector.flushPayloadSync();\n  agent.emit('harvestFinished');\n  logger.info('Harvest finished.');\n};\n\nAgent.prototype._beforeMetricDataSend = function _beforeMetricDataSend() {\n  this._generateEntityStatsAndClear(); // Send uninstrumented supportability metrics every metric harvest cycle\n\n\n  uninstrumented.createMetrics(this.metrics);\n};\n\nAgent.prototype._generateEntityStatsAndClear = function _generateHarvestMetrics() {\n  // Note some information about the size of this harvest.\n  if (logger.traceEnabled()) {\n    logger.trace({\n      segmentTotal: this.totalActiveSegments,\n      harvestCreated: this.segmentsCreatedInHarvest,\n      harvestCleared: this.segmentsClearedInHarvest,\n      activeTransactions: this.activeTransactions\n    }, 'Entity stats on metric harvest');\n  } // Reset the counters.\n\n\n  this.segmentsCreatedInHarvest = 0;\n  this.segmentsClearedInHarvest = 0;\n};\n/**\n * Public interface for passing configuration data from the collector\n * on to the configuration, in an effort to keep them at least somewhat\n * decoupled.\n *\n * @param {object} configuration New config JSON from the collector.\n */\n\n\nAgent.prototype.reconfigure = function reconfigure(configuration) {\n  if (!configuration) throw new TypeError('must pass configuration');\n  this.config.onConnect(configuration);\n};\n/**\n * Set the current state of the agent. Some states will not allow the\n * creation of Transactions.\n *\n * @param {string} newState The new state of the agent.\n */\n\n\nAgent.prototype.setState = function setState(newState) {\n  if (!STATES.hasOwnProperty(newState)) {\n    throw new TypeError('Invalid state ' + newState);\n  }\n\n  logger.info('Agent state changed from %s to %s.', this._state, newState);\n  this._state = newState;\n  this.emit(this._state);\n};\n/**\n * Return true if the agent is in a run state that can collect and\n * process data.\n */\n\n\nAgent.prototype.canCollectData = function canCollectData() {\n  return STATES[this._state];\n};\n/**\n * `agent_enabled` changed. This will generally only happen because of a high\n * security mode mismatch between the agent and the collector. This only\n * expects to have to stop the agent. No provisions have been made, nor\n * testing have been done to make sure it is safe to start the agent back up.\n */\n\n\nAgent.prototype._enabledChange = function _enabledChange() {\n  if (this.config.agent_enabled === false) {\n    logger.warn('agent_enabled has been changed to false, stopping the agent.');\n    this.stop(function nop() {});\n  }\n};\n/**\n * Report new settings to collector after a configuration has changed. This\n * always occurs after handling a response from a connect call.\n */\n\n\nAgent.prototype._configChange = function _configChange() {\n  this.collector.reportSettings();\n};\n\nAgent.prototype._addIntrinsicAttrsFromTransaction = _addIntrinsicAttrsFromTransaction;\n\nfunction _addIntrinsicAttrsFromTransaction(transaction) {\n  const intrinsicAttributes = {\n    webDuration: transaction.timer.getDurationInMillis() / 1000,\n    timestamp: transaction.timer.start,\n    name: transaction.getFullName(),\n    duration: transaction.timer.getDurationInMillis() / 1000,\n    totalTime: transaction.trace.getTotalTimeDurationInMillis() / 1000,\n    type: 'Transaction',\n    error: transaction.hasErrors()\n  };\n  let metric = transaction.metrics.getMetric(NAMES.QUEUETIME);\n\n  if (metric) {\n    intrinsicAttributes.queueDuration = metric.total;\n  }\n\n  metric = transaction.metrics.getMetric(NAMES.EXTERNAL.ALL);\n\n  if (metric) {\n    intrinsicAttributes.externalDuration = metric.total;\n    intrinsicAttributes.externalCallCount = metric.callCount;\n  }\n\n  metric = transaction.metrics.getMetric(NAMES.DB.ALL);\n\n  if (metric) {\n    intrinsicAttributes.databaseDuration = metric.total;\n    intrinsicAttributes.databaseCallCount = metric.callCount;\n  }\n\n  if (this.config.distributed_tracing.enabled) {\n    transaction.addDistributedTraceIntrinsics(intrinsicAttributes);\n\n    if (transaction.parentSpanId) {\n      intrinsicAttributes.parentSpanId = transaction.parentSpanId;\n    }\n\n    if (transaction.parentId) {\n      intrinsicAttributes.parentId = transaction.parentId;\n    }\n  } else if (this.config.cross_application_tracer.enabled && !transaction.invalidIncomingExternalTransaction && (transaction.referringTransactionGuid || transaction.includesOutboundRequests())) {\n    intrinsicAttributes['nr.guid'] = transaction.id;\n    intrinsicAttributes['nr.tripId'] = transaction.tripId || transaction.id;\n    intrinsicAttributes['nr.pathHash'] = hashes.calculatePathHash(this.config.applications()[0], transaction.getFullName(), transaction.referringPathHash);\n\n    if (transaction.referringPathHash) {\n      intrinsicAttributes['nr.referringPathHash'] = transaction.referringPathHash;\n    }\n\n    if (transaction.referringTransactionGuid) {\n      var refId = transaction.referringTransactionGuid;\n      intrinsicAttributes['nr.referringTransactionGuid'] = refId;\n    }\n\n    var alternatePathHashes = transaction.alternatePathHashes();\n\n    if (alternatePathHashes) {\n      intrinsicAttributes['nr.alternatePathHashes'] = alternatePathHashes;\n    }\n\n    if (transaction.baseSegment && transaction.type === 'web') {\n      var apdex = this.config.web_transactions_apdex[transaction.getFullName()] || this.config.apdex_t;\n      var duration = transaction.baseSegment.getDurationInMillis() / 1000;\n      intrinsicAttributes['nr.apdexPerfZone'] = calculateApdexZone(duration, apdex);\n    }\n  }\n\n  if (transaction.syntheticsData) {\n    intrinsicAttributes['nr.syntheticsResourceId'] = transaction.syntheticsData.resourceId;\n    intrinsicAttributes['nr.syntheticsJobId'] = transaction.syntheticsData.jobId;\n    intrinsicAttributes['nr.syntheticsMonitorId'] = transaction.syntheticsData.monitorId;\n  }\n\n  return intrinsicAttributes;\n}\n\nfunction calculateApdexZone(duration, apdexT) {\n  if (duration <= apdexT) {\n    return 'S'; // satisfied\n  }\n\n  if (duration <= apdexT * 4) {\n    return 'T'; // tolerating\n  }\n\n  return 'F'; // frustrated\n}\n\nAgent.prototype._addEventFromTransaction = function _addEventFromTransaction(tx) {\n  if (!this.config.transaction_events.enabled) return;\n\n  const intrinsicAttributes = this._addIntrinsicAttrsFromTransaction(tx);\n\n  const userAttributes = tx.trace.custom.get(DESTINATIONS.TRANS_EVENT);\n  const agentAttributes = tx.trace.attributes.get(DESTINATIONS.TRANS_EVENT);\n  const event = [intrinsicAttributes, userAttributes, agentAttributes];\n  this.transactionEventAggregator.add(event, tx.priority || Math.random());\n};\n/**\n * Put all the logic for handing finalized transactions off to the tracers and\n * metric collections in one place.\n *\n * @param {Transaction} transaction Newly-finalized transaction.\n */\n\n\nAgent.prototype._transactionFinished = function _transactionFinished(transaction) {\n  // Allow the API to explicitly set the ignored status.\n  if (transaction.forceIgnore !== null) {\n    transaction.ignore = transaction.forceIgnore;\n  }\n\n  if (!transaction.ignore) {\n    if (transaction.forceIgnore === false) {\n      logger.debug('Explicitly not ignoring %s (%s).', transaction.name, transaction.id);\n    }\n\n    this.metrics.merge(transaction.metrics, false);\n    this.errors.onTransactionFinished(transaction);\n    this.traces.add(transaction);\n    const trace = transaction.trace;\n    trace.intrinsics = transaction.getIntrinsicAttributes();\n\n    this._addEventFromTransaction(transaction);\n  } else if (transaction.forceIgnore === true) {\n    logger.debug('Explicitly ignoring %s (%s).', transaction.name, transaction.id);\n  } else {\n    logger.debug('Ignoring %s (%s).', transaction.name, transaction.id);\n  }\n\n  --this.activeTransactions;\n  this.totalActiveSegments -= transaction.numSegments;\n  this.segmentsClearedInHarvest += transaction.numSegments;\n};\n\nAgent.prototype.setLambdaArn = function setLambdaArn(arn) {\n  if (this.collector instanceof ServerlessCollector) {\n    this.collector.setLambdaArn(arn);\n  }\n};\n/**\n * Get the current transaction (if there is one) from the tracer.\n *\n * @returns {Transaction} The current transaction.\n */\n\n\nAgent.prototype.getTransaction = function getTransaction() {\n  return this.tracer.getTransaction();\n};\n\nAgent.prototype.recordSupportability = function recordSupportability(name, value) {\n  const metric = this.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.PREFIX + name);\n\n  if (value != null) {\n    metric.recordValue(value);\n  } else {\n    metric.incrementCallCount();\n  }\n};\n\nAgent.prototype._listenForConfigChanges = function _listenForConfigChanges() {\n  const self = this;\n  this.config.on('agent_enabled', this._enabledChange.bind(this));\n  this.config.on('change', this._configChange.bind(this));\n  this.config.on('metric_name_rules', function updateMetricNameNormalizer() {\n    self.metricNameNormalizer.load.apply(self.metricNameNormalizer, arguments);\n  });\n  this.config.on('transaction_name_rules', function updateTransactionNameNormalizer() {\n    self.transactionNameNormalizer.load.apply(self.transactionNameNormalizer, arguments);\n  });\n  this.config.on('url_rules', function updateUrlNormalizer() {\n    self.urlNormalizer.load.apply(self.urlNormalizer, arguments);\n  });\n  this.config.on('transaction_segment_terms', function updateSegmentNormalizer() {\n    self.txSegmentNormalizer.load.apply(self.txSegmentNormalizer, arguments);\n  });\n  this.config.on('sampling_target', function updateSamplingTarget(target) {\n    self.transactionSampler.samplingTarget = target;\n  });\n  this.config.on('sampling_target_period_in_seconds', function updateSamplePeriod(period) {\n    self.transactionSampler.samplingPeriod = period * 1000;\n  });\n  this.config.on('event_harvest_config', function onHarvestConfigReceived(harvestConfig) {\n    if (harvestConfig) {\n      generateEventHarvestSupportMetrics(self, harvestConfig);\n    }\n  });\n};\n\nfunction generateEventHarvestSupportMetrics(agent, harvestConfig) {\n  const harvestLimits = harvestConfig.harvest_limits;\n  const harvestNames = NAMES.EVENT_HARVEST;\n  const harvestLimitNames = harvestNames.HARVEST_LIMIT;\n  const reportPeriodMetric = agent.metrics.getOrCreateMetric(harvestNames.REPORT_PERIOD);\n  reportPeriodMetric.recordValue(harvestConfig.report_period_ms);\n  const analyticLimit = harvestLimits.analytic_event_data;\n\n  if (analyticLimit) {\n    const analyticLimitMetric = agent.metrics.getOrCreateMetric(harvestLimitNames.ANALYTIC);\n    analyticLimitMetric.recordValue(analyticLimit);\n  }\n\n  const customLimit = harvestLimits.custom_event_data;\n\n  if (customLimit) {\n    const customLimitMetric = agent.metrics.getOrCreateMetric(harvestLimitNames.CUSTOM);\n    customLimitMetric.recordValue(customLimit);\n  }\n\n  const errorLimit = harvestLimits.error_event_data;\n\n  if (errorLimit) {\n    const errorLimitMetric = agent.metrics.getOrCreateMetric(harvestLimitNames.ERROR);\n    errorLimitMetric.recordValue(errorLimit);\n  }\n\n  const spanLimit = harvestLimits.span_event_data;\n\n  if (spanLimit) {\n    const spanLimitMetric = agent.metrics.getOrCreateMetric(harvestLimitNames.SPAN);\n    spanLimitMetric.recordValue(spanLimit);\n  }\n}\n\nmodule.exports = Agent;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/agent.js"],"names":["AdaptiveSampler","require","CollectorAPI","ServerlessCollector","DESTINATIONS","CustomEventAggregator","ErrorCollector","ErrorTraceAggregator","ErrorEventAggregator","EventEmitter","hashes","logger","MetricMapper","MetricNormalizer","MetricAggregator","NAMES","QueryTraceAggregator","sampler","TransactionTraceAggregator","SpanEventAggregator","TransactionEventAggregator","Tracer","TxSegmentNormalizer","uninstrumented","util","STATES","stopped","starting","connecting","connected","started","disconnected","stopping","errored","MAX_ERROR_TRACES_DEFAULT","INITIAL_HARVEST_DELAY_MS","DEFAULT_HARVEST_INTERVAL_MS","Agent","config","call","Error","_state","environment","version","serverless_mode","enabled","collector","mapper","metricNameNormalizer","metrics","periodMs","apdexT","apdex_t","normalizer","on","_beforeMetricDataSend","bind","spanEventAggregator","event_harvest_config","report_period_ms","limit","harvest_limits","span_event_data","transactionNameNormalizer","txSegmentNormalizer","urlNormalizer","userNormalizer","loadFromConfig","transactionEventAggregator","analytic_event_data","customEventAggregator","custom_event_data","errorTraceAggregator","errorEventAggregator","error_event_data","errors","tracer","traces","isAsync","method","transactionSampler","agent","serverless","period","sampling_target_period_in_seconds","target","sampling_target","queries","_listenForConfigChanges","totalActiveSegments","segmentsCreatedInHarvest","segmentsClearedInHarvest","activeTransactions","_transactionFinished","inherits","prototype","start","callback","TypeError","setState","agent_enabled","warn","process","nextTick","_serverlessModeStart","license_key","error","stop","onNextTick","info","connect","onStartConnect","response","shouldShutdownRun","payload","isConnected","onConnect","no_immediate_harvest","startAggregators","setTimeout","afterTimeout","forceHarvestAll","afterAllAggregatorsSend","promises","metricPromise","Promise","resolve","once","onMetricsFinished","send","push","distributed_tracing","span_events","spanPromise","onSpansFinished","custom_insights_events","customEventPromise","onCustomEventsFinished","transaction_events","transactionEventPromise","onTransactionEventsFinished","transaction_tracer","collect_traces","transactionTracePromise","onTracesFinished","slow_sql","sqlTracePromise","onSqlTracesFinished","errorCollectorEnabled","error_collector","collect_errors","errorTracePromise","traceAggregator","onErrorTracesFinished","capture_events","errorEventPromise","eventAggregator","onErrorEventsFinished","all","then","setImmediate","stopAggregators","reconfigure","shutdown","onShutdown","trace","_resetQueries","resetQueries","clear","_resetErrors","resetErrors","clearAll","_resetEvents","resetEvents","_resetCustomEvents","resetCustomEvents","harvestSync","emit","flushPayloadSync","_generateEntityStatsAndClear","createMetrics","_generateHarvestMetrics","traceEnabled","segmentTotal","harvestCreated","harvestCleared","configuration","newState","hasOwnProperty","canCollectData","_enabledChange","nop","_configChange","reportSettings","_addIntrinsicAttrsFromTransaction","transaction","intrinsicAttributes","webDuration","timer","getDurationInMillis","timestamp","name","getFullName","duration","totalTime","getTotalTimeDurationInMillis","type","hasErrors","metric","getMetric","QUEUETIME","queueDuration","total","EXTERNAL","ALL","externalDuration","externalCallCount","callCount","DB","databaseDuration","databaseCallCount","addDistributedTraceIntrinsics","parentSpanId","parentId","cross_application_tracer","invalidIncomingExternalTransaction","referringTransactionGuid","includesOutboundRequests","id","tripId","calculatePathHash","applications","referringPathHash","refId","alternatePathHashes","baseSegment","apdex","web_transactions_apdex","calculateApdexZone","syntheticsData","resourceId","jobId","monitorId","_addEventFromTransaction","tx","userAttributes","custom","get","TRANS_EVENT","agentAttributes","attributes","event","add","priority","Math","random","forceIgnore","ignore","debug","merge","onTransactionFinished","intrinsics","getIntrinsicAttributes","numSegments","setLambdaArn","arn","getTransaction","recordSupportability","value","getOrCreateMetric","SUPPORTABILITY","PREFIX","recordValue","incrementCallCount","self","updateMetricNameNormalizer","load","apply","arguments","updateTransactionNameNormalizer","updateUrlNormalizer","updateSegmentNormalizer","updateSamplingTarget","samplingTarget","updateSamplePeriod","samplingPeriod","onHarvestConfigReceived","harvestConfig","generateEventHarvestSupportMetrics","harvestLimits","harvestNames","EVENT_HARVEST","harvestLimitNames","HARVEST_LIMIT","reportPeriodMetric","REPORT_PERIOD","analyticLimit","analyticLimitMetric","ANALYTIC","customLimit","customLimitMetric","CUSTOM","errorLimit","errorLimitMetric","ERROR","spanLimit","spanLimitMetric","SPAN","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst AdaptiveSampler = require('./adaptive-sampler')\nconst CollectorAPI = require('./collector/api')\nconst ServerlessCollector = require('./collector/serverless')\nconst DESTINATIONS = require('./config/attribute-filter').DESTINATIONS\nconst CustomEventAggregator = require('./custom-events/custom-event-aggregator')\nconst ErrorCollector = require('./errors/error-collector')\nconst ErrorTraceAggregator = require('./errors/error-trace-aggregator')\nconst ErrorEventAggregator = require('./errors/error-event-aggregator')\nconst EventEmitter = require('events').EventEmitter\nconst hashes = require('./util/hashes')\nconst logger = require('./logger')\nconst MetricMapper = require('./metrics/mapper')\nconst MetricNormalizer = require('./metrics/normalizer')\nconst MetricAggregator = require('./metrics/metric-aggregator')\nconst NAMES = require('./metrics/names')\nconst QueryTraceAggregator = require('./db/query-trace-aggregator')\nconst sampler = require('./sampler')\nconst TransactionTraceAggregator = require('./transaction/trace/aggregator')\nconst SpanEventAggregator = require('./spans/span-event-aggregator')\nconst TransactionEventAggregator = require('./transaction/transaction-event-aggregator')\nconst Tracer = require('./transaction/tracer')\nconst TxSegmentNormalizer = require('./metrics/normalizer/tx_segment')\nconst uninstrumented = require('./uninstrumented')\nconst util = require('util')\n\n// Map of valid states to whether or not data collection is valid\nconst STATES = {\n  stopped: false,\n  starting: true,\n  connecting: true,\n  connected: true,\n  started: true,\n  disconnected: false,\n  stopping: false,\n  errored: false\n}\n\nconst MAX_ERROR_TRACES_DEFAULT = 20\nconst INITIAL_HARVEST_DELAY_MS = 1000\nconst DEFAULT_HARVEST_INTERVAL_MS = 60000\n\n/**\n * There's a lot of stuff in this constructor, due to Agent acting as the\n * orchestrator for New Relic within instrumented applications.\n *\n * This constructor can throw if, for some reason, the configuration isn't\n * available. Don't try to recover here, because without configuration the\n * agent can't be brought up to a useful state.\n */\nfunction Agent(config) {\n  EventEmitter.call(this)\n\n  if (!config) throw new Error('Agent must be created with a configuration!')\n\n  // The agent base attributes which last throughout its lifetime.\n  this._state = 'stopped'\n  this.config = config\n  this.environment = require('./environment')\n  this.version = this.config.version\n\n  if (config.serverless_mode.enabled) {\n    this.collector = new ServerlessCollector(this)\n  } else {\n    this.collector = new CollectorAPI(this)\n  }\n\n  this.mapper = new MetricMapper()\n  this.metricNameNormalizer = new MetricNormalizer(this.config, 'metric name')\n\n  this.metrics = new MetricAggregator(\n    {\n      periodMs: DEFAULT_HARVEST_INTERVAL_MS,\n      apdexT: this.config.apdex_t,\n      mapper: this.mapper,\n      normalizer: this.metricNameNormalizer\n    },\n    this.collector\n  )\n\n  this.metrics.on(\n    'starting metric_data data send.',\n    this._beforeMetricDataSend.bind(this)\n  )\n\n  // Open tracing.\n  this.spanEventAggregator = new SpanEventAggregator({\n    periodMs: config.event_harvest_config.report_period_ms,\n    limit: config.event_harvest_config.harvest_limits.span_event_data\n  },\n  this.collector,\n  this.metrics)\n\n  this.transactionNameNormalizer = new MetricNormalizer(this.config, 'transaction name')\n  // Segment term based tx renaming for MGI mitigation.\n  this.txSegmentNormalizer = new TxSegmentNormalizer()\n\n  // User naming and ignoring rules.\n  this.urlNormalizer = new MetricNormalizer(this.config, 'URL')\n  this.userNormalizer = new MetricNormalizer(this.config, 'user')\n  this.userNormalizer.loadFromConfig()\n\n  this.transactionEventAggregator = new TransactionEventAggregator(\n    {\n      periodMs: config.event_harvest_config.report_period_ms,\n      limit: config.event_harvest_config.harvest_limits.analytic_event_data\n    },\n    this.collector,\n    this.metrics\n  )\n\n  this.customEventAggregator = new CustomEventAggregator(\n    {\n      periodMs: config.event_harvest_config.report_period_ms,\n      limit: config.event_harvest_config.harvest_limits.custom_event_data\n    },\n    this.collector,\n    this.metrics\n  )\n\n  const errorTraceAggregator = new ErrorTraceAggregator(\n    {\n      periodMs: DEFAULT_HARVEST_INTERVAL_MS,\n      limit: MAX_ERROR_TRACES_DEFAULT\n    },\n    this.collector\n  )\n\n  const errorEventAggregator =  new ErrorEventAggregator(\n    {\n      periodMs: config.event_harvest_config.report_period_ms,\n      limit: config.event_harvest_config.harvest_limits.error_event_data\n    },\n    this.collector,\n    this.metrics\n  )\n\n  this.errors = new ErrorCollector(\n    config,\n    errorTraceAggregator,\n    errorEventAggregator,\n    this.metrics\n  )\n\n  // Transaction tracing.\n  this.tracer = new Tracer(this)\n  this.traces = new TransactionTraceAggregator(\n    {\n      periodMs: DEFAULT_HARVEST_INTERVAL_MS,\n      config: this.config,\n      isAsync: !config.serverless_mode.enabled,\n      method: 'transaction_sample_data'\n    },\n    this.collector\n  )\n  this.transactionSampler = new AdaptiveSampler({\n    agent: this,\n    serverless: config.serverless_mode.enabled,\n    period: config.sampling_target_period_in_seconds * 1000,\n    target: config.sampling_target\n  })\n\n  this.queries = new QueryTraceAggregator(\n    {\n      config: this.config,\n      periodMs: DEFAULT_HARVEST_INTERVAL_MS,\n      method: 'sql_trace_data',\n      isAsync: !config.serverless_mode.enabled\n    },\n    this.collector\n  )\n\n  // Set up all the configuration events the agent needs to listen for.\n  this._listenForConfigChanges()\n\n  // Entity tracking metrics.\n  this.totalActiveSegments = 0\n  this.segmentsCreatedInHarvest = 0\n  this.segmentsClearedInHarvest = 0\n  // Used by shutdown code as well as entity tracking stats\n  this.activeTransactions = 0\n\n  // Finally, add listeners for the agent's own events.\n  this.on('transactionFinished', this._transactionFinished.bind(this))\n}\nutil.inherits(Agent, EventEmitter)\n\n/**\n * The agent is meant to only exist once per application, but the singleton is\n * managed by index.js. An agent will be created even if the agent's disabled by\n * the configuration.\n *\n * @config {boolean} agent_enabled Whether to start up the agent.\n *\n * @param {Function} callback Continuation and error handler.\n */\nAgent.prototype.start = function start(callback) {\n  if (!callback) throw new TypeError('callback required!')\n\n  const agent = this\n\n  this.setState('starting')\n\n  if (this.config.agent_enabled !== true) {\n    logger.warn('The New Relic Node.js agent is disabled by its configuration. ' +\n                'Not starting!')\n\n    this.setState('stopped')\n    return process.nextTick(callback)\n  }\n\n  sampler.start(agent)\n\n  if (this.config.serverless_mode.enabled) {\n    return this._serverlessModeStart(callback)\n  }\n\n  if (!this.config.license_key) {\n    logger.error('A valid account license key cannot be found. ' +\n                 'Has a license key been specified in the agent configuration ' +\n                 'file or via the NEW_RELIC_LICENSE_KEY environment variable?')\n\n    this.setState('errored')\n    sampler.stop()\n    return process.nextTick(function onNextTick() {\n      callback(new Error('Not starting without license key!'))\n    })\n  }\n  logger.info('Starting New Relic for Node.js connection process.')\n\n  this.collector.connect(function onStartConnect(error, response) {\n    if (error || response.shouldShutdownRun()) {\n      agent.setState('errored')\n      sampler.stop()\n      callback(\n        error || new Error('Failed to connect to collector'),\n        response && response.payload\n      )\n      return\n    }\n\n    if (agent.collector.isConnected()) {\n      agent.onConnect()\n      agent.setState('started')\n      const config = response.payload\n\n      if (agent.config.no_immediate_harvest) {\n        agent.startAggregators()\n        callback(null, config)\n      } else {\n        // Harvest immediately for quicker data display, but after at least 1\n        // second or the collector will throw away the data.\n        //\n        // NOTE: this setTimeout is deliberately NOT unref'd due to it being\n        // the last step in the Agent startup process\n        setTimeout(function afterTimeout() {\n          logger.info(`Starting initial ${INITIAL_HARVEST_DELAY_MS}ms harvest.`)\n\n          agent.forceHarvestAll(function afterAllAggregatorsSend() {\n            agent.startAggregators()\n            callback(null, config)\n          })\n        }, INITIAL_HARVEST_DELAY_MS)\n      }\n    } else {\n      callback(new Error('Collector did not connect and did not error'))\n    }\n  })\n}\n\n/**\n * Forces all aggregators to send the data collected.\n * @param {Function} callback The callback to invoke when all data types have been sent.\n */\nAgent.prototype.forceHarvestAll = function forceHarvestAll(callback) {\n  const agent = this\n  const promises = []\n\n  const metricPromise = new Promise((resolve) => {\n    agent.metrics.once(\n      'finished metric_data data send.',\n      function onMetricsFinished() {\n        resolve()\n      }\n    )\n    agent.metrics.send()\n  })\n\n  promises.push(metricPromise)\n\n  // TODO: plumb config through to aggregators so they can do their own checking.\n  if (agent.config.distributed_tracing.enabled &&\n      agent.config.span_events.enabled) {\n    const spanPromise = new Promise((resolve) => {\n      agent.spanEventAggregator.once(\n        'finished span_event_data data send.',\n        function onSpansFinished() {\n          resolve()\n        }\n      )\n      agent.spanEventAggregator.send()\n    })\n\n    promises.push(spanPromise)\n  }\n\n  if (agent.config.custom_insights_events.enabled) {\n    const customEventPromise = new Promise((resolve) => {\n      agent.customEventAggregator.once(\n        'finished custom_event_data data send.',\n        function onCustomEventsFinished() {\n          resolve()\n        }\n      )\n      agent.customEventAggregator.send()\n    })\n\n    promises.push(customEventPromise)\n  }\n\n  if (agent.config.transaction_events.enabled) {\n    const transactionEventPromise = new Promise((resolve) => {\n      agent.transactionEventAggregator.once(\n        'finished analytic_event_data data send.',\n        function onTransactionEventsFinished() {\n          resolve()\n        }\n      )\n      agent.transactionEventAggregator.send()\n    })\n\n    promises.push(transactionEventPromise)\n  }\n\n  if (agent.config.transaction_tracer.enabled && agent.config.collect_traces) {\n    const transactionTracePromise = new Promise((resolve) => {\n      agent.traces.once(\n        'finished transaction_sample_data data send.',\n        function onTracesFinished() {\n          resolve()\n        }\n      )\n      agent.traces.send()\n    })\n\n    promises.push(transactionTracePromise)\n  }\n\n  if (agent.config.slow_sql.enabled) {\n    const sqlTracePromise = new Promise((resolve) => {\n      agent.queries.once(\n        'finished sql_trace_data data send.',\n        function onSqlTracesFinished() {\n          resolve()\n        }\n      )\n      agent.queries.send()\n    })\n\n    promises.push(sqlTracePromise)\n  }\n\n  const errorCollectorEnabled =\n    agent.config.error_collector && agent.config.error_collector.enabled\n\n  if (errorCollectorEnabled && agent.config.collect_errors) {\n    const errorTracePromise = new Promise((resolve) => {\n      agent.errors.traceAggregator.once(\n        'finished error_data data send.',\n        function onErrorTracesFinished() {\n          resolve()\n        }\n      )\n      agent.errors.traceAggregator.send()\n    })\n\n    promises.push(errorTracePromise)\n  }\n\n  if (errorCollectorEnabled && agent.config.error_collector.capture_events) {\n    const errorEventPromise = new Promise((resolve) => {\n      agent.errors.eventAggregator.once(\n        'finished error_event_data data send.',\n        function onErrorEventsFinished() {\n          resolve()\n        }\n      )\n      agent.errors.eventAggregator.send()\n    })\n\n    promises.push(errorEventPromise)\n  }\n\n  Promise.all(promises).then(() => {\n    // Get out of the promise so callback errors aren't treated as\n    // promise rejections.\n    setImmediate(callback)\n  })\n}\n\nAgent.prototype.stopAggregators = function stopAggregators() {\n  this.metrics.stop()\n  this.errors.stop()\n  this.traces.stop()\n  this.queries.stop()\n  this.spanEventAggregator.stop()\n  this.transactionEventAggregator.stop()\n  this.customEventAggregator.stop()\n}\n\nAgent.prototype.startAggregators = function startAggregators() {\n  this.metrics.start()\n  this.errors.start()\n  if (this.config.transaction_tracer.enabled && this.config.collect_traces) {\n    this.traces.start()\n  }\n\n  if (this.config.slow_sql.enabled) {\n    this.queries.start()\n  }\n\n  if (this.config.distributed_tracing.enabled &&\n      this.config.span_events.enabled) {\n    this.spanEventAggregator.start()\n  }\n\n  if (this.config.transaction_events.enabled) {\n    this.transactionEventAggregator.start()\n  }\n\n  if (this.config.custom_insights_events.enabled) {\n    this.customEventAggregator.start()\n  }\n}\n\nAgent.prototype.onConnect = function onConnect() {\n  this.metrics.reconfigure(this.config)\n  this.errors.reconfigure(this.config)\n  this.traces.reconfigure(this.config)\n  this.queries.reconfigure(this.config)\n  this.spanEventAggregator.reconfigure(this.config)\n  this.transactionEventAggregator.reconfigure(this.config)\n  this.customEventAggregator.reconfigure(this.config)\n}\n\n/**\n *  Bypasses standard collector connection by immediately invoking the startup\n *  callback, after gathering local environment details.\n *\n * @param {Function} callback\n */\nAgent.prototype._serverlessModeStart = function _serverlessModeStart(callback) {\n  logger.info(\n    'New Relic for Node.js starting in serverless mode -- skipping connection process.'\n  )\n\n  setImmediate(() => callback(null, this.config))\n}\n\n/**\n * Any memory claimed by the agent will be retained after stopping.\n *\n * FIXME: make it possible to dispose of the agent, as well as do a\n * \"hard\" restart. This requires working with shimmer to strip the\n * current instrumentation and patch to the module loader.\n */\nAgent.prototype.stop = function stop(callback) {\n  if (!callback) throw new TypeError('callback required!')\n\n  const agent = this\n\n  this.setState('stopping')\n\n  this.stopAggregators()\n\n  sampler.stop()\n\n  if (this.collector.isConnected()) {\n    this.collector.shutdown(function onShutdown(error) {\n      if (error) {\n        agent.setState('errored')\n        logger.warn(error, 'Got error shutting down connection to New Relic:')\n      } else {\n        agent.setState('stopped')\n        logger.info('Stopped New Relic for Node.js.')\n      }\n\n      callback(error)\n    })\n  } else {\n    logger.trace('Collector was not connected, invoking callback.')\n\n    process.nextTick(callback)\n  }\n}\n\n/**\n * Resets queries.\n */\nAgent.prototype._resetQueries = function resetQueries() {\n  this.queries.clear()\n}\n\nAgent.prototype._resetErrors = function resetErrors() {\n  this.errors.clearAll()\n\n  // TODO: is this still necessary?\n  // Likely do more direct with new config\n  this.errors.reconfigure(this.config)\n}\n\n/**\n * Resets events.\n */\nAgent.prototype._resetEvents = function resetEvents() {\n  this.transactionEventAggregator.clear()\n}\n\n/**\n * Resets custom events.\n *\n * @param {boolean} forceReset\n *   Flag signalling unconditional reset, sent during LASP application.\n */\nAgent.prototype._resetCustomEvents = function resetCustomEvents() {\n  this.customEventAggregator.clear()\n}\n\n/**\n * This method invokes a harvest synchronously.\n *\n * NOTE: this doesn't currently work outside of serverless mode.\n */\nAgent.prototype.harvestSync = function harvestSync() {\n  logger.trace('Peparing to harvest.')\n\n  if (!this.collector.isConnected()) {\n    throw new Error('Sync harvest not connected/enabled!')\n  }\n\n  // We have a connection, create a new harvest.\n  this.emit('harvestStarted')\n  logger.info('Harvest started.')\n\n  const collector = this.collector\n  const agent = this\n\n  // \"Sends\" data to the serverless collector collection\n  this.metrics.send()\n  this.errors.traceAggregator.send()\n  this.errors.eventAggregator.send()\n  this.traces.send()\n  this.queries.send()\n  this.spanEventAggregator.send()\n  this.transactionEventAggregator.send()\n  this.customEventAggregator.send()\n\n  // Write serverless output\n  collector.flushPayloadSync()\n\n  agent.emit('harvestFinished')\n  logger.info('Harvest finished.')\n}\n\nAgent.prototype._beforeMetricDataSend = function _beforeMetricDataSend() {\n  this._generateEntityStatsAndClear()\n\n  // Send uninstrumented supportability metrics every metric harvest cycle\n  uninstrumented.createMetrics(this.metrics)\n}\n\nAgent.prototype._generateEntityStatsAndClear = function _generateHarvestMetrics() {\n  // Note some information about the size of this harvest.\n  if (logger.traceEnabled()) {\n    logger.trace({\n      segmentTotal: this.totalActiveSegments,\n      harvestCreated: this.segmentsCreatedInHarvest,\n      harvestCleared: this.segmentsClearedInHarvest,\n      activeTransactions: this.activeTransactions\n    }, 'Entity stats on metric harvest')\n  }\n\n  // Reset the counters.\n  this.segmentsCreatedInHarvest = 0\n  this.segmentsClearedInHarvest = 0\n}\n\n/**\n * Public interface for passing configuration data from the collector\n * on to the configuration, in an effort to keep them at least somewhat\n * decoupled.\n *\n * @param {object} configuration New config JSON from the collector.\n */\nAgent.prototype.reconfigure = function reconfigure(configuration) {\n  if (!configuration) throw new TypeError('must pass configuration')\n\n  this.config.onConnect(configuration)\n}\n\n/**\n * Set the current state of the agent. Some states will not allow the\n * creation of Transactions.\n *\n * @param {string} newState The new state of the agent.\n */\nAgent.prototype.setState = function setState(newState) {\n  if (!STATES.hasOwnProperty(newState)) {\n    throw new TypeError('Invalid state ' + newState)\n  }\n\n  logger.info('Agent state changed from %s to %s.', this._state, newState)\n  this._state = newState\n  this.emit(this._state)\n}\n\n/**\n * Return true if the agent is in a run state that can collect and\n * process data.\n */\nAgent.prototype.canCollectData = function canCollectData() {\n  return STATES[this._state]\n}\n\n/**\n * `agent_enabled` changed. This will generally only happen because of a high\n * security mode mismatch between the agent and the collector. This only\n * expects to have to stop the agent. No provisions have been made, nor\n * testing have been done to make sure it is safe to start the agent back up.\n */\nAgent.prototype._enabledChange = function _enabledChange() {\n  if (this.config.agent_enabled === false) {\n    logger.warn('agent_enabled has been changed to false, stopping the agent.')\n    this.stop(function nop() {})\n  }\n}\n\n/**\n * Report new settings to collector after a configuration has changed. This\n * always occurs after handling a response from a connect call.\n */\nAgent.prototype._configChange = function _configChange() {\n  this.collector.reportSettings()\n}\n\nAgent.prototype._addIntrinsicAttrsFromTransaction = _addIntrinsicAttrsFromTransaction\n\nfunction _addIntrinsicAttrsFromTransaction(transaction) {\n  const intrinsicAttributes = {\n    webDuration: transaction.timer.getDurationInMillis() / 1000,\n    timestamp: transaction.timer.start,\n    name: transaction.getFullName(),\n    duration: transaction.timer.getDurationInMillis() / 1000,\n    totalTime: transaction.trace.getTotalTimeDurationInMillis() / 1000,\n    type: 'Transaction',\n    error: transaction.hasErrors()\n  }\n\n  let metric = transaction.metrics.getMetric(NAMES.QUEUETIME)\n  if (metric) {\n    intrinsicAttributes.queueDuration = metric.total\n  }\n\n  metric = transaction.metrics.getMetric(NAMES.EXTERNAL.ALL)\n  if (metric) {\n    intrinsicAttributes.externalDuration = metric.total\n    intrinsicAttributes.externalCallCount = metric.callCount\n  }\n\n  metric = transaction.metrics.getMetric(NAMES.DB.ALL)\n  if (metric) {\n    intrinsicAttributes.databaseDuration = metric.total\n    intrinsicAttributes.databaseCallCount = metric.callCount\n  }\n\n  if (this.config.distributed_tracing.enabled) {\n    transaction.addDistributedTraceIntrinsics(intrinsicAttributes)\n    if (transaction.parentSpanId) {\n      intrinsicAttributes.parentSpanId = transaction.parentSpanId\n    }\n\n    if (transaction.parentId) {\n      intrinsicAttributes.parentId = transaction.parentId\n    }\n  } else if (\n    this.config.cross_application_tracer.enabled &&\n    !transaction.invalidIncomingExternalTransaction && (\n      transaction.referringTransactionGuid ||\n      transaction.includesOutboundRequests()\n    )\n  ) {\n    intrinsicAttributes['nr.guid'] = transaction.id\n    intrinsicAttributes['nr.tripId'] = transaction.tripId || transaction.id\n    intrinsicAttributes['nr.pathHash'] = hashes.calculatePathHash(\n      this.config.applications()[0],\n      transaction.getFullName(),\n      transaction.referringPathHash\n    )\n    if (transaction.referringPathHash) {\n      intrinsicAttributes['nr.referringPathHash'] = transaction.referringPathHash\n    }\n    if (transaction.referringTransactionGuid) {\n      var refId = transaction.referringTransactionGuid\n      intrinsicAttributes['nr.referringTransactionGuid'] = refId\n    }\n    var alternatePathHashes = transaction.alternatePathHashes()\n    if (alternatePathHashes) {\n      intrinsicAttributes['nr.alternatePathHashes'] = alternatePathHashes\n    }\n    if (transaction.baseSegment && transaction.type === 'web') {\n      var apdex = (\n        this.config.web_transactions_apdex[transaction.getFullName()] ||\n        this.config.apdex_t\n      )\n      var duration = transaction.baseSegment.getDurationInMillis() / 1000\n      intrinsicAttributes['nr.apdexPerfZone'] = calculateApdexZone(duration, apdex)\n    }\n  }\n\n  if (transaction.syntheticsData) {\n    intrinsicAttributes['nr.syntheticsResourceId'] = transaction.syntheticsData.resourceId\n    intrinsicAttributes['nr.syntheticsJobId'] = transaction.syntheticsData.jobId\n    intrinsicAttributes['nr.syntheticsMonitorId'] = transaction.syntheticsData.monitorId\n  }\n\n  return intrinsicAttributes\n}\n\nfunction calculateApdexZone(duration, apdexT) {\n  if (duration <= apdexT) {\n    return 'S' // satisfied\n  }\n\n  if (duration <= apdexT * 4) {\n    return 'T' // tolerating\n  }\n\n  return 'F' // frustrated\n}\n\nAgent.prototype._addEventFromTransaction = function _addEventFromTransaction(tx) {\n  if (!this.config.transaction_events.enabled) return\n\n  const intrinsicAttributes = this._addIntrinsicAttrsFromTransaction(tx)\n  const userAttributes = tx.trace.custom.get(DESTINATIONS.TRANS_EVENT)\n  const agentAttributes = tx.trace.attributes.get(DESTINATIONS.TRANS_EVENT)\n\n  const event = [\n    intrinsicAttributes,\n    userAttributes,\n    agentAttributes\n  ]\n\n  this.transactionEventAggregator.add(event, tx.priority || Math.random())\n}\n\n/**\n * Put all the logic for handing finalized transactions off to the tracers and\n * metric collections in one place.\n *\n * @param {Transaction} transaction Newly-finalized transaction.\n */\nAgent.prototype._transactionFinished = function _transactionFinished(transaction) {\n  // Allow the API to explicitly set the ignored status.\n  if (transaction.forceIgnore !== null) {\n    transaction.ignore = transaction.forceIgnore\n  }\n\n  if (!transaction.ignore) {\n    if (transaction.forceIgnore === false) {\n      logger.debug('Explicitly not ignoring %s (%s).', transaction.name, transaction.id)\n    }\n    this.metrics.merge(transaction.metrics, false)\n\n    this.errors.onTransactionFinished(transaction)\n\n    this.traces.add(transaction)\n\n    const trace = transaction.trace\n    trace.intrinsics = transaction.getIntrinsicAttributes()\n\n    this._addEventFromTransaction(transaction)\n  } else if (transaction.forceIgnore === true) {\n    logger.debug('Explicitly ignoring %s (%s).', transaction.name, transaction.id)\n  } else {\n    logger.debug('Ignoring %s (%s).', transaction.name, transaction.id)\n  }\n\n  --this.activeTransactions\n  this.totalActiveSegments -= transaction.numSegments\n  this.segmentsClearedInHarvest += transaction.numSegments\n}\n\nAgent.prototype.setLambdaArn = function setLambdaArn(arn) {\n  if (this.collector instanceof ServerlessCollector) {\n    this.collector.setLambdaArn(arn)\n  }\n}\n\n/**\n * Get the current transaction (if there is one) from the tracer.\n *\n * @returns {Transaction} The current transaction.\n */\nAgent.prototype.getTransaction = function getTransaction() {\n  return this.tracer.getTransaction()\n}\n\nAgent.prototype.recordSupportability = function recordSupportability(name, value) {\n  const metric = this.metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.PREFIX + name)\n  if (value != null) {\n    metric.recordValue(value)\n  } else {\n    metric.incrementCallCount()\n  }\n}\n\nAgent.prototype._listenForConfigChanges = function _listenForConfigChanges() {\n  const self = this\n  this.config.on('agent_enabled', this._enabledChange.bind(this))\n  this.config.on('change', this._configChange.bind(this))\n  this.config.on('metric_name_rules', function updateMetricNameNormalizer() {\n    self.metricNameNormalizer.load.apply(self.metricNameNormalizer, arguments)\n  })\n  this.config.on('transaction_name_rules', function updateTransactionNameNormalizer() {\n    self.transactionNameNormalizer.load.apply(self.transactionNameNormalizer, arguments)\n  })\n  this.config.on('url_rules', function updateUrlNormalizer() {\n    self.urlNormalizer.load.apply(self.urlNormalizer, arguments)\n  })\n  this.config.on('transaction_segment_terms', function updateSegmentNormalizer() {\n    self.txSegmentNormalizer.load.apply(self.txSegmentNormalizer, arguments)\n  })\n  this.config.on('sampling_target', function updateSamplingTarget(target) {\n    self.transactionSampler.samplingTarget = target\n  })\n  this.config.on(\n    'sampling_target_period_in_seconds',\n    function updateSamplePeriod(period) {\n      self.transactionSampler.samplingPeriod = period * 1000\n    }\n  )\n  this.config.on('event_harvest_config', function onHarvestConfigReceived(harvestConfig) {\n    if (harvestConfig) {\n      generateEventHarvestSupportMetrics(self, harvestConfig)\n    }\n  })\n}\n\nfunction generateEventHarvestSupportMetrics(agent, harvestConfig) {\n  const harvestLimits = harvestConfig.harvest_limits\n\n  const harvestNames = NAMES.EVENT_HARVEST\n  const harvestLimitNames = harvestNames.HARVEST_LIMIT\n\n  const reportPeriodMetric = agent.metrics.getOrCreateMetric(harvestNames.REPORT_PERIOD)\n  reportPeriodMetric.recordValue(harvestConfig.report_period_ms)\n\n  const analyticLimit = harvestLimits.analytic_event_data\n  if (analyticLimit) {\n    const analyticLimitMetric = agent.metrics.getOrCreateMetric(\n      harvestLimitNames.ANALYTIC\n    )\n    analyticLimitMetric.recordValue(analyticLimit)\n  }\n\n  const customLimit = harvestLimits.custom_event_data\n  if (customLimit) {\n    const customLimitMetric = agent.metrics.getOrCreateMetric(harvestLimitNames.CUSTOM)\n    customLimitMetric.recordValue(customLimit)\n  }\n\n  const errorLimit = harvestLimits.error_event_data\n  if (errorLimit) {\n    const errorLimitMetric = agent.metrics.getOrCreateMetric(harvestLimitNames.ERROR)\n    errorLimitMetric.recordValue(errorLimit)\n  }\n\n  const spanLimit = harvestLimits.span_event_data\n  if (spanLimit) {\n    const spanLimitMetric = agent.metrics.getOrCreateMetric(harvestLimitNames.SPAN)\n    spanLimitMetric.recordValue(spanLimit)\n  }\n}\n\nmodule.exports = Agent\n"]},"metadata":{},"sourceType":"script"}