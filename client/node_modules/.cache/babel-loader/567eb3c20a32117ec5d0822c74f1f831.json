{"ast":null,"code":"'use strict';\n/*\n *\n * CONSTANTS\n *\n */\n\nvar BYTES_PER_MB = 1024 * 1024;\nvar FROM_MILLIS = 1e-3;\n/**\n * Simple container for tracking running statistics for a metric.\n */\n\nfunction Stats() {\n  this.total = 0;\n  this.totalExclusive = 0;\n  this.min = 0;\n  this.max = 0;\n  this.sumOfSquares = 0;\n  this.callCount = 0;\n}\n/**\n * Update the summary statistics with a new value.\n *\n * @param {Number} totalTime Time, in seconds, of the measurement.\n * @param {Number} exclusiveTime Time that was taken by only the\n *                               current measurement (optional).\n */\n\n\nStats.prototype.recordValue = function recordValue(totalTime, exclusiveTime) {\n  // even if a caller messes up, don't break everything else\n  if (totalTime !== 0 && !totalTime) totalTime = 0;\n  if (exclusiveTime !== 0 && !exclusiveTime) exclusiveTime = totalTime;\n\n  if (this.callCount > 0) {\n    this.min = Math.min(totalTime, this.min);\n  } else {\n    this.min = totalTime;\n  }\n\n  this.max = Math.max(totalTime, this.max);\n  this.sumOfSquares += totalTime * totalTime;\n  ++this.callCount;\n  this.total += totalTime;\n  this.totalExclusive += exclusiveTime;\n};\n/**\n * Until the collector accepts statistics in milliseconds, this code is going\n * to have some hinky floating-point values to deal with.\n */\n\n\nStats.prototype.recordValueInMillis = recordValueInMillis;\n\nfunction recordValueInMillis(totalTime, exclusiveTime) {\n  this.recordValue(totalTime * FROM_MILLIS, exclusiveTime >= 0 ? exclusiveTime * FROM_MILLIS : null);\n}\n/**\n * Really?\n *\n * FIXME: Really?\n */\n\n\nStats.prototype.recordValueInBytes = function recordValueInBytes(bytes, exclusiveBytes) {\n  exclusiveBytes = exclusiveBytes || bytes;\n  this.recordValue(bytes / BYTES_PER_MB, exclusiveBytes / BYTES_PER_MB);\n};\n\nStats.prototype.incrementCallCount = function incrementCallCount(count) {\n  if (typeof count === 'undefined') count = 1;\n  this.callCount += count;\n};\n/**\n * Fold another summary's statistics into this one.\n */\n\n\nStats.prototype.merge = function merge(other) {\n  if (other.count && !other.callCount) {\n    other.callCount = other.count;\n  }\n\n  if (other.totalExclusive == null) {\n    other.totalExclusive = other.total;\n  }\n\n  if (other.callCount > 0) {\n    if (this.callCount > 0) {\n      this.min = Math.min(this.min, other.min);\n    } else {\n      this.min = other.min;\n    }\n  }\n\n  this.max = Math.max(this.max, other.max);\n  this.total += other.total;\n  this.totalExclusive += other.totalExclusive;\n  this.sumOfSquares += other.sumOfSquares;\n  this.callCount += other.callCount;\n};\n/**\n * The serializer relies upon this representation, so don't change the\n * values, cardinality, or ordering of this array without ensuring that\n * it matches the version of the \"protocol\" being sent to the collector.\n *\n * @returns {Array} Number of calls,\n *                  total time in seconds,\n *                  time for this metric alone in seconds,\n *                  shortest individual time in seconds,\n *                  longest individual time in seconds,\n *                  running sum of squares.\n */\n\n\nStats.prototype.toJSON = function toJSON() {\n  return [this.callCount, this.total, this.totalExclusive, this.min, this.max, this.sumOfSquares];\n};\n\nmodule.exports = Stats;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/stats/index.js"],"names":["BYTES_PER_MB","FROM_MILLIS","Stats","total","totalExclusive","min","max","sumOfSquares","callCount","prototype","recordValue","totalTime","exclusiveTime","Math","recordValueInMillis","recordValueInBytes","bytes","exclusiveBytes","incrementCallCount","count","merge","other","toJSON","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n/*\n *\n * CONSTANTS\n *\n */\nvar BYTES_PER_MB = 1024 * 1024\nvar FROM_MILLIS = 1e-3\n\n\n/**\n * Simple container for tracking running statistics for a metric.\n */\nfunction Stats() {\n  this.total = 0\n  this.totalExclusive = 0\n  this.min = 0\n  this.max = 0\n  this.sumOfSquares = 0\n  this.callCount = 0\n}\n\n/**\n * Update the summary statistics with a new value.\n *\n * @param {Number} totalTime Time, in seconds, of the measurement.\n * @param {Number} exclusiveTime Time that was taken by only the\n *                               current measurement (optional).\n */\nStats.prototype.recordValue = function recordValue(totalTime, exclusiveTime) {\n  // even if a caller messes up, don't break everything else\n  if (totalTime !== 0 && !totalTime) totalTime = 0\n  if (exclusiveTime !== 0 && !exclusiveTime) exclusiveTime = totalTime\n\n  if (this.callCount > 0) {\n    this.min = Math.min(totalTime, this.min)\n  } else {\n    this.min = totalTime\n  }\n  this.max = Math.max(totalTime, this.max)\n\n  this.sumOfSquares += (totalTime * totalTime)\n  ++this.callCount\n  this.total += totalTime\n  this.totalExclusive += exclusiveTime\n}\n\n/**\n * Until the collector accepts statistics in milliseconds, this code is going\n * to have some hinky floating-point values to deal with.\n */\nStats.prototype.recordValueInMillis = recordValueInMillis\nfunction recordValueInMillis(totalTime, exclusiveTime) {\n  this.recordValue(\n    totalTime * FROM_MILLIS,\n    exclusiveTime >= 0 ? exclusiveTime * FROM_MILLIS : null\n  )\n}\n\n/**\n * Really?\n *\n * FIXME: Really?\n */\nStats.prototype.recordValueInBytes = function recordValueInBytes(bytes, exclusiveBytes) {\n  exclusiveBytes = exclusiveBytes || bytes\n  this.recordValue(bytes / BYTES_PER_MB, exclusiveBytes / BYTES_PER_MB)\n}\n\nStats.prototype.incrementCallCount = function incrementCallCount(count) {\n  if (typeof count === 'undefined') count = 1\n  this.callCount += count\n}\n\n/**\n * Fold another summary's statistics into this one.\n */\nStats.prototype.merge = function merge(other) {\n  if (other.count && !other.callCount) {\n    other.callCount = other.count\n  }\n\n  if (other.totalExclusive == null) {\n    other.totalExclusive = other.total\n  }\n\n  if (other.callCount > 0) {\n    if (this.callCount > 0) {\n      this.min = Math.min(this.min, other.min)\n    } else {\n      this.min = other.min\n    }\n  }\n  this.max = Math.max(this.max, other.max)\n\n  this.total += other.total\n  this.totalExclusive += other.totalExclusive\n  this.sumOfSquares += other.sumOfSquares\n  this.callCount += other.callCount\n}\n\n/**\n * The serializer relies upon this representation, so don't change the\n * values, cardinality, or ordering of this array without ensuring that\n * it matches the version of the \"protocol\" being sent to the collector.\n *\n * @returns {Array} Number of calls,\n *                  total time in seconds,\n *                  time for this metric alone in seconds,\n *                  shortest individual time in seconds,\n *                  longest individual time in seconds,\n *                  running sum of squares.\n */\nStats.prototype.toJSON = function toJSON() {\n  return [\n    this.callCount,\n    this.total,\n    this.totalExclusive,\n    this.min,\n    this.max,\n    this.sumOfSquares\n  ]\n}\n\nmodule.exports = Stats\n"]},"metadata":{},"sourceType":"script"}