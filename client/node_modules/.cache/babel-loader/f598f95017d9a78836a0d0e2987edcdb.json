{"ast":null,"code":"'use strict';\n\nvar Transaction = require('../index.js');\n\nvar logger = require('../../logger').child({\n  component: 'tracer'\n});\n/*\n * CONSTANTS\n */\n\n\nvar ORIGINAL = '__NR_original';\nvar SEGMENT = '__NR_segment';\nmodule.exports = Tracer;\n\nfunction Tracer(agent) {\n  if (!agent) throw new Error(\"Must be initialized with an agent.\");\n  this.agent = agent;\n  this._segment = null;\n}\n\nTracer.prototype.getTransaction = getTransaction;\nTracer.prototype.getSegment = getSegment;\nTracer.prototype.createSegment = createSegment;\nTracer.prototype.addSegment = addSegment;\nTracer.prototype.transactionProxy = transactionProxy;\nTracer.prototype.transactionNestProxy = transactionNestProxy;\nTracer.prototype.bindFunction = bindFunction;\nTracer.prototype.bindEmitter = bindEmitter;\nTracer.prototype.getOriginal = getOriginal;\nTracer.prototype.getSegmentFromWrapped = getSegmentFromWrapped;\nTracer.prototype.slice = argSlice;\nTracer.prototype.wrapFunctionNoSegment = wrapFunctionNoSegment;\nTracer.prototype.wrapFunctionFirstNoSegment = wrapFunctionFirstNoSegment;\nTracer.prototype.wrapFunction = wrapFunction;\nTracer.prototype.wrapFunctionLast = wrapFunctionLast;\nTracer.prototype.wrapFunctionFirst = wrapFunctionFirst;\nTracer.prototype.wrapSyncFunction = wrapSyncFunction;\nTracer.prototype.wrapCallback = wrapCallback;\nObject.defineProperty(Tracer.prototype, 'segment', {\n  get: function segmentGetter() {\n    return this._segment;\n  },\n  set: function segmentSetter(segment) {\n    this._segment && this._segment.probe('Segment removed from tracer');\n    segment && segment.probe('Set tracer.segment');\n    return this._segment = segment;\n  }\n});\n\nfunction getTransaction() {\n  if (this.segment && this.segment.transaction && this.segment.transaction.isActive()) {\n    return this.segment.transaction;\n  }\n\n  return null;\n}\n\nfunction getSegment() {\n  return this.segment;\n}\n\nfunction createSegment(name, recorder, _parent) {\n  var parent = _parent || this.segment;\n\n  if (!parent || !parent.transaction.isActive()) {\n    logger.trace({\n      hasParent: !!parent,\n      transactionActive: parent && parent.transaction.isActive()\n    }, 'Not creating segment %s, no parent or active transaction available.', name);\n    return null;\n  }\n\n  return parent.add(name, recorder);\n}\n\nfunction addSegment(name, recorder, parent, full, task) {\n  if (typeof task !== 'function') {\n    throw new Error('task must be a function');\n  }\n\n  var segment = this.createSegment(name, recorder, parent);\n  return this.bindFunction(task, segment, full)(segment);\n}\n\nfunction transactionProxy(handler) {\n  // if there's no handler, there's nothing to proxy.\n  if (typeof handler !== 'function') return handler;\n  var tracer = this;\n\n  var wrapped = function wrapTransactionInvocation() {\n    if (!tracer.agent.canCollectData()) {\n      return handler.apply(this, arguments);\n    } // don't nest transactions, reuse existing ones\n\n\n    var segment = tracer.segment;\n\n    if (segment) {\n      if (segment.transaction.traceStacks) {\n        segment.probe('!!! Nested transaction creation !!!');\n        segment.transaction.traceFlag = true; // Will log the stacks when it ends.\n      }\n\n      logger.warn({\n        transaction: {\n          id: segment.transaction.id,\n          name: segment.transaction.getName()\n        },\n        segment: segment.name\n      }, 'Active transaction when creating non-nested transaction');\n      tracer.agent.recordSupportability('Nodejs/Transactions/Nested');\n      return handler.apply(this, arguments);\n    }\n\n    var transaction = new Transaction(tracer.agent);\n    return tracer.bindFunction(handler, transaction.trace.root, true).apply(this, arguments);\n  };\n\n  wrapped[ORIGINAL] = handler;\n  return wrapped;\n}\n/**\n * Use transactionNestProxy to wrap a closure that is a top-level handler that\n * is meant to start transactions. This wraps the first half of asynchronous\n * handlers. Use bindFunction to wrap handler callbacks. This detects to see\n * if there is an in play segment and uses that as the root instead of\n * transaction.trace.root.\n *\n * @param {Function} handler - Generator to be proxied.\n *\n * @return {Function} Proxy.\n */\n\n\nfunction transactionNestProxy(type, handler) {\n  if (handler === undefined && typeof type === 'function') {\n    handler = type;\n    type = undefined;\n  } // if there's no handler, there's nothing to proxy.\n\n\n  if (typeof handler !== 'function') return handler;\n  var tracer = this;\n\n  var wrapped = function wrapTransactionInvocation() {\n    if (!tracer.agent.canCollectData()) {\n      return handler.apply(this, arguments);\n    } // don't nest transactions, reuse existing ones\n\n\n    var transaction = tracer.getTransaction();\n    var segment = tracer.segment;\n    var createNew = false;\n\n    if (!transaction || transaction.type !== type) {\n      createNew = true;\n    }\n\n    if (createNew) {\n      transaction = new Transaction(tracer.agent);\n      transaction.type = type;\n      segment = transaction.trace.root;\n    }\n\n    return tracer.bindFunction(handler, segment).apply(this, arguments);\n  };\n\n  wrapped[ORIGINAL] = handler;\n  return wrapped;\n}\n\nfunction bindFunction(handler, segment, full) {\n  if (typeof handler !== 'function') {\n    return handler;\n  }\n\n  return _makeWrapped(this, handler, segment || this.segment, !!full);\n}\n\nfunction _makeWrapped(tracer, handler, active, full) {\n  wrapped[ORIGINAL] = getOriginal(handler);\n  wrapped[SEGMENT] = active;\n  return wrapped;\n\n  function wrapped() {\n    var prev = tracer.segment;\n    tracer.segment = active;\n    if (active && full) active.start();\n\n    try {\n      return handler.apply(this, arguments);\n    } catch (err) {\n      logger.trace(err, \"Error from wrapped function:\");\n\n      if (prev === null && process.domain != null) {\n        process.domain.__NR_transactionSegment = tracer.segment;\n      }\n\n      throw err; // Re-throwing application error, this is not an agent error.\n    } finally {\n      if (active && full) active.touch();\n      tracer.segment = prev;\n    }\n  }\n}\n\nfunction getOriginal(fn) {\n  return fn && fn[ORIGINAL] ? fn[ORIGINAL] : fn;\n}\n\nfunction getSegmentFromWrapped(fn) {\n  return fn && fn[SEGMENT] ? fn[SEGMENT] : null;\n}\n\nfunction bindEmitter(emitter, segment) {\n  if (!emitter || !emitter.emit) {\n    return emitter;\n  }\n\n  var emit = getOriginal(emitter.emit);\n  emitter.emit = this.bindFunction(emit, segment);\n  return emitter;\n}\n\nfunction argSlice(args) {\n  /**\n   * Usefully nerfed version of slice for use in instrumentation. Way faster\n   * than using [].slice.call, and maybe putting it in here (instead of the\n   * same module context where it will be used) will make it faster by\n   * defeating inlining.\n   *\n   *   http://jsperf.com/array-slice-call-arguments-2\n   *\n   *  for untrustworthy benchmark numbers. Only useful for copying whole\n   *  arrays, and really only meant to be used with the arguments array like.\n   *\n   *  Also putting this comment inside the function in an effort to defeat\n   *  inlining.\n   *\n   */\n  var length = args.length;\n  var array = new Array(length);\n\n  for (var i = 0; i < length; i++) {\n    array[i] = args[i];\n  }\n\n  return array;\n}\n\nfunction wrapFunctionNoSegment(original, name, wrapper) {\n  if (typeof original !== 'function') return original;\n  logger.trace('Wrapping function %s (no segment)', name || original.name || 'anonymous');\n  var tracer = this;\n  return wrappedFunction;\n\n  function wrappedFunction() {\n    if (!tracer.getTransaction()) return original.apply(this, arguments);\n    var args = tracer.slice(arguments);\n\n    if (wrapper === undefined) {\n      var last = args.length - 1;\n      var cb = args[last];\n\n      if (typeof cb === 'function') {\n        args[last] = tracer.bindFunction(cb);\n      }\n    } else {\n      args = wrapper(args);\n    }\n\n    return original.apply(this, args);\n  }\n}\n\nfunction wrapFunctionFirstNoSegment(original, name) {\n  if (typeof original !== 'function') return original;\n  logger.trace('Wrapping function %s (no segment)', name || original.name || 'anonymous');\n  var tracer = this;\n  return wrappedFunction;\n\n  function wrappedFunction() {\n    if (!tracer.getTransaction()) return original.apply(this, arguments);\n    var args = tracer.slice(arguments);\n    var cb = args[0];\n\n    if (typeof cb === 'function') {\n      args[0] = tracer.bindFunction(cb);\n    }\n\n    return original.apply(this, args);\n  }\n}\n\nfunction wrapFunctionLast(name, recorder, original) {\n  if (typeof original !== 'function') {\n    logger.trace('Not wrapping \"%s\" because it was not a function', name);\n    return original;\n  }\n\n  logger.trace('Wrapping %s as a callback-last function', name);\n  var tracer = this;\n  return wrappedFunction;\n\n  function wrappedFunction() {\n    var transaction = tracer.getTransaction();\n\n    if (!transaction) {\n      logger.trace('Not creating segment \"%s\" because no transaction was active', name);\n      return original.apply(this, arguments);\n    }\n\n    logger.trace('Creating \"%s\" segment for transaction %s.', name, transaction.id);\n    var args = tracer.slice(arguments);\n    var last = args.length - 1;\n    var cb = args[last];\n    if (typeof cb !== 'function') return original.apply(this, arguments);\n    var child = tracer.createSegment(name, recorder);\n    args[last] = tracer.wrapCallback(cb, child, wrappedCallback);\n    child.start();\n    return tracer.bindFunction(original, child).apply(this, args);\n\n    function wrappedCallback() {\n      logger.trace('Ending \"%s\" segment for transaction %s.', name, transaction.id);\n      child.touch();\n      return cb.apply(this, arguments);\n    }\n  }\n}\n\nfunction wrapFunctionFirst(name, recorder, original) {\n  if (typeof original !== 'function') {\n    logger.trace('Not wrapping \"%s\" because it was not a function', name);\n    return original;\n  }\n\n  logger.trace('Wrapping %s as a callback-first function', name);\n  var tracer = this;\n  return wrappedFunction;\n\n  function wrappedFunction() {\n    var transaction = tracer.getTransaction();\n\n    if (!transaction) {\n      logger.trace('Not creating segment \"%s\" because no transaction was active', name);\n      return original.apply(this, arguments);\n    }\n\n    logger.trace('Creating \"%s\" segment for transaction %s.', name, transaction.id);\n    var args = tracer.slice(arguments);\n    var cb = args[0];\n    if (typeof cb !== 'function') return original.apply(this, arguments);\n    var child = tracer.createSegment(name, recorder);\n    args[0] = tracer.wrapCallback(cb, child, wrappedCallback);\n    child.start();\n    return tracer.bindFunction(original, child).apply(this, args);\n\n    function wrappedCallback() {\n      logger.trace('Ending \"%s\" segment for transaction %s.', name, transaction.id);\n      child.touch();\n      var result = cb.apply(this, arguments);\n      return result;\n    }\n  }\n}\n\nfunction wrapFunction(name, recorder, original, wrapper, resp) {\n  if (typeof original !== 'function' || !wrapper) {\n    logger.trace('Not wrapping \"%s\" because it was not a function', name);\n    return original;\n  }\n\n  logger.trace('Wrapping %s using a custom wrapper', name);\n  var tracer = this;\n  return wrappedFunction;\n\n  function wrappedFunction() {\n    var transaction = tracer.getTransaction();\n\n    if (!transaction) {\n      logger.trace('Not creating segment \"%s\" because no transaction was active', name);\n      return original.apply(this, arguments);\n    }\n\n    logger.trace('Creating \"%s\" segment for transaction %s.', name, transaction.id);\n    var child = tracer.createSegment(name, recorder);\n    var args = wrapper.call(this, child, tracer.slice(arguments), bind);\n    child.start();\n    var result = tracer.bindFunction(original, child).apply(this, args);\n    if (resp) result = resp.call(this, child, result, bind);\n    return result;\n\n    function bind(fn) {\n      if (!fn) return fn;\n      return tracer.wrapCallback(fn, child, function nrWrappedHandler() {\n        logger.trace('Touching \"%s\" segment for transaction %s.', name, transaction.id);\n        child.touch();\n        return fn.apply(this, arguments);\n      });\n    }\n  }\n}\n\nfunction wrapSyncFunction(name, recorder, original) {\n  if (typeof original !== 'function') {\n    logger.trace('Not wrapping \"%s\" because it was not a function', name);\n    return original;\n  }\n\n  logger.trace('Wrapping \"%s\" as a synchronous function', name);\n  var tracer = this;\n  return wrappedFunction;\n\n  function wrappedFunction() {\n    var transaction = tracer.getTransaction();\n\n    if (!transaction) {\n      logger.trace('Not creating segment \"%s\" because no transaction was active', name);\n      return original.apply(this, arguments);\n    }\n\n    logger.trace('Creating \"%s\" sync segment for transaction %s.', name, transaction.id);\n    var child = tracer.createSegment(name, recorder);\n    if (child) child.async = false;\n    return tracer.bindFunction(original, child, true).apply(this, arguments);\n  }\n}\n\nfunction wrapCallback(original, segment, wrapped) {\n  var tracer = this;\n  if (typeof original !== 'function') return original;\n  logger.trace('Wrapping callback for \"%s\" segment', segment ? segment.name : 'unknown');\n  return tracer.bindFunction(function wrappedCallback() {\n    if (wrapped) wrapped[ORIGINAL] = original;\n    var child = tracer.createSegment('Callback: ' + (original.name || 'anonymous'), null, segment);\n    if (child) child.async = false;\n    return tracer.bindFunction(wrapped || original, child, true).apply(this, arguments);\n  }, segment, false);\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/transaction/tracer/index.js"],"names":["Transaction","require","logger","child","component","ORIGINAL","SEGMENT","module","exports","Tracer","agent","Error","_segment","prototype","getTransaction","getSegment","createSegment","addSegment","transactionProxy","transactionNestProxy","bindFunction","bindEmitter","getOriginal","getSegmentFromWrapped","slice","argSlice","wrapFunctionNoSegment","wrapFunctionFirstNoSegment","wrapFunction","wrapFunctionLast","wrapFunctionFirst","wrapSyncFunction","wrapCallback","Object","defineProperty","get","segmentGetter","set","segmentSetter","segment","probe","transaction","isActive","name","recorder","_parent","parent","trace","hasParent","transactionActive","add","full","task","handler","tracer","wrapped","wrapTransactionInvocation","canCollectData","apply","arguments","traceStacks","traceFlag","warn","id","getName","recordSupportability","root","type","undefined","createNew","_makeWrapped","active","prev","start","err","process","domain","__NR_transactionSegment","touch","fn","emitter","emit","args","length","array","Array","i","original","wrapper","wrappedFunction","last","cb","wrappedCallback","result","resp","call","bind","nrWrappedHandler","async"],"mappings":"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","sourcesContent":["'use strict'\n\nvar Transaction = require('../index.js')\nvar logger = require('../../logger').child({component: 'tracer'})\n\n/*\n * CONSTANTS\n */\nvar ORIGINAL = '__NR_original'\nvar SEGMENT = '__NR_segment'\n\n\nmodule.exports = Tracer\n\nfunction Tracer(agent) {\n  if (!agent) throw new Error(\"Must be initialized with an agent.\")\n\n  this.agent = agent\n  this._segment = null\n}\n\nTracer.prototype.getTransaction = getTransaction\nTracer.prototype.getSegment = getSegment\nTracer.prototype.createSegment = createSegment\nTracer.prototype.addSegment = addSegment\nTracer.prototype.transactionProxy = transactionProxy\nTracer.prototype.transactionNestProxy = transactionNestProxy\nTracer.prototype.bindFunction = bindFunction\nTracer.prototype.bindEmitter = bindEmitter\nTracer.prototype.getOriginal = getOriginal\nTracer.prototype.getSegmentFromWrapped = getSegmentFromWrapped\nTracer.prototype.slice = argSlice\nTracer.prototype.wrapFunctionNoSegment = wrapFunctionNoSegment\nTracer.prototype.wrapFunctionFirstNoSegment = wrapFunctionFirstNoSegment\nTracer.prototype.wrapFunction = wrapFunction\nTracer.prototype.wrapFunctionLast = wrapFunctionLast\nTracer.prototype.wrapFunctionFirst = wrapFunctionFirst\nTracer.prototype.wrapSyncFunction = wrapSyncFunction\nTracer.prototype.wrapCallback = wrapCallback\n\nObject.defineProperty(Tracer.prototype, 'segment', {\n  get: function segmentGetter() {\n    return this._segment\n  },\n  set: function segmentSetter(segment) {\n    this._segment && this._segment.probe('Segment removed from tracer')\n    segment && segment.probe('Set tracer.segment')\n    return this._segment = segment\n  }\n})\n\nfunction getTransaction() {\n  if (this.segment && this.segment.transaction && this.segment.transaction.isActive()) {\n    return this.segment.transaction\n  }\n\n  return null\n}\n\nfunction getSegment() {\n  return this.segment\n}\n\nfunction createSegment(name, recorder, _parent) {\n  var parent = _parent || this.segment\n  if (!parent || !parent.transaction.isActive()) {\n    logger.trace({\n      hasParent: !!parent,\n      transactionActive: (parent && parent.transaction.isActive())\n    }, 'Not creating segment %s, no parent or active transaction available.', name)\n    return null\n  }\n  return parent.add(name, recorder)\n}\n\nfunction addSegment(name, recorder, parent, full, task) {\n  if (typeof task !== 'function') {\n    throw new Error('task must be a function')\n  }\n\n  var segment = this.createSegment(name, recorder, parent)\n\n  return this.bindFunction(task, segment, full)(segment)\n}\n\nfunction transactionProxy(handler) {\n  // if there's no handler, there's nothing to proxy.\n  if (typeof handler !== 'function') return handler\n\n  var tracer = this\n  var wrapped = function wrapTransactionInvocation() {\n    if (!tracer.agent.canCollectData()) {\n      return handler.apply(this, arguments)\n    }\n\n    // don't nest transactions, reuse existing ones\n    var segment = tracer.segment\n    if (segment) {\n      if (segment.transaction.traceStacks) {\n        segment.probe('!!! Nested transaction creation !!!')\n        segment.transaction.traceFlag = true // Will log the stacks when it ends.\n      }\n      logger.warn({\n        transaction: {id: segment.transaction.id, name: segment.transaction.getName()},\n        segment: segment.name\n      }, 'Active transaction when creating non-nested transaction')\n      tracer.agent.recordSupportability('Nodejs/Transactions/Nested')\n      return handler.apply(this, arguments)\n    }\n    var transaction = new Transaction(tracer.agent)\n    return tracer.bindFunction(handler, transaction.trace.root, true)\n      .apply(this, arguments)\n  }\n\n  wrapped[ORIGINAL] = handler\n\n  return wrapped\n}\n\n\n/**\n * Use transactionNestProxy to wrap a closure that is a top-level handler that\n * is meant to start transactions. This wraps the first half of asynchronous\n * handlers. Use bindFunction to wrap handler callbacks. This detects to see\n * if there is an in play segment and uses that as the root instead of\n * transaction.trace.root.\n *\n * @param {Function} handler - Generator to be proxied.\n *\n * @return {Function} Proxy.\n */\nfunction transactionNestProxy(type, handler) {\n  if (handler === undefined && typeof type === 'function') {\n    handler = type\n    type = undefined\n  }\n  // if there's no handler, there's nothing to proxy.\n  if (typeof handler !== 'function') return handler\n\n  var tracer = this\n  var wrapped = function wrapTransactionInvocation() {\n    if (!tracer.agent.canCollectData()) {\n      return handler.apply(this, arguments)\n    }\n\n    // don't nest transactions, reuse existing ones\n    var transaction = tracer.getTransaction()\n    var segment = tracer.segment\n\n    var createNew = false\n\n    if (!transaction || transaction.type !== type) {\n      createNew = true\n    }\n\n    if (createNew) {\n      transaction = new Transaction(tracer.agent)\n      transaction.type = type\n      segment = transaction.trace.root\n    }\n\n    return tracer.bindFunction(handler, segment).apply(this, arguments)\n  }\n\n  wrapped[ORIGINAL] = handler\n\n  return wrapped\n}\n\nfunction bindFunction(handler, segment, full) {\n  if (typeof handler !== 'function') {\n    return handler\n  }\n\n  return _makeWrapped(this, handler, segment || this.segment, !!full)\n}\nfunction _makeWrapped(tracer, handler, active, full) {\n  wrapped[ORIGINAL] = getOriginal(handler)\n  wrapped[SEGMENT] = active\n\n  return wrapped\n\n  function wrapped() {\n    var prev = tracer.segment\n    tracer.segment = active\n    if (active && full) active.start()\n    try {\n      return handler.apply(this, arguments)\n    } catch (err) {\n      logger.trace(err, \"Error from wrapped function:\")\n\n      if (prev === null && process.domain != null) {\n        process.domain.__NR_transactionSegment = tracer.segment\n      }\n\n      throw err // Re-throwing application error, this is not an agent error.\n    } finally {\n      if (active && full) active.touch()\n      tracer.segment = prev\n    }\n  }\n}\n\nfunction getOriginal(fn) {\n  return fn && fn[ORIGINAL] ? fn[ORIGINAL] : fn\n}\n\nfunction getSegmentFromWrapped(fn) {\n  return fn && fn[SEGMENT] ? fn[SEGMENT] : null\n}\n\nfunction bindEmitter(emitter, segment) {\n  if (!emitter || !emitter.emit) {\n    return emitter\n  }\n\n  var emit = getOriginal(emitter.emit)\n  emitter.emit = this.bindFunction(emit, segment)\n\n  return emitter\n}\n\nfunction argSlice(args) {\n  /**\n   * Usefully nerfed version of slice for use in instrumentation. Way faster\n   * than using [].slice.call, and maybe putting it in here (instead of the\n   * same module context where it will be used) will make it faster by\n   * defeating inlining.\n   *\n   *   http://jsperf.com/array-slice-call-arguments-2\n   *\n   *  for untrustworthy benchmark numbers. Only useful for copying whole\n   *  arrays, and really only meant to be used with the arguments array like.\n   *\n   *  Also putting this comment inside the function in an effort to defeat\n   *  inlining.\n   *\n   */\n  var length = args.length\n  var array = new Array(length)\n\n  for (var i = 0; i < length; i++) {\n    array[i] = args[i]\n  }\n\n  return array\n}\n\nfunction wrapFunctionNoSegment(original, name, wrapper) {\n  if (typeof original !== 'function') return original\n\n  logger.trace('Wrapping function %s (no segment)', name || original.name || 'anonymous')\n  var tracer = this\n\n  return wrappedFunction\n\n  function wrappedFunction() {\n    if (!tracer.getTransaction()) return original.apply(this, arguments)\n    var args = tracer.slice(arguments)\n\n    if (wrapper === undefined) {\n      var last = args.length - 1\n      var cb = args[last]\n      if (typeof cb === 'function') {\n        args[last] = tracer.bindFunction(cb)\n      }\n    } else {\n      args = wrapper(args)\n    }\n    return original.apply(this, args)\n  }\n}\n\nfunction wrapFunctionFirstNoSegment(original, name) {\n  if (typeof original !== 'function') return original\n\n  logger.trace('Wrapping function %s (no segment)', name || original.name || 'anonymous')\n  var tracer = this\n\n  return wrappedFunction\n\n  function wrappedFunction() {\n    if (!tracer.getTransaction()) return original.apply(this, arguments)\n    var args = tracer.slice(arguments)\n    var cb = args[0]\n    if (typeof cb === 'function') {\n      args[0] = tracer.bindFunction(cb)\n    }\n    return original.apply(this, args)\n  }\n}\n\nfunction wrapFunctionLast(name, recorder, original) {\n  if (typeof original !== 'function') {\n    logger.trace('Not wrapping \"%s\" because it was not a function', name)\n    return original\n  }\n\n  logger.trace('Wrapping %s as a callback-last function', name)\n  var tracer = this\n\n  return wrappedFunction\n\n  function wrappedFunction() {\n    var transaction = tracer.getTransaction()\n    if (!transaction) {\n      logger.trace('Not creating segment \"%s\" because no transaction was active', name)\n      return original.apply(this, arguments)\n    }\n\n    logger.trace('Creating \"%s\" segment for transaction %s.', name, transaction.id)\n    var args = tracer.slice(arguments)\n    var last = args.length - 1\n    var cb = args[last]\n    if (typeof cb !== 'function') return original.apply(this, arguments)\n    var child = tracer.createSegment(name, recorder)\n    args[last] = tracer.wrapCallback(cb, child, wrappedCallback)\n    child.start()\n    return tracer.bindFunction(original, child).apply(this, args)\n\n    function wrappedCallback() {\n      logger.trace('Ending \"%s\" segment for transaction %s.', name, transaction.id)\n      child.touch()\n      return cb.apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapFunctionFirst(name, recorder, original) {\n  if (typeof original !== 'function') {\n    logger.trace('Not wrapping \"%s\" because it was not a function', name)\n    return original\n  }\n\n  logger.trace('Wrapping %s as a callback-first function', name)\n  var tracer = this\n\n  return wrappedFunction\n\n  function wrappedFunction() {\n    var transaction = tracer.getTransaction()\n    if (!transaction) {\n      logger.trace('Not creating segment \"%s\" because no transaction was active', name)\n      return original.apply(this, arguments)\n    }\n\n    logger.trace('Creating \"%s\" segment for transaction %s.', name, transaction.id)\n    var args = tracer.slice(arguments)\n    var cb = args[0]\n    if (typeof cb !== 'function') return original.apply(this, arguments)\n    var child = tracer.createSegment(name, recorder)\n    args[0] = tracer.wrapCallback(cb, child, wrappedCallback)\n    child.start()\n    return tracer.bindFunction(original, child).apply(this, args)\n\n    function wrappedCallback() {\n      logger.trace('Ending \"%s\" segment for transaction %s.', name, transaction.id)\n      child.touch()\n      var result = cb.apply(this, arguments)\n      return result\n    }\n  }\n}\n\nfunction wrapFunction(name, recorder, original, wrapper, resp) {\n  if (typeof original !== 'function' || !wrapper) {\n    logger.trace('Not wrapping \"%s\" because it was not a function', name)\n    return original\n  }\n\n  logger.trace('Wrapping %s using a custom wrapper', name)\n\n  var tracer = this\n\n  return wrappedFunction\n\n  function wrappedFunction() {\n    var transaction = tracer.getTransaction()\n    if (!transaction) {\n      logger.trace('Not creating segment \"%s\" because no transaction was active', name)\n      return original.apply(this, arguments)\n    }\n\n    logger.trace('Creating \"%s\" segment for transaction %s.', name, transaction.id)\n\n    var child = tracer.createSegment(name, recorder)\n    var args = wrapper.call(this, child, tracer.slice(arguments), bind)\n    child.start()\n    var result = tracer.bindFunction(original, child).apply(this, args)\n    if (resp) result = resp.call(this, child, result, bind)\n    return result\n\n    function bind(fn) {\n      if (!fn) return fn\n      return tracer.wrapCallback(fn, child, function nrWrappedHandler() {\n        logger.trace('Touching \"%s\" segment for transaction %s.', name, transaction.id)\n        child.touch()\n        return fn.apply(this, arguments)\n      })\n    }\n  }\n}\n\nfunction wrapSyncFunction(name, recorder, original) {\n  if (typeof original !== 'function') {\n    logger.trace('Not wrapping \"%s\" because it was not a function', name)\n    return original\n  }\n\n  logger.trace('Wrapping \"%s\" as a synchronous function', name)\n\n  var tracer = this\n\n  return wrappedFunction\n\n  function wrappedFunction() {\n    var transaction = tracer.getTransaction()\n    if (!transaction) {\n      logger.trace('Not creating segment \"%s\" because no transaction was active', name)\n      return original.apply(this, arguments)\n    }\n    logger.trace('Creating \"%s\" sync segment for transaction %s.', name, transaction.id)\n    var child = tracer.createSegment(name, recorder)\n    if (child) child.async = false\n    return tracer.bindFunction(original, child, true).apply(this, arguments)\n  }\n}\n\nfunction wrapCallback(original, segment, wrapped) {\n  var tracer = this\n\n  if (typeof original !== 'function') return original\n\n  logger.trace(\n    'Wrapping callback for \"%s\" segment',\n    segment ? segment.name : 'unknown'\n  )\n\n  return tracer.bindFunction(function wrappedCallback() {\n    if (wrapped) wrapped[ORIGINAL] = original\n\n    var child = tracer.createSegment(\n      'Callback: ' + (original.name || 'anonymous'),\n      null,\n      segment\n    )\n\n    if (child) child.async = false\n\n    return tracer.bindFunction(wrapped || original, child, true).apply(this, arguments)\n  }, segment, false)\n}\n"]},"metadata":{},"sourceType":"script"}