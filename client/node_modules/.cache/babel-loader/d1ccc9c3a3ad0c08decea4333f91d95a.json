{"ast":null,"code":"'use strict';\n\nconst arity = require('../util/arity');\n\nconst constants = require('./constants');\n\nconst events = require('events');\n\nconst hasOwnProperty = require('../util/properties').hasOwn;\n\nconst logger = require('../logger').child({\n  component: 'Shim'\n});\n\nconst path = require('path');\n\nconst specs = require('./specs');\n\nconst util = require('util'); // Some modules do terrible things, like change the prototype of functions. To\n// avoid crashing things we'll use a cached copy of apply everywhere.\n\n\nconst fnApply = Function.prototype.apply;\n/**\n * Constructs a shim associated with the given agent instance.\n *\n * @constructor\n * @classdesc\n *  A helper class for wrapping modules with segments.\n *\n * @param {Agent}   agent         - The agent this shim will use.\n * @param {string}  moduleName    - The name of the module being instrumented.\n * @param {string}  resolvedName  - The full path to the loaded module.\n */\n\nfunction Shim(agent, moduleName, resolvedName) {\n  if (!agent || !moduleName) {\n    throw new Error('Shim must be initialized with an agent and module name.');\n  }\n\n  this._logger = logger.child({\n    module: moduleName\n  });\n  this._agent = agent;\n  this._toExport = null;\n  this._debug = false;\n  this.defineProperty(this, 'moduleName', moduleName); // Determine the root directory of the module.\n\n  var moduleRoot = null;\n  var next = resolvedName || '/';\n\n  do {\n    moduleRoot = next;\n    next = path.dirname(moduleRoot);\n  } while (moduleRoot.length > 1 && !/node_modules(?:\\/@[^/]+)?$/.test(next));\n\n  this._moduleRoot = moduleRoot;\n}\n\nmodule.exports = Shim;\nShim.defineProperty = defineProperty;\nShim.defineProperties = defineProperties; // Copy the argument index enumeration onto the shim.\n\nShim.prototype.ARG_INDEXES = specs.ARG_INDEXES;\ndefineProperties(Shim.prototype, specs.ARG_INDEXES); // Copy symbols to the shim as well.\n\ndefineProperties(Shim, constants.SYMBOLS);\ndefineProperties(Shim.prototype, constants.SYMBOLS); // Define other miscellaneous properties of the shim.\n\ndefineProperties(Shim.prototype, {\n  /**\n   * The agent associated with this shim.\n   *\n   * @readonly\n   * @member {Agent} Shim.prototype.agent\n   */\n  agent: function getAgent() {\n    return this._agent;\n  },\n\n  /**\n   * The tracer in use by the agent for the shim.\n   *\n   * @readonly\n   * @member {Tracer} Shim.prototype.tracer\n   */\n  tracer: function getTracer() {\n    return this._agent.tracer;\n  },\n\n  /**\n   * The logger for this shim.\n   *\n   * @readonly\n   * @member {Logger} Shim.prototype.logger\n   */\n  logger: function getLogger() {\n    return this._logger;\n  }\n});\nShim.prototype.wrap = wrap;\nShim.prototype.bindSegment = bindSegment;\nShim.prototype.execute = execute;\nShim.prototype.wrapReturn = wrapReturn;\nShim.prototype.wrapClass = wrapClass;\nShim.prototype.wrapExport = wrapExport;\nShim.prototype.record = record;\nShim.prototype.isWrapped = isWrapped;\nShim.prototype.unwrap = unwrap;\nShim.prototype.unwrapOnce = unwrapOnce;\nShim.prototype.getOriginal = getOriginal;\nShim.prototype.getSegment = getSegment;\nShim.prototype.getActiveSegment = getActiveSegment;\nShim.prototype.setActiveSegment = setActiveSegment;\nShim.prototype.storeSegment = storeSegment;\nShim.prototype.bindCallbackSegment = bindCallbackSegment;\nShim.prototype.applySegment = applySegment;\nShim.prototype.createSegment = createSegment;\nShim.prototype.getName = getName;\nShim.prototype.isObject = isObject;\nShim.prototype.isFunction = isFunction;\nShim.prototype.isPromise = isPromise;\nShim.prototype.isString = isString;\nShim.prototype.isNumber = isNumber;\nShim.prototype.isBoolean = isBoolean;\nShim.prototype.isArray = isArray;\nShim.prototype.isNull = isNull;\nShim.prototype.toArray = toArray;\nShim.prototype.argsToArray = argsToArray;\nShim.prototype.normalizeIndex = normalizeIndex;\nShim.prototype.listenerCount = listenerCount;\nShim.prototype.once = once;\nShim.prototype.setInternalProperty = setInternalProperty;\nShim.prototype.defineProperty = defineProperty;\nShim.prototype.defineProperties = defineProperties;\nShim.prototype.setDefaults = setDefaults;\nShim.prototype.proxy = proxy;\nShim.prototype.require = shimRequire;\nShim.prototype.copySegmentParameters = copySegmentParameters;\nShim.prototype.interceptPromise = interceptPromise;\nShim.prototype.fixArity = arity.fixArity; // Internal methods.\n\nShim.prototype.getExport = getExport;\nShim.prototype.enableDebug = enableDebug;\nShim.prototype.__NR_unwrap = unwrapAll; // -------------------------------------------------------------------------- //\n\n/**\n * @callback WrapFunction\n *\n * @summary\n *  A function which performs the actual wrapping logic.\n *\n * @description\n *  If the return value of this function is not `original` then the return value\n *  will be marked as a wrapper.\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Object|Function} original\n *  The item which needs wrapping. Most of the time this will be a function.\n *\n * @param {string} name\n *  The name of `original` if it can be determined, otherwise `'<anonymous>'`.\n *\n * @return {*} The wrapper for the original, or the original value itself.\n */\n\n/**\n * @private\n * @callback ArrayWrapFunction\n *\n * @description\n *   A wrap function used on elements of an array. In addition to the parameters\n *   of `WrapFunction`, these also receive an `index` and `total` as described\n *   below.\n *\n * @see WrapFunction\n *\n * @param {number} index - The index of the current element in the array.\n * @param {number} total - The total number of items in the array.\n */\n\n/**\n * @private\n * @callback ArgumentsFunction\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Function} func\n *  The function these arguments were passed to.\n *\n * @param {*} context\n *  The context the function is executing under (i.e. `this`).\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the function.\n */\n\n/**\n * @callback SegmentFunction\n *\n * @summary\n *  A function which is called to compose a segment.\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Function} func\n *  The function the segment is created for.\n *\n * @param {string} name\n *  The name of the function.\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the function.\n *\n * @return {string|SegmentSpec} The desired properties for the new segment.\n */\n\n/**\n * @callback RecorderFunction\n *\n * @summary\n *  A function which is called to compose a segment for recording.\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Function} func\n *  The function being recorded.\n *\n * @param {string} name\n *  The name of the function.\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the function.\n *\n * @return {string|RecorderSpec} The desired properties for the new segment.\n */\n\n/**\n * @callback CallbackBindFunction\n *\n * @summary\n *  Performs segment binding on a callback function. Useful when identifying a\n *  callback is more complex than a simple argument offset.\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Function} func\n *  The function being recorded.\n *\n * @param {string} name\n *  The name of the function.\n *\n * @param {TraceSegment} segment\n *  The segment that the callback should be bound to.\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the function.\n */\n\n/**\n * @private\n * @callback MetricFunction\n *\n * @summary\n *  Measures all the necessary metrics for the given segment. This functionality\n *  is meant to be used by Shim subclasses, instrumentations should never create\n *  their own recorders.\n *\n * @param {TraceSegment}  segment - The segment to record.\n * @param {string}        [scope] - The scope of the recording.\n */\n\n/**\n * @callback ConstructorHookFunction\n *\n * @summary\n *  Pre/post constructor execution hook for wrapping classes. Used by\n *  {@link ClassWrapSpec}.\n *\n * @param {Shim} shim\n *  The shim performing the wrapping/binding.\n *\n * @param {Function} Base\n *  The class that was wrapped.\n *\n * @param {string} name\n *  The name of the `Base` class.\n *\n * @param {Array.<*>} args\n *  The arguments to the class constructor.\n *\n * @see ClassWrapSpec\n */\n\n/**\n * @private\n * @interface Spec\n *\n * @description\n *  The syntax for declarative instrumentation. It can be used interlaced with\n *  custom, hand-written instrumentation for one-off or hard to simplifiy\n *  instrumentation logic.\n *\n * @property {Spec|WrapFunction} $return\n *  Changes the context to the return value of the current context. This means\n *  the sub spec will not be executed up front, but instead upon every execution\n *  of the current context.\n *\n *  ```js\n *  var ret = func.apply(this, args);\n *  return shim.wrap(ret, spec.$return)\n *  ```\n *\n * @property {Spec|WrapFunction} $proto\n *  Changes the context to the prototype of the current context. The prototype\n *  is found using `Object.getPrototypeOf`.\n *\n *  ```js\n *  shim.wrap(Object.getPrototypeOf(context), spec.$proto)\n *  ```\n *\n * @property {bool} $once\n *  Ensures that the parent spec will only be executed one time if the value is\n *  `true`. Good for preventing double wrapping of prototype methods.\n *\n *  ```js\n *  if (spec.$once && spec.__NR_onceExecuted) {\n *    return context\n *  }\n *  spec.__NR_onceExecuted = true\n *  ```\n *\n * @property {ArgumentsFunction} $arguments\n *  Executes the function with all of the arguments passed in. The arguments can\n *  be modified in place. This will execute before `$eachArgument`.\n *\n *  ```js\n *  spec.$arguments(args)\n *  ```\n *\n * @property {Spec|ArrayWrapFunction} $eachArgument\n *  Executes `shim.wrap` on each argument passed to the current context. The\n *  returned arguments will then be used to actually execute the function.\n *\n *  ```js\n *  var argLength = arguments.length\n *  var extraArgs = extras.concat([0, argLength])\n *  var iIdx = extraArgs.length - 2\n *  var args = new Array(argLength)\n *  for (var i = 0; i < argLength; ++i) {\n *    extraArgs[iIdx] = i\n *    args[i] = shim.wrap(arguments[i], spec.$eachArgument, extraArgs)\n *  }\n *  func.apply(this, args)\n *  ```\n *\n * @property {Array.<{$properties: Array.<string>, $spec: Spec}>} $wrappings\n *  Executes `shim.wrap` with the current context as the `nodule` for each\n *  element in the array. The `$properties` sub-key must list one or more\n *  properties to be wrapped. The `$spec` sub-key must be a {@link Spec} or\n *  {@link WrapFunction} for wrapping the properties.\n *\n *  ```js\n *  spec.$wrappings.forEach(function($wrap) {\n *    shim.wrap(context, $wrap.$properties, $wrap.$spec)\n *  })\n *  ```\n *\n * @property {bool|string|SegmentFunction} $segment\n *  Controls segment creation. If a falsey value (i.e. `undefined`, `false`,\n *  `null`, etc) then no segment will be created. If the value is `true`, then\n *  the name of the current context is used to name the segment. If the value is\n *  a string then that string will be the name of the segment. Lastly, if the\n *  value is a function, that function will be called with the current context\n *  and arguments.\n *\n *  ```js\n *  var segment = null\n *  if (spec.$segment) {\n *    var seg = {name: spec.$segment}\n *    if (shim.isFunction(seg.name)) {\n *      seg = seg.name(func, this, arguments)\n *    }\n *    else if (seg.name === true) {\n *      seg.name = func.name\n *    }\n *    segment = shim.createSegment(seg.name, seg.recorder, seg.parent)\n *  }\n *  ```\n *\n * @property {Object.<string, *>} $cache\n *  Adds the value as an extra parameter to all specs in the same context as the\n *  cache. If the current context is a function, the cache will be recreated on\n *  each invocation of the function. This value can be useful for passing a\n *  value at runtime from one spec into another.\n *\n *  ```js\n *  var args = extras || []\n *  if (spec.$cache) {\n *    args.push({})\n *  }\n *  ```\n *\n * @property {number} $callback\n *  Indicates that one of the parameters is a callback which should be wrapped.\n *\n *  ```js\n *  if (shim.isNumber(spec.$callback)) {\n *    var idx = spec.$callback\n *    if (idx < 0) {\n *      idx = args.length + idx\n *    }\n *    args[idx] = shim.bindSegment(args[idx], segment)\n *  }\n *  ```\n *\n * @property {Spec|WrapFunction} property\n *  Any field which does not start with a `$` is assumed to name a property on\n *  the current context which should be wrapped. This is simply shorthand for a\n *  `$wrappings` with only one `$properties` value.\n */\n\n/**\n * @interface SegmentSpec\n *\n * @description\n *  The return value from a {@link SegmentFunction}, used to set the parameters\n *  of segment creation.\n *\n * @property {string} name\n *  The name for the segment to-be.\n *\n * @property {MetricFunction} [recorder]\n *  A metric recorder for the segment. This is purely for internal use by shim\n *  classes. Instrumentations should never implement their own metric functions.\n *\n * @property {TraceSegment} [parent]\n *  The parent segment. Defaults to the currently active segment.\n *\n * @see RecorderSpec\n * @see SegmentFunction\n */\n\n/**\n * @interface RecorderSpec\n * @extends SegmentSpec\n *\n * @description\n *  The return value from a {@link RecorderFunction}, used to set the parameters\n *  of segment creation and lifetime. Extends the {@link SegmentSpec}.\n *\n * @property {bool|string} [stream]\n *  Indicates if the return value from the wrapped function is a stream. If the\n *  value is truthy then the recording will extend to the `end` event of the\n *  stream. If the value is a string it is assumed to be the name of an event to\n *  measure. A segment will be created to record emissions of the event.\n *\n * @property {bool} [promise]\n *  Indicates if the return value from the wrapped function is a Promise. If the\n *  value is truthy then the recording will extend to the completion of the\n *  Promise.\n *\n * @property {number|CallbackBindFunction} [callback]\n *  If this is a number, it identifies which argument is the callback and the\n *  segment will also be bound to the callback. Otherwise, the passed function\n *  should perform the segment binding itself.\n *\n * @property {number|CallbackBindFunction} [rowCallback]\n *  Like `callback`, this identifies a callback function in the arguments. The\n *  difference is that the default behavior for row callbacks is to only create\n *  one segment for all calls to the callback. This is mostly useful for\n *  functions which will be called repeatedly, such as once for each item in a\n *  result set.\n *\n * @property {bool} [internal=false]\n *  Marks this as the boundary point into the instrumented library. If `true`\n *  and the current segment is _also_ marked as `internal` by the same shim,\n *  then we will not record this inner activity.\n *\n *  This is useful when instrumenting a library which implements high-order\n *  methods which simply call other public methods and you only want to record\n *  the method directly called by the user while still instrumenting all\n *  endpoints.\n *\n * @property {function} [after=null]\n *  A function to call after the synchronous execution of the recorded method.\n *  If the function synchronously threw an error, that error will be handed to\n *  this function.\n *\n * @property {bool} [callbackRequired]\n *  When `true`, a recorded method must be called with a callback for a segment\n *  to be created. Does not apply if a custom callback method has been assigned\n *  via {@link callback}.\n *\n * @see SegmentSpec\n * @see RecorderFunction\n */\n\n/**\n * @interface ClassWrapSpec\n *\n * @description\n *  Specifies the style of wrapping and construction hooks for wrapping classes.\n *\n * @property {bool} [es6=false]\n * @property {ConstructorHookFunction} [pre=null]\n *  A function called with the constructor's arguments before the base class'\n *  constructor is executed. The `this` value will be `null`.\n *\n * @property {ConstructorHookFunction} [post=null]\n *  A function called with the constructor's arguments after the base class'\n *  constructor is executed. The `this` value will be the just-constructed object.\n *\n */\n// -------------------------------------------------------------------------- //\n\n/**\n * Entry point for executing a spec.\n *\n * @memberof Shim.prototype\n */\n\nfunction execute(nodule, spec) {\n  if (this.isFunction(spec)) {\n    spec(this, nodule);\n  } else {\n    _specToFunction(spec)(this, nodule);\n  }\n}\n/**\n * Executes the provided spec on one or more objects.\n *\n * - `wrap(nodule, properties, spec [, args])`\n * - `wrap(func, spec [, args])`\n *\n * When called with a `nodule` and one or more properties, the spec will be\n * executed on each property listed and the return value put back on the\n * `nodule`.\n *\n * When called with just a function, the spec will be executed on the function\n * and the return value of the spec simply passed back.\n *\n * The wrapped version will have the same prototype as the original\n * method.\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {Spec|WrapFunction} spec\n *  The spec for wrapping these items.\n *\n * @param {Array.<*>} [args=[]]\n *  Optional extra arguments to be sent to the spec when executing it.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see WrapFunction\n */\n\n\nfunction wrap(nodule, properties, spec, args) {\n  if (!nodule) {\n    this.logger.debug('Not wrapping non-existent nodule.');\n    return nodule;\n  } // Sort out the parameters.\n\n\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // wrap(nodule, spec [, args])\n    args = spec;\n    spec = properties;\n    properties = null;\n  }\n\n  if (this.isFunction(spec)) {\n    // wrap(nodule [, properties], wrapper [, args])\n    spec = {\n      wrapper: spec\n    };\n  } // TODO: Add option for omitting __NR_original; unwrappable: false\n\n\n  spec = this.setDefaults(spec, {\n    matchArity: false\n  }); // If we're just wrapping one thing, just wrap it and return.\n\n  if (properties == null) {\n    const name = this.getName(nodule);\n    this.logger.trace('Wrapping nodule itself (%s).', name);\n    return _wrap(this, nodule, name, spec, args);\n  } // Coerce properties into an array.\n\n\n  if (!this.isArray(properties)) {\n    properties = [properties];\n  } // Wrap each property and return the nodule.\n\n\n  this.logger.trace('Wrapping %d properties on nodule.', properties.length);\n  properties.forEach(function wrapEachProperty(prop) {\n    // Skip nonexistent properties.\n    var original = nodule[prop];\n\n    if (!original) {\n      this.logger.debug('Not wrapping missing property \"%s\"', prop);\n      return;\n    } // Wrap up the property and add a special unwrapper.\n\n\n    var wrapped = _wrap(this, original, prop, spec, args);\n\n    if (wrapped && wrapped !== original) {\n      this.logger.trace('Replacing \"%s\" with wrapped version', prop);\n      nodule[prop] = wrapped;\n      this.setInternalProperty(wrapped, '__NR_unwrap', function unwrapWrap() {\n        nodule[prop] = original;\n        return original;\n      });\n    }\n  }, this);\n  return nodule;\n}\n/**\n * Executes the provided spec with the return value of the given properties.\n *\n * - `wrapReturn(nodule, properties, spec [, args])`\n * - `wrapReturn(func, spec [, args])`\n *\n * If the wrapper is executed with `new` then the wrapped function will also be\n * called with `new`. This feature should only be used with factory methods\n * disguised as classes. Normally {@link Shim#wrapClass} should be used to wrap\n * constructors instead.\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {Spec|WrapReturnFunction} spec\n *  The spec for wrapping the returned value from the properties.\n *\n * @param {Array.<*>} [args=[]]\n *  Optional extra arguments to be sent to the spec when executing it.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see WrapReturnFunction\n */\n\n\nfunction wrapReturn(nodule, properties, spec, args) {\n  // Munge our parameters as needed.\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // wrapReturn(nodule, spec [, args])\n    args = spec;\n    spec = properties;\n    properties = null;\n  }\n\n  if (!this.isFunction(spec)) {\n    spec = _specToFunction(spec);\n  }\n\n  if (!this.isArray(args)) {\n    args = [];\n  } // Perform the wrapping!\n\n\n  return this.wrap(nodule, properties, function returnWrapper(shim, fn, fnName) {\n    // Only functions can have return values for us to wrap.\n    if (!shim.isFunction(fn)) {\n      return fn;\n    }\n\n    let unwrapReference = null;\n    const handler = {\n      get: function getTrap(target, prop) {\n        // Allow for look up of the target\n        if (prop === '__NR_original') {\n          return target;\n        }\n\n        if (prop === '__NR_unwrap') {\n          return unwrapReference;\n        }\n\n        return target[prop];\n      },\n      defineProperty: function definePropertyTrap(target, key, descriptor) {\n        if (key === '__NR_unwrap') {\n          unwrapReference = descriptor.value;\n        } else {\n          Object.defineProperty(target, key, descriptor);\n        }\n\n        return true;\n      },\n      set: function setTrap(target, key, val) {\n        if (key === '__NR_unwrap') {\n          unwrapReference = val;\n        } else {\n          target[key] = val;\n        }\n\n        return true;\n      },\n      construct: function constructTrap(Target, proxyArgs) {\n        // Call the underlying function. If this was called as a constructor, call\n        // the wrapped function as a constructor too.\n        let ret = new Target(...proxyArgs); // Assemble the arguments to hand to the spec.\n\n        const _args = [shim, fn, fnName, ret];\n\n        if (args.length > 0) {\n          _args.push.apply(_args, args);\n        } // Call the spec and see if it handed back a different return value.\n\n\n        const newRet = spec.apply(ret, _args);\n\n        if (newRet) {\n          ret = newRet;\n        }\n\n        return ret;\n      },\n      apply: function applyTrap(target, thisArg, proxyArgs) {\n        // Call the underlying function. If this was called as a constructor, call\n        // the wrapped function as a constructor too.\n        let ret = target.apply(thisArg, proxyArgs); // Assemble the arguments to hand to the spec.\n\n        const _args = [shim, fn, fnName, ret];\n\n        if (args.length > 0) {\n          _args.push.apply(_args, args);\n        } // Call the spec and see if it handed back a different return value.\n\n\n        const newRet = spec.apply(thisArg, _args);\n\n        if (newRet) {\n          ret = newRet;\n        }\n\n        return ret;\n      }\n    };\n    return new Proxy(fn, handler);\n  });\n}\n/**\n * Wraps a class constructor using a subclass with pre- and post-construction\n * hooks.\n *\n * - `wrapClass(nodule, properties, spec [, args])`\n * - `wrapClass(func, spec [, args])`\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the constructor to wrap.\n *\n * @param {ClassWrapSpec|ConstructorHookFunction} spec\n *  The spec for wrapping the returned value from the properties or a post hook.\n *\n * @param {Array.<*>} [args=[]]\n *  Optional extra arguments to be sent to the spec when executing it.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n */\n\n\nfunction wrapClass(nodule, properties, spec, args) {\n  // Munge our parameters as needed.\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // wrapReturn(nodule, spec [, args])\n    args = spec;\n    spec = properties;\n    properties = null;\n  }\n\n  if (this.isFunction(spec)) {\n    spec = {\n      pre: null,\n      post: spec\n    };\n  } else {\n    spec.pre = spec.pre || null;\n    spec.post = spec.post || null;\n  }\n\n  if (!this.isArray(args)) {\n    args = [];\n  } // Perform the wrapping!\n\n\n  return this.wrap(nodule, properties, function classWrapper(shim, Base, fnName) {\n    // Only functions can have return values for us to wrap.\n    if (!shim.isFunction(Base) || shim.isWrapped(Base)) {\n      return Base;\n    } // When es6 classes are being wrapped, we need to use an es6 class due to\n    // the fact our es5 wrapper depends on calling the constructor without `new`.\n\n\n    var wrapper = spec.es6 || /^class /.test(Base.toString()) ? _es6WrapClass : _es5WrapClass;\n    return wrapper(shim, Base, fnName, spec, args);\n  });\n}\n/**\n * Wraps the actual module being instrumented to change what `require` returns.\n *\n * - `wrapExport(nodule, spec)`\n *\n * @memberof Shim.prototype\n *\n * @param {*} nodule\n *  The original export to replace with our new one.\n *\n * @param {WrapFunction} spec\n *  A wrapper function. The return value from this spec is what will replace\n *  the export.\n *\n * @return {*} The return value from `spec`.\n */\n\n\nfunction wrapExport(nodule, spec) {\n  return this._toExport = this.wrap(nodule, null, spec);\n}\n/**\n * If the export was wrapped, that wrapper is returned, otherwise `defaultExport`.\n *\n * @private\n * @memberof Shim.prototype\n *\n * @param {*} defaultExport - The original export in case it was never wrapped.\n *\n * @return {*} The result from calling {@link Shim#wrapExport} or `defaultExport`\n *  if it was never used.\n *\n * @see Shim.wrapExport\n */\n\n\nfunction getExport(defaultExport) {\n  return this._toExport || defaultExport;\n}\n/**\n * Determines if the specified function or property exists and is wrapped.\n *\n * - `isWrapped(nodule, property)`\n * - `isWrapped(func)`\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the property or a single function to check.\n *\n * @param {string} [property]\n *  The property to check. If omitted, the `nodule` parameter is assumed to be\n *  the function to check.\n *\n * @return {bool} True if the item exists and has been wrapped.\n *\n * @see Shim#wrap\n * @see Shim#bindSegment\n */\n\n\nfunction isWrapped(nodule, property) {\n  if (property) {\n    return !!(nodule && nodule[property] && nodule[property].__NR_original);\n  }\n\n  return !!(nodule && nodule.__NR_original);\n}\n/**\n * Wraps a function with segment creation and binding.\n *\n * - `record(nodule, properties, recordNamer)`\n * - `record(func, recordNamer)`\n *\n * This is shorthand for calling {@link Shim#wrap} and manually creating a segment.\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to record, or a single function to record.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to record. If omitted, the `nodule` parameter is\n *  assumed to be the function to record.\n *\n * @param {RecorderFunction} recordNamer\n *  A function which returns a record descriptor that gives the name and type of\n *  record we'll make.\n *\n * @return {Object|Function} The first parameter, possibly wrapped.\n *\n * @see RecorderFunction\n * @see RecorderSpec\n * @see Shim#wrap\n */\n\n\nfunction record(nodule, properties, recordNamer) {\n  if (this.isFunction(properties)) {\n    recordNamer = properties;\n    properties = null;\n  }\n\n  return this.wrap(nodule, properties, function makeWrapper(shim, fn, name) {\n    // Can't record things that aren't functions.\n    if (!shim.isFunction(fn)) {\n      shim.logger.debug('Not recording non-function \"%s\".', name);\n      return fn;\n    }\n\n    shim.logger.trace('Wrapping \"%s\" with metric recording.', name);\n    return function wrapper() {\n      // Create the segment that will be recorded.\n      var args = argsToArray.apply(shim, arguments);\n      var segDesc = recordNamer.call(this, shim, fn, name, args);\n\n      if (!segDesc) {\n        shim.logger.trace('No segment descriptor for \"%s\", not recording.', name);\n        return fnApply.call(fn, this, args);\n      }\n\n      segDesc = new specs.RecorderSpec(segDesc); // See if we're in an active transaction.\n\n      var parent;\n\n      if (segDesc.parent) {\n        // We only want to continue recording in a transaction if the\n        // transaction is active.\n        parent = segDesc.parent.transaction.isActive() ? segDesc.parent : null;\n      } else {\n        parent = shim.getActiveSegment();\n      }\n\n      if (!parent) {\n        shim.logger.debug('Not recording function %s, not in a transaction.', name);\n        return fnApply.call(fn, this, arguments);\n      }\n\n      if (segDesc.callbackRequired && !_hasValidCallbackArg(shim, args, segDesc.callback)) {\n        return fnApply.call(fn, this, arguments);\n      } // Only create a segment if:\n      //  - We are _not_ making an internal segment.\n      //  - OR the parent segment is either not internal or not from this shim.\n\n\n      var shouldCreateSegment = !(parent.opaque || segDesc.internal && parent.internal && shim === parent.shim);\n      var segment = shouldCreateSegment ? _rawCreateSegment(shim, segDesc) : parent;\n      return _doRecord.call(this, segment, args, segDesc, shouldCreateSegment);\n    };\n\n    function _hasValidCallbackArg(shim, args, specCallback) {\n      if (shim.isNumber(specCallback)) {\n        const cbIdx = normalizeIndex(args.length, specCallback);\n\n        if (cbIdx === null) {\n          return false;\n        }\n\n        const callback = args[cbIdx];\n        return shim.isFunction(callback);\n      }\n\n      return true;\n    }\n\n    function _doRecord(segment, args, segDesc, shouldCreateSegment) {\n      // Now bind any callbacks specified in the segment descriptor.\n      _bindAllCallbacks.call(this, shim, fn, name, args, {\n        spec: segDesc,\n        segment: segment,\n        shouldCreateSegment: shouldCreateSegment\n      }); // Apply the function, and (if it returned a stream) bind that too.\n      // If you are looking here Geoff, the reason there is no check for\n      // `segment` is because it should be guaranteed by the parent and active\n      // transaction check at the beginning of this function. :)\n\n\n      var ret = _applyRecorderSegment(segment, this, args, segDesc);\n\n      if (ret) {\n        if (segDesc.stream) {\n          shim.logger.trace('Binding return value as stream.');\n\n          _bindStream(shim, ret, segment, {\n            event: shim.isString(segDesc.stream) ? segDesc.stream : null,\n            shouldCreateSegment: shouldCreateSegment\n          });\n        } else if (segDesc.promise && shim.isPromise(ret)) {\n          shim.logger.trace('Binding return value as Promise.');\n          ret = _bindPromise(shim, ret, segment);\n        }\n      }\n\n      return ret;\n    }\n\n    function _applyRecorderSegment(segment, ctx, args, segDesc) {\n      var error = null;\n      var promised = false;\n      var ret;\n\n      try {\n        ret = shim.applySegment(fn, segment, true, ctx, args, segDesc.inContext);\n\n        if (segDesc.after && segDesc.promise && shim.isPromise(ret)) {\n          promised = true;\n          return ret.then(function onThen(val) {\n            segment.touch();\n            segDesc.after(shim, fn, name, null, val);\n            return val;\n          }, function onCatch(err) {\n            segment.touch();\n            segDesc.after(shim, fn, name, err, null);\n            throw err; // NOTE: This is not an error from our instrumentation.\n          });\n        }\n\n        return ret;\n      } catch (err) {\n        error = err;\n        throw err; // Just rethrowing this error, not our error!\n      } finally {\n        if (segDesc.after && (error || !promised)) {\n          segDesc.after(shim, fn, name, error, ret);\n        }\n      }\n    }\n  });\n}\n/**\n * Unwraps one or more items, revealing the original value.\n *\n * - `unwrap(nodule, property)`\n * - `unwrap(func)`\n *\n * If called with a `nodule` and properties, the unwrapped values will be put\n * back on the nodule. Otherwise, the unwrapped function is just returned.\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to unwrap, or a single function to unwrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to unwrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to unwrap.\n *\n * @return {Object|Function} The first parameter after unwrapping.\n */\n\n\nfunction unwrap(nodule, properties) {\n  // Don't try to unwrap potentially `null` or `undefined` things.\n  if (!nodule) {\n    return nodule;\n  } // If we're unwrapping multiple things\n\n\n  if (this.isArray(properties)) {\n    properties.forEach(unwrap.bind(this, nodule));\n    return nodule;\n  }\n\n  this.logger.trace('Unwrapping %s', properties || '<nodule>');\n  var original = properties ? nodule[properties] : nodule;\n\n  while (original && original.__NR_original) {\n    original = this.isFunction(original.__NR_unwrap) ? original.__NR_unwrap() : original.__NR_original;\n  }\n\n  return original;\n}\n/**\n * Unwraps one item, revealing the underlying value.\n *\n * - `unwrapOnce(nodule, property)`\n * - `unwrapOnce(func)`\n *\n * If called with a `nodule` and properties, the unwrapped value will be put\n * back on the nodule. Otherwise, the unwrapped function is just returned.\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to unwrap, or a single function to unwrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to unwrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to unwrap.\n *\n * @return {Object|Function} The first parameter after unwrapping.\n */\n\n\nfunction unwrapOnce(nodule, properties) {\n  // Don't try to unwrap potentially `null` or `undefined` things.\n  if (!nodule) {\n    return nodule;\n  } // If we're unwrapping multiple things\n\n\n  if (this.isArray(properties)) {\n    properties.forEach(unwrapOnce.bind(this, nodule));\n    return nodule;\n  }\n\n  this.logger.trace('Unwrapping %s', properties || '<nodule>');\n  var original = properties ? nodule[properties] : nodule;\n\n  if (original && original.__NR_original) {\n    original = this.isFunction(original.__NR_unwrap) ? original.__NR_unwrap() : original.__NR_original;\n  }\n\n  return original;\n}\n/**\n * Retrieves the original method for a wrapped function.\n *\n * - `getOriginal(nodule, property)`\n * - `getOriginal(func)`\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source of the property to get the original of, or a function to unwrap.\n *\n * @param {string} [property]\n *  A property on `nodule` to get the original value of.\n *\n * @return {Object|Function} The original value for the given item.\n */\n\n\nfunction getOriginal(nodule, property) {\n  if (!nodule) {\n    return nodule;\n  }\n\n  var original = property ? nodule[property] : nodule;\n\n  while (original && original.__NR_original) {\n    original = original.__NR_original;\n  }\n\n  return original;\n}\n/**\n * Binds the execution of a function to a single segment.\n *\n * - `bindSegment(nodule , property [, segment [, full]])`\n * - `bindSegment(func [, segment [, full]])`\n *\n * If called with a `nodule` and a property, the wrapped property will be put\n * back on the nodule. Otherwise, the wrapped function is just returned.\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the property or a single function to bind to a segment.\n *\n * @param {string} [property]\n *  The property to bind. If omitted, the `nodule` parameter is assumed\n *  to be the function to bind the segment to.\n *\n * @param {?TraceSegment} [segment=null]\n *  The segment to bind the execution of the function to. If omitted or `null`\n *  the currently active segment will be bound instead.\n *\n * @param {bool} [full=false]\n *  Indicates if the full lifetime of the segment is bound to this function.\n *\n * @return {Object|Function} The first parameter after wrapping.\n */\n\n\nfunction bindSegment(nodule, property, segment, full) {\n  // Don't bind to null arguments.\n  if (!nodule) {\n    return nodule;\n  } // Determine our arguments.\n\n\n  if (this.isObject(property) && !this.isArray(property)) {\n    // bindSegment(func, segment [, full])\n    full = segment;\n    segment = property;\n    property = null;\n  } // This protects against the `bindSegment(func, null, true)` case, where the\n  // segment is `null`, and thus `true` (the full param) is detected as the\n  // segment.\n\n\n  if (segment != null && !this.isObject(segment)) {\n    this.logger.debug({\n      segment: segment\n    }, 'Segment is not a segment, not binding.');\n    return nodule;\n  }\n\n  var wrapped = this.wrap(nodule, property, function wrapFunc(shim, func) {\n    if (!shim.isFunction(func)) {\n      return func;\n    } // Wrap up the function with this segment.\n\n\n    segment = segment || shim.getSegment();\n\n    if (!segment) {\n      return func;\n    }\n\n    var binder = _makeBindWrapper(shim, func, segment, full || false);\n\n    shim.storeSegment(binder, segment);\n    return binder;\n  });\n  return wrapped;\n}\n/**\n * Replaces the callback in an arguments array with one that has been bound to\n * the given segment.\n *\n * - `bindCallbackSegment(args, cbIdx [, segment])`\n * - `bindCallbackSegment(obj, property [, segment])`\n *\n * @memberof Shim.prototype\n *\n * @param {Array|Object} args\n *  The arguments array to pull the cb from.\n *\n * @param {number|string} cbIdx\n *  The index of the callback.\n *\n * @param {TraceSegment} [parentSegment]\n *  The segment to use as the callback segment's parent. Defaults to the\n *  currently active segment.\n *\n * @see Shim#bindSegment\n */\n\n\nfunction bindCallbackSegment(args, cbIdx, parentSegment) {\n  if (!args) {\n    return;\n  }\n\n  if (this.isNumber(cbIdx)) {\n    var normalizedCBIdx = normalizeIndex(args.length, cbIdx);\n\n    if (normalizedCBIdx === null) {\n      // Bad index.\n      this.logger.debug('Invalid index %d for args of length %d, not binding callback segment', cbIdx, args.length);\n      return;\n    }\n\n    cbIdx = normalizedCBIdx;\n  } // Pull out the callback and make sure it is a function.\n\n\n  var cb = args[cbIdx];\n\n  if (this.isFunction(cb)) {\n    var shim = this;\n    var realParent = parentSegment || shim.getSegment();\n    args[cbIdx] = shim.wrap(cb, null, function callbackWrapper(shim, fn, name) {\n      return function wrappedCallback() {\n        if (realParent) {\n          realParent.opaque = false;\n        }\n\n        var segment = _rawCreateSegment(shim, new specs.SegmentSpec({\n          name: 'Callback: ' + name,\n          parent: realParent\n        }));\n\n        if (segment) {\n          segment.async = false;\n        } // CB may end the transaction so update the parent's time preemptively.\n\n\n        realParent && realParent.touch();\n        return shim.applySegment(cb, segment, true, this, arguments);\n      };\n    });\n    shim.storeSegment(args[cbIdx], realParent);\n  }\n}\n/**\n * Retrieves the segment associated with the given object, or the current\n * segment if no object is given.\n *\n * - `getSegment([obj])`\n *\n * @memberof Shim.prototype\n *\n * @param {*} [obj] - The object to retrieve a segment from.\n *\n * @return {?TraceSegment} The trace segment associated with the given object or\n *  the current segment if no object is provided or no segment is associated\n *  with the object.\n */\n\n\nfunction getSegment(obj) {\n  if (obj && obj.__NR_segment) {\n    return obj.__NR_segment;\n  }\n\n  return this.tracer.getSegment();\n}\n/**\n * Retrieves the segment associated with the given object, or the currently\n * active segment if no object is given.\n *\n * - `getActiveSegment([obj])`\n *\n * An active segment is one whose transaction is still active (e.g. has not\n * ended yet).\n *\n * @memberof Shim.prototype\n *\n * @param {*} [obj] - The object to retrieve a segment from.\n *\n * @return {?TraceSegment} The trace segment associated with the given object or\n *  the currently active segment if no object is provided or no segment is\n *  associated with the object.\n */\n\n\nfunction getActiveSegment(obj) {\n  var segment = this.getSegment(obj);\n\n  if (segment && segment.transaction && segment.transaction.isActive()) {\n    return segment;\n  }\n\n  return null;\n}\n/**\n * Explicitly sets the active segment to the one passed in. This method\n * should only be used if there is no function to tie a segment's timing\n * to.\n *\n * - `setActiveSegment(segment)`\n *\n * @memberof Shim.prototype\n *\n * @param {TraceSegment} segment - The segment to set as the active segment.\n *\n */\n\n\nfunction setActiveSegment(segment) {\n  return this.tracer.segment = segment;\n}\n/**\n * Associates a segment with the given object.\n *\n * - `storeSegment(obj [, segment])`\n *\n * If no segment is provided, the currently active segment is used.\n *\n * @memberof Shim.prototype\n *\n * @param {!*}            obj       - The object to retrieve a segment from.\n * @param {TraceSegment}  [segment] - The segment to link the object to.\n */\n\n\nfunction storeSegment(obj, segment) {\n  this.setInternalProperty(obj, '__NR_segment', segment || this.tracer.getSegment());\n}\n/**\n * Sets the given segment as the active one for the duration of the function's\n * execution.\n *\n * - `applySegment(func, segment, full, context, args[, inContextCB])`\n *\n * @memberof Shim.prototype\n *\n * @param {Function} func\n *  The function to execute in the context of the given segment.\n *\n * @param {TraceSegment} segment\n *  The segment to make active for the duration of the function.\n *\n * @param {bool} full\n *  Indicates if the full lifetime of the segment is bound to this function.\n *\n * @param {*} context\n *  The `this` argument for the function.\n *\n * @param {Array.<*>} args\n *  The arguments to be passed into the function.\n *\n * @param {Function} [inContextCB]\n *  The function used to do more instrumentation work. This function is\n *  guaranteed to be executed with the segment associated with.\n *\n *\n * @return {*} Whatever value `func` returned.\n */\n\n/* eslint-disable max-params */\n\n\nfunction applySegment(func, segment, full, context, args, inContextCB) {\n  // Exist fast for bad arguments.\n  if (!this.isFunction(func)) {\n    return;\n  }\n\n  if (!segment) {\n    this.logger.trace('No segment to apply to function.');\n    return fnApply.call(func, context, args);\n  }\n\n  this.logger.trace('Applying segment %s', segment.name); // Set this segment as the current one on the tracer.\n\n  var tracer = this.tracer;\n  var prevSegment = tracer.segment;\n  tracer.segment = segment;\n\n  if (full) {\n    segment.start();\n  }\n\n  if (typeof inContextCB === 'function') {\n    inContextCB();\n  } // Execute the function and then return the tracer segment to the old one.\n\n\n  try {\n    return fnApply.call(func, context, args);\n  } catch (error) {\n    if (prevSegment === null && process.domain != null) {\n      process.domain.__NR_segment = tracer.segment;\n    }\n\n    throw error; // Rethrowing application error, this is not an agent error.\n  } finally {\n    if (full) {\n      segment.touch();\n    }\n\n    tracer.segment = prevSegment;\n  }\n}\n/* eslint-enable max-params */\n\n/**\n * Creates a new segment.\n *\n * - `createSegment(opts)`\n * - `createSegment(name [, recorder] [, parent])`\n *\n * @memberof Shim.prototype\n *\n * @param {string} name\n *  The name to give the new segment.\n *\n * @param {?Function} [recorder=null]\n *  Optional. A function which will record the segment as a metric. Default is\n *  to not record the segment.\n *\n * @param {TraceSegment} [parent]\n *  Optional. The segment to use as the parent. Default is to use the currently\n *  active segment.\n *\n * @return {?TraceSegment} A new trace segment if a transaction is active, else\n *  `null` is returned.\n */\n\n\nfunction createSegment(name, recorder, parent) {\n  var opts = null;\n\n  if (this.isString(name)) {\n    // createSegment(name [, recorder] [, parent])\n    opts = new specs.SegmentSpec({\n      name\n    }); // if the recorder arg is not used, it can either be omitted or null\n\n    if (this.isFunction(recorder) || this.isNull(recorder)) {\n      // createSegment(name, recorder [, parent])\n      opts.recorder = recorder;\n      opts.parent = parent;\n    } else {\n      // createSegment(name [, parent])\n      opts.parent = recorder;\n    }\n  } else {\n    // createSegment(opts)\n    opts = name;\n  }\n\n  return _rawCreateSegment(this, opts);\n}\n\nfunction _rawCreateSegment(shim, opts) {\n  // Grab parent segment when none in opts so we can check opaqueness\n  opts.parent = opts.parent || shim.getActiveSegment(); // When parent exists and is opaque, no new segment will be created\n  // by tracer.createSegment and the parent will be returned. We bail\n  // out early so we do not risk modifying the parent segment.\n\n  if (opts.parent && opts.parent.opaque) {\n    shim.logger.trace(opts, 'Did not create segment because parent is opaque');\n    return opts.parent;\n  }\n\n  var segment = shim.tracer.createSegment(opts.name, opts.recorder, opts.parent);\n\n  if (segment) {\n    segment.internal = opts.internal;\n    segment.opaque = opts.opaque;\n    segment.shim = shim;\n\n    if (hasOwnProperty(opts, 'parameters')) {\n      shim.copySegmentParameters(segment, opts.parameters);\n    }\n\n    shim.logger.trace(opts, 'Created segment');\n  } else {\n    shim.logger.debug(opts, 'Failed to create segment');\n  }\n\n  return segment;\n}\n/**\n * Determine the name of an object.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to get a name for.\n *\n * @return {string} The name of the object if it has one, else `<anonymous>`.\n */\n\n\nfunction getName(obj) {\n  return String(!obj || obj === true ? obj : obj.name || '<anonymous>');\n}\n/**\n * Determines if the given object is an Object.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is an Object, else false.\n */\n\n\nfunction isObject(obj) {\n  return obj instanceof Object;\n}\n/**\n * Determines if the given object exists and is a function.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is a function, else false.\n */\n\n\nfunction isFunction(obj) {\n  return typeof obj === 'function';\n}\n/**\n * Determines if the given object exists and is a string.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is a string, else false.\n */\n\n\nfunction isString(obj) {\n  return typeof obj === 'string';\n}\n/**\n * Determines if the given object is a number literal.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is a number literal, else false.\n */\n\n\nfunction isNumber(obj) {\n  return typeof obj === 'number';\n}\n/**\n * Determines if the given object is a boolean literal.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is a boolean literal, else false.\n */\n\n\nfunction isBoolean(obj) {\n  return typeof obj === 'boolean';\n}\n/**\n * Determines if the given object exists and is an array.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is an array, else false.\n */\n\n\nfunction isArray(obj) {\n  return obj instanceof Array;\n}\n/**\n * Determines if the given object is a promise instance.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is a promise, else false.\n */\n\n\nfunction isPromise(obj) {\n  return obj && typeof obj.then === 'function';\n}\n/**\n * Determines if the given value is null.\n *\n * @memberof Shim.prototype\n *\n * @param {*} val - The value to check.\n *\n * @return {bool} True if the value is null, else false.\n */\n\n\nfunction isNull(val) {\n  return val === null;\n}\n/**\n * Converts an array-like object into an array.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The array-like object (i.e. `arguments`).\n *\n * @return {Array.<*>} An instance of `Array` containing the elements of the\n *  array-like.\n */\n\n\nfunction toArray(obj) {\n  var len = obj.length;\n  var arr = new Array(len);\n\n  for (var i = 0; i < len; ++i) {\n    arr[i] = obj[i];\n  }\n\n  return arr;\n}\n/**\n * Like {@link Shim#toArray}, but converts `arguments` to an array.\n *\n * This is the preferred function, when used with `.apply`, for converting the\n * `arguments` object into an actual `Array` as it will not cause deopts.\n *\n * @memberof Shim.prototype\n *\n * @return {Array} An array containing the elements of `arguments`.\n *\n * @see Shim#toArray\n * @see https://github.com/petkaantonov/bluebird/wiki/Optimization-killers\n */\n\n\nfunction argsToArray() {\n  var len = arguments.length;\n  var arr = new Array(len);\n\n  for (var i = 0; i < len; ++i) {\n    arr[i] = arguments[i];\n  }\n\n  return arr;\n}\n/**\n * Ensures the given index is a valid index inside the array.\n *\n * A negative index value is converted to a positive one by adding it to the\n * array length before checking it.\n *\n * @memberof Shim.prototype\n *\n * @param {number} arrayLength  - The length of the array this index is for.\n * @param {number} idx          - The index to normalize.\n *\n * @return {?number} The adjusted index value if it is valid, else `null`.\n */\n\n\nfunction normalizeIndex(arrayLength, idx) {\n  if (idx < 0) {\n    idx = arrayLength + idx;\n  }\n\n  return idx < 0 || idx >= arrayLength ? null : idx;\n}\n/**\n * Retrieves the number of listeners for the given event.\n *\n * @memberof Shim.prototype\n *\n * @param {object} emitter  - The emitter to count the listeners on.\n * @param {string} event    - The event to count.\n *\n * @return {number} The number of listeners on the given event for this emitter.\n */\n\n\nfunction listenerCount(emitter, evnt) {\n  if (events.EventEmitter.listenerCount) {\n    return events.EventEmitter.listenerCount(emitter, evnt);\n  }\n\n  return emitter.listeners(evnt).length;\n}\n/**\n * Wraps a function such that it will only be executed once.\n *\n * @memberof Shim.prototype\n *\n * @param {function} fn - The function to wrap in an execution guard.\n *\n * @return {function} A function which will execute `fn` at most once.\n */\n\n\nfunction once(fn) {\n  var called = false;\n  return function onceCaller() {\n    if (!called) {\n      called = true;\n      return fn.apply(this, arguments);\n    }\n  };\n}\n/**\n * Sets a property to the given value. If the property doesn't exist yet it will\n * be made writable and non-enumerable.\n *\n * @memberof Shim.prototype\n *\n * @param {!object} obj   - The object to add the property to.\n * @param {!string} name  - The name for this property.\n * @param {*}       val   - The value to set the property as.\n *\n * @return {object} The `obj` value.\n */\n\n\nfunction setInternalProperty(obj, name, val) {\n  if (!obj || !name) {\n    this.logger.debug('Not setting property; object or name is missing.');\n    return obj;\n  }\n\n  try {\n    if (this.agent.config.transaction_tracer.hide_internals) {\n      _slowSetInternalProperty(obj, name, val);\n    } else {\n      obj[name] = val;\n    }\n  } catch (err) {\n    this.logger.debug(err, 'Failed to set property \"%s\" to %j', name, val);\n  }\n\n  return obj;\n}\n\nfunction _slowSetInternalProperty(obj, name, val) {\n  if (!hasOwnProperty(obj, name)) {\n    Object.defineProperty(obj, name, {\n      enumerable: false,\n      writable: true,\n      value: val\n    });\n  } else {\n    obj[name] = val;\n  }\n}\n/**\n * Defines a read-only property on the given object.\n *\n * @memberof Shim.prototype\n *\n * @param {object} obj\n *  The object to add the property to.\n *\n * @param {string} name\n *  The name of the property to add.\n *\n * @param {*|function} value\n *  The value to set. If a function is given, it is used as a getter, otherwise\n *  the value is directly set as an unwritable property.\n */\n\n\nfunction defineProperty(obj, name, value) {\n  // We have define property! Use that.\n  var prop = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (isFunction(value)) {\n    prop.get = value;\n  } else {\n    prop.writable = false;\n    prop.value = value;\n  }\n\n  Object.defineProperty(obj, name, prop);\n}\n/**\n * Adds several properties to the given object.\n *\n * @memberof Shim.prototype\n *\n * @param {object} obj    - The object to add the properties to.\n * @param {object} props  - A mapping of properties to values to add.\n *\n * @see Shim#defineProperty\n */\n\n\nfunction defineProperties(obj, props) {\n  var keys = Object.keys(props);\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    defineProperty(obj, key, props[key]);\n  }\n}\n/**\n * Performs a shallow copy of each property from `defaults` only if `obj` does\n * not already have that property.\n *\n * @memberof Shim.prototype\n *\n * @param {object?} obj       - The object to copy the defaults onto.\n * @param {object}  defaults  - A mapping of keys to default values.\n *\n * @return {object} The `obj` with the default values copied onto it. If `obj`\n *  was falsey, then a new object with the defaults copied onto it is returned\n *  instead.\n */\n\n\nfunction setDefaults(obj, defaults) {\n  if (!obj) {\n    obj = Object.create(null);\n  }\n\n  var keys = Object.keys(defaults);\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n\n    if (!hasOwnProperty(obj, key)) {\n      obj[key] = defaults[key];\n    }\n  }\n\n  return obj;\n}\n/**\n * Proxies all set/get actions for each given property on `dest` onto `source`.\n *\n * @memberof Shim.prototype\n *\n * @param {*} source\n *  The object on which all the set/get actions will actually occur.\n *\n * @param {string|Array.<string>} properties\n *  All of the properties to proxy.\n *\n * @param {*} dest\n *  The object which is proxying the source's properties.\n */\n\n\nfunction proxy(source, properties, dest) {\n  if (!this.isArray(properties)) {\n    properties = [properties];\n  }\n\n  properties.forEach(function forEachProxyProp(prop) {\n    Object.defineProperty(dest, prop, {\n      get: function proxyGet() {\n        return source[prop];\n      },\n      set: function proxySet(val) {\n        return source[prop] = val;\n      }\n    });\n  });\n}\n/**\n * Loads a node module from the instrumented library's own root directory.\n *\n * @memberof Shim.prototype\n *\n * @param {string} filePath - A relative path inside the module's directory.\n *\n * @return {*?} The result of loading the given module. If the module fails to\n *  load, `null` is returned instead.\n */\n\n\nfunction shimRequire(filePath) {\n  try {\n    return require(path.resolve(this._moduleRoot, filePath));\n  } catch (e) {\n    this.logger.debug('Failed to load %j: %s', filePath, e.stack);\n    return null;\n  }\n}\n/**\n * Executes the given callback when the promise is finalized, whether it is\n * resolved or rejected.\n *\n * @memberof Shim.prototype\n *\n * @param {Promise} prom  - Some kind of promise. Must have a `then` method.\n * @param {Function} cb   - A function to call when the promise resolves.\n *\n * @return {Promise} A new promise to replace the original one.\n */\n\n\nfunction interceptPromise(prom, cb) {\n  if (this.isFunction(prom.finally)) {\n    return prom.finally(cb);\n  }\n\n  return prom.then(function onThen(arg) {\n    cb();\n    return arg;\n  }, function onCatch(err) {\n    cb();\n    throw err; // This is not our error, just rethrowing the promise rejection.\n  });\n}\n/**\n * Copies the given parameters onto the segment, respecting the current agent\n * configuration.\n *\n * @memberof Shim.protoype\n *\n * @param {TraceSegment}  segment     - The segment to copy the parameters onto.\n * @param {object}        parameters  - The paramters to copy.\n */\n\n\nfunction copySegmentParameters(segment, parameters) {\n  for (var key in parameters) {\n    if (hasOwnProperty(parameters, key)) {\n      segment.addAttribute(key, parameters[key]);\n    }\n  }\n}\n/**\n * Enables debugging mode of the shim.\n *\n * In debug mode the shim will track all methods that it wraps so they can be\n * unwrapped. This should _not_ be done in production code because a lot more\n * objects are held onto in memory.\n *\n * @private\n * @memberof Shim.prototype\n */\n\n\nfunction enableDebug() {\n  this.logger.warn('Enabling debug mode for shim!');\n  this._debug = true;\n  this._wrapped = [];\n}\n/**\n * Unwraps everything that the shim has wrapped. Only works if debugging mode is\n * enabled first.\n *\n * @private\n * @member Shim.prototype.__NR_unwrap\n */\n\n\nfunction unwrapAll() {\n  if (this._wrapped) {\n    this.logger.debug('Unwrapping %d items.', this._wrapped.length);\n\n    this._wrapped.forEach(function unwrapEach(wrapped) {\n      this.unwrap(wrapped);\n    }, this);\n  }\n} // -------------------------------------------------------------------------- //\n\n/**\n * Coerces the given spec into a function which {@link Shim#wrap} can use.\n *\n * @private\n *\n * @param {Spec|WrapFunction} spec - The spec to coerce into a function.\n *\n * @return {WrapFunction} The spec itself if spec is a function, otherwise a\n *  function which will execute the spec when called.\n */\n\n/* eslint-disable no-unused-vars */\n\n\nfunction _specToFunction(spec) {\n  throw new Error('Declarative specs are not implemented yet.');\n}\n/* eslint-enable no-unused-vars */\n\n/**\n * Executes the provided spec on the given object.\n *\n * - `_wrap(shim, original, name, spec [, args])`\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim that is executing the wrapping.\n *\n * @param {*} original\n *  The object being wrapped.\n *\n * @param {string} name\n *  A logical name for the item to be wrapped.\n *\n * @param {WrapFunction} spec\n *  The spec for wrapping these items.\n *\n * @param {Array.<*>} [args=[]]\n *  Optional extra arguments to be sent to the spec when executing it.\n *\n * @return {Function} The return value from `spec` or the original value if it\n *  did not return anything.\n */\n\n\nfunction _wrap(shim, original, name, spec, args) {\n  // Assemble the spec's arguments.\n  var specArgs = [shim, original, name];\n\n  if (args && args.length) {\n    specArgs.push.apply(specArgs, args);\n  } // Apply the spec and see if it returned a wrapped version of the property.\n\n\n  var wrapped = spec.wrapper.apply(null, specArgs);\n\n  if (wrapped && wrapped !== original) {\n    if (spec.matchArity && shim.isFunction(wrapped)) {\n      wrapped = arity.fixArity(original, wrapped);\n    } // TODO: Once all wrapping is converted to proxies, we won't need to \n    // set this property as the trap on 'get' will return the original for\n    // __NR_original. For now, we have to prevent setting this on original.\n\n\n    if (!wrapped.__NR_original) {\n      shim.setInternalProperty(wrapped, '__NR_original', original);\n    }\n\n    if (shim._debug) {\n      shim._wrapped.push(wrapped);\n    }\n  } else {\n    wrapped = original;\n  }\n\n  return wrapped;\n}\n/**\n * Creates the `bindSegment` wrapper function in its own, clean closure.\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim used for the binding.\n *\n * @param {function} fn\n *  The function to be bound to the segment.\n *\n * @param {TraceSegment} segment\n *  The segment the function is bound to.\n *\n * @param {boolean} full\n *  Indicates if the segment's full lifetime is bound to the function.\n *\n * @return {function} A function which wraps `fn` and makes the given segment\n *  active for the duration of its execution.\n */\n\n\nfunction _makeBindWrapper(shim, fn, segment, full) {\n  return function wrapper() {\n    return shim.applySegment(fn, segment, full, this, arguments);\n  };\n}\n/**\n * Binds all callbacks identified in the given spec.\n *\n * The callbacks are bound using the method meant for that type if available\n * (i.e. `bindRowCallbackSegment` for `rowCallback`), but will fall back to the\n * generic callback binding method, `bindCallbackSegment`, otherwise.\n *\n * @this *\n * @private\n *\n * @param {Shim} shim\n *  The shim performing this binding.\n *\n * @param {Function} fn\n *  The function the spec describes.\n *\n * @param {string} name\n *  The name of the function the spec describes.\n *\n * @param {Array} args\n *  The arguments to be passed into `fn`.\n *\n * @param {object} spec\n *  The specification for bind the callbacks.\n *\n * @param {SegmentSpec} spec.spec\n *  The segment specification for the function we're pulling callbacks out of.\n *\n * @param {TraceSegment} spec.segment\n *  The segment measuring the function which will be the parent of any callback\n *  segments that may be created.\n *\n * @param {bool} spec.shouldCreateSegment\n *  Flag indicating if we should create segments for the callbacks. We almost\n *  always do, but in the special case of nested internal methods we do not.\n */\n\n\nfunction _bindAllCallbacks(shim, fn, name, args, spec) {\n  // Check for a normal callback.\n  if (hasOwnProperty(spec.spec, 'callback') && spec.spec.callback !== null) {\n    _bindCallback(this, spec.spec.callback, shim.bindCallbackSegment);\n  } // And check for a row callback.\n\n\n  if (hasOwnProperty(spec.spec, 'rowCallback') && spec.spec.rowCallback !== null) {\n    _bindCallback(this, spec.spec.rowCallback, shim.bindRowCallbackSegment || shim.bindCallbackSegment);\n  }\n\n  function _bindCallback(context, callback, binder) {\n    if (shim.isFunction(callback)) {\n      callback.call(context, shim, fn, name, spec.segment, args);\n    } else if (shim.isNumber(callback)) {\n      shim.logger.trace('Binding callback %d segment: %j', callback, !!spec.segment);\n      var cbIdx = normalizeIndex(args.length, callback);\n\n      if (cbIdx !== null) {\n        if (spec.shouldCreateSegment) {\n          binder.call(shim, args, cbIdx, spec.segment);\n        } else {\n          args[cbIdx] = shim.bindSegment(args[cbIdx], spec.segment, true);\n        }\n      }\n    }\n  }\n}\n/**\n * Binds the given segment to the lifetime of the stream.\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim performing the wrapping/binding.\n *\n * @param {EventEmitter} stream\n *  The stream to bind.\n *\n * @param {?TraceSegment} segment\n *  The segment to bind to the stream.\n *\n * @param {Object} [spec]\n *  Specification for how to bind the stream. The `end` and `error` events will\n *  always be bound, so if no functionality is desired beyond that, then this\n *  parameter may be omitted.\n *\n * @param {string} [spec.event]\n *  The name of an event to record. If provided, a new segment will be created\n *  for this event and will measure each time the event is emitted.\n *\n * @param {bool} spec.shouldCreateSegment\n *  Indicates if any child segments should be created. This should always be\n *  true unless this segment and its parent are both internal segments.\n */\n\n\nfunction _bindStream(shim, stream, segment, spec) {\n  if (!segment || !shim.isFunction(stream.emit)) {\n    shim.logger.trace('Not binding stream; have segment=%j; typeof emit=%s', !!segment, typeof stream.emit);\n    return;\n  } // We have a segment and an emit function, pull out the relevant parts of the\n  // spec and prepare to create an event segment.\n\n\n  var specEvent = spec && spec.event || null;\n  var shouldCreateSegment = spec && spec.shouldCreateSegment || false;\n  var segmentName = 'Event callback: ' + specEvent; // Wrap emit such that each event handler is executed within context of this\n  // segment or the event-specific segment.\n\n  shim.wrap(stream, 'emit', function wrapStreamEmit(shim, emit) {\n    var tx = segment.transaction;\n    var streamBoundEmit = shim.bindSegment(emit, segment, true);\n    var eventSegment = null;\n    var eventBoundEmit = null;\n    var emitCount = 0;\n\n    if (!shouldCreateSegment) {\n      return streamBoundEmit;\n    }\n\n    return function wrappedEmit(evnt) {\n      var emitToCall = streamBoundEmit;\n\n      if (evnt === specEvent && tx.isActive()) {\n        if (!eventBoundEmit) {\n          eventSegment = shim.createSegment(segmentName, segment);\n          eventBoundEmit = shim.bindSegment(emit, eventSegment, true);\n        }\n\n        eventSegment.addAttribute('count', ++emitCount);\n        emitToCall = eventBoundEmit;\n      }\n\n      if (evnt === 'end' || evnt === 'error') {\n        segment.opaque = false;\n        segment.touch();\n      }\n\n      return emitToCall.apply(this, arguments);\n    };\n  }); // Also wrap up any listeners for end or error events.\n\n  shim.wrap(stream, ['on', 'addListener'], function wrapOn(shim, fn) {\n    if (!shim.isFunction(fn)) {\n      return fn;\n    }\n\n    return function wrappedOn(onEvent) {\n      if (onEvent !== specEvent && (onEvent === 'end' || onEvent === 'error')) {\n        var args = argsToArray.apply(shim, arguments);\n        shim.bindCallbackSegment(args, shim.LAST, segment);\n        return fn.apply(this, args);\n      }\n\n      return fn.apply(this, arguments);\n    };\n  });\n}\n/**\n * Binds the given segment to the completion of the Promise.\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim performing the wrapping/binding.\n *\n * @param {!Promise} promise\n *  The Promise to bind.\n *\n * @param {!TraceSegment} segment\n *  The segment to bind to the Promise.\n *\n * @return {Promise} The promise to continue with.\n */\n\n\nfunction _bindPromise(shim, promise, segment) {\n  return shim.interceptPromise(promise, function thenTouch() {\n    segment.opaque = false;\n    segment.touch();\n  });\n}\n/**\n* Wraps an es6-style class using a subclass.\n*\n* - `_es6WrapClass(shim, Base, fnName, spec, args)`\n*\n* @private\n*\n* @param {Shim} shim\n*  The shim performing the wrapping/binding.\n*\n* @param {class} Base\n*  The es6 class to be wrapped.\n*\n* @param {string} fnName\n*  The name of the base class.\n*\n* @param {ClassWrapSpec} spec\n*  The spec with pre- and post-execution hooks to call.\n*\n* @param {Array.<*>} args\n*  Extra arguments to pass through to the pre- and post-execution hooks.\n*\n* @return {class} A class that extends Base with execution hooks.\n */\n\n\nfunction _es6WrapClass(shim, Base, fnName, spec, args) {\n  return class WrappedClass extends Base {\n    constructor() {\n      var cnstrctArgs = shim.argsToArray.apply(shim, arguments); // Assemble the arguments to hand to the spec.\n\n      var _args = [shim, Base, fnName, cnstrctArgs];\n\n      if (args.length > 0) {\n        _args.push.apply(_args, args);\n      } // Call the spec's before hook, then call the base constructor, then call\n      // the spec's after hook.\n\n\n      spec.pre && spec.pre.apply(null, _args);\n      super(...cnstrctArgs);\n      spec.post && spec.post.apply(this, _args);\n    }\n\n  };\n}\n/**\n * Wraps an es5-style class using a subclass.\n *\n * - `_es5WrapClass(shim, Base, fnName, spec, args)`\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim performing the wrapping/binding.\n *\n * @param {Function} Base\n *  The class to be wrapped.\n *\n * @param {string} fnName\n *  The name of the base class.\n *\n * @param {ClassWrapSpec} spec\n *  The spec with pre- and post-execution hooks to call.\n *\n * @param {Array.<*>} args\n *  Extra arguments to pass through to the pre- and post-execution hooks.\n *\n * @return {Function} A class that extends Base with execution hooks.\n */\n\n\nfunction _es5WrapClass(shim, Base, fnName, spec, args) {\n  function WrappedClass() {\n    var cnstrctArgs = argsToArray.apply(shim, arguments);\n\n    if (!(this instanceof WrappedClass)) {\n      // Some libraries support calling constructors without the `new` keyword.\n      // In order to support this we must apply the super constructor if `this`\n      // is not an instance of ourself. JavaScript really needs a better way\n      // to generically apply constructors.\n      cnstrctArgs.unshift(WrappedClass); // `unshift` === `push_front`\n\n      return new (WrappedClass.bind.apply(WrappedClass, cnstrctArgs))();\n    } // Assemble the arguments to hand to the spec.\n\n\n    var _args = [shim, Base, fnName, cnstrctArgs];\n\n    if (args.length > 0) {\n      _args.push.apply(_args, args);\n    } // Call the spec's before hook, then call the base constructor, then call\n    // the spec's after hook.\n\n\n    spec.pre && spec.pre.apply(null, _args);\n    Base.apply(this, cnstrctArgs);\n    spec.post && spec.post.apply(this, _args);\n  }\n\n  util.inherits(WrappedClass, Base);\n  WrappedClass.prototype = Base.prototype;\n  return WrappedClass;\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/shim/shim.js"],"names":["arity","require","constants","events","hasOwnProperty","hasOwn","logger","child","component","path","specs","util","fnApply","Function","prototype","apply","Shim","agent","moduleName","resolvedName","Error","_logger","module","_agent","_toExport","_debug","defineProperty","moduleRoot","next","dirname","length","test","_moduleRoot","exports","defineProperties","ARG_INDEXES","SYMBOLS","getAgent","tracer","getTracer","getLogger","wrap","bindSegment","execute","wrapReturn","wrapClass","wrapExport","record","isWrapped","unwrap","unwrapOnce","getOriginal","getSegment","getActiveSegment","setActiveSegment","storeSegment","bindCallbackSegment","applySegment","createSegment","getName","isObject","isFunction","isPromise","isString","isNumber","isBoolean","isArray","isNull","toArray","argsToArray","normalizeIndex","listenerCount","once","setInternalProperty","setDefaults","proxy","shimRequire","copySegmentParameters","interceptPromise","fixArity","getExport","enableDebug","__NR_unwrap","unwrapAll","nodule","spec","_specToFunction","properties","args","debug","wrapper","matchArity","name","trace","_wrap","forEach","wrapEachProperty","prop","original","wrapped","unwrapWrap","returnWrapper","shim","fn","fnName","unwrapReference","handler","get","getTrap","target","definePropertyTrap","key","descriptor","value","Object","set","setTrap","val","construct","constructTrap","Target","proxyArgs","ret","_args","push","newRet","applyTrap","thisArg","Proxy","pre","post","classWrapper","Base","es6","toString","_es6WrapClass","_es5WrapClass","defaultExport","property","__NR_original","recordNamer","makeWrapper","arguments","segDesc","call","RecorderSpec","parent","transaction","isActive","callbackRequired","_hasValidCallbackArg","callback","shouldCreateSegment","opaque","internal","segment","_rawCreateSegment","_doRecord","specCallback","cbIdx","_bindAllCallbacks","_applyRecorderSegment","stream","_bindStream","event","promise","_bindPromise","ctx","error","promised","inContext","after","then","onThen","touch","onCatch","err","bind","full","wrapFunc","func","binder","_makeBindWrapper","parentSegment","normalizedCBIdx","cb","realParent","callbackWrapper","wrappedCallback","SegmentSpec","async","obj","__NR_segment","context","inContextCB","prevSegment","start","process","domain","recorder","opts","parameters","String","Array","len","arr","i","arrayLength","idx","emitter","evnt","EventEmitter","listeners","called","onceCaller","config","transaction_tracer","hide_internals","_slowSetInternalProperty","enumerable","writable","configurable","props","keys","defaults","create","source","dest","forEachProxyProp","proxyGet","proxySet","filePath","resolve","e","stack","prom","finally","arg","addAttribute","warn","_wrapped","unwrapEach","specArgs","_bindCallback","rowCallback","bindRowCallbackSegment","emit","specEvent","segmentName","wrapStreamEmit","tx","streamBoundEmit","eventSegment","eventBoundEmit","emitCount","wrappedEmit","emitToCall","wrapOn","wrappedOn","onEvent","LAST","thenTouch","WrappedClass","constructor","cnstrctArgs","unshift","inherits"],"mappings":"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","sourcesContent":["'use strict'\n\nconst arity = require('../util/arity')\nconst constants = require('./constants')\nconst events = require('events')\nconst hasOwnProperty = require('../util/properties').hasOwn\nconst logger = require('../logger').child({component: 'Shim'})\nconst path = require('path')\nconst specs = require('./specs')\nconst util = require('util')\n\n// Some modules do terrible things, like change the prototype of functions. To\n// avoid crashing things we'll use a cached copy of apply everywhere.\nconst fnApply = Function.prototype.apply\n\n/**\n * Constructs a shim associated with the given agent instance.\n *\n * @constructor\n * @classdesc\n *  A helper class for wrapping modules with segments.\n *\n * @param {Agent}   agent         - The agent this shim will use.\n * @param {string}  moduleName    - The name of the module being instrumented.\n * @param {string}  resolvedName  - The full path to the loaded module.\n */\nfunction Shim(agent, moduleName, resolvedName) {\n  if (!agent || !moduleName) {\n    throw new Error('Shim must be initialized with an agent and module name.')\n  }\n\n  this._logger = logger.child({module: moduleName})\n  this._agent = agent\n  this._toExport = null\n  this._debug = false\n  this.defineProperty(this, 'moduleName', moduleName)\n\n  // Determine the root directory of the module.\n  var moduleRoot = null\n  var next = resolvedName || '/'\n  do {\n    moduleRoot = next\n    next = path.dirname(moduleRoot)\n  } while (moduleRoot.length > 1 && !/node_modules(?:\\/@[^/]+)?$/.test(next))\n  this._moduleRoot = moduleRoot\n}\nmodule.exports = Shim\n\nShim.defineProperty = defineProperty\nShim.defineProperties = defineProperties\n\n// Copy the argument index enumeration onto the shim.\nShim.prototype.ARG_INDEXES = specs.ARG_INDEXES\ndefineProperties(Shim.prototype, specs.ARG_INDEXES)\n\n// Copy symbols to the shim as well.\ndefineProperties(Shim, constants.SYMBOLS)\ndefineProperties(Shim.prototype, constants.SYMBOLS)\n\n// Define other miscellaneous properties of the shim.\ndefineProperties(Shim.prototype, {\n  /**\n   * The agent associated with this shim.\n   *\n   * @readonly\n   * @member {Agent} Shim.prototype.agent\n   */\n  agent: function getAgent() {\n    return this._agent\n  },\n\n  /**\n   * The tracer in use by the agent for the shim.\n   *\n   * @readonly\n   * @member {Tracer} Shim.prototype.tracer\n   */\n  tracer: function getTracer() {\n    return this._agent.tracer\n  },\n\n  /**\n   * The logger for this shim.\n   *\n   * @readonly\n   * @member {Logger} Shim.prototype.logger\n   */\n  logger: function getLogger() {\n    return this._logger\n  }\n})\n\nShim.prototype.wrap = wrap\nShim.prototype.bindSegment = bindSegment\n\nShim.prototype.execute = execute\nShim.prototype.wrapReturn = wrapReturn\nShim.prototype.wrapClass = wrapClass\nShim.prototype.wrapExport = wrapExport\nShim.prototype.record = record\nShim.prototype.isWrapped = isWrapped\nShim.prototype.unwrap = unwrap\nShim.prototype.unwrapOnce = unwrapOnce\nShim.prototype.getOriginal = getOriginal\nShim.prototype.getSegment = getSegment\nShim.prototype.getActiveSegment = getActiveSegment\nShim.prototype.setActiveSegment = setActiveSegment\nShim.prototype.storeSegment = storeSegment\nShim.prototype.bindCallbackSegment = bindCallbackSegment\nShim.prototype.applySegment = applySegment\nShim.prototype.createSegment = createSegment\nShim.prototype.getName = getName\nShim.prototype.isObject = isObject\nShim.prototype.isFunction = isFunction\nShim.prototype.isPromise = isPromise\nShim.prototype.isString = isString\nShim.prototype.isNumber = isNumber\nShim.prototype.isBoolean = isBoolean\nShim.prototype.isArray = isArray\nShim.prototype.isNull = isNull\nShim.prototype.toArray = toArray\nShim.prototype.argsToArray = argsToArray\nShim.prototype.normalizeIndex = normalizeIndex\nShim.prototype.listenerCount = listenerCount\nShim.prototype.once = once\n\nShim.prototype.setInternalProperty = setInternalProperty\n\nShim.prototype.defineProperty = defineProperty\nShim.prototype.defineProperties = defineProperties\nShim.prototype.setDefaults = setDefaults\nShim.prototype.proxy = proxy\nShim.prototype.require = shimRequire\nShim.prototype.copySegmentParameters = copySegmentParameters\nShim.prototype.interceptPromise = interceptPromise\nShim.prototype.fixArity = arity.fixArity\n\n// Internal methods.\nShim.prototype.getExport = getExport\nShim.prototype.enableDebug = enableDebug\nShim.prototype.__NR_unwrap = unwrapAll\n\n// -------------------------------------------------------------------------- //\n\n/**\n * @callback WrapFunction\n *\n * @summary\n *  A function which performs the actual wrapping logic.\n *\n * @description\n *  If the return value of this function is not `original` then the return value\n *  will be marked as a wrapper.\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Object|Function} original\n *  The item which needs wrapping. Most of the time this will be a function.\n *\n * @param {string} name\n *  The name of `original` if it can be determined, otherwise `'<anonymous>'`.\n *\n * @return {*} The wrapper for the original, or the original value itself.\n */\n\n/**\n * @private\n * @callback ArrayWrapFunction\n *\n * @description\n *   A wrap function used on elements of an array. In addition to the parameters\n *   of `WrapFunction`, these also receive an `index` and `total` as described\n *   below.\n *\n * @see WrapFunction\n *\n * @param {number} index - The index of the current element in the array.\n * @param {number} total - The total number of items in the array.\n */\n\n/**\n * @private\n * @callback ArgumentsFunction\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Function} func\n *  The function these arguments were passed to.\n *\n * @param {*} context\n *  The context the function is executing under (i.e. `this`).\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the function.\n */\n\n/**\n * @callback SegmentFunction\n *\n * @summary\n *  A function which is called to compose a segment.\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Function} func\n *  The function the segment is created for.\n *\n * @param {string} name\n *  The name of the function.\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the function.\n *\n * @return {string|SegmentSpec} The desired properties for the new segment.\n */\n\n/**\n * @callback RecorderFunction\n *\n * @summary\n *  A function which is called to compose a segment for recording.\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Function} func\n *  The function being recorded.\n *\n * @param {string} name\n *  The name of the function.\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the function.\n *\n * @return {string|RecorderSpec} The desired properties for the new segment.\n */\n\n/**\n * @callback CallbackBindFunction\n *\n * @summary\n *  Performs segment binding on a callback function. Useful when identifying a\n *  callback is more complex than a simple argument offset.\n *\n * @param {Shim} shim\n *  The shim this function was passed to.\n *\n * @param {Function} func\n *  The function being recorded.\n *\n * @param {string} name\n *  The name of the function.\n *\n * @param {TraceSegment} segment\n *  The segment that the callback should be bound to.\n *\n * @param {Array.<*>} args\n *  The arguments being passed into the function.\n */\n\n/**\n * @private\n * @callback MetricFunction\n *\n * @summary\n *  Measures all the necessary metrics for the given segment. This functionality\n *  is meant to be used by Shim subclasses, instrumentations should never create\n *  their own recorders.\n *\n * @param {TraceSegment}  segment - The segment to record.\n * @param {string}        [scope] - The scope of the recording.\n */\n\n/**\n * @callback ConstructorHookFunction\n *\n * @summary\n *  Pre/post constructor execution hook for wrapping classes. Used by\n *  {@link ClassWrapSpec}.\n *\n * @param {Shim} shim\n *  The shim performing the wrapping/binding.\n *\n * @param {Function} Base\n *  The class that was wrapped.\n *\n * @param {string} name\n *  The name of the `Base` class.\n *\n * @param {Array.<*>} args\n *  The arguments to the class constructor.\n *\n * @see ClassWrapSpec\n */\n\n/**\n * @private\n * @interface Spec\n *\n * @description\n *  The syntax for declarative instrumentation. It can be used interlaced with\n *  custom, hand-written instrumentation for one-off or hard to simplifiy\n *  instrumentation logic.\n *\n * @property {Spec|WrapFunction} $return\n *  Changes the context to the return value of the current context. This means\n *  the sub spec will not be executed up front, but instead upon every execution\n *  of the current context.\n *\n *  ```js\n *  var ret = func.apply(this, args);\n *  return shim.wrap(ret, spec.$return)\n *  ```\n *\n * @property {Spec|WrapFunction} $proto\n *  Changes the context to the prototype of the current context. The prototype\n *  is found using `Object.getPrototypeOf`.\n *\n *  ```js\n *  shim.wrap(Object.getPrototypeOf(context), spec.$proto)\n *  ```\n *\n * @property {bool} $once\n *  Ensures that the parent spec will only be executed one time if the value is\n *  `true`. Good for preventing double wrapping of prototype methods.\n *\n *  ```js\n *  if (spec.$once && spec.__NR_onceExecuted) {\n *    return context\n *  }\n *  spec.__NR_onceExecuted = true\n *  ```\n *\n * @property {ArgumentsFunction} $arguments\n *  Executes the function with all of the arguments passed in. The arguments can\n *  be modified in place. This will execute before `$eachArgument`.\n *\n *  ```js\n *  spec.$arguments(args)\n *  ```\n *\n * @property {Spec|ArrayWrapFunction} $eachArgument\n *  Executes `shim.wrap` on each argument passed to the current context. The\n *  returned arguments will then be used to actually execute the function.\n *\n *  ```js\n *  var argLength = arguments.length\n *  var extraArgs = extras.concat([0, argLength])\n *  var iIdx = extraArgs.length - 2\n *  var args = new Array(argLength)\n *  for (var i = 0; i < argLength; ++i) {\n *    extraArgs[iIdx] = i\n *    args[i] = shim.wrap(arguments[i], spec.$eachArgument, extraArgs)\n *  }\n *  func.apply(this, args)\n *  ```\n *\n * @property {Array.<{$properties: Array.<string>, $spec: Spec}>} $wrappings\n *  Executes `shim.wrap` with the current context as the `nodule` for each\n *  element in the array. The `$properties` sub-key must list one or more\n *  properties to be wrapped. The `$spec` sub-key must be a {@link Spec} or\n *  {@link WrapFunction} for wrapping the properties.\n *\n *  ```js\n *  spec.$wrappings.forEach(function($wrap) {\n *    shim.wrap(context, $wrap.$properties, $wrap.$spec)\n *  })\n *  ```\n *\n * @property {bool|string|SegmentFunction} $segment\n *  Controls segment creation. If a falsey value (i.e. `undefined`, `false`,\n *  `null`, etc) then no segment will be created. If the value is `true`, then\n *  the name of the current context is used to name the segment. If the value is\n *  a string then that string will be the name of the segment. Lastly, if the\n *  value is a function, that function will be called with the current context\n *  and arguments.\n *\n *  ```js\n *  var segment = null\n *  if (spec.$segment) {\n *    var seg = {name: spec.$segment}\n *    if (shim.isFunction(seg.name)) {\n *      seg = seg.name(func, this, arguments)\n *    }\n *    else if (seg.name === true) {\n *      seg.name = func.name\n *    }\n *    segment = shim.createSegment(seg.name, seg.recorder, seg.parent)\n *  }\n *  ```\n *\n * @property {Object.<string, *>} $cache\n *  Adds the value as an extra parameter to all specs in the same context as the\n *  cache. If the current context is a function, the cache will be recreated on\n *  each invocation of the function. This value can be useful for passing a\n *  value at runtime from one spec into another.\n *\n *  ```js\n *  var args = extras || []\n *  if (spec.$cache) {\n *    args.push({})\n *  }\n *  ```\n *\n * @property {number} $callback\n *  Indicates that one of the parameters is a callback which should be wrapped.\n *\n *  ```js\n *  if (shim.isNumber(spec.$callback)) {\n *    var idx = spec.$callback\n *    if (idx < 0) {\n *      idx = args.length + idx\n *    }\n *    args[idx] = shim.bindSegment(args[idx], segment)\n *  }\n *  ```\n *\n * @property {Spec|WrapFunction} property\n *  Any field which does not start with a `$` is assumed to name a property on\n *  the current context which should be wrapped. This is simply shorthand for a\n *  `$wrappings` with only one `$properties` value.\n */\n\n/**\n * @interface SegmentSpec\n *\n * @description\n *  The return value from a {@link SegmentFunction}, used to set the parameters\n *  of segment creation.\n *\n * @property {string} name\n *  The name for the segment to-be.\n *\n * @property {MetricFunction} [recorder]\n *  A metric recorder for the segment. This is purely for internal use by shim\n *  classes. Instrumentations should never implement their own metric functions.\n *\n * @property {TraceSegment} [parent]\n *  The parent segment. Defaults to the currently active segment.\n *\n * @see RecorderSpec\n * @see SegmentFunction\n */\n\n/**\n * @interface RecorderSpec\n * @extends SegmentSpec\n *\n * @description\n *  The return value from a {@link RecorderFunction}, used to set the parameters\n *  of segment creation and lifetime. Extends the {@link SegmentSpec}.\n *\n * @property {bool|string} [stream]\n *  Indicates if the return value from the wrapped function is a stream. If the\n *  value is truthy then the recording will extend to the `end` event of the\n *  stream. If the value is a string it is assumed to be the name of an event to\n *  measure. A segment will be created to record emissions of the event.\n *\n * @property {bool} [promise]\n *  Indicates if the return value from the wrapped function is a Promise. If the\n *  value is truthy then the recording will extend to the completion of the\n *  Promise.\n *\n * @property {number|CallbackBindFunction} [callback]\n *  If this is a number, it identifies which argument is the callback and the\n *  segment will also be bound to the callback. Otherwise, the passed function\n *  should perform the segment binding itself.\n *\n * @property {number|CallbackBindFunction} [rowCallback]\n *  Like `callback`, this identifies a callback function in the arguments. The\n *  difference is that the default behavior for row callbacks is to only create\n *  one segment for all calls to the callback. This is mostly useful for\n *  functions which will be called repeatedly, such as once for each item in a\n *  result set.\n *\n * @property {bool} [internal=false]\n *  Marks this as the boundary point into the instrumented library. If `true`\n *  and the current segment is _also_ marked as `internal` by the same shim,\n *  then we will not record this inner activity.\n *\n *  This is useful when instrumenting a library which implements high-order\n *  methods which simply call other public methods and you only want to record\n *  the method directly called by the user while still instrumenting all\n *  endpoints.\n *\n * @property {function} [after=null]\n *  A function to call after the synchronous execution of the recorded method.\n *  If the function synchronously threw an error, that error will be handed to\n *  this function.\n *\n * @property {bool} [callbackRequired]\n *  When `true`, a recorded method must be called with a callback for a segment\n *  to be created. Does not apply if a custom callback method has been assigned\n *  via {@link callback}.\n *\n * @see SegmentSpec\n * @see RecorderFunction\n */\n\n/**\n * @interface ClassWrapSpec\n *\n * @description\n *  Specifies the style of wrapping and construction hooks for wrapping classes.\n *\n * @property {bool} [es6=false]\n * @property {ConstructorHookFunction} [pre=null]\n *  A function called with the constructor's arguments before the base class'\n *  constructor is executed. The `this` value will be `null`.\n *\n * @property {ConstructorHookFunction} [post=null]\n *  A function called with the constructor's arguments after the base class'\n *  constructor is executed. The `this` value will be the just-constructed object.\n *\n */\n\n// -------------------------------------------------------------------------- //\n\n/**\n * Entry point for executing a spec.\n *\n * @memberof Shim.prototype\n */\nfunction execute(nodule, spec) {\n  if (this.isFunction(spec)) {\n    spec(this, nodule)\n  } else {\n    _specToFunction(spec)(this, nodule)\n  }\n}\n\n/**\n * Executes the provided spec on one or more objects.\n *\n * - `wrap(nodule, properties, spec [, args])`\n * - `wrap(func, spec [, args])`\n *\n * When called with a `nodule` and one or more properties, the spec will be\n * executed on each property listed and the return value put back on the\n * `nodule`.\n *\n * When called with just a function, the spec will be executed on the function\n * and the return value of the spec simply passed back.\n *\n * The wrapped version will have the same prototype as the original\n * method.\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {Spec|WrapFunction} spec\n *  The spec for wrapping these items.\n *\n * @param {Array.<*>} [args=[]]\n *  Optional extra arguments to be sent to the spec when executing it.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see WrapFunction\n */\nfunction wrap(nodule, properties, spec, args) {\n  if (!nodule) {\n    this.logger.debug('Not wrapping non-existent nodule.')\n    return nodule\n  }\n\n  // Sort out the parameters.\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // wrap(nodule, spec [, args])\n    args = spec\n    spec = properties\n    properties = null\n  }\n  if (this.isFunction(spec)) {\n    // wrap(nodule [, properties], wrapper [, args])\n    spec = {\n      wrapper: spec\n    }\n  }\n\n  // TODO: Add option for omitting __NR_original; unwrappable: false\n  spec = this.setDefaults(spec, {matchArity: false})\n\n  // If we're just wrapping one thing, just wrap it and return.\n  if (properties == null) {\n    const name = this.getName(nodule)\n    this.logger.trace('Wrapping nodule itself (%s).', name)\n    return _wrap(this, nodule, name, spec, args)\n  }\n\n  // Coerce properties into an array.\n  if (!this.isArray(properties)) {\n    properties = [properties]\n  }\n\n  // Wrap each property and return the nodule.\n  this.logger.trace('Wrapping %d properties on nodule.', properties.length)\n  properties.forEach(function wrapEachProperty(prop) {\n    // Skip nonexistent properties.\n    var original = nodule[prop]\n    if (!original) {\n      this.logger.debug('Not wrapping missing property \"%s\"', prop)\n      return\n    }\n\n    // Wrap up the property and add a special unwrapper.\n    var wrapped = _wrap(this, original, prop, spec, args)\n    if (wrapped && wrapped !== original) {\n      this.logger.trace('Replacing \"%s\" with wrapped version', prop)\n\n      nodule[prop] = wrapped\n      this.setInternalProperty(wrapped, '__NR_unwrap', function unwrapWrap() {\n        nodule[prop] = original\n        return original\n      })\n    }\n  }, this)\n  return nodule\n}\n\n/**\n * Executes the provided spec with the return value of the given properties.\n *\n * - `wrapReturn(nodule, properties, spec [, args])`\n * - `wrapReturn(func, spec [, args])`\n *\n * If the wrapper is executed with `new` then the wrapped function will also be\n * called with `new`. This feature should only be used with factory methods\n * disguised as classes. Normally {@link Shim#wrapClass} should be used to wrap\n * constructors instead.\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to wrap.\n *\n * @param {Spec|WrapReturnFunction} spec\n *  The spec for wrapping the returned value from the properties.\n *\n * @param {Array.<*>} [args=[]]\n *  Optional extra arguments to be sent to the spec when executing it.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n * @see WrapReturnFunction\n */\nfunction wrapReturn(nodule, properties, spec, args) {\n  // Munge our parameters as needed.\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // wrapReturn(nodule, spec [, args])\n    args = spec\n    spec = properties\n    properties = null\n  }\n  if (!this.isFunction(spec)) {\n    spec = _specToFunction(spec)\n  }\n  if (!this.isArray(args)) {\n    args = []\n  }\n\n  // Perform the wrapping!\n  return this.wrap(nodule, properties, function returnWrapper(shim, fn, fnName) {\n    // Only functions can have return values for us to wrap.\n    if (!shim.isFunction(fn)) {\n      return fn\n    }\n\n    let unwrapReference = null\n    const handler = {\n      get: function getTrap(target, prop) {\n        // Allow for look up of the target\n        if (prop === '__NR_original') {\n          return target\n        }\n        if (prop === '__NR_unwrap') {\n          return unwrapReference\n        }\n\n        return target[prop]\n      },\n      defineProperty: function definePropertyTrap(target, key, descriptor) {\n        if (key === '__NR_unwrap') {\n          unwrapReference = descriptor.value\n        } else {\n          Object.defineProperty(target, key, descriptor)\n        }\n        return true\n      },\n      set: function setTrap(target, key, val) {\n        if (key === '__NR_unwrap') {\n          unwrapReference = val\n        } else {\n          target[key] = val\n        }\n        return true\n      },\n      construct: function constructTrap(Target, proxyArgs) {\n        // Call the underlying function. If this was called as a constructor, call\n        // the wrapped function as a constructor too.\n        let ret = new Target(...proxyArgs)\n\n        // Assemble the arguments to hand to the spec.\n        const _args = [shim, fn, fnName, ret]\n        if (args.length > 0) {\n          _args.push.apply(_args, args)\n        }\n\n        // Call the spec and see if it handed back a different return value.\n        const newRet = spec.apply(ret, _args)\n        if (newRet) {\n          ret = newRet\n        }\n\n        return ret\n      },\n      apply: function applyTrap(target, thisArg, proxyArgs) {\n        // Call the underlying function. If this was called as a constructor, call\n        // the wrapped function as a constructor too.\n        let ret = target.apply(thisArg, proxyArgs)\n\n        // Assemble the arguments to hand to the spec.\n        const _args = [shim, fn, fnName, ret]\n        if (args.length > 0) {\n          _args.push.apply(_args, args)\n        }\n\n        // Call the spec and see if it handed back a different return value.\n        const newRet = spec.apply(thisArg, _args)\n        if (newRet) {\n          ret = newRet\n        }\n\n        return ret\n      }\n    }\n    return new Proxy(fn, handler)\n  })\n}\n\n/**\n * Wraps a class constructor using a subclass with pre- and post-construction\n * hooks.\n *\n * - `wrapClass(nodule, properties, spec [, args])`\n * - `wrapClass(func, spec [, args])`\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to wrap, or a single function to wrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to wrap. If omitted, the `nodule` parameter is\n *  assumed to be the constructor to wrap.\n *\n * @param {ClassWrapSpec|ConstructorHookFunction} spec\n *  The spec for wrapping the returned value from the properties or a post hook.\n *\n * @param {Array.<*>} [args=[]]\n *  Optional extra arguments to be sent to the spec when executing it.\n *\n * @return {Object|Function} The first parameter to this function, after\n *  wrapping it or its properties.\n *\n * @see Shim#wrap\n */\nfunction wrapClass(nodule, properties, spec, args) {\n  // Munge our parameters as needed.\n  if (this.isObject(properties) && !this.isArray(properties)) {\n    // wrapReturn(nodule, spec [, args])\n    args = spec\n    spec = properties\n    properties = null\n  }\n  if (this.isFunction(spec)) {\n    spec = {pre: null, post: spec}\n  } else {\n    spec.pre = spec.pre || null\n    spec.post = spec.post || null\n  }\n  if (!this.isArray(args)) {\n    args = []\n  }\n\n  // Perform the wrapping!\n  return this.wrap(nodule, properties, function classWrapper(shim, Base, fnName) {\n    // Only functions can have return values for us to wrap.\n    if (!shim.isFunction(Base) || shim.isWrapped(Base)) {\n      return Base\n    }\n\n    // When es6 classes are being wrapped, we need to use an es6 class due to\n    // the fact our es5 wrapper depends on calling the constructor without `new`.\n    var wrapper = spec.es6 || /^class /.test(Base.toString())\n      ? _es6WrapClass\n      : _es5WrapClass\n\n    return wrapper(shim, Base, fnName, spec, args)\n  })\n}\n\n/**\n * Wraps the actual module being instrumented to change what `require` returns.\n *\n * - `wrapExport(nodule, spec)`\n *\n * @memberof Shim.prototype\n *\n * @param {*} nodule\n *  The original export to replace with our new one.\n *\n * @param {WrapFunction} spec\n *  A wrapper function. The return value from this spec is what will replace\n *  the export.\n *\n * @return {*} The return value from `spec`.\n */\nfunction wrapExport(nodule, spec) {\n  return this._toExport = this.wrap(nodule, null, spec)\n}\n\n/**\n * If the export was wrapped, that wrapper is returned, otherwise `defaultExport`.\n *\n * @private\n * @memberof Shim.prototype\n *\n * @param {*} defaultExport - The original export in case it was never wrapped.\n *\n * @return {*} The result from calling {@link Shim#wrapExport} or `defaultExport`\n *  if it was never used.\n *\n * @see Shim.wrapExport\n */\nfunction getExport(defaultExport) {\n  return this._toExport || defaultExport\n}\n\n/**\n * Determines if the specified function or property exists and is wrapped.\n *\n * - `isWrapped(nodule, property)`\n * - `isWrapped(func)`\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the property or a single function to check.\n *\n * @param {string} [property]\n *  The property to check. If omitted, the `nodule` parameter is assumed to be\n *  the function to check.\n *\n * @return {bool} True if the item exists and has been wrapped.\n *\n * @see Shim#wrap\n * @see Shim#bindSegment\n */\nfunction isWrapped(nodule, property) {\n  if (property) {\n    return !!(nodule && nodule[property] && nodule[property].__NR_original)\n  }\n  return !!(nodule && nodule.__NR_original)\n}\n\n/**\n * Wraps a function with segment creation and binding.\n *\n * - `record(nodule, properties, recordNamer)`\n * - `record(func, recordNamer)`\n *\n * This is shorthand for calling {@link Shim#wrap} and manually creating a segment.\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to record, or a single function to record.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to record. If omitted, the `nodule` parameter is\n *  assumed to be the function to record.\n *\n * @param {RecorderFunction} recordNamer\n *  A function which returns a record descriptor that gives the name and type of\n *  record we'll make.\n *\n * @return {Object|Function} The first parameter, possibly wrapped.\n *\n * @see RecorderFunction\n * @see RecorderSpec\n * @see Shim#wrap\n */\nfunction record(nodule, properties, recordNamer) {\n  if (this.isFunction(properties)) {\n    recordNamer = properties\n    properties = null\n  }\n\n  return this.wrap(nodule, properties, function makeWrapper(shim, fn, name) {\n    // Can't record things that aren't functions.\n    if (!shim.isFunction(fn)) {\n      shim.logger.debug('Not recording non-function \"%s\".', name)\n      return fn\n    }\n    shim.logger.trace('Wrapping \"%s\" with metric recording.', name)\n\n    return function wrapper() {\n      // Create the segment that will be recorded.\n      var args = argsToArray.apply(shim, arguments)\n      var segDesc = recordNamer.call(this, shim, fn, name, args)\n      if (!segDesc) {\n        shim.logger.trace('No segment descriptor for \"%s\", not recording.', name)\n        return fnApply.call(fn, this, args)\n      }\n      segDesc = new specs.RecorderSpec(segDesc)\n\n      // See if we're in an active transaction.\n      var parent\n      if (segDesc.parent) {\n        // We only want to continue recording in a transaction if the\n        // transaction is active.\n        parent = segDesc.parent.transaction.isActive() ? segDesc.parent : null\n      } else {\n        parent = shim.getActiveSegment()\n      }\n\n      if (!parent) {\n        shim.logger.debug('Not recording function %s, not in a transaction.', name)\n        return fnApply.call(fn, this, arguments)\n      }\n\n      if (\n        segDesc.callbackRequired &&\n        !_hasValidCallbackArg(shim, args, segDesc.callback)\n      ) {\n        return fnApply.call(fn, this, arguments)\n      }\n\n      // Only create a segment if:\n      //  - We are _not_ making an internal segment.\n      //  - OR the parent segment is either not internal or not from this shim.\n      var shouldCreateSegment = !(\n        parent.opaque || (segDesc.internal && parent.internal && shim === parent.shim)\n      )\n\n      var segment = shouldCreateSegment ? _rawCreateSegment(shim, segDesc) : parent\n\n      return _doRecord.call(this, segment, args, segDesc, shouldCreateSegment)\n    }\n\n    function _hasValidCallbackArg(shim, args, specCallback) {\n      if (shim.isNumber(specCallback)) {\n        const cbIdx = normalizeIndex(args.length, specCallback)\n        if (cbIdx === null) {\n          return false\n        }\n\n        const callback = args[cbIdx]\n        return shim.isFunction(callback)\n      }\n\n      return true\n    }\n\n    function _doRecord(segment, args, segDesc, shouldCreateSegment) {\n      // Now bind any callbacks specified in the segment descriptor.\n      _bindAllCallbacks.call(this, shim, fn, name, args, {\n        spec: segDesc,\n        segment: segment,\n        shouldCreateSegment: shouldCreateSegment\n      })\n\n      // Apply the function, and (if it returned a stream) bind that too.\n      // If you are looking here Geoff, the reason there is no check for\n      // `segment` is because it should be guaranteed by the parent and active\n      // transaction check at the beginning of this function. :)\n      var ret = _applyRecorderSegment(segment, this, args, segDesc)\n      if (ret) {\n        if (segDesc.stream) {\n          shim.logger.trace('Binding return value as stream.')\n          _bindStream(shim, ret, segment, {\n            event: shim.isString(segDesc.stream) ? segDesc.stream : null,\n            shouldCreateSegment: shouldCreateSegment\n          })\n        } else if (segDesc.promise && shim.isPromise(ret)) {\n          shim.logger.trace('Binding return value as Promise.')\n          ret = _bindPromise(shim, ret, segment)\n        }\n      }\n      return ret\n    }\n\n    function _applyRecorderSegment(segment, ctx, args, segDesc) {\n      var error = null\n      var promised = false\n      var ret\n      try {\n        ret = shim.applySegment(fn, segment, true, ctx, args, segDesc.inContext)\n        if (segDesc.after && segDesc.promise && shim.isPromise(ret)) {\n          promised = true\n          return ret.then(function onThen(val) {\n            segment.touch()\n            segDesc.after(shim, fn, name, null, val)\n            return val\n          }, function onCatch(err) {\n            segment.touch()\n            segDesc.after(shim, fn, name, err, null)\n            throw err // NOTE: This is not an error from our instrumentation.\n          })\n        }\n        return ret\n      } catch (err) {\n        error = err\n        throw err // Just rethrowing this error, not our error!\n      } finally {\n        if (segDesc.after && (error || !promised)) {\n          segDesc.after(shim, fn, name, error, ret)\n        }\n      }\n    }\n  })\n}\n\n/**\n * Unwraps one or more items, revealing the original value.\n *\n * - `unwrap(nodule, property)`\n * - `unwrap(func)`\n *\n * If called with a `nodule` and properties, the unwrapped values will be put\n * back on the nodule. Otherwise, the unwrapped function is just returned.\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to unwrap, or a single function to unwrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to unwrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to unwrap.\n *\n * @return {Object|Function} The first parameter after unwrapping.\n */\nfunction unwrap(nodule, properties) {\n  // Don't try to unwrap potentially `null` or `undefined` things.\n  if (!nodule) {\n    return nodule\n  }\n\n  // If we're unwrapping multiple things\n  if (this.isArray(properties)) {\n    properties.forEach(unwrap.bind(this, nodule))\n    return nodule\n  }\n\n  this.logger.trace('Unwrapping %s', properties || '<nodule>')\n  var original = properties ? nodule[properties] : nodule\n  while (original && original.__NR_original) {\n    original = this.isFunction(original.__NR_unwrap)\n      ? original.__NR_unwrap()\n      : original.__NR_original\n  }\n  return original\n}\n\n/**\n * Unwraps one item, revealing the underlying value.\n *\n * - `unwrapOnce(nodule, property)`\n * - `unwrapOnce(func)`\n *\n * If called with a `nodule` and properties, the unwrapped value will be put\n * back on the nodule. Otherwise, the unwrapped function is just returned.\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the properties to unwrap, or a single function to unwrap.\n *\n * @param {string|Array.<string>} [properties]\n *  One or more properties to unwrap. If omitted, the `nodule` parameter is\n *  assumed to be the function to unwrap.\n *\n * @return {Object|Function} The first parameter after unwrapping.\n */\nfunction unwrapOnce(nodule, properties) {\n  // Don't try to unwrap potentially `null` or `undefined` things.\n  if (!nodule) {\n    return nodule\n  }\n\n  // If we're unwrapping multiple things\n  if (this.isArray(properties)) {\n    properties.forEach(unwrapOnce.bind(this, nodule))\n    return nodule\n  }\n\n  this.logger.trace('Unwrapping %s', properties || '<nodule>')\n  var original = properties ? nodule[properties] : nodule\n  if (original && original.__NR_original) {\n    original = this.isFunction(original.__NR_unwrap)\n      ? original.__NR_unwrap()\n      : original.__NR_original\n  }\n  return original\n}\n\n/**\n * Retrieves the original method for a wrapped function.\n *\n * - `getOriginal(nodule, property)`\n * - `getOriginal(func)`\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source of the property to get the original of, or a function to unwrap.\n *\n * @param {string} [property]\n *  A property on `nodule` to get the original value of.\n *\n * @return {Object|Function} The original value for the given item.\n */\nfunction getOriginal(nodule, property) {\n  if (!nodule) {\n    return nodule\n  }\n\n  var original = property ? nodule[property] : nodule\n  while (original && original.__NR_original) {\n    original = original.__NR_original\n  }\n  return original\n}\n\n/**\n * Binds the execution of a function to a single segment.\n *\n * - `bindSegment(nodule , property [, segment [, full]])`\n * - `bindSegment(func [, segment [, full]])`\n *\n * If called with a `nodule` and a property, the wrapped property will be put\n * back on the nodule. Otherwise, the wrapped function is just returned.\n *\n * @memberof Shim.prototype\n *\n * @param {Object|Function} nodule\n *  The source for the property or a single function to bind to a segment.\n *\n * @param {string} [property]\n *  The property to bind. If omitted, the `nodule` parameter is assumed\n *  to be the function to bind the segment to.\n *\n * @param {?TraceSegment} [segment=null]\n *  The segment to bind the execution of the function to. If omitted or `null`\n *  the currently active segment will be bound instead.\n *\n * @param {bool} [full=false]\n *  Indicates if the full lifetime of the segment is bound to this function.\n *\n * @return {Object|Function} The first parameter after wrapping.\n */\nfunction bindSegment(nodule, property, segment, full) {\n  // Don't bind to null arguments.\n  if (!nodule) {\n    return nodule\n  }\n\n  // Determine our arguments.\n  if (this.isObject(property) && !this.isArray(property)) {\n    // bindSegment(func, segment [, full])\n    full = segment\n    segment = property\n    property = null\n  }\n\n  // This protects against the `bindSegment(func, null, true)` case, where the\n  // segment is `null`, and thus `true` (the full param) is detected as the\n  // segment.\n  if (segment != null && !this.isObject(segment)) {\n    this.logger.debug({segment: segment}, 'Segment is not a segment, not binding.')\n    return nodule\n  }\n\n  var wrapped = this.wrap(nodule, property, function wrapFunc(shim, func) {\n    if (!shim.isFunction(func)) {\n      return func\n    }\n\n    // Wrap up the function with this segment.\n    segment = segment || shim.getSegment()\n    if (!segment) {\n      return func\n    }\n\n    var binder = _makeBindWrapper(shim, func, segment, full || false)\n    shim.storeSegment(binder, segment)\n    return binder\n  })\n\n  return wrapped\n}\n\n/**\n * Replaces the callback in an arguments array with one that has been bound to\n * the given segment.\n *\n * - `bindCallbackSegment(args, cbIdx [, segment])`\n * - `bindCallbackSegment(obj, property [, segment])`\n *\n * @memberof Shim.prototype\n *\n * @param {Array|Object} args\n *  The arguments array to pull the cb from.\n *\n * @param {number|string} cbIdx\n *  The index of the callback.\n *\n * @param {TraceSegment} [parentSegment]\n *  The segment to use as the callback segment's parent. Defaults to the\n *  currently active segment.\n *\n * @see Shim#bindSegment\n */\nfunction bindCallbackSegment(args, cbIdx, parentSegment) {\n  if (!args) {\n    return\n  }\n\n  if (this.isNumber(cbIdx)) {\n    var normalizedCBIdx = normalizeIndex(args.length, cbIdx)\n    if (normalizedCBIdx === null) {\n      // Bad index.\n      this.logger.debug(\n        'Invalid index %d for args of length %d, not binding callback segment',\n        cbIdx, args.length\n      )\n      return\n    }\n    cbIdx = normalizedCBIdx\n  }\n\n  // Pull out the callback and make sure it is a function.\n  var cb = args[cbIdx]\n  if (this.isFunction(cb)) {\n    var shim = this\n    var realParent = parentSegment || shim.getSegment()\n    args[cbIdx] = shim.wrap(cb, null, function callbackWrapper(shim, fn, name) {\n      return function wrappedCallback() {\n        if (realParent) {\n          realParent.opaque = false\n        }\n        var segment = _rawCreateSegment(shim, new specs.SegmentSpec({\n          name: 'Callback: ' + name,\n          parent: realParent\n        }))\n\n        if (segment) {\n          segment.async = false\n        }\n\n        // CB may end the transaction so update the parent's time preemptively.\n        realParent && realParent.touch()\n        return shim.applySegment(cb, segment, true, this, arguments)\n      }\n    })\n    shim.storeSegment(args[cbIdx], realParent)\n  }\n}\n\n/**\n * Retrieves the segment associated with the given object, or the current\n * segment if no object is given.\n *\n * - `getSegment([obj])`\n *\n * @memberof Shim.prototype\n *\n * @param {*} [obj] - The object to retrieve a segment from.\n *\n * @return {?TraceSegment} The trace segment associated with the given object or\n *  the current segment if no object is provided or no segment is associated\n *  with the object.\n */\nfunction getSegment(obj) {\n  if (obj && obj.__NR_segment) {\n    return obj.__NR_segment\n  }\n  return this.tracer.getSegment()\n}\n\n\n/**\n * Retrieves the segment associated with the given object, or the currently\n * active segment if no object is given.\n *\n * - `getActiveSegment([obj])`\n *\n * An active segment is one whose transaction is still active (e.g. has not\n * ended yet).\n *\n * @memberof Shim.prototype\n *\n * @param {*} [obj] - The object to retrieve a segment from.\n *\n * @return {?TraceSegment} The trace segment associated with the given object or\n *  the currently active segment if no object is provided or no segment is\n *  associated with the object.\n */\nfunction getActiveSegment(obj) {\n  var segment = this.getSegment(obj)\n  if (segment && segment.transaction && segment.transaction.isActive()) {\n    return segment\n  }\n  return null\n}\n\n/**\n * Explicitly sets the active segment to the one passed in. This method\n * should only be used if there is no function to tie a segment's timing\n * to.\n *\n * - `setActiveSegment(segment)`\n *\n * @memberof Shim.prototype\n *\n * @param {TraceSegment} segment - The segment to set as the active segment.\n *\n */\nfunction setActiveSegment(segment) {\n  return this.tracer.segment = segment\n}\n\n/**\n * Associates a segment with the given object.\n *\n * - `storeSegment(obj [, segment])`\n *\n * If no segment is provided, the currently active segment is used.\n *\n * @memberof Shim.prototype\n *\n * @param {!*}            obj       - The object to retrieve a segment from.\n * @param {TraceSegment}  [segment] - The segment to link the object to.\n */\nfunction storeSegment(obj, segment) {\n  this.setInternalProperty(obj, '__NR_segment', segment || this.tracer.getSegment())\n}\n\n/**\n * Sets the given segment as the active one for the duration of the function's\n * execution.\n *\n * - `applySegment(func, segment, full, context, args[, inContextCB])`\n *\n * @memberof Shim.prototype\n *\n * @param {Function} func\n *  The function to execute in the context of the given segment.\n *\n * @param {TraceSegment} segment\n *  The segment to make active for the duration of the function.\n *\n * @param {bool} full\n *  Indicates if the full lifetime of the segment is bound to this function.\n *\n * @param {*} context\n *  The `this` argument for the function.\n *\n * @param {Array.<*>} args\n *  The arguments to be passed into the function.\n *\n * @param {Function} [inContextCB]\n *  The function used to do more instrumentation work. This function is\n *  guaranteed to be executed with the segment associated with.\n *\n *\n * @return {*} Whatever value `func` returned.\n */\n/* eslint-disable max-params */\nfunction applySegment(func, segment, full, context, args, inContextCB) {\n  // Exist fast for bad arguments.\n  if (!this.isFunction(func)) {\n    return\n  }\n\n  if (!segment) {\n    this.logger.trace('No segment to apply to function.')\n    return fnApply.call(func, context, args)\n  }\n  this.logger.trace('Applying segment %s', segment.name)\n\n  // Set this segment as the current one on the tracer.\n  var tracer = this.tracer\n  var prevSegment = tracer.segment\n  tracer.segment = segment\n  if (full) {\n    segment.start()\n  }\n\n  if (typeof inContextCB === 'function') {\n    inContextCB()\n  }\n\n  // Execute the function and then return the tracer segment to the old one.\n  try {\n    return fnApply.call(func, context, args)\n  } catch (error) {\n    if (prevSegment === null && process.domain != null) {\n      process.domain.__NR_segment = tracer.segment\n    }\n\n    throw error // Rethrowing application error, this is not an agent error.\n  } finally {\n    if (full) {\n      segment.touch()\n    }\n    tracer.segment = prevSegment\n  }\n}\n/* eslint-enable max-params */\n\n/**\n * Creates a new segment.\n *\n * - `createSegment(opts)`\n * - `createSegment(name [, recorder] [, parent])`\n *\n * @memberof Shim.prototype\n *\n * @param {string} name\n *  The name to give the new segment.\n *\n * @param {?Function} [recorder=null]\n *  Optional. A function which will record the segment as a metric. Default is\n *  to not record the segment.\n *\n * @param {TraceSegment} [parent]\n *  Optional. The segment to use as the parent. Default is to use the currently\n *  active segment.\n *\n * @return {?TraceSegment} A new trace segment if a transaction is active, else\n *  `null` is returned.\n */\nfunction createSegment(name, recorder, parent) {\n  var opts = null\n  if (this.isString(name)) {\n    // createSegment(name [, recorder] [, parent])\n    opts = new specs.SegmentSpec({name})\n\n    // if the recorder arg is not used, it can either be omitted or null\n    if (this.isFunction(recorder) || this.isNull(recorder)) {\n      // createSegment(name, recorder [, parent])\n      opts.recorder = recorder\n      opts.parent = parent\n    } else {\n      // createSegment(name [, parent])\n      opts.parent = recorder\n    }\n  } else {\n    // createSegment(opts)\n    opts = name\n  }\n\n  return _rawCreateSegment(this, opts)\n}\n\nfunction _rawCreateSegment(shim, opts) {\n  // Grab parent segment when none in opts so we can check opaqueness\n  opts.parent = opts.parent || shim.getActiveSegment()\n\n  // When parent exists and is opaque, no new segment will be created\n  // by tracer.createSegment and the parent will be returned. We bail\n  // out early so we do not risk modifying the parent segment.\n  if (opts.parent && opts.parent.opaque) {\n    shim.logger.trace(opts, 'Did not create segment because parent is opaque')\n    return opts.parent\n  }\n\n  var segment = shim.tracer.createSegment(opts.name, opts.recorder, opts.parent)\n  if (segment) {\n    segment.internal = opts.internal\n    segment.opaque = opts.opaque\n    segment.shim = shim\n\n    if (hasOwnProperty(opts, 'parameters')) {\n      shim.copySegmentParameters(segment, opts.parameters)\n    }\n    shim.logger.trace(opts, 'Created segment')\n  } else {\n    shim.logger.debug(opts,'Failed to create segment')\n  }\n\n  return segment\n}\n\n/**\n * Determine the name of an object.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to get a name for.\n *\n * @return {string} The name of the object if it has one, else `<anonymous>`.\n */\nfunction getName(obj) {\n  return String((!obj || obj === true) ? obj : (obj.name || '<anonymous>'))\n}\n\n/**\n * Determines if the given object is an Object.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is an Object, else false.\n */\nfunction isObject(obj) {\n  return obj instanceof Object\n}\n\n/**\n * Determines if the given object exists and is a function.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is a function, else false.\n */\nfunction isFunction(obj) {\n  return typeof obj === 'function'\n}\n\n/**\n * Determines if the given object exists and is a string.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is a string, else false.\n */\nfunction isString(obj) {\n  return typeof obj === 'string'\n}\n\n/**\n * Determines if the given object is a number literal.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is a number literal, else false.\n */\nfunction isNumber(obj) {\n  return typeof obj === 'number'\n}\n\n/**\n * Determines if the given object is a boolean literal.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is a boolean literal, else false.\n */\nfunction isBoolean(obj) {\n  return typeof obj === 'boolean'\n}\n\n/**\n * Determines if the given object exists and is an array.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is an array, else false.\n */\nfunction isArray(obj) {\n  return obj instanceof Array\n}\n\n/**\n * Determines if the given object is a promise instance.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The object to check.\n *\n * @return {bool} True if the object is a promise, else false.\n */\nfunction isPromise(obj) {\n  return obj && typeof obj.then === 'function'\n}\n\n/**\n * Determines if the given value is null.\n *\n * @memberof Shim.prototype\n *\n * @param {*} val - The value to check.\n *\n * @return {bool} True if the value is null, else false.\n */\nfunction isNull(val) {\n  return val === null\n}\n\n/**\n * Converts an array-like object into an array.\n *\n * @memberof Shim.prototype\n *\n * @param {*} obj - The array-like object (i.e. `arguments`).\n *\n * @return {Array.<*>} An instance of `Array` containing the elements of the\n *  array-like.\n */\nfunction toArray(obj) {\n  var len = obj.length\n  var arr = new Array(len)\n  for (var i = 0; i < len; ++i) {\n    arr[i] = obj[i]\n  }\n  return arr\n}\n\n/**\n * Like {@link Shim#toArray}, but converts `arguments` to an array.\n *\n * This is the preferred function, when used with `.apply`, for converting the\n * `arguments` object into an actual `Array` as it will not cause deopts.\n *\n * @memberof Shim.prototype\n *\n * @return {Array} An array containing the elements of `arguments`.\n *\n * @see Shim#toArray\n * @see https://github.com/petkaantonov/bluebird/wiki/Optimization-killers\n */\nfunction argsToArray() {\n  var len = arguments.length\n  var arr = new Array(len)\n  for (var i = 0; i < len; ++i) {\n    arr[i] = arguments[i]\n  }\n  return arr\n}\n\n/**\n * Ensures the given index is a valid index inside the array.\n *\n * A negative index value is converted to a positive one by adding it to the\n * array length before checking it.\n *\n * @memberof Shim.prototype\n *\n * @param {number} arrayLength  - The length of the array this index is for.\n * @param {number} idx          - The index to normalize.\n *\n * @return {?number} The adjusted index value if it is valid, else `null`.\n */\nfunction normalizeIndex(arrayLength, idx) {\n  if (idx < 0) {\n    idx = arrayLength + idx\n  }\n  return (idx < 0 || idx >= arrayLength) ? null : idx\n}\n\n/**\n * Retrieves the number of listeners for the given event.\n *\n * @memberof Shim.prototype\n *\n * @param {object} emitter  - The emitter to count the listeners on.\n * @param {string} event    - The event to count.\n *\n * @return {number} The number of listeners on the given event for this emitter.\n */\nfunction listenerCount(emitter, evnt) {\n  if (events.EventEmitter.listenerCount) {\n    return events.EventEmitter.listenerCount(emitter, evnt)\n  }\n  return emitter.listeners(evnt).length\n}\n\n/**\n * Wraps a function such that it will only be executed once.\n *\n * @memberof Shim.prototype\n *\n * @param {function} fn - The function to wrap in an execution guard.\n *\n * @return {function} A function which will execute `fn` at most once.\n */\nfunction once(fn) {\n  var called = false\n  return function onceCaller() {\n    if (!called) {\n      called = true\n      return fn.apply(this, arguments)\n    }\n  }\n}\n\n/**\n * Sets a property to the given value. If the property doesn't exist yet it will\n * be made writable and non-enumerable.\n *\n * @memberof Shim.prototype\n *\n * @param {!object} obj   - The object to add the property to.\n * @param {!string} name  - The name for this property.\n * @param {*}       val   - The value to set the property as.\n *\n * @return {object} The `obj` value.\n */\nfunction setInternalProperty(obj, name, val) {\n  if (!obj || !name) {\n    this.logger.debug('Not setting property; object or name is missing.')\n    return obj\n  }\n\n  try {\n    if (this.agent.config.transaction_tracer.hide_internals) {\n      _slowSetInternalProperty(obj, name, val)\n    } else {\n      obj[name] = val\n    }\n  } catch (err) {\n    this.logger.debug(err, 'Failed to set property \"%s\" to %j', name, val)\n  }\n  return obj\n}\n\nfunction _slowSetInternalProperty(obj, name, val) {\n  if (!hasOwnProperty(obj, name)) {\n    Object.defineProperty(obj, name, {\n      enumerable: false,\n      writable: true,\n      value: val\n    })\n  } else {\n    obj[name] = val\n  }\n}\n\n/**\n * Defines a read-only property on the given object.\n *\n * @memberof Shim.prototype\n *\n * @param {object} obj\n *  The object to add the property to.\n *\n * @param {string} name\n *  The name of the property to add.\n *\n * @param {*|function} value\n *  The value to set. If a function is given, it is used as a getter, otherwise\n *  the value is directly set as an unwritable property.\n */\nfunction defineProperty(obj, name, value) {\n  // We have define property! Use that.\n  var prop = {\n    enumerable: true,\n    configurable: true\n  }\n  if (isFunction(value)) {\n    prop.get = value\n  } else {\n    prop.writable = false\n    prop.value = value\n  }\n  Object.defineProperty(obj, name, prop)\n}\n\n/**\n * Adds several properties to the given object.\n *\n * @memberof Shim.prototype\n *\n * @param {object} obj    - The object to add the properties to.\n * @param {object} props  - A mapping of properties to values to add.\n *\n * @see Shim#defineProperty\n */\nfunction defineProperties(obj, props) {\n  var keys = Object.keys(props)\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i]\n    defineProperty(obj, key, props[key])\n  }\n}\n\n/**\n * Performs a shallow copy of each property from `defaults` only if `obj` does\n * not already have that property.\n *\n * @memberof Shim.prototype\n *\n * @param {object?} obj       - The object to copy the defaults onto.\n * @param {object}  defaults  - A mapping of keys to default values.\n *\n * @return {object} The `obj` with the default values copied onto it. If `obj`\n *  was falsey, then a new object with the defaults copied onto it is returned\n *  instead.\n */\nfunction setDefaults(obj, defaults) {\n  if (!obj) {\n    obj = Object.create(null)\n  }\n  var keys = Object.keys(defaults)\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i]\n    if (!hasOwnProperty(obj, key)) {\n      obj[key] = defaults[key]\n    }\n  }\n\n  return obj\n}\n\n/**\n * Proxies all set/get actions for each given property on `dest` onto `source`.\n *\n * @memberof Shim.prototype\n *\n * @param {*} source\n *  The object on which all the set/get actions will actually occur.\n *\n * @param {string|Array.<string>} properties\n *  All of the properties to proxy.\n *\n * @param {*} dest\n *  The object which is proxying the source's properties.\n */\nfunction proxy(source, properties, dest) {\n  if (!this.isArray(properties)) {\n    properties = [properties]\n  }\n\n  properties.forEach(function forEachProxyProp(prop) {\n    Object.defineProperty(dest, prop, {\n      get: function proxyGet() {\n        return source[prop]\n      },\n      set: function proxySet(val) {\n        return source[prop] = val\n      }\n    })\n  })\n}\n\n/**\n * Loads a node module from the instrumented library's own root directory.\n *\n * @memberof Shim.prototype\n *\n * @param {string} filePath - A relative path inside the module's directory.\n *\n * @return {*?} The result of loading the given module. If the module fails to\n *  load, `null` is returned instead.\n */\nfunction shimRequire(filePath) {\n  try {\n    return require(path.resolve(this._moduleRoot, filePath))\n  } catch (e) {\n    this.logger.debug('Failed to load %j: %s', filePath, e.stack)\n    return null\n  }\n}\n\n/**\n * Executes the given callback when the promise is finalized, whether it is\n * resolved or rejected.\n *\n * @memberof Shim.prototype\n *\n * @param {Promise} prom  - Some kind of promise. Must have a `then` method.\n * @param {Function} cb   - A function to call when the promise resolves.\n *\n * @return {Promise} A new promise to replace the original one.\n */\nfunction interceptPromise(prom, cb) {\n  if (this.isFunction(prom.finally)) {\n    return prom.finally(cb)\n  }\n  return prom.then(function onThen(arg) {\n    cb()\n    return arg\n  }, function onCatch(err) {\n    cb()\n    throw err // This is not our error, just rethrowing the promise rejection.\n  })\n}\n\n/**\n * Copies the given parameters onto the segment, respecting the current agent\n * configuration.\n *\n * @memberof Shim.protoype\n *\n * @param {TraceSegment}  segment     - The segment to copy the parameters onto.\n * @param {object}        parameters  - The paramters to copy.\n */\nfunction copySegmentParameters(segment, parameters) {\n  for (var key in parameters) {\n    if (hasOwnProperty(parameters, key)) {\n      segment.addAttribute(key, parameters[key])\n    }\n  }\n}\n\n/**\n * Enables debugging mode of the shim.\n *\n * In debug mode the shim will track all methods that it wraps so they can be\n * unwrapped. This should _not_ be done in production code because a lot more\n * objects are held onto in memory.\n *\n * @private\n * @memberof Shim.prototype\n */\nfunction enableDebug() {\n  this.logger.warn('Enabling debug mode for shim!')\n  this._debug = true\n  this._wrapped = []\n}\n\n/**\n * Unwraps everything that the shim has wrapped. Only works if debugging mode is\n * enabled first.\n *\n * @private\n * @member Shim.prototype.__NR_unwrap\n */\nfunction unwrapAll() {\n  if (this._wrapped) {\n    this.logger.debug('Unwrapping %d items.', this._wrapped.length)\n    this._wrapped.forEach(function unwrapEach(wrapped) {\n      this.unwrap(wrapped)\n    }, this)\n  }\n}\n\n// -------------------------------------------------------------------------- //\n\n/**\n * Coerces the given spec into a function which {@link Shim#wrap} can use.\n *\n * @private\n *\n * @param {Spec|WrapFunction} spec - The spec to coerce into a function.\n *\n * @return {WrapFunction} The spec itself if spec is a function, otherwise a\n *  function which will execute the spec when called.\n */\n/* eslint-disable no-unused-vars */\nfunction _specToFunction(spec) {\n  throw new Error('Declarative specs are not implemented yet.')\n}\n/* eslint-enable no-unused-vars */\n\n/**\n * Executes the provided spec on the given object.\n *\n * - `_wrap(shim, original, name, spec [, args])`\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim that is executing the wrapping.\n *\n * @param {*} original\n *  The object being wrapped.\n *\n * @param {string} name\n *  A logical name for the item to be wrapped.\n *\n * @param {WrapFunction} spec\n *  The spec for wrapping these items.\n *\n * @param {Array.<*>} [args=[]]\n *  Optional extra arguments to be sent to the spec when executing it.\n *\n * @return {Function} The return value from `spec` or the original value if it\n *  did not return anything.\n */\nfunction _wrap(shim, original, name, spec, args) {\n  // Assemble the spec's arguments.\n  var specArgs = [shim, original, name]\n  if (args && args.length) {\n    specArgs.push.apply(specArgs, args)\n  }\n\n  // Apply the spec and see if it returned a wrapped version of the property.\n  var wrapped = spec.wrapper.apply(null, specArgs)\n  if (wrapped && wrapped !== original) {\n    if (spec.matchArity && shim.isFunction(wrapped)) {\n      wrapped = arity.fixArity(original, wrapped)\n    }\n\n    // TODO: Once all wrapping is converted to proxies, we won't need to \n    // set this property as the trap on 'get' will return the original for\n    // __NR_original. For now, we have to prevent setting this on original.\n    if (!wrapped.__NR_original) {\n      shim.setInternalProperty(wrapped, '__NR_original', original)\n    }\n\n    if (shim._debug) {\n      shim._wrapped.push(wrapped)\n    }\n  } else {\n    wrapped = original\n  }\n  return wrapped\n}\n\n/**\n * Creates the `bindSegment` wrapper function in its own, clean closure.\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim used for the binding.\n *\n * @param {function} fn\n *  The function to be bound to the segment.\n *\n * @param {TraceSegment} segment\n *  The segment the function is bound to.\n *\n * @param {boolean} full\n *  Indicates if the segment's full lifetime is bound to the function.\n *\n * @return {function} A function which wraps `fn` and makes the given segment\n *  active for the duration of its execution.\n */\nfunction _makeBindWrapper(shim, fn, segment, full) {\n  return function wrapper() {\n    return shim.applySegment(fn, segment, full, this, arguments)\n  }\n}\n\n/**\n * Binds all callbacks identified in the given spec.\n *\n * The callbacks are bound using the method meant for that type if available\n * (i.e. `bindRowCallbackSegment` for `rowCallback`), but will fall back to the\n * generic callback binding method, `bindCallbackSegment`, otherwise.\n *\n * @this *\n * @private\n *\n * @param {Shim} shim\n *  The shim performing this binding.\n *\n * @param {Function} fn\n *  The function the spec describes.\n *\n * @param {string} name\n *  The name of the function the spec describes.\n *\n * @param {Array} args\n *  The arguments to be passed into `fn`.\n *\n * @param {object} spec\n *  The specification for bind the callbacks.\n *\n * @param {SegmentSpec} spec.spec\n *  The segment specification for the function we're pulling callbacks out of.\n *\n * @param {TraceSegment} spec.segment\n *  The segment measuring the function which will be the parent of any callback\n *  segments that may be created.\n *\n * @param {bool} spec.shouldCreateSegment\n *  Flag indicating if we should create segments for the callbacks. We almost\n *  always do, but in the special case of nested internal methods we do not.\n */\nfunction _bindAllCallbacks(shim, fn, name, args, spec) {\n  // Check for a normal callback.\n  if (hasOwnProperty(spec.spec, 'callback') && spec.spec.callback !== null) {\n    _bindCallback(this, spec.spec.callback, shim.bindCallbackSegment)\n  }\n\n  // And check for a row callback.\n  if (hasOwnProperty(spec.spec, 'rowCallback') && spec.spec.rowCallback !== null) {\n    _bindCallback(\n      this,\n      spec.spec.rowCallback,\n      shim.bindRowCallbackSegment || shim.bindCallbackSegment\n    )\n  }\n\n  function _bindCallback(context, callback, binder) {\n    if (shim.isFunction(callback)) {\n      callback.call(context, shim, fn, name, spec.segment, args)\n    } else if (shim.isNumber(callback)) {\n      shim.logger.trace('Binding callback %d segment: %j', callback, !!spec.segment)\n      var cbIdx = normalizeIndex(args.length, callback)\n      if (cbIdx !== null) {\n        if (spec.shouldCreateSegment) {\n          binder.call(shim, args, cbIdx, spec.segment)\n        } else {\n          args[cbIdx] = shim.bindSegment(args[cbIdx], spec.segment, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Binds the given segment to the lifetime of the stream.\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim performing the wrapping/binding.\n *\n * @param {EventEmitter} stream\n *  The stream to bind.\n *\n * @param {?TraceSegment} segment\n *  The segment to bind to the stream.\n *\n * @param {Object} [spec]\n *  Specification for how to bind the stream. The `end` and `error` events will\n *  always be bound, so if no functionality is desired beyond that, then this\n *  parameter may be omitted.\n *\n * @param {string} [spec.event]\n *  The name of an event to record. If provided, a new segment will be created\n *  for this event and will measure each time the event is emitted.\n *\n * @param {bool} spec.shouldCreateSegment\n *  Indicates if any child segments should be created. This should always be\n *  true unless this segment and its parent are both internal segments.\n */\nfunction _bindStream(shim, stream, segment, spec) {\n  if (!segment || !shim.isFunction(stream.emit)) {\n    shim.logger.trace(\n      'Not binding stream; have segment=%j; typeof emit=%s',\n      !!segment, typeof stream.emit\n    )\n    return\n  }\n\n  // We have a segment and an emit function, pull out the relevant parts of the\n  // spec and prepare to create an event segment.\n  var specEvent = (spec && spec.event) || null\n  var shouldCreateSegment = (spec && spec.shouldCreateSegment) || false\n  var segmentName = 'Event callback: ' + specEvent\n\n  // Wrap emit such that each event handler is executed within context of this\n  // segment or the event-specific segment.\n  shim.wrap(stream, 'emit', function wrapStreamEmit(shim, emit) {\n    var tx = segment.transaction\n    var streamBoundEmit = shim.bindSegment(emit, segment, true)\n    var eventSegment = null\n    var eventBoundEmit = null\n    var emitCount = 0\n\n    if (!shouldCreateSegment) {\n      return streamBoundEmit\n    }\n\n    return function wrappedEmit(evnt) {\n      var emitToCall = streamBoundEmit\n      if (evnt === specEvent && tx.isActive()) {\n        if (!eventBoundEmit) {\n          eventSegment = shim.createSegment(segmentName, segment)\n          eventBoundEmit = shim.bindSegment(emit, eventSegment, true)\n        }\n        eventSegment.addAttribute('count', ++emitCount)\n        emitToCall = eventBoundEmit\n      }\n      if (evnt === 'end' || evnt === 'error') {\n        segment.opaque = false\n        segment.touch()\n      }\n\n      return emitToCall.apply(this, arguments)\n    }\n  })\n\n  // Also wrap up any listeners for end or error events.\n  shim.wrap(stream, ['on', 'addListener'], function wrapOn(shim, fn) {\n    if (!shim.isFunction(fn)) {\n      return fn\n    }\n\n    return function wrappedOn(onEvent) {\n      if (onEvent !== specEvent && (onEvent === 'end' || onEvent === 'error')) {\n        var args = argsToArray.apply(shim, arguments)\n        shim.bindCallbackSegment(args, shim.LAST, segment)\n        return fn.apply(this, args)\n      }\n      return fn.apply(this, arguments)\n    }\n  })\n}\n\n/**\n * Binds the given segment to the completion of the Promise.\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim performing the wrapping/binding.\n *\n * @param {!Promise} promise\n *  The Promise to bind.\n *\n * @param {!TraceSegment} segment\n *  The segment to bind to the Promise.\n *\n * @return {Promise} The promise to continue with.\n */\nfunction _bindPromise(shim, promise, segment) {\n  return shim.interceptPromise(promise, function thenTouch() {\n    segment.opaque = false\n    segment.touch()\n  })\n}\n\n/**\n* Wraps an es6-style class using a subclass.\n*\n* - `_es6WrapClass(shim, Base, fnName, spec, args)`\n*\n* @private\n*\n* @param {Shim} shim\n*  The shim performing the wrapping/binding.\n*\n* @param {class} Base\n*  The es6 class to be wrapped.\n*\n* @param {string} fnName\n*  The name of the base class.\n*\n* @param {ClassWrapSpec} spec\n*  The spec with pre- and post-execution hooks to call.\n*\n* @param {Array.<*>} args\n*  Extra arguments to pass through to the pre- and post-execution hooks.\n*\n* @return {class} A class that extends Base with execution hooks.\n */\nfunction _es6WrapClass(shim, Base, fnName, spec, args) {\n  return class WrappedClass extends Base {\n    constructor() {\n      var cnstrctArgs = shim.argsToArray.apply(shim, arguments)\n      // Assemble the arguments to hand to the spec.\n      var _args = [shim, Base, fnName, cnstrctArgs]\n      if (args.length > 0) {\n        _args.push.apply(_args, args)\n      }\n\n      // Call the spec's before hook, then call the base constructor, then call\n      // the spec's after hook.\n      spec.pre && spec.pre.apply(null, _args)\n      super(...cnstrctArgs)\n      spec.post && spec.post.apply(this, _args)\n    }\n  }\n}\n\n/**\n * Wraps an es5-style class using a subclass.\n *\n * - `_es5WrapClass(shim, Base, fnName, spec, args)`\n *\n * @private\n *\n * @param {Shim} shim\n *  The shim performing the wrapping/binding.\n *\n * @param {Function} Base\n *  The class to be wrapped.\n *\n * @param {string} fnName\n *  The name of the base class.\n *\n * @param {ClassWrapSpec} spec\n *  The spec with pre- and post-execution hooks to call.\n *\n * @param {Array.<*>} args\n *  Extra arguments to pass through to the pre- and post-execution hooks.\n *\n * @return {Function} A class that extends Base with execution hooks.\n */\nfunction _es5WrapClass(shim, Base, fnName, spec, args) {\n  function WrappedClass() {\n    var cnstrctArgs = argsToArray.apply(shim, arguments)\n    if (!(this instanceof WrappedClass)) {\n      // Some libraries support calling constructors without the `new` keyword.\n      // In order to support this we must apply the super constructor if `this`\n      // is not an instance of ourself. JavaScript really needs a better way\n      // to generically apply constructors.\n      cnstrctArgs.unshift(WrappedClass) // `unshift` === `push_front`\n      return new (WrappedClass.bind.apply(WrappedClass, cnstrctArgs))()\n    }\n\n    // Assemble the arguments to hand to the spec.\n    var _args = [shim, Base, fnName, cnstrctArgs]\n    if (args.length > 0) {\n      _args.push.apply(_args, args)\n    }\n\n    // Call the spec's before hook, then call the base constructor, then call\n    // the spec's after hook.\n    spec.pre && spec.pre.apply(null, _args)\n    Base.apply(this, cnstrctArgs)\n    spec.post && spec.post.apply(this, _args)\n  }\n  util.inherits(WrappedClass, Base)\n  WrappedClass.prototype = Base.prototype\n\n  return WrappedClass\n}\n"]},"metadata":{},"sourceType":"script"}