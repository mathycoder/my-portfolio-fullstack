{"ast":null,"code":"'use strict';\n\nconst logger = require('../logger').child({\n  component: 'PromiseShim'\n});\n\nconst Shim = require('./shim');\n/**\n * A helper class for wrapping promise modules.\n *\n * @extends Shim\n */\n\n\nclass PromiseShim extends Shim {\n  /**\n   * Constructs a shim associated with the given agent instance, specialized for\n   * instrumenting promise libraries.\n   *\n   * @param {Agent} agent\n   *  The agent this shim will use.\n   *\n   * @param {string} moduleName\n   *  The name of the module being instrumented.\n   *\n   * @param {string} resolvedName\n   *  The full path to the loaded module.\n   *\n   * @see Shim\n   */\n  constructor(agent, moduleName, resolvedName) {\n    super(agent, moduleName, resolvedName);\n    this._logger = logger.child({\n      module: moduleName\n    });\n    this._class = null;\n  }\n  /**\n   * Grants access to the `Contextualizer` class used by the `PromiseShim` to\n   * propagate context down promise chains.\n   *\n   * @private\n   */\n\n\n  static get Contextualizer() {\n    return Contextualizer;\n  }\n  /**\n   * Sets the class used to indentify promises from the wrapped promise library.\n   *\n   * @param {function} clss - The promise library's class.\n   */\n\n\n  setClass(clss) {\n    this._class = clss;\n  }\n  /**\n   * Checks if the given object is an instance of a promise from the promise\n   * library being wrapped.\n   *\n   * @param {*} obj - The object to check the instance type of.\n   *\n   * @return {bool} True if the provided object is an instance of a promise from\n   *  this promise library.\n   *\n   * @see PromiseShim#setClass\n   */\n\n\n  isPromiseInstance(obj) {\n    return !!this._class && obj instanceof this._class;\n  }\n  /**\n   * Wraps the given properties as constructors for the promise library.\n   *\n   * - `wrapConstructor(nodule, properties)`\n   * - `wrapConstructor(func)`\n   *\n   * It is only necessary to wrap the constructor for the class if there is no\n   * other way to access the executor function. Some libraries expose a separate\n   * method which is called to execute the executor. If that is available, it is\n   * better to wrap that using {@link PromiseShim#wrapExecutorCaller} than to\n   * use this method.\n   *\n   * @param {object|function} nodule\n   *  The source of the properties to wrap, or a single function to wrap.\n   *\n   * @param {string|array.<string>} [properties]\n   *  One or more properties to wrap. If omitted, the `nodule` parameter is\n   *  assumed to be the constructor to wrap.\n   *\n   * @return {object|function} The first parameter to this function, after\n   *  wrapping it or its properties.\n   *\n   * @see PromiseShim#wrapExecutorCaller\n   */\n\n\n  wrapConstructor(nodule, properties) {\n    return this.wrapClass(nodule, properties, {\n      pre: function prePromise(shim, Promise, name, args) {\n        // We are expecting one function argument for executor, anything else is\n        // non-standard, do not attempt to wrap. Also do not attempt to wrap if\n        // we are not in a transaction.\n        if (args.length !== 1 || !shim.isFunction(args[0]) || !shim.getActiveSegment()) {\n          return;\n        }\n\n        _wrapExecutorContext(shim, args);\n      },\n      post: function postPromise(shim, Promise, name, args) {\n        // This extra property is added by `_wrapExecutorContext` in the pre step.\n        const executor = args[0];\n        const context = executor && executor.__NR_executorContext;\n\n        if (!context || !shim.isFunction(context.executor)) {\n          return;\n        }\n\n        context.promise = this;\n        Contextualizer.link(null, this, shim.getSegment());\n\n        try {\n          // Must run after promise is defined so that `__NR_wrapper` can be set.\n          context.executor.apply(context.self, context.args);\n        } catch (e) {\n          const reject = context.args[1];\n          reject(e);\n        }\n      }\n    });\n  }\n  /**\n   * Wraps the given properties as the caller of promise executors.\n   *\n   * - `wrapExecutorCaller(nodule, properties)`\n   * - `wrapExecutorCaller(func)`\n   *\n   * Wrapping the executor caller method directly is preferable to wrapping\n   * the constructor of the promise class.\n   *\n   * @param {object|function} nodule\n   *  The source of the properties to wrap, or a single function to wrap.\n   *\n   * @param {string|array.<string>} [properties]\n   *  One or more properties to wrap. If omitted, the `nodule` parameter is\n   *  assumed to be the function to wrap.\n   *\n   * @return {object|function} The first parameter to this function, after\n   *  wrapping it or its properties.\n   *\n   * @see PromiseShim#wrapConstructor\n   */\n\n\n  wrapExecutorCaller(nodule, properties) {\n    return this.wrap(nodule, properties, function executorWrapper(shim, caller) {\n      if (!shim.isFunction(caller) || shim.isWrapped(caller)) {\n        return;\n      }\n\n      return function wrappedExecutorCaller(executor) {\n        var parent = shim.getActiveSegment();\n\n        if (!this || !parent) {\n          return caller.apply(this, arguments);\n        }\n\n        if (!this.__NR_context) {\n          Contextualizer.link(null, this, parent);\n        }\n\n        const args = shim.argsToArray.apply(shim, arguments);\n\n        _wrapExecutorContext(shim, args);\n\n        const ret = caller.apply(this, args);\n        const context = args[0].__NR_executorContext;\n        context.promise = this; // Bluebird catches executor errors and auto-rejects when it catches them,\n        // thus we need to do so as well.\n        //\n        // When adding new libraries, make sure to check that they behave the same\n        // way. We may need to enhance the promise spec to handle this variance.\n\n        try {\n          executor.apply(context.self, context.args);\n        } catch (e) {\n          const reject = context.args[1];\n          reject(e);\n        }\n\n        return ret;\n      };\n    });\n  }\n  /**\n   * Wraps the given properties as methods which take is some value other than\n   * a function to call and return a promise.\n   *\n   * - `wrapCast(nodule, properties)`\n   * - `wrapCast(func)`\n   *\n   * Examples of promise cast methods include `Promise.resolve`, `Promise.all`,\n   * and Bluebird's `Promise.delay`. These are static methods which accept some\n   * arbitrary value and return a Promise instance.\n   *\n   * @param {object|function} nodule\n   *  The source of the properties to wrap, or a single function to wrap.\n   *\n   * @param {string|array.<string>} [properties]\n   *  One or more properties to wrap. If omitted, the `nodule` parameter is\n   *  assumed to be the function to wrap.\n   *\n   * @return {object|function} The first parameter to this function, after\n   *  wrapping it or its properties.\n   */\n\n\n  wrapCast(nodule, properties) {\n    return this.wrap(nodule, properties, function castWrapper(shim, cast) {\n      if (!shim.isFunction(cast) || shim.isWrapped(cast)) {\n        return;\n      }\n\n      return function __NR_wrappedCast() {\n        const segment = shim.getSegment();\n        const prom = cast.apply(this, arguments);\n\n        if (segment) {\n          Contextualizer.link(null, prom, segment);\n        }\n\n        return prom;\n      };\n    });\n  }\n  /**\n   * Wraps the given properties as promise chaining methods.\n   *\n   * - `wrapThen(nodule, properties)`\n   * - `wrapThen(func)`\n   *\n   * NOTE: You must set class used by the library before wrapping then-methods.\n   *\n   * Examples of promise then methods include `Promise#then`, `Promise#finally`,\n   * and Bluebird's `Promise#map`. These are methods which take a function to\n   * execute once the promise resolves and hands back a new promise.\n   *\n   * @param {object|function} nodule\n   *  The source of the properties to wrap, or a single function to wrap.\n   *\n   * @param {string|array.<string>} [properties]\n   *  One or more properties to wrap. If omitted, the `nodule` parameter is\n   *  assumed to be the function to wrap.\n   *\n   * @return {object|function} The first parameter to this function, after\n   *  wrapping it or its properties.\n   *\n   * @see PromiseShim#setClass\n   * @see PromiseShim#wrapCatch\n   */\n\n\n  wrapThen(nodule, properties) {\n    return this.wrap(nodule, properties, _wrapThen, [true]);\n  }\n  /**\n   * Wraps the given properties as rejected promise chaining methods.\n   *\n   * - `wrapCatch(nodule, properties)`\n   * - `wrapCatch(func)`\n   *\n   * NOTE: You must set class used by the library before wrapping catch-methods.\n   *\n   * Promise catch methods differ from then methods in that only one function\n   * will be executed and only if the promise is rejected. Some libraries accept\n   * an additional argument to `Promise#catch` which is usually an error class\n   * to filter rejections by. This wrap method will handle that case.\n   *\n   * @param {object|function} nodule\n   *  The source of the properties to wrap, or a single function to wrap.\n   *\n   * @param {string|array.<string>} [properties]\n   *  One or more properties to wrap. If omitted, the `nodule` parameter is\n   *  assumed to be the function to wrap.\n   *\n   * @return {object|function} The first parameter to this function, after\n   *  wrapping it or its properties.\n   *\n   * @see PromiseShim#setClass\n   * @see PromiseShim#wrapThen\n   */\n\n\n  wrapCatch(nodule, properties) {\n    return this.wrap(nodule, properties, _wrapThen, [false]);\n  }\n  /**\n   * Wraps the given properties as callback-to-promise conversion methods.\n   *\n   * - `wrapPromisify(nodule, properties)`\n   * - `wrapPromisify(func)`\n   *\n   * @param {object|function} nodule\n   *  The source of the properties to wrap, or a single function to wrap.\n   *\n   * @param {string|array.<string>} [properties]\n   *  One or more properties to wrap. If omitted, the `nodule` parameter is\n   *  assumed to be the function to wrap.\n   *\n   * @return {object|function} The first parameter to this function, after\n   *  wrapping it or its properties.\n   */\n\n\n  wrapPromisify(nodule, properties) {\n    return this.wrap(nodule, properties, function promisifyWrapper(shim, promisify) {\n      if (!shim.isFunction(promisify) || shim.isWrapped(promisify)) {\n        return;\n      }\n\n      return function __NR_wrappedPromisify() {\n        const promisified = promisify.apply(this, arguments);\n\n        if (typeof promisified !== 'function') {\n          return promisified;\n        }\n\n        Object.keys(promisified).forEach(function forEachProperty(prop) {\n          __NR_wrappedPromisified[prop] = promisified[prop];\n        });\n        return __NR_wrappedPromisified;\n\n        function __NR_wrappedPromisified() {\n          const segment = shim.getActiveSegment();\n\n          if (!segment) {\n            return promisified.apply(this, arguments);\n          }\n\n          const prom = shim.applySegment(promisified, segment, true, this, arguments);\n          Contextualizer.link(null, prom, segment);\n          return prom;\n        }\n      };\n    });\n  }\n\n}\n\nmodule.exports = PromiseShim; // -------------------------------------------------------------------------- //\n\n/**\n * @private\n */\n\nfunction _wrapExecutorContext(shim, args) {\n  const context = {\n    executor: args[0],\n    promise: null,\n    self: null,\n    args: null\n  };\n  contextExporter.__NR_executorContext = context;\n  args[0] = contextExporter;\n\n  function contextExporter(resolve, reject) {\n    context.self = this;\n    context.args = shim.argsToArray.apply(shim, arguments);\n    context.args[0] = _wrapResolver(context, resolve);\n    context.args[1] = _wrapResolver(context, reject);\n  }\n}\n/**\n * @private\n */\n\n\nfunction _wrapResolver(context, fn) {\n  return function wrappedResolveReject(val) {\n    const promise = context.promise;\n\n    if (promise && promise.__NR_context) {\n      promise.__NR_context.getSegment().touch();\n    }\n\n    fn(val);\n  };\n}\n/**\n * @private\n */\n\n\nfunction _wrapThen(shim, fn, name, useAllParams) {\n  // Don't wrap non-functions.\n  if (shim.isWrapped(fn) || !shim.isFunction(fn)) {\n    return;\n  }\n\n  return function __NR_wrappedThen() {\n    if (!(this instanceof shim._class)) {\n      return fn.apply(this, arguments);\n    }\n\n    const thenSegment = shim.getSegment();\n    const promise = this; // Wrap up the arguments and execute the real then.\n\n    let isWrapped = false;\n    const args = new Array(arguments.length);\n\n    for (let i = 0; i < arguments.length; ++i) {\n      args[i] = wrapHandler(arguments[i], i, arguments.length);\n    }\n\n    const next = fn.apply(this, args); // If we got a promise (which we should have), link the parent's context.\n\n    if (!isWrapped && next instanceof shim._class && next !== promise) {\n      Contextualizer.link(promise, next, thenSegment);\n    }\n\n    return next;\n\n    function wrapHandler(handler, i, length) {\n      if (!shim.isFunction(handler) || // Not a function\n      shim.isWrapped(handler) || // Already wrapped\n      !useAllParams && i !== length - 1 // Don't want all and not last\n      ) {\n          isWrapped = shim.isWrapped(handler);\n          return handler;\n        }\n\n      return function __NR_wrappedThenHandler() {\n        if (!next || !next.__NR_context) {\n          return handler.apply(this, arguments);\n        }\n\n        let promSegment = next.__NR_context.getSegment();\n\n        const segment = promSegment || shim.getSegment();\n\n        if (segment && segment !== promSegment) {\n          next.__NR_context.setSegment(segment);\n\n          promSegment = segment;\n        }\n\n        let ret = null;\n\n        try {\n          ret = shim.applySegment(handler, promSegment, true, this, arguments);\n        } finally {\n          if (ret && typeof ret.then === 'function') {\n            ret = next.__NR_context.continueContext(ret);\n          }\n        }\n\n        return ret;\n      };\n    }\n  };\n}\n/**\n * @private\n */\n\n\nclass Context {\n  constructor(segment) {\n    this.segments = [segment];\n  }\n\n  branch() {\n    return this.segments.push(null) - 1;\n  }\n\n}\n/**\n * @private\n */\n\n\nclass Contextualizer {\n  constructor(idx, context) {\n    this.parentIdx = -1;\n    this.idx = idx;\n    this.context = context;\n    this.child = null;\n  }\n\n  static link(prev, next, segment) {\n    let ctxlzr = prev && prev.__NR_context;\n\n    if (ctxlzr && !ctxlzr.isActive()) {\n      ctxlzr = prev.__NR_context = null;\n    }\n\n    if (ctxlzr) {\n      // If prev has one child already, branch the context and update the child.\n      if (ctxlzr.child) {\n        // When the branch-point is the 2nd through nth link in the chain, it is\n        // necessary to track its segment separately so the branches can parent\n        // their segments on the branch-point.\n        if (ctxlzr.parentIdx !== -1) {\n          ctxlzr.idx = ctxlzr.context.branch();\n        } // The first child needs to be updated to have its own branch as well. And\n        // each of that child's children must be updated with the new parent index.\n        // This is the only non-constant-time action for linking, but it only\n        // happens with branching promise chains specifically when the 2nd branch\n        // is added.\n        //\n        // Note: This does not account for branches of branches. That may result\n        // in improperly parented segments.\n\n\n        let parent = ctxlzr;\n        let child = ctxlzr.child;\n        const branchIdx = ctxlzr.context.branch();\n\n        do {\n          child.parentIdx = parent.idx;\n          child.idx = branchIdx;\n          parent = child;\n          child = child.child;\n        } while (child); // We set the child to something falsey that isn't `null` so we can\n        // distinguish between having no child, having one child, and having\n        // multiple children.\n\n\n        ctxlzr.child = false;\n      } // If this is a branching link then create a new branch for the next promise.\n      // Otherwise, we can just piggy-back on the previous link's spot.\n\n\n      const idx = ctxlzr.child === false ? ctxlzr.context.branch() : ctxlzr.idx; // Create a new context for this next promise.\n\n      next.__NR_context = new Contextualizer(idx, ctxlzr.context);\n      next.__NR_context.parentIdx = ctxlzr.idx; // If this was our first child, remember it in case we have a 2nd.\n\n      if (ctxlzr.child === null) {\n        ctxlzr.child = next.__NR_context;\n      }\n    } else if (segment) {\n      // This next promise is the root of a chain. Either there was no previous\n      // promise or the promise was created out of context.\n      next.__NR_context = new Contextualizer(0, new Context(segment));\n    }\n  }\n\n  isActive() {\n    const segments = this.context.segments;\n    const segment = segments[this.idx] || segments[this.parentIdx] || segments[0];\n    return segment && segment.transaction.isActive();\n  }\n\n  getSegment() {\n    const segments = this.context.segments;\n    let segment = segments[this.idx];\n\n    if (segment == null) {\n      segment = segments[this.idx] = segments[this.parentIdx] || segments[0];\n    }\n\n    return segment;\n  }\n\n  setSegment(segment) {\n    return this.context.segments[this.idx] = segment;\n  }\n\n  toJSON() {// No-op.\n  }\n\n  continueContext(prom) {\n    const self = this;\n    const nextContext = prom.__NR_context;\n\n    if (!nextContext) {\n      return prom;\n    } // If we have `finally`, use that to sneak our context update.\n\n\n    if (typeof prom.finally === 'function') {\n      return prom.finally(__NR_continueContext);\n    } // No `finally` means we need to hook into resolve and reject individually and\n    // pass through whatever happened.\n\n\n    return prom.then(function __NR_thenContext(val) {\n      __NR_continueContext();\n\n      return val;\n    }, function __NR_catchContext(err) {\n      __NR_continueContext();\n\n      throw err; // Re-throwing promise rejection, this is not New Relic's error.\n    });\n\n    function __NR_continueContext() {\n      self.setSegment(nextContext.getSegment());\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/shim/promise-shim.js"],"names":["logger","require","child","component","Shim","PromiseShim","constructor","agent","moduleName","resolvedName","_logger","module","_class","Contextualizer","setClass","clss","isPromiseInstance","obj","wrapConstructor","nodule","properties","wrapClass","pre","prePromise","shim","Promise","name","args","length","isFunction","getActiveSegment","_wrapExecutorContext","post","postPromise","executor","context","__NR_executorContext","promise","link","getSegment","apply","self","e","reject","wrapExecutorCaller","wrap","executorWrapper","caller","isWrapped","wrappedExecutorCaller","parent","arguments","__NR_context","argsToArray","ret","wrapCast","castWrapper","cast","__NR_wrappedCast","segment","prom","wrapThen","_wrapThen","wrapCatch","wrapPromisify","promisifyWrapper","promisify","__NR_wrappedPromisify","promisified","Object","keys","forEach","forEachProperty","prop","__NR_wrappedPromisified","applySegment","exports","contextExporter","resolve","_wrapResolver","fn","wrappedResolveReject","val","touch","useAllParams","__NR_wrappedThen","thenSegment","Array","i","wrapHandler","next","handler","__NR_wrappedThenHandler","promSegment","setSegment","then","continueContext","Context","segments","branch","push","idx","parentIdx","prev","ctxlzr","isActive","branchIdx","transaction","toJSON","nextContext","finally","__NR_continueContext","__NR_thenContext","__NR_catchContext","err"],"mappings":"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","sourcesContent":["'use strict'\n\nconst logger = require('../logger').child({component: 'PromiseShim'})\nconst Shim = require('./shim')\n\n/**\n * A helper class for wrapping promise modules.\n *\n * @extends Shim\n */\nclass PromiseShim extends Shim {\n  /**\n   * Constructs a shim associated with the given agent instance, specialized for\n   * instrumenting promise libraries.\n   *\n   * @param {Agent} agent\n   *  The agent this shim will use.\n   *\n   * @param {string} moduleName\n   *  The name of the module being instrumented.\n   *\n   * @param {string} resolvedName\n   *  The full path to the loaded module.\n   *\n   * @see Shim\n   */\n  constructor(agent, moduleName, resolvedName) {\n    super(agent, moduleName, resolvedName)\n    this._logger = logger.child({module: moduleName})\n    this._class = null\n  }\n\n  /**\n   * Grants access to the `Contextualizer` class used by the `PromiseShim` to\n   * propagate context down promise chains.\n   *\n   * @private\n   */\n  static get Contextualizer() {\n    return Contextualizer\n  }\n\n  /**\n   * Sets the class used to indentify promises from the wrapped promise library.\n   *\n   * @param {function} clss - The promise library's class.\n   */\n  setClass(clss) {\n    this._class = clss\n  }\n\n  /**\n   * Checks if the given object is an instance of a promise from the promise\n   * library being wrapped.\n   *\n   * @param {*} obj - The object to check the instance type of.\n   *\n   * @return {bool} True if the provided object is an instance of a promise from\n   *  this promise library.\n   *\n   * @see PromiseShim#setClass\n   */\n  isPromiseInstance(obj) {\n    return !!this._class && obj instanceof this._class\n  }\n\n  /**\n   * Wraps the given properties as constructors for the promise library.\n   *\n   * - `wrapConstructor(nodule, properties)`\n   * - `wrapConstructor(func)`\n   *\n   * It is only necessary to wrap the constructor for the class if there is no\n   * other way to access the executor function. Some libraries expose a separate\n   * method which is called to execute the executor. If that is available, it is\n   * better to wrap that using {@link PromiseShim#wrapExecutorCaller} than to\n   * use this method.\n   *\n   * @param {object|function} nodule\n   *  The source of the properties to wrap, or a single function to wrap.\n   *\n   * @param {string|array.<string>} [properties]\n   *  One or more properties to wrap. If omitted, the `nodule` parameter is\n   *  assumed to be the constructor to wrap.\n   *\n   * @return {object|function} The first parameter to this function, after\n   *  wrapping it or its properties.\n   *\n   * @see PromiseShim#wrapExecutorCaller\n   */\n  wrapConstructor(nodule, properties) {\n    return this.wrapClass(nodule, properties, {\n      pre: function prePromise(shim, Promise, name, args) {\n        // We are expecting one function argument for executor, anything else is\n        // non-standard, do not attempt to wrap. Also do not attempt to wrap if\n        // we are not in a transaction.\n        if (args.length !== 1 || !shim.isFunction(args[0]) || !shim.getActiveSegment()) {\n          return\n        }\n        _wrapExecutorContext(shim, args)\n      },\n      post: function postPromise(shim, Promise, name, args) {\n        // This extra property is added by `_wrapExecutorContext` in the pre step.\n        const executor = args[0]\n        const context = executor && executor.__NR_executorContext\n        if (!context || !shim.isFunction(context.executor)) {\n          return\n        }\n\n        context.promise = this\n        Contextualizer.link(null, this, shim.getSegment())\n        try {\n          // Must run after promise is defined so that `__NR_wrapper` can be set.\n          context.executor.apply(context.self, context.args)\n        } catch (e) {\n          const reject = context.args[1]\n          reject(e)\n        }\n      }\n    })\n  }\n\n  /**\n   * Wraps the given properties as the caller of promise executors.\n   *\n   * - `wrapExecutorCaller(nodule, properties)`\n   * - `wrapExecutorCaller(func)`\n   *\n   * Wrapping the executor caller method directly is preferable to wrapping\n   * the constructor of the promise class.\n   *\n   * @param {object|function} nodule\n   *  The source of the properties to wrap, or a single function to wrap.\n   *\n   * @param {string|array.<string>} [properties]\n   *  One or more properties to wrap. If omitted, the `nodule` parameter is\n   *  assumed to be the function to wrap.\n   *\n   * @return {object|function} The first parameter to this function, after\n   *  wrapping it or its properties.\n   *\n   * @see PromiseShim#wrapConstructor\n   */\n  wrapExecutorCaller(nodule, properties) {\n    return this.wrap(nodule, properties, function executorWrapper(shim, caller) {\n      if (!shim.isFunction(caller) || shim.isWrapped(caller)) {\n        return\n      }\n\n      return function wrappedExecutorCaller(executor) {\n        var parent = shim.getActiveSegment()\n        if (!this || !parent) {\n          return caller.apply(this, arguments)\n        }\n\n        if (!this.__NR_context) {\n          Contextualizer.link(null, this, parent)\n        }\n\n        const args = shim.argsToArray.apply(shim, arguments)\n        _wrapExecutorContext(shim, args)\n        const ret = caller.apply(this, args)\n        const context = args[0].__NR_executorContext\n        context.promise = this\n\n        // Bluebird catches executor errors and auto-rejects when it catches them,\n        // thus we need to do so as well.\n        //\n        // When adding new libraries, make sure to check that they behave the same\n        // way. We may need to enhance the promise spec to handle this variance.\n        try {\n          executor.apply(context.self, context.args)\n        } catch (e) {\n          const reject = context.args[1]\n          reject(e)\n        }\n        return ret\n      }\n    })\n  }\n\n  /**\n   * Wraps the given properties as methods which take is some value other than\n   * a function to call and return a promise.\n   *\n   * - `wrapCast(nodule, properties)`\n   * - `wrapCast(func)`\n   *\n   * Examples of promise cast methods include `Promise.resolve`, `Promise.all`,\n   * and Bluebird's `Promise.delay`. These are static methods which accept some\n   * arbitrary value and return a Promise instance.\n   *\n   * @param {object|function} nodule\n   *  The source of the properties to wrap, or a single function to wrap.\n   *\n   * @param {string|array.<string>} [properties]\n   *  One or more properties to wrap. If omitted, the `nodule` parameter is\n   *  assumed to be the function to wrap.\n   *\n   * @return {object|function} The first parameter to this function, after\n   *  wrapping it or its properties.\n   */\n  wrapCast(nodule, properties) {\n    return this.wrap(nodule, properties, function castWrapper(shim, cast) {\n      if (!shim.isFunction(cast) || shim.isWrapped(cast)) {\n        return\n      }\n\n      return function __NR_wrappedCast() {\n        const segment = shim.getSegment()\n        const prom = cast.apply(this, arguments)\n        if (segment) {\n          Contextualizer.link(null, prom, segment)\n        }\n        return prom\n      }\n    })\n  }\n\n  /**\n   * Wraps the given properties as promise chaining methods.\n   *\n   * - `wrapThen(nodule, properties)`\n   * - `wrapThen(func)`\n   *\n   * NOTE: You must set class used by the library before wrapping then-methods.\n   *\n   * Examples of promise then methods include `Promise#then`, `Promise#finally`,\n   * and Bluebird's `Promise#map`. These are methods which take a function to\n   * execute once the promise resolves and hands back a new promise.\n   *\n   * @param {object|function} nodule\n   *  The source of the properties to wrap, or a single function to wrap.\n   *\n   * @param {string|array.<string>} [properties]\n   *  One or more properties to wrap. If omitted, the `nodule` parameter is\n   *  assumed to be the function to wrap.\n   *\n   * @return {object|function} The first parameter to this function, after\n   *  wrapping it or its properties.\n   *\n   * @see PromiseShim#setClass\n   * @see PromiseShim#wrapCatch\n   */\n  wrapThen(nodule, properties) {\n    return this.wrap(nodule, properties, _wrapThen, [true])\n  }\n\n  /**\n   * Wraps the given properties as rejected promise chaining methods.\n   *\n   * - `wrapCatch(nodule, properties)`\n   * - `wrapCatch(func)`\n   *\n   * NOTE: You must set class used by the library before wrapping catch-methods.\n   *\n   * Promise catch methods differ from then methods in that only one function\n   * will be executed and only if the promise is rejected. Some libraries accept\n   * an additional argument to `Promise#catch` which is usually an error class\n   * to filter rejections by. This wrap method will handle that case.\n   *\n   * @param {object|function} nodule\n   *  The source of the properties to wrap, or a single function to wrap.\n   *\n   * @param {string|array.<string>} [properties]\n   *  One or more properties to wrap. If omitted, the `nodule` parameter is\n   *  assumed to be the function to wrap.\n   *\n   * @return {object|function} The first parameter to this function, after\n   *  wrapping it or its properties.\n   *\n   * @see PromiseShim#setClass\n   * @see PromiseShim#wrapThen\n   */\n  wrapCatch(nodule, properties) {\n    return this.wrap(nodule, properties, _wrapThen, [false])\n  }\n\n  /**\n   * Wraps the given properties as callback-to-promise conversion methods.\n   *\n   * - `wrapPromisify(nodule, properties)`\n   * - `wrapPromisify(func)`\n   *\n   * @param {object|function} nodule\n   *  The source of the properties to wrap, or a single function to wrap.\n   *\n   * @param {string|array.<string>} [properties]\n   *  One or more properties to wrap. If omitted, the `nodule` parameter is\n   *  assumed to be the function to wrap.\n   *\n   * @return {object|function} The first parameter to this function, after\n   *  wrapping it or its properties.\n   */\n  wrapPromisify(nodule, properties) {\n    return this.wrap(nodule, properties, function promisifyWrapper(shim, promisify) {\n      if (!shim.isFunction(promisify) || shim.isWrapped(promisify)) {\n        return\n      }\n\n      return function __NR_wrappedPromisify() {\n        const promisified = promisify.apply(this, arguments)\n        if (typeof promisified !== 'function') {\n          return promisified\n        }\n\n        Object.keys(promisified).forEach(function forEachProperty(prop) {\n          __NR_wrappedPromisified[prop] = promisified[prop]\n        })\n\n        return __NR_wrappedPromisified\n        function __NR_wrappedPromisified() {\n          const segment = shim.getActiveSegment()\n          if (!segment) {\n            return promisified.apply(this, arguments)\n          }\n\n          const prom = shim.applySegment(promisified, segment, true, this, arguments)\n          Contextualizer.link(null, prom, segment)\n          return prom\n        }\n      }\n    })\n  }\n}\nmodule.exports = PromiseShim\n\n// -------------------------------------------------------------------------- //\n\n/**\n * @private\n */\nfunction _wrapExecutorContext(shim, args) {\n  const context = {\n    executor: args[0],\n    promise: null,\n    self: null,\n    args: null\n  }\n  contextExporter.__NR_executorContext = context\n  args[0] = contextExporter\n\n  function contextExporter(resolve, reject) {\n    context.self = this\n    context.args = shim.argsToArray.apply(shim, arguments)\n    context.args[0] = _wrapResolver(context, resolve)\n    context.args[1] = _wrapResolver(context, reject)\n  }\n}\n\n/**\n * @private\n */\nfunction _wrapResolver(context, fn) {\n  return function wrappedResolveReject(val) {\n    const promise = context.promise\n    if (promise && promise.__NR_context) {\n      promise.__NR_context.getSegment().touch()\n    }\n    fn(val)\n  }\n}\n\n/**\n * @private\n */\nfunction _wrapThen(shim, fn, name, useAllParams) {\n  // Don't wrap non-functions.\n  if (shim.isWrapped(fn) || !shim.isFunction(fn)) {\n    return\n  }\n\n  return function __NR_wrappedThen() {\n    if (!(this instanceof shim._class)) {\n      return fn.apply(this, arguments)\n    }\n\n    const thenSegment = shim.getSegment()\n    const promise = this\n\n    // Wrap up the arguments and execute the real then.\n    let isWrapped = false\n    const args = new Array(arguments.length)\n    for (let i = 0; i < arguments.length; ++i) {\n      args[i] = wrapHandler(arguments[i], i, arguments.length)\n    }\n    const next = fn.apply(this, args)\n\n    // If we got a promise (which we should have), link the parent's context.\n    if (!isWrapped && next instanceof shim._class && next !== promise) {\n      Contextualizer.link(promise, next, thenSegment)\n    }\n    return next\n\n    function wrapHandler(handler, i, length) {\n      if (\n        !shim.isFunction(handler) ||          // Not a function\n        shim.isWrapped(handler)   ||          // Already wrapped\n        (!useAllParams && i !== (length - 1)) // Don't want all and not last\n      ) {\n        isWrapped = shim.isWrapped(handler)\n        return handler\n      }\n\n      return function __NR_wrappedThenHandler() {\n        if (!next || !next.__NR_context) {\n          return handler.apply(this, arguments)\n        }\n\n        let promSegment = next.__NR_context.getSegment()\n        const segment = promSegment || shim.getSegment()\n        if (segment && segment !== promSegment) {\n          next.__NR_context.setSegment(segment)\n          promSegment = segment\n        }\n\n        let ret = null\n        try {\n          ret = shim.applySegment(handler, promSegment, true, this, arguments)\n        } finally {\n          if (ret && typeof ret.then === 'function') {\n            ret = next.__NR_context.continueContext(ret)\n          }\n        }\n        return ret\n      }\n    }\n  }\n}\n\n/**\n * @private\n */\nclass Context {\n  constructor(segment) {\n    this.segments = [segment]\n  }\n\n  branch() {\n    return this.segments.push(null) - 1\n  }\n}\n\n/**\n * @private\n */\nclass Contextualizer {\n  constructor(idx, context) {\n    this.parentIdx = -1\n    this.idx = idx\n    this.context = context\n    this.child = null\n  }\n\n  static link(prev, next, segment) {\n    let ctxlzr = prev && prev.__NR_context\n    if (ctxlzr && !ctxlzr.isActive()) {\n      ctxlzr = prev.__NR_context = null\n    }\n\n    if (ctxlzr) {\n      // If prev has one child already, branch the context and update the child.\n      if (ctxlzr.child) {\n        // When the branch-point is the 2nd through nth link in the chain, it is\n        // necessary to track its segment separately so the branches can parent\n        // their segments on the branch-point.\n        if (ctxlzr.parentIdx !== -1) {\n          ctxlzr.idx = ctxlzr.context.branch()\n        }\n\n        // The first child needs to be updated to have its own branch as well. And\n        // each of that child's children must be updated with the new parent index.\n        // This is the only non-constant-time action for linking, but it only\n        // happens with branching promise chains specifically when the 2nd branch\n        // is added.\n        //\n        // Note: This does not account for branches of branches. That may result\n        // in improperly parented segments.\n        let parent = ctxlzr\n        let child = ctxlzr.child\n        const branchIdx = ctxlzr.context.branch()\n        do {\n          child.parentIdx = parent.idx\n          child.idx = branchIdx\n          parent = child\n          child = child.child\n        } while (child)\n\n        // We set the child to something falsey that isn't `null` so we can\n        // distinguish between having no child, having one child, and having\n        // multiple children.\n        ctxlzr.child = false\n      }\n\n      // If this is a branching link then create a new branch for the next promise.\n      // Otherwise, we can just piggy-back on the previous link's spot.\n      const idx = ctxlzr.child === false ? ctxlzr.context.branch() : ctxlzr.idx\n\n      // Create a new context for this next promise.\n      next.__NR_context = new Contextualizer(idx, ctxlzr.context)\n      next.__NR_context.parentIdx = ctxlzr.idx\n\n      // If this was our first child, remember it in case we have a 2nd.\n      if (ctxlzr.child === null) {\n        ctxlzr.child = next.__NR_context\n      }\n    } else if (segment) {\n      // This next promise is the root of a chain. Either there was no previous\n      // promise or the promise was created out of context.\n      next.__NR_context = new Contextualizer(0, new Context(segment))\n    }\n  }\n\n  isActive() {\n    const segments = this.context.segments\n    const segment = segments[this.idx] || segments[this.parentIdx] || segments[0]\n    return segment && segment.transaction.isActive()\n  }\n\n  getSegment() {\n    const segments = this.context.segments\n    let segment = segments[this.idx]\n    if (segment == null) {\n      segment = segments[this.idx] = segments[this.parentIdx] || segments[0]\n    }\n    return segment\n  }\n\n  setSegment(segment) {\n    return this.context.segments[this.idx] = segment\n  }\n\n  toJSON() {\n    // No-op.\n  }\n\n  continueContext(prom) {\n    const self = this\n    const nextContext = prom.__NR_context\n    if (!nextContext) {\n      return prom\n    }\n\n    // If we have `finally`, use that to sneak our context update.\n    if (typeof prom.finally === 'function') {\n      return prom.finally(__NR_continueContext)\n    }\n\n    // No `finally` means we need to hook into resolve and reject individually and\n    // pass through whatever happened.\n    return prom.then(function __NR_thenContext(val) {\n      __NR_continueContext()\n      return val\n    }, function __NR_catchContext(err) {\n      __NR_continueContext()\n      throw err // Re-throwing promise rejection, this is not New Relic's error.\n    })\n\n    function __NR_continueContext() {\n      self.setSegment(nextContext.getSegment())\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}