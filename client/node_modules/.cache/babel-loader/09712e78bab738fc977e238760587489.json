{"ast":null,"code":"'use strict';\n\nconst Config = require('./config');\n\nconst logger = require('./logger').child({\n  component: 'attributes'\n});\n\nconst isValidType = require('./util/attribute-types');\n\nconst byteUtils = require('./util/byte-limit');\n\nconst properties = require('./util/properties');\n/**\n * @class\n * @private\n */\n\n\nclass Attributes {\n  /**\n   * @param {string} scope\n   *  The scope of the attributes this will collect. Must be `transaction` or\n   *  `segment`.\n   *\n   * @param {number} [limit=Infinity]\n   *  The maximum number of attributes to retrieve for each destination.\n   */\n  constructor(scope, limit = Infinity) {\n    this.filter = makeFilter(scope);\n    this.limit = limit;\n    this.attributes = Object.create(null);\n  }\n  /**\n   * Checks if a given string is within agent attribute limits.\n   *\n   * @param {string} str - Object key name or value\n   */\n\n\n  isValidLength(str) {\n    return typeof str === 'number' || byteUtils.isValidLength(str, 255);\n  }\n  /**\n   * Adds the given attribute to the instance attributes object,\n   * overwriting existing keys if necessary.\n   *\n   * @param {AttributeFilter.DESTINATIONS} destinations - Allowed destinations\n   * @param {string}  key            - Attribute key\n   * @param {string}  value          - Attribute value\n   * @param {boolean} truncateExempt - Flag marking value exempt from truncation\n   */\n\n\n  _set(destinations, key, value, truncateExempt) {\n    this.attributes[key] = {\n      value,\n      destinations,\n      truncateExempt\n    };\n  }\n  /**\n   * Retrieves all attribute key-value pairs where the given `dest` is included\n   * in the list of allowed destinations. If there is a limit on the number of\n   * attributes allowed, no more than that number will be included in the result.\n   *\n   * @param {AttributeFilter.DESTINATIONS} dest\n   * @return {object}\n   */\n\n\n  get(dest) {\n    const attrs = Object.create(null);\n    let attrCount = 0;\n\n    for (let key in this.attributes) {\n      // eslint-disable-line guard-for-in\n      const attr = this.attributes[key];\n\n      if (!(attr.destinations & dest)) {\n        continue;\n      }\n\n      attrs[key] = typeof attr.value === 'string' && !attr.truncateExempt ? byteUtils.truncate(attr.value, 255) : attr.value;\n\n      if (++attrCount >= this.limit) {\n        break;\n      }\n    }\n\n    return attrs;\n  }\n  /**\n   * Checks if a given key exists in the instance attributes object.\n   *\n   * @param {string} key\n   */\n\n\n  has(key) {\n    return !!this.attributes[key];\n  }\n  /**\n   * Clears instance attributes. Used for enforcing updated LASP\n   * settings on connect.\n   */\n\n\n  reset() {\n    this.attributes = Object.create(null);\n  }\n  /**\n   * Adds given key-value pair to destination's agent attributes,\n   * if it passes filtering rules.\n   *\n   * @param {DESTINATIONS}  destinations  - The default destinations for this key.\n   * @param {string}        key           - The attribute name.\n   * @param {string}        value         - The attribute value.\n   * @param {boolean} [truncateExempt=false] - Flag marking value exempt from truncation\n   */\n\n\n  addAttribute(destinations, key, value, truncateExempt = false) {\n    if (!isValidType(value)) {\n      return logger.debug('Not adding attribute %s with %s value type. This is expected for undefined' + 'attributes and only an issue if an attribute is not expected to be undefined' + 'or not of the type expected.', key, typeof value);\n    }\n\n    if (!this.isValidLength(key)) {\n      return logger.warn('Length limit exceeded for attribute name, not adding: %s', key);\n    } // Only set the attribute if at least one destination passed\n\n\n    const validDestinations = this.filter(destinations, key);\n\n    if (validDestinations) {\n      this._set(validDestinations, key, value, truncateExempt);\n    }\n  }\n  /**\n   * Passthrough method for adding multiple unknown attributes at once.\n   *\n   * @param {DESTINATIONS}  destinations  - The default destinations for these attributes.\n   * @param {object}        attrs         - The attributes to add.\n   */\n\n\n  addAttributes(destinations, attrs) {\n    for (let key in attrs) {\n      if (properties.hasOwn(attrs, key)) {\n        this.addAttribute(destinations, key, attrs[key]);\n      }\n    }\n  }\n\n}\n/**\n * Creates a filter function for the given scope.\n *\n * @param {string} scope - The scope of the filter to make.\n *\n * @return {function} A function that performs attribute filtering for the given\n *  scope.\n */\n\n\nfunction makeFilter(scope) {\n  const _Config$getInstance = Config.getInstance(),\n        attributeFilter = _Config$getInstance.attributeFilter;\n\n  if (scope === 'transaction') {\n    return (d, k) => attributeFilter.filterTransaction(d, k);\n  } else if (scope === 'segment') {\n    return (d, k) => attributeFilter.filterSegment(d, k);\n  }\n}\n\nmodule.exports = Attributes;","map":{"version":3,"sources":["/Users/adamsarli/Coding/my-portfolio/node_modules/newrelic/lib/attributes.js"],"names":["Config","require","logger","child","component","isValidType","byteUtils","properties","Attributes","constructor","scope","limit","Infinity","filter","makeFilter","attributes","Object","create","isValidLength","str","_set","destinations","key","value","truncateExempt","get","dest","attrs","attrCount","attr","truncate","has","reset","addAttribute","debug","warn","validDestinations","addAttributes","hasOwn","getInstance","attributeFilter","d","k","filterTransaction","filterSegment","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAP,CAAoBE,KAApB,CAA0B;AAACC,EAAAA,SAAS,EAAE;AAAZ,CAA1B,CAAf;;AACA,MAAMC,WAAW,GAAGJ,OAAO,CAAC,wBAAD,CAA3B;;AACA,MAAMK,SAAS,GAAGL,OAAO,CAAC,mBAAD,CAAzB;;AACA,MAAMM,UAAU,GAAGN,OAAO,CAAC,mBAAD,CAA1B;AAEA;;;;;;AAIA,MAAMO,UAAN,CAAiB;AACf;;;;;;;;AAQAC,EAAAA,WAAW,CAACC,KAAD,EAAQC,KAAK,GAAGC,QAAhB,EAA0B;AACnC,SAAKC,MAAL,GAAcC,UAAU,CAACJ,KAAD,CAAxB;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKI,UAAL,GAAkBC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAlB;AACD;AAED;;;;;;;AAKAC,EAAAA,aAAa,CAACC,GAAD,EAAM;AACjB,WAAO,OAAOA,GAAP,KAAe,QAAf,IAA2Bb,SAAS,CAACY,aAAV,CAAwBC,GAAxB,EAA6B,GAA7B,CAAlC;AACD;AAED;;;;;;;;;;;AASAC,EAAAA,IAAI,CAACC,YAAD,EAAeC,GAAf,EAAoBC,KAApB,EAA2BC,cAA3B,EAA2C;AAC7C,SAAKT,UAAL,CAAgBO,GAAhB,IAAuB;AAACC,MAAAA,KAAD;AAAQF,MAAAA,YAAR;AAAsBG,MAAAA;AAAtB,KAAvB;AACD;AAED;;;;;;;;;;AAQAC,EAAAA,GAAG,CAACC,IAAD,EAAO;AACR,UAAMC,KAAK,GAAGX,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;AACA,QAAIW,SAAS,GAAG,CAAhB;;AACA,SAAK,IAAIN,GAAT,IAAgB,KAAKP,UAArB,EAAiC;AAAE;AACjC,YAAMc,IAAI,GAAG,KAAKd,UAAL,CAAgBO,GAAhB,CAAb;;AACA,UAAI,EAAEO,IAAI,CAACR,YAAL,GAAoBK,IAAtB,CAAJ,EAAiC;AAC/B;AACD;;AAEDC,MAAAA,KAAK,CAACL,GAAD,CAAL,GAAa,OAAOO,IAAI,CAACN,KAAZ,KAAsB,QAAtB,IAAkC,CAACM,IAAI,CAACL,cAAxC,GACTlB,SAAS,CAACwB,QAAV,CAAmBD,IAAI,CAACN,KAAxB,EAA+B,GAA/B,CADS,GAETM,IAAI,CAACN,KAFT;;AAIA,UAAI,EAAEK,SAAF,IAAe,KAAKjB,KAAxB,EAA+B;AAC7B;AACD;AACF;;AAED,WAAOgB,KAAP;AACD;AAED;;;;;;;AAKAI,EAAAA,GAAG,CAACT,GAAD,EAAM;AACP,WAAO,CAAC,CAAC,KAAKP,UAAL,CAAgBO,GAAhB,CAAT;AACD;AAED;;;;;;AAIAU,EAAAA,KAAK,GAAG;AACN,SAAKjB,UAAL,GAAkBC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAlB;AACD;AAED;;;;;;;;;;;AASAgB,EAAAA,YAAY,CAACZ,YAAD,EAAeC,GAAf,EAAoBC,KAApB,EAA2BC,cAAc,GAAG,KAA5C,EAAmD;AAC7D,QAAI,CAACnB,WAAW,CAACkB,KAAD,CAAhB,EAAyB;AACvB,aAAOrB,MAAM,CAACgC,KAAP,CACL,+EACA,8EADA,GAEA,8BAHK,EAILZ,GAJK,EAKL,OAAOC,KALF,CAAP;AAOD;;AAED,QAAI,CAAC,KAAKL,aAAL,CAAmBI,GAAnB,CAAL,EAA8B;AAC5B,aAAOpB,MAAM,CAACiC,IAAP,CACL,0DADK,EAELb,GAFK,CAAP;AAID,KAhB4D,CAkB7D;;;AACA,UAAMc,iBAAiB,GAAG,KAAKvB,MAAL,CAAYQ,YAAZ,EAA0BC,GAA1B,CAA1B;;AACA,QAAIc,iBAAJ,EAAuB;AACrB,WAAKhB,IAAL,CAAUgB,iBAAV,EAA6Bd,GAA7B,EAAkCC,KAAlC,EAAyCC,cAAzC;AACD;AACF;AAED;;;;;;;;AAMAa,EAAAA,aAAa,CAAChB,YAAD,EAAeM,KAAf,EAAsB;AACjC,SAAK,IAAIL,GAAT,IAAgBK,KAAhB,EAAuB;AACrB,UAAIpB,UAAU,CAAC+B,MAAX,CAAkBX,KAAlB,EAAyBL,GAAzB,CAAJ,EAAmC;AACjC,aAAKW,YAAL,CAAkBZ,YAAlB,EAAgCC,GAAhC,EAAqCK,KAAK,CAACL,GAAD,CAA1C;AACD;AACF;AACF;;AAjIc;AAoIjB;;;;;;;;;;AAQA,SAASR,UAAT,CAAoBJ,KAApB,EAA2B;AAAA,8BACCV,MAAM,CAACuC,WAAP,EADD;AAAA,QAClBC,eADkB,uBAClBA,eADkB;;AAEzB,MAAI9B,KAAK,KAAK,aAAd,EAA6B;AAC3B,WAAO,CAAC+B,CAAD,EAAIC,CAAJ,KAAUF,eAAe,CAACG,iBAAhB,CAAkCF,CAAlC,EAAqCC,CAArC,CAAjB;AACD,GAFD,MAEO,IAAIhC,KAAK,KAAK,SAAd,EAAyB;AAC9B,WAAO,CAAC+B,CAAD,EAAIC,CAAJ,KAAUF,eAAe,CAACI,aAAhB,CAA8BH,CAA9B,EAAiCC,CAAjC,CAAjB;AACD;AACF;;AAEDG,MAAM,CAACC,OAAP,GAAiBtC,UAAjB","sourcesContent":["'use strict'\n\nconst Config = require('./config')\nconst logger = require('./logger').child({component: 'attributes'})\nconst isValidType = require('./util/attribute-types')\nconst byteUtils = require('./util/byte-limit')\nconst properties = require('./util/properties')\n\n/**\n * @class\n * @private\n */\nclass Attributes {\n  /**\n   * @param {string} scope\n   *  The scope of the attributes this will collect. Must be `transaction` or\n   *  `segment`.\n   *\n   * @param {number} [limit=Infinity]\n   *  The maximum number of attributes to retrieve for each destination.\n   */\n  constructor(scope, limit = Infinity) {\n    this.filter = makeFilter(scope)\n    this.limit = limit\n    this.attributes = Object.create(null)\n  }\n\n  /**\n   * Checks if a given string is within agent attribute limits.\n   *\n   * @param {string} str - Object key name or value\n   */\n  isValidLength(str) {\n    return typeof str === 'number' || byteUtils.isValidLength(str, 255)\n  }\n\n  /**\n   * Adds the given attribute to the instance attributes object,\n   * overwriting existing keys if necessary.\n   *\n   * @param {AttributeFilter.DESTINATIONS} destinations - Allowed destinations\n   * @param {string}  key            - Attribute key\n   * @param {string}  value          - Attribute value\n   * @param {boolean} truncateExempt - Flag marking value exempt from truncation\n   */\n  _set(destinations, key, value, truncateExempt) {\n    this.attributes[key] = {value, destinations, truncateExempt}\n  }\n\n  /**\n   * Retrieves all attribute key-value pairs where the given `dest` is included\n   * in the list of allowed destinations. If there is a limit on the number of\n   * attributes allowed, no more than that number will be included in the result.\n   *\n   * @param {AttributeFilter.DESTINATIONS} dest\n   * @return {object}\n   */\n  get(dest) {\n    const attrs = Object.create(null)\n    let attrCount = 0\n    for (let key in this.attributes) { // eslint-disable-line guard-for-in\n      const attr = this.attributes[key]\n      if (!(attr.destinations & dest)) {\n        continue\n      }\n\n      attrs[key] = typeof attr.value === 'string' && !attr.truncateExempt\n        ? byteUtils.truncate(attr.value, 255)\n        : attr.value\n\n      if (++attrCount >= this.limit) {\n        break\n      }\n    }\n\n    return attrs\n  }\n\n  /**\n   * Checks if a given key exists in the instance attributes object.\n   *\n   * @param {string} key\n   */\n  has(key) {\n    return !!this.attributes[key]\n  }\n\n  /**\n   * Clears instance attributes. Used for enforcing updated LASP\n   * settings on connect.\n   */\n  reset() {\n    this.attributes = Object.create(null)\n  }\n\n  /**\n   * Adds given key-value pair to destination's agent attributes,\n   * if it passes filtering rules.\n   *\n   * @param {DESTINATIONS}  destinations  - The default destinations for this key.\n   * @param {string}        key           - The attribute name.\n   * @param {string}        value         - The attribute value.\n   * @param {boolean} [truncateExempt=false] - Flag marking value exempt from truncation\n   */\n  addAttribute(destinations, key, value, truncateExempt = false) {\n    if (!isValidType(value)) {\n      return logger.debug(\n        'Not adding attribute %s with %s value type. This is expected for undefined' +\n        'attributes and only an issue if an attribute is not expected to be undefined' +\n        'or not of the type expected.',\n        key,\n        typeof value\n      )\n    }\n\n    if (!this.isValidLength(key)) {\n      return logger.warn(\n        'Length limit exceeded for attribute name, not adding: %s',\n        key\n      )\n    }\n\n    // Only set the attribute if at least one destination passed\n    const validDestinations = this.filter(destinations, key)\n    if (validDestinations) {\n      this._set(validDestinations, key, value, truncateExempt)\n    }\n  }\n\n  /**\n   * Passthrough method for adding multiple unknown attributes at once.\n   *\n   * @param {DESTINATIONS}  destinations  - The default destinations for these attributes.\n   * @param {object}        attrs         - The attributes to add.\n   */\n  addAttributes(destinations, attrs) {\n    for (let key in attrs) {\n      if (properties.hasOwn(attrs, key)) {\n        this.addAttribute(destinations, key, attrs[key])\n      }\n    }\n  }\n}\n\n/**\n * Creates a filter function for the given scope.\n *\n * @param {string} scope - The scope of the filter to make.\n *\n * @return {function} A function that performs attribute filtering for the given\n *  scope.\n */\nfunction makeFilter(scope) {\n  const {attributeFilter} = Config.getInstance()\n  if (scope === 'transaction') {\n    return (d, k) => attributeFilter.filterTransaction(d, k)\n  } else if (scope === 'segment') {\n    return (d, k) => attributeFilter.filterSegment(d, k)\n  }\n}\n\nmodule.exports = Attributes\n"]},"metadata":{},"sourceType":"script"}